<!DOCTYPE html>
<html lang="zh-CN">
<head>

  <!--pjax：防止跳转页面音乐暂停-->
  <script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.js"></script>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":300,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":5,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="线程和进程进程是操作系统中的应用程序，是资源分配的基本单位，线程是用来执行具体的任务和功能，是CPU调度和分派的最小单位。 一个进程往往可以包含多个线程，至少包含一个。 对于Java而言：Thread、Runable、Callable进行开启线程的。">
<meta property="og:type" content="article">
<meta property="og:title" content="Juc">
<meta property="og:url" content="http://example.com/2023/03/29/Juc/index.html">
<meta property="og:site_name" content="白都">
<meta property="og:description" content="线程和进程进程是操作系统中的应用程序，是资源分配的基本单位，线程是用来执行具体的任务和功能，是CPU调度和分派的最小单位。 一个进程往往可以包含多个线程，至少包含一个。 对于Java而言：Thread、Runable、Callable进行开启线程的。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.p04e.com/baid/i/2023/03/29/7k03x.png">
<meta property="og:image" content="http://example.com/C:/Users/Lenovo/AppData/Roaming/Typora/typora-user-images/1680096740590.png">
<meta property="og:image" content="https://i.p04e.com/baid/i/2023/03/29/5la7.png">
<meta property="og:image" content="https://i.p04e.com/baid/i/2023/03/29/139pc.png">
<meta property="og:image" content="https://i.p04e.com/baid/i/2023/03/29/13bl4.png">
<meta property="og:image" content="https://i.p04e.com/baid/i/2023/03/29/7oeeh.png">
<meta property="og:image" content="https://i.p04e.com/baid/i/2023/03/29/5ng0.png">
<meta property="og:image" content="https://i.p04e.com/baid/i/2023/03/29/5nmo.png">
<meta property="og:image" content="https://i.p04e.com/baid/i/2023/03/29/13ekp.png">
<meta property="og:image" content="https://i.p04e.com/baid/i/2023/03/29/5ne9.png">
<meta property="og:image" content="https://i.p04e.com/baid/i/2023/03/29/7q0iz.png">
<meta property="og:image" content="http://example.com/C:/Users/Lenovo/AppData/Roaming/Typora/typora-user-images/1680097974324.png">
<meta property="og:image" content="https://i.p04e.com/baid/i/2023/03/29/7v0mi.png">
<meta property="og:image" content="https://i.p04e.com/baid/i/2023/03/29/5s28.png">
<meta property="og:image" content="https://i.p04e.com/baid/i/2023/03/29/14m8l.png">
<meta property="og:image" content="https://i.p04e.com/baid/i/2023/03/29/14o7r.png">
<meta property="og:image" content="https://i.p04e.com/baid/i/2023/03/29/5ssz.png">
<meta property="og:image" content="https://i.p04e.com/baid/i/2023/03/29/5sae.png">
<meta property="og:image" content="https://i.p04e.com/baid/i/2023/03/29/trr.png">
<meta property="og:image" content="https://i.p04e.com/baid/i/2023/03/29/14jgv.png">
<meta property="og:image" content="https://i.p04e.com/baid/i/2023/03/29/5tgz.png">
<meta property="og:image" content="https://i.p04e.com/baid/i/2023/03/29/14rsd.png">
<meta property="og:image" content="https://i.p04e.com/baid/i/2023/03/29/tzw.png">
<meta property="og:image" content="https://i.p04e.com/baid/i/2023/03/29/5ujl.png">
<meta property="og:image" content="https://i.p04e.com/baid/i/2023/03/29/u5r.png">
<meta property="og:image" content="https://i.p04e.com/baid/i/2023/03/29/7zyy4.png">
<meta property="og:image" content="https://i.p04e.com/baid/i/2023/03/29/15516.png">
<meta property="og:image" content="https://i.p04e.com/baid/i/2023/03/29/81oa1.png">
<meta property="og:image" content="https://i.p04e.com/baid/i/2023/03/29/80pou.png">
<meta property="og:image" content="https://i.p04e.com/baid/i/2023/03/29/822tb.png">
<meta property="og:image" content="https://i.p04e.com/baid/i/2023/03/29/5xhy.png">
<meta property="og:image" content="https://i.p04e.com/baid/i/2023/03/29/15jn3.png">
<meta property="og:image" content="https://i.p04e.com/baid/i/2023/03/29/15lxm.png">
<meta property="og:image" content="https://i.p04e.com/baid/i/2023/03/29/83mnx.png">
<meta property="og:image" content="https://i.p04e.com/baid/i/2023/03/29/15pcg.png">
<meta property="og:image" content="https://i.p04e.com/baid/i/2023/03/29/b21dhd.png">
<meta property="og:image" content="https://i.p04e.com/baid/i/2023/03/29/15m0t.png">
<meta property="og:image" content="https://i.p04e.com/baid/i/2023/03/29/5y53.png">
<meta property="og:image" content="https://i.p04e.com/baid/i/2023/03/29/15t7v.png">
<meta property="og:image" content="https://i.p04e.com/baid/i/2023/03/29/5zg6.png">
<meta property="og:image" content="https://i.p04e.com/baid/i/2023/03/29/4em.png">
<meta property="og:image" content="https://i.p04e.com/baid/i/2023/03/29/86swp.png">
<meta property="og:image" content="https://i.p04e.com/baid/i/2023/03/29/15ttg.png">
<meta property="og:image" content="https://i.p04e.com/baid/i/2023/03/29/860tj.png">
<meta property="og:image" content="https://i.p04e.com/baid/i/2023/03/29/60c2.png">
<meta property="og:image" content="https://i.p04e.com/baid/i/2023/03/29/87ipf.png">
<meta property="og:image" content="https://i.p04e.com/baid/i/2023/03/29/16ay5.png">
<meta property="og:image" content="https://i.p04e.com/baid/i/2023/03/29/v54.png">
<meta property="og:image" content="https://i.p04e.com/baid/i/2023/03/29/16gtz.png">
<meta property="og:image" content="https://i.p04e.com/baid/i/2023/03/29/16c1z.png">
<meta property="og:image" content="https://i.p04e.com/baid/i/2023/03/29/16b4l.png">
<meta property="article:published_time" content="2023-03-29T13:23:25.000Z">
<meta property="article:modified_time" content="2023-03-29T15:01:45.150Z">
<meta property="article:author" content="白都">
<meta property="article:tag" content="Juc">
<meta property="article:tag" content="生产者和消费者">
<meta property="article:tag" content="Lock">
<meta property="article:tag" content="Callable">
<meta property="article:tag" content="线程池">
<meta property="article:tag" content="volatile">
<meta property="article:tag" content="Stream">
<meta property="article:tag" content="CAS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.p04e.com/baid/i/2023/03/29/7k03x.png">

<link rel="canonical" href="http://example.com/2023/03/29/Juc/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Juc | 白都</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">白都</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">linBaiDu</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>

  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/yourname" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/29/Juc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="白都">
      <meta itemprop="description" content="这是我的个人知识技术总结博客，欢迎大家的到来，博客会慢慢更新。 ------------有问题请通过邮箱2653751429@qq.com联系，评论功能是不会开启的。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="白都">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Juc
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-03-29 21:23:25 / 修改时间：23:01:45" itemprop="dateCreated datePublished" datetime="2023-03-29T21:23:25+08:00">2023-03-29</time>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h3><p>进程是操作系统中的应用程序，是资源分配的基本单位，线程是用来执行具体的任务和功能，是CPU调度和分派的最小单位。</p>
<p>一个进程往往可以包含多个线程，至少包含一个。</p>
<p>对于Java而言：Thread、Runable、Callable进行开启线程的。</p>
<span id="more"></span>
<h3 id="什么是JUC"><a href="#什么是JUC" class="headerlink" title="什么是JUC"></a>什么是JUC</h3><p><img src="https://i.p04e.com/baid/i/2023/03/29/7k03x.png"></p>
<p>Runnable 没有返回值，企业中使用Callable</p>
<p>java默认有几个线程？</p>
<p>java默认有两个线程：main、GC</p>
<p>java真的可以开启线程吗？</p>
<p>不可以！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.guocl.demo0;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test0</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//查看线程启动，点击start查看</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java源码：调用native方法(本地方法栈的C++方法)，java运行在虚拟机之上，无法直接操作硬件，由C++开启多线程。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> start0（）；</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>并发编程：并发、并行；</p>
<p>并发（多线程操作同一资源）</p>
<ul>
<li>CPU一核，模拟出来多条线程，快速交替。</li>
</ul>
<p>并行（多个人一起行走）</p>
<ul>
<li>CPU多核，多个线程可以同时执行；线程池。</li>
</ul>
<p><strong>并发编程的本质：充分利用cpu资源</strong></p>
<blockquote>
<p>使用代码查看cpu</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.guocl.demo0;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test0</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//获取cpu的核数</span></span><br><span class="line">        <span class="comment">//cpu密集型，io密集型</span></span><br><span class="line">        System.out.println(Runtime.getRuntime().availableProcessors());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果为 4</span></span><br></pre></td></tr></table></figure>
<h4 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.guocl.demo0;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test0</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//查看线程状态,恩住ctrl，点State</span></span><br><span class="line">        Thread.State</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//线程的状态：6个</span><br><span class="line">public enum State &#123;</span><br><span class="line">//就绪</span><br><span class="line">NEW,</span><br><span class="line">//运行</span><br><span class="line">RUNNABLE,</span><br><span class="line">//阻塞</span><br><span class="line">BLOCKED,</span><br><span class="line">//等待(死死的等)</span><br><span class="line">WAITING,</span><br><span class="line">//超时等待(超过一定时间，不再等待)</span><br><span class="line">TIMED_WAITING,</span><br><span class="line">//终止</span><br><span class="line">TERMINATED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="wait于sleep的区别"><a href="#wait于sleep的区别" class="headerlink" title="wait于sleep的区别"></a>wait于sleep的区别</h4><p>来自不同的类<br>wait=》Object<br>sleep=》Thread<br>wait释放锁，sleep不释放锁（sleep抱着锁睡觉）<br>wait必须在同步代码块中，sleep可以在任何地方（sleep可以在任何地方睡觉）<br>wait不需要捕获异常，sleep需要捕获异常（可能发生超时等待）</p>
<h3 id="Lock锁（重点）"><a href="#Lock锁（重点）" class="headerlink" title="Lock锁（重点）"></a>Lock锁（重点）</h3><h4 id="传统的Synchronized锁"><a href="#传统的Synchronized锁" class="headerlink" title="传统的Synchronized锁"></a>传统的Synchronized锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.guocl.demo0;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 不加Synchronized</span></span><br><span class="line"><span class="comment"> * 真正的多线程开发</span></span><br><span class="line"><span class="comment"> * 线程就是一个资源类，没有任何附属的操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SaleTicket</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//并发：多线程操作同一个资源类，把资源类丢入线程</span></span><br><span class="line">        <span class="type">Ticket</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket</span>();</span><br><span class="line">        <span class="comment">// Runnable方式 -- @FunctionalInterface函数式接口</span></span><br><span class="line"><span class="comment">//        new Thread(new Runnable() &#123;</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public void run() &#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;).start();</span></span><br><span class="line">        <span class="comment">// jdk1.8  使用lambda表达式</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//资源类OOP编程</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ticket</span>&#123;</span><br><span class="line">    <span class="comment">//属性，方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">    <span class="comment">//买票的方式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sale</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (number &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;卖出了第&quot;</span>+(number--)+<span class="string">&quot;票,剩余：&quot;</span>+number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">A卖出了第30票,剩余：29</span><br><span class="line">B卖出了第29票,剩余：28</span><br><span class="line">A卖出了第28票,剩余：27</span><br><span class="line">B卖出了第27票,剩余：26</span><br><span class="line">A卖出了第26票,剩余：25</span><br><span class="line">B卖出了第25票,剩余：24</span><br><span class="line">B卖出了第23票,剩余：22</span><br><span class="line">B卖出了第22票,剩余：21</span><br><span class="line">B卖出了第21票,剩余：20</span><br><span class="line">B卖出了第20票,剩余：19</span><br><span class="line">B卖出了第19票,剩余：18</span><br><span class="line">B卖出了第18票,剩余：17</span><br><span class="line">B卖出了第17票,剩余：16</span><br><span class="line">B卖出了第16票,剩余：15</span><br><span class="line">B卖出了第15票,剩余：14</span><br><span class="line">B卖出了第14票,剩余：13</span><br><span class="line">B卖出了第13票,剩余：12</span><br><span class="line">B卖出了第12票,剩余：11</span><br><span class="line">B卖出了第11票,剩余：10</span><br><span class="line">B卖出了第10票,剩余：9</span><br><span class="line">B卖出了第9票,剩余：8</span><br><span class="line">B卖出了第8票,剩余：7</span><br><span class="line">B卖出了第7票,剩余：6</span><br><span class="line">B卖出了第6票,剩余：5</span><br><span class="line">B卖出了第5票,剩余：4</span><br><span class="line">B卖出了第4票,剩余：3</span><br><span class="line">B卖出了第3票,剩余：2</span><br><span class="line">B卖出了第2票,剩余：1</span><br><span class="line">B卖出了第1票,剩余：0</span><br><span class="line">A卖出了第24票,剩余：23</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br><span class="line">//结果是乱的</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.guocl.demo0;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 不加Synchronized</span></span><br><span class="line"><span class="comment"> * 真正的多线程开发</span></span><br><span class="line"><span class="comment"> * 线程就是一个资源类，没有任何附属的操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SaleTicket</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//并发：多线程操作同一个资源类，把资源类丢入线程</span></span><br><span class="line">        <span class="type">Ticket</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket</span>();</span><br><span class="line">        <span class="comment">// Runnable方式 -- @FunctionalInterface函数式接口</span></span><br><span class="line"><span class="comment">//        new Thread(new Runnable() &#123;</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public void run() &#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;).start();</span></span><br><span class="line">        <span class="comment">// jdk1.8  使用lambda表达式</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//资源类OOP编程</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ticket</span>&#123;</span><br><span class="line">    <span class="comment">//属性，方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">    <span class="comment">//买票的方式</span></span><br><span class="line">    <span class="comment">//synchronized  本质：队列，锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sale</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (number &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;卖出了第&quot;</span>+(number--)+<span class="string">&quot;票,剩余：&quot;</span>+number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">A卖出了第30票,剩余：29</span><br><span class="line">A卖出了第29票,剩余：28</span><br><span class="line">A卖出了第28票,剩余：27</span><br><span class="line">A卖出了第27票,剩余：26</span><br><span class="line">A卖出了第26票,剩余：25</span><br><span class="line">A卖出了第25票,剩余：24</span><br><span class="line">A卖出了第24票,剩余：23</span><br><span class="line">A卖出了第23票,剩余：22</span><br><span class="line">A卖出了第22票,剩余：21</span><br><span class="line">A卖出了第21票,剩余：20</span><br><span class="line">A卖出了第20票,剩余：19</span><br><span class="line">A卖出了第19票,剩余：18</span><br><span class="line">A卖出了第18票,剩余：17</span><br><span class="line">A卖出了第17票,剩余：16</span><br><span class="line">A卖出了第16票,剩余：15</span><br><span class="line">A卖出了第15票,剩余：14</span><br><span class="line">A卖出了第14票,剩余：13</span><br><span class="line">A卖出了第13票,剩余：12</span><br><span class="line">A卖出了第12票,剩余：11</span><br><span class="line">A卖出了第11票,剩余：10</span><br><span class="line">A卖出了第10票,剩余：9</span><br><span class="line">A卖出了第9票,剩余：8</span><br><span class="line">A卖出了第8票,剩余：7</span><br><span class="line">A卖出了第7票,剩余：6</span><br><span class="line">A卖出了第6票,剩余：5</span><br><span class="line">A卖出了第5票,剩余：4</span><br><span class="line">A卖出了第4票,剩余：3</span><br><span class="line">A卖出了第3票,剩余：2</span><br><span class="line">A卖出了第2票,剩余：1</span><br><span class="line">A卖出了第1票,剩余：0</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="Lock锁（接口）"><a href="#Lock锁（接口）" class="headerlink" title="Lock锁（接口）"></a>Lock锁（接口）<img src="/C:/Users\Lenovo\AppData\Roaming\Typora\typora-user-images\1680096740590.png" alt="1680096740590"></h4><ul>
<li>公平锁：十分公平，必须先来后到；</li>
<li>非公平锁：十分不公平，可以插队； <strong>（默认为非公平锁）</strong></li>
</ul>
<blockquote>
<p>用lock锁实现买票实例</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.guocl.demo0;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockTicket</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//资源类</span></span><br><span class="line">        <span class="type">Ticket2</span> <span class="variable">ticket2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket2</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">                ticket2.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">                ticket2.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">                ticket2.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;C&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//lock三部曲</span></span><br><span class="line"><span class="comment">//1、    Lock lock=new ReentrantLock();</span></span><br><span class="line"><span class="comment">//2、    lock.lock() 加锁</span></span><br><span class="line"><span class="comment">//3、    finally=&gt; 解锁：lock.unlock();</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ticket2</span>&#123;</span><br><span class="line">    <span class="comment">//属性，方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">    <span class="comment">//创建锁</span></span><br><span class="line">    <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="comment">//买票的方式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sale</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//开启锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (number &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;卖出了第&quot;</span>+(number--)+<span class="string">&quot;票,剩余：&quot;</span>+number);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="Synchronized和Lock区别"><a href="#Synchronized和Lock区别" class="headerlink" title="Synchronized和Lock区别"></a>Synchronized和Lock区别</h4><p>1、Synchronized 是内置的java关键字，Lock是一个接口；</p>
<p>2、Synchronized 无法判断获取锁的状态，Lock可以判断；</p>
<p>3、Synchronized 会自动释放锁，Lock必须要手动加锁和手动释放锁！（若不释放锁，可能会造成死锁）；</p>
<p>4、Synchronized 线程1（获得锁-&gt;阻塞）、线程2（等待）（会一直等待下去）；Lock就不一定会一直等待下去，lock会有一个trylock去尝试获取锁，不会造成长久的等待；</p>
<p>5、Synchronized 是可重入锁，不可以中断的，非公平锁；Lock是可重入锁，可以中断锁，可以自己设置公平锁和非公平锁；</p>
<p>6、Synchronized 适合锁少量的代码同步问题，Lock适合锁大量同步代码问题；</p>
<p>深入研究Lock和Synchronized的区别于用法</p>
<p>参考文章：</p>
<p><a target="_blank" rel="noopener" href="http://t.csdn.cn/Uouwa">http://t.csdn.cn/Uouwa</a></p>
<h5 id="1、synchronize和lock的用法区别"><a href="#1、synchronize和lock的用法区别" class="headerlink" title="1、synchronize和lock的用法区别"></a>1、synchronize和lock的用法区别</h5><p>synchronize：在需要同步的对象中加入此控制，synchronize可以加在方法上（同步方法），也可以加在特定代码块中（同步代码块），括号中表示需要锁的对象。</p>
<p>lock：需要显示指定起始位置和终止位置。一般使用ReentranLock类做为锁，多个线程中必须要使用一个ReentranLock类做为对象才能保证锁的生效。且在加锁和解锁处需要通过lock()和unlock()显示指出。所以一般会在finally块中写unlock()以防死锁。</p>
<h5 id="2、synchronized和lock性能区别"><a href="#2、synchronized和lock性能区别" class="headerlink" title="2、synchronized和lock性能区别"></a>2、synchronized和lock性能区别</h5><p>synchronized是托管给JVM执行的，而lock是java写的控制锁的代码。在Java1.5中，synchronized是性能很低效的。因为这是一个重量级操作。需要调用操作接口，导致有可能加锁消耗的系统时间比加锁以外的操作还多。相比之下使用java提供的lock对象，性能更高一些。但是到了JDK1.6，发生了变化。synchronize在语义上很清晰，可以进行很多优化，有适应自旋，锁消除，锁粗化，轻量级锁，偏向锁等等。导致在Java1.6上synchronize的性能并不比Lock差。官方也表示，他们也更支持synchronize，在未来的版本中还有优化余地。</p>
<p>说到这里，还是想提一下这两种机制的具体区别。据我所知，synchronized原始采用的是CPU悲观锁机制，即线程获得的是独占锁。独占锁意味着其他线程只能依靠阻塞来等待线程释放锁。而在CPU转换线程阻塞时会引起线程上下文切换，当有很多线程竞争锁的时候，会引起CPU频繁的上下文切换导致效率很低。</p>
<p>而lock用的是乐观锁方式，所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。乐观锁实现的机制就是CAS操作Compare and Swap）。我们可以进一步研究ReentrantLock的源代码，会发现其中比较重要的获得锁的一个方法是compareAndSetState。这里其实就是调用的CPU提供的特殊指令。</p>
<p>现代的CPU提供了指令，可以自动更新共享数据，而且能够检测其他线程的干扰，而 compareAndSet() 就用这些代替了锁定。这个算法称作非阻塞算法，意思是一个线程的失败或者挂起不应该影响其他线程的失败或挂起的算法。</p>
<h5 id="3、synchronized和lock用途区别"><a href="#3、synchronized和lock用途区别" class="headerlink" title="3、synchronized和lock用途区别"></a>3、synchronized和lock用途区别</h5><p>synchronized原语和ReentrantLock在一般情况下没有什么区别，但是在非常复杂的同步应用中，请考虑使用ReentrantLock，特别是遇到下面2种需求的时候。</p>
<p>某个线程在等待一个锁的控制权的这段时间需要中断。<br>需要分开处理一些wait（等待）-notify（唤醒），ReentrantLock里面的Condition应用（Condition定义了等待await/通知signal、signalAll两种类型的方法），能够控制notify哪个线程。<br>具有公平锁功能，每个到来的线程都将排队等候。<br>下面细细道来……</p>
<p>先说第一种情况，ReentrantLock的lock机制有2种，忽略中断锁和响应中断锁，这给我们带来了很大的灵活性。比如：如果A、B2个线程去竞争锁，A线程得到了锁，B线程等待，但是A线程这个时候实在有太多事情要处理，就是一直不返回，B线程可能就会等不及了，想中断自己，不再等待这个锁了，转而处理其他事情。这个时候ReentrantLock就提供了2种机制，第一，B线程中断自己（或者别的线程中断它），但是ReentrantLock不去响应，继续让B线程等待，你再怎么中断，我全当耳边风（synchronized原语就是如此）；第二，B线程中断自己（或者别的线程中断它），ReentrantLock处理了这个中断，并且不再等待这个锁的到来，完全放弃。（如果你没有了解java的中断机制，请参考下相关资料，再回头看这篇文章，80%的人根本没有真正理解什么是java的中断（下面有讲解），呵呵）</p>
<p>这里来做个试验，首先搞一个Buffer类，它有读操作和写操作，为了不读到脏数据，写和读都需要加锁，我们先用synchronized原语来加锁，如下：</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package com.guocl.lockorsyn.syndemo;</span><br><span class="line"></span><br><span class="line">public class Buffer &#123;</span><br><span class="line">    private Object lock;</span><br><span class="line"></span><br><span class="line">    public Buffer()&#123;</span><br><span class="line">        lock = this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void write()&#123;</span><br><span class="line">        synchronized (lock)&#123;</span><br><span class="line">            long startTime = System.currentTimeMillis();</span><br><span class="line">            System.out.println(&quot;开始往这个buff写入数据…&quot;);</span><br><span class="line">            // 模拟要处理很长时间</span><br><span class="line">            for (;;)&#123;</span><br><span class="line">                if (System.currentTimeMillis() - startTime &gt; Integer.MAX_VALUE)</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;终于写完了&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void read()&#123;</span><br><span class="line">        synchronized (lock)&#123;</span><br><span class="line">            System.out.println(&quot;从这个buff读数据&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>读操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package com.guocl.lockorsyn.syndemo;</span><br><span class="line"></span><br><span class="line">public class Reader extends Thread&#123;</span><br><span class="line">    private Buffer buffer;</span><br><span class="line"></span><br><span class="line">    public Reader(Buffer buffer)&#123;</span><br><span class="line">        this.buffer = buffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        //这里估计会一直阻塞</span><br><span class="line">        buffer.read();</span><br><span class="line">        System.out.println(&quot;读结束&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.guocl.lockorsyn.syndemo;</span><br><span class="line"></span><br><span class="line">public class Writer extends Thread&#123;</span><br><span class="line">    private Buffer buffer;</span><br><span class="line"></span><br><span class="line">    public Writer(Buffer buffer)&#123;</span><br><span class="line">        this.buffer = buffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        buffer.write();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Main方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package com.guocl.lockorsyn.syndemo;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Buffer buffer = new Buffer();</span><br><span class="line"></span><br><span class="line">        final Writer writer = new Writer(buffer);</span><br><span class="line">        final Reader reader = new Reader(buffer);</span><br><span class="line"></span><br><span class="line">        writer.start();</span><br><span class="line">        reader.start();</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            long start = System.currentTimeMillis();</span><br><span class="line">            for (;;)&#123;</span><br><span class="line">                //等5秒钟去中断读</span><br><span class="line">                if (System.currentTimeMillis() - start &gt; 5000)&#123;</span><br><span class="line">                    System.out.println(&quot;不等了，尝试中断&quot;);</span><br><span class="line">                    reader.interrupt();</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">开始往这个buff写入数据…</span><br><span class="line">不等了，尝试中断</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们期待“读”这个线程能退出等待锁，可是事与愿违，一旦读这个线程发现自己得不到锁，就一直开始等待了，就算它等死，也得不到锁，因为写线程要21亿秒才能完成 T_T ，即使我们中断它，它都不来响应下，看来真的要等死了。</p>
<p>这个时候，ReentrantLock给了一种机制让我们来响应中断，让“读”能伸能屈，勇敢放弃对这个锁的等待。我们来改写Buffer这个类，就叫BufferInterruptibly吧，可中断缓存。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">package com.guocl.lockorsyn.lockdemo;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">public class BufferInterruptibly&#123;</span><br><span class="line"></span><br><span class="line">    private Lock lock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">    public void write()&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            long startTime = System.currentTimeMillis();</span><br><span class="line">            System.out.println(&quot;开始往这个buff写入数据…&quot;);</span><br><span class="line">            for (;;)// 模拟要处理很长时间</span><br><span class="line">            &#123;</span><br><span class="line">                if (System.currentTimeMillis()</span><br><span class="line">                        - startTime &gt; Integer.MAX_VALUE)</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;终于写完了&quot;);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void read() throws InterruptedException &#123;</span><br><span class="line">        // 注意这里，可以响应中断</span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(&quot;从这个buff读数据&quot;);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>读</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package com.guocl.lockorsyn.lockdemo;</span><br><span class="line"></span><br><span class="line">public class Reader extends Thread&#123;</span><br><span class="line"></span><br><span class="line">    private BufferInterruptibly buff;</span><br><span class="line"></span><br><span class="line">    public Reader(BufferInterruptibly buff)&#123;</span><br><span class="line">        this.buff = buff;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            //可以收到中断的异常，从而有效退出</span><br><span class="line">            buff.read();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(&quot;我不读了&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;读结束&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>写</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package com.guocl.lockorsyn.lockdemo;</span><br><span class="line"></span><br><span class="line">public class Writer extends Thread&#123;</span><br><span class="line"></span><br><span class="line">    private BufferInterruptibly buff;</span><br><span class="line"></span><br><span class="line">    public Writer(BufferInterruptibly buff)&#123;</span><br><span class="line">        this.buff = buff;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        buff.write();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package com.guocl.lockorsyn.lockdemo;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        BufferInterruptibly buff = new BufferInterruptibly();</span><br><span class="line"></span><br><span class="line">        final Reader reader = new Reader(buff);</span><br><span class="line">        final Writer writer = new Writer(buff);</span><br><span class="line"></span><br><span class="line">        writer.start();</span><br><span class="line">        reader.start();</span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            long start = System.currentTimeMillis();</span><br><span class="line">                for (;;) &#123;</span><br><span class="line">                    if (System.currentTimeMillis()</span><br><span class="line">                            - start &gt; 5000) &#123;</span><br><span class="line">                        System.out.println(&quot;不等了，尝试中断&quot;);</span><br><span class="line">                        reader.interrupt();</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">开始往这个buff写入数据…</span><br><span class="line">不等了，尝试中断</span><br><span class="line">我不读了</span><br><span class="line">读结束</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这次“读”线程接收到了lock.lockInterruptibly()中断，并且有效处理了这个“异常”。</p>
<p>至于第二种情况，ReentrantLock可以与Condition的配合使用，Condition为ReentrantLock锁的等待和释放提供控制逻辑。<br>例如，使用ReentrantLock加锁之后，可以通过它自身的Condition.await()方法释放该锁，线程在此等待Condition.signal()方法，然后继续执行下去。await方法需要放在while循环中，因此，在不同线程之间实现并发控制，还需要一个volatile的变量，boolean是原子性的变量。因此，一般的并发控制的操作逻辑如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">volatile boolean isProcess = false;</span><br><span class="line">ReentrantLock lock  = new ReentrantLock();</span><br><span class="line">Condtion processReady = lock.newCondtion();</span><br><span class="line">thread: run() &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    isProcess = true;</span><br><span class="line">   try &#123;</span><br><span class="line">    while(!isProcessReady) &#123;  //isProcessReady 是另外一个线程的控制变量</span><br><span class="line">      processReady.await();//释放了lock，在此等待signal</span><br><span class="line">     &#125;catch (InterruptedException e) &#123;</span><br><span class="line">          Thread.currentThread().interrupt();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">          lock.unlock();</span><br><span class="line">          isProcess = false;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里只是代码使用的一段简化，下面我们看Hadoop的一段摘取的源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line">	private class MapOutputBuffer&lt;K extends Object, V extends Object&gt;</span><br><span class="line">2</span><br><span class="line">      implements MapOutputCollector&lt;K, V&gt;, IndexedSortable &#123;</span><br><span class="line">3</span><br><span class="line">...</span><br><span class="line">4</span><br><span class="line">    boolean spillInProgress;</span><br><span class="line">5</span><br><span class="line">    final ReentrantLock spillLock = new ReentrantLock();</span><br><span class="line">6</span><br><span class="line">    final Condition spillDone = spillLock.newCondition();</span><br><span class="line">7</span><br><span class="line">    final Condition spillReady = spillLock.newCondition();</span><br><span class="line">8</span><br><span class="line">    volatile boolean spillThreadRunning = false;</span><br><span class="line">9</span><br><span class="line">    final SpillThread spillThread = new SpillThread();</span><br><span class="line">10</span><br><span class="line">...</span><br><span class="line">11</span><br><span class="line">    public MapOutputBuffer(TaskUmbilicalProtocol umbilical, JobConf job,</span><br><span class="line">12</span><br><span class="line">                           TaskReporter reporter</span><br><span class="line">13</span><br><span class="line">                           ) throws IOException, ClassNotFoundException &#123;</span><br><span class="line">14</span><br><span class="line">    ...</span><br><span class="line">15</span><br><span class="line">      spillInProgress = false;</span><br><span class="line">16</span><br><span class="line">      spillThread.setDaemon(true);</span><br><span class="line">17</span><br><span class="line">      spillThread.setName(&quot;SpillThread&quot;);</span><br><span class="line">18</span><br><span class="line">      spillLock.lock();</span><br><span class="line">19</span><br><span class="line">      try &#123;</span><br><span class="line">20</span><br><span class="line">        spillThread.start();</span><br><span class="line">21</span><br><span class="line">        while (!spillThreadRunning) &#123;</span><br><span class="line">22</span><br><span class="line">          spillDone.await();</span><br><span class="line">23</span><br><span class="line">        &#125;</span><br><span class="line">24</span><br><span class="line">      &#125; catch (InterruptedException e) &#123;</span><br><span class="line">25</span><br><span class="line">        throw new IOException(&quot;Spill thread failed to initialize&quot;, e);</span><br><span class="line">26</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">27</span><br><span class="line">        spillLock.unlock();</span><br><span class="line">28</span><br><span class="line">      &#125;</span><br><span class="line">29</span><br><span class="line">    &#125;</span><br><span class="line">30</span><br><span class="line"> </span><br><span class="line">31</span><br><span class="line">    protected class SpillThread extends Thread &#123;</span><br><span class="line">32</span><br><span class="line"> </span><br><span class="line">33</span><br><span class="line">      @Override</span><br><span class="line">34</span><br><span class="line">      public void run() &#123;</span><br><span class="line">35</span><br><span class="line">        spillLock.lock();</span><br><span class="line">36</span><br><span class="line">        spillThreadRunning = true;</span><br><span class="line">37</span><br><span class="line">        try &#123;</span><br><span class="line">38</span><br><span class="line">          while (true) &#123;</span><br><span class="line">39</span><br><span class="line">            spillDone.signal();</span><br><span class="line">40</span><br><span class="line">            while (!spillInProgress) &#123;</span><br><span class="line">41</span><br><span class="line">              spillReady.await();</span><br><span class="line">42</span><br><span class="line">            &#125;</span><br><span class="line">43</span><br><span class="line">            try &#123;</span><br><span class="line">44</span><br><span class="line">              spillLock.unlock();</span><br><span class="line">45</span><br><span class="line">              sortAndSpill();</span><br><span class="line">46</span><br><span class="line">            &#125; catch (Throwable t) &#123;</span><br><span class="line">47</span><br><span class="line">              sortSpillException = t;</span><br><span class="line">48</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">49</span><br><span class="line">              spillLock.lock();</span><br><span class="line">50</span><br><span class="line">              if (bufend &lt; bufstart) &#123;</span><br><span class="line">51</span><br><span class="line">                bufvoid = kvbuffer.length;</span><br><span class="line">52</span><br><span class="line">              &#125;</span><br><span class="line">53</span><br><span class="line">              kvstart = kvend;</span><br><span class="line">54</span><br><span class="line">              bufstart = bufend;</span><br><span class="line">55</span><br><span class="line">              spillInProgress = false;</span><br><span class="line">56</span><br><span class="line">            &#125;</span><br><span class="line">57</span><br><span class="line">          &#125;</span><br><span class="line">58</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">59</span><br><span class="line">          Thread.currentThread().interrupt();</span><br><span class="line">60</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">61</span><br><span class="line">          spillLock.unlock();</span><br><span class="line">62</span><br><span class="line">          spillThreadRunning = false;</span><br><span class="line">63</span><br><span class="line">        &#125;</span><br><span class="line">64</span><br><span class="line">      &#125;</span><br><span class="line">65</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>代码中spillDone 就是 spillLock的一个newCondition()。调用spillDone.await()时可以释放spillLock锁，线程进入阻塞状态，而等待其他线程的 spillDone.signal()操作时，就会唤醒线程，重新持有spillLock锁。</p>
<p>这里可以看出，利用lock可以使我们多线程交互变得方便，而使用synchronized则无法做到这点。</p>
<p>最后呢，ReentrantLock这个类还提供了2种竞争锁的机制：公平锁和非公平锁。这2种机制的意思从字面上也能了解个大概：即对于多线程来说，公平锁会依赖线程进来的顺序，后进来的线程后获得锁。而非公平锁的意思就是后进来的锁也可以和前边等待锁的线程同时竞争锁资源。对于效率来讲，当然是非公平锁效率更高，因为公平锁还要判断是不是线程队列的第一个才会让线程获得锁。</p>
<p>3.4、Java中断机制<br>参考文章：<a target="_blank" rel="noopener" href="http://t.csdn.cn/sQxDN">http://t.csdn.cn/sQxDN</a></p>
<p>3.4.1、中断<br> 如果程序需要停止正在运行的线程，如果直接stop线程，则有可能导致程序运行不完整，因此Java提供了中断机制。中断（Interrupt）一个线程意味着在该线程完成任务之前停止其正在进行的一切，有效地终止其当前的操作。线程是死亡、还是等待新的任务或者是继续运行至下一步，就取决于这个程序。虽然初次看来它可能显得简单，但是，你必须进行一些预警以实现期望的结果。你最好还是牢记以下的几点告诫。</p>
<p>首先，忘掉Thread.stop方法。虽然它确实停止了一个正在运行的线程，然而，这种方法是不安全也是不受提倡的，这意味着，在未来的JAVA版本中，它将不复存在。<br>Java的中断是一种协作机制，也就是说通过中断并不能直接STOP另外一个线程，而需要被中断的线程自己处理中断，即仅给了另一个线程一个中断标识，由线程自行处理。<br>3.4.2、中断的原理<br> Java中断机制是一种协作机制，也就是说通过中断并不能直接终止另一个线程，而需要被中断的线程自己处理中断。这好比是家里的父母叮嘱在外的子女要注意身体，但子女是否注意身体，怎么注意身体则完全取决于自己。</p>
<p> Java中断模型也是这么简单，每个线程对象里都有一个boolean类型的标识（不一定就要是Thread类的字段，实际上也的确不是，这几个方法最终都是通过native方法来完成的），代表着是否有中断请求（该请求可以来自所有线程，包括被中断的线程本身）。例如，当线程t1想中断线程t2，只需要在线程t1中将线程t2对象的中断标识置为true，然后线程2可以选择在合适的时候处理该中断请求，甚至可以不理会该请求，就像这个线程没有被中断一样。</p>
<p> java.lang.Thread类提供了几个方法来操作这个中断状态，这些方法包括：</p>
<p>public static boolean interrupted<br>测试当前线程是否已经中断。线程的中断状态 由该方法清除。换句话说，如果连续两次调用该方法，则第二次调用将返回 false（在第一次调用已清除了其中断状态之后，且第二次调用检验完中断状态前，当前线程再次中断的情况除外）。</p>
<p>public boolean isInterrupted()<br>测试线程是否已经中断。线程的中断状态不受该方法的影响。</p>
<p>public void interrupt()<br>中断线程。</p>
<p>其中，interrupt方法是唯一能将中断状态设置为true的方法。静态方法interrupted会将当前线程的中断状态清除，但这个方法的命名极不直观，很容易造成误解，需要特别注意。</p>
<p>上面的例子中，线程t1通过调用interrupt方法将线程t2的中断状态置为true，t2可以在合适的时候调用interrupted或isInterrupted来检测状态并做相应的处理。</p>
<p>此外，类库中的有些类的方法也可能会调用中断，如FutureTask中的cancel方法，如果传入的参数为true，它将会在正在运行异步任务的线程上调用interrupt方法，如果正在执行的异步任务中的代码没有对中断做出响应，那么cancel方法中的参数将不会起到什么效果；又如ThreadPoolExecutor中的shutdownNow方法会遍历线程池中的工作线程并调用线程的interrupt方法来中断线程，所以如果工作线程中正在执行的任务没有对中断做出响应，任务将一直执行直到正常结束。</p>
<p>3.4.3、中断的处理<br>既然Java中断机制只是设置被中断线程的中断状态，那么被中断线程该做些什么？</p>
<p>3.4.3.1、处理时机<br> 显然，作为一种协作机制，不会强求被中断线程一定要在某个点进行处理。实际上，被中断线程只需在合适的时候处理即可，如果没有合适的时间点，甚至可以不处理，这时候在任务处理层面，就跟没有调用中断方法一样。“合适的时候”与线程正在处理的业务逻辑紧密相关，例如，每次迭代的时候，进入一个可能阻塞且无法中断的方法之前等，但多半不会出现在某个临界区更新另一个对象状态的时候，因为这可能会导致对象处于不一致状态。</p>
<p> 处理时机决定着程序的效率与中断响应的灵敏性。频繁的检查中断状态可能会使程序执行效率下降，相反，检查的较少可能使中断请求得不到及时响应。如果发出中断请求之后，被中断的线程继续执行一段时间不会给系统带来灾难，那么就可以将中断处理放到方便检查中断，同时又能从一定程度上保证响应灵敏度的地方。当程序的性能指标比较关键时，可能需要建立一个测试模型来分析最佳的中断检测点，以平衡性能和响应灵敏性。</p>
<p>3.4.3.2、处理方式<br>1、 中断状态的管理</p>
<p>一般说来，当可能阻塞的方法声明中有抛出InterruptedException则暗示该方法是可中断的，如BlockingQueue#put、BlockingQueue#take、Object#wait、Thread#sleep等，如果程序捕获到这些可中断的阻塞方法抛出的InterruptedException或检测到中断后，这些中断信息该如何处理？一般有以下两个通用原则：</p>
<p>如果遇到的是可中断的阻塞方法抛出InterruptedException，可以继续向方法调用栈的上层抛出该异常，如果是检测到中断，则可清除中断状态并抛出InterruptedException，使当前方法也成为一个可中断的方法。<br>若有时候不太方便在方法上抛出InterruptedException，比如要实现的某个接口中的方法签名上没有throws InterruptedException，这时就可以捕获可中断方法的InterruptedException并通过Thread.currentThread.interrupt()来重新设置中断状态。如果是检测并清除了中断状态，亦是如此。<br> 一般的代码中，尤其是作为一个基础类库时，绝不应当吞掉中断，即捕获到InterruptedException后在catch里什么也不做，清除中断状态后又不重设中断状态也不抛出InterruptedException等。因为吞掉中断状态会导致方法调用栈的上层得不到这些信息。</p>
<p> 当然，凡事总有例外的时候，当你完全清楚自己的方法会被谁调用，而调用者也不会因为中断被吞掉了而遇到麻烦，就可以这么做。</p>
<p>总得来说，就是要让方法调用栈的上层获知中断的发生。假设你写了一个类库，类库里有个方法amethod，在amethod中检测并清除了中断状态，而没有抛出InterruptedException，作为amethod的用户来说，他并不知道里面的细节，如果用户在调用amethod后也要使用中断来做些事情，那么在调用amethod之后他将永远也检测不到中断了，因为中断信息已经被amethod清除掉了。如果作为用户，遇到这样有问题的类库，又不能修改代码，那该怎么处理？只好在自己的类里设置一个自己的中断状态，在调用interrupt方法的时候，同时设置该状态，这实在是无路可走时才使用的方法。</p>
<p>2、中断的响应</p>
<p>程序里发现中断后该怎么响应？这就得视实际情况而定了。有些程序可能一检测到中断就立马将线程终止，有些可能是退出当前执行的任务，继续执行下一个任务……作为一种协作机制，这要与中断方协商好，当调用interrupt会发生些什么都是事先知道的，如做一些事务回滚操作，一些清理工作，一些补偿操作等。若不确定调用某个线程的interrupt后该线程会做出什么样的响应，那就不应当中断该线程。</p>
<p>3.4.3.3、线程在不同状态下对于中断所产生的反应<br>线程一共6种状态，分别是NEW，RUNNABLE，BLOCKED，WAITING，TIMED_WAITING，TERMINATED（Thread类中有一个State枚举类型列举了线程的所有状态）。</p>
<p>NEW和TERMINATED<br>线程的new状态表示还未调用start方法，还未真正启动。线程的terminated状态表示线程已经运行终止。这两个状态下调用中断方法来中断线程的时候，Java认为毫无意义，所以并不会设置线程的中断标识位，什么事也不会发生。</p>
<p>RUNNABLE<br>如果线程处于运行状态，那么该线程的状态就是RUNNABLE，但是不一定所有处于RUNNABLE状态的线程都能获得CPU运行，在某个时间段，只能由一个线程占用CPU，那么其余的线程虽然状态是RUNNABLE，但是都没有处于运行状态。而我们处于RUNNABLE状态的线程在遭遇中断操作的时候只会设置该线程的中断标志位，并不会让线程实际中断，想要发现本线程已经被要求中断了则需要用程序去判断。</p>
<p>BLOCKED<br>当线程处于BLOCKED状态说明该线程由于竞争某个对象的锁失败而被挂在了该对象的阻塞队列上了。那么此时发起中断操作不会对该线程产生任何影响，依然只是设置中断标志位。</p>
<p>WAITING/TIMED_WAITING<br>这两种状态本质上是同一种状态，只不过TIMED_WAITING在等待一段时间后会自动释放自己，而WAITING则是无限期等待，需要其他线程调用notify方法释放自己。但是他们都是线程在运行的过程中由于缺少某些条件（例如：调用wait()）而被挂起在某个对象的等待队列上。当这些线程遇到中断操作的时候，会抛出一个InterruptedException异常，并清空中断标志位。</p>
<p>Thread.interrupt VS Thread.stop</p>
<p>Thread.stop方法已经不推荐使用了。而在某些方面Thread.stop与中断机制有着相似之处。如当线程在等待内置锁或IO时，stop跟interrupt一样，不会中止这些操作；当catch住stop导致的异常时，程序也可以继续执行，虽然stop本意是要停止线程，这么做会让程序行为变得更加混乱。</p>
<p>那么它们的区别在哪里？最重要的就是中断需要程序自己去检测然后做相应的处理，而Thread.stop会直接在代码执行过程中抛出ThreadDeath错误，这是一个java.lang.Error的子类。</p>
<p>3.4.4、使用 interrupt 方法<br> Thread.interrupt()方法: 作用是中断线程。将会设置该线程的中断状态位，即设置为true，中断的结果线程是死亡、还是等待新的任务或是继续运行至下一步，就取决于这个程序本身。线程会不时地检测这个中断标示位，以判断线程是否应该被中断（中断标示值是否为true）。它并不像stop方法那样会中断一个正在运行的线程。</p>
<p> interrupt()方法只是改变中断状态，不会中断一个正在运行的线程。需要用户自己去监视线程的状态为并做处理。支持线程中断的方法（也就是线程中断后会抛出interruptedException的方法）就是在监视线程的中断状态，一旦线程的中断状态被置为“中断状态”，就会抛出中断异常。这一方法实际完成的是，给受阻塞的线程发出一个中断信号，这样受阻线程检查到中断标识，就得以退出阻塞的状态。</p>
<p> 更确切的说，如果线程被Object.wait, Thread.join和Thread.sleep三种方法之一阻塞，此时调用该线程的interrupt()方法，那么该线程将抛出一个 InterruptedException中断异常（该线程必须事先预备好处理此异常），从而提早地终结被阻塞状态。如果线程没有被阻塞，这时调用 interrupt()将不起作用，直到执行到wait(),sleep(),join()时,才马上会抛出 InterruptedException。</p>
<p>3.4.4.1、使用 interrupt() + InterruptedException来中断线程<br>线程处于阻塞状态，如Thread.sleep、wait、IO阻塞等情况时，调用interrupt方法后，sleep等方法将会抛出一个InterruptedException：</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        Thread thread = new Thread() &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(&quot;线程启动了&quot;);</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(1000 * 100);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(&quot;线程结束了&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        thread.start();</span><br><span class="line"> </span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(1000 * 5);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        thread.interrupt();//作用是：在线程阻塞时抛出一个中断信号，这样线程就得以退出阻塞的状态</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://i.p04e.com/baid/i/2023/03/29/5la7.png"></p>
<p>使用 interrupt() + isInterrupted()来中断线程<br> <em>this.interrupted()😗</em>测试当前线程是否已经中断（静态方法）。如果连续调用该方法，则第二次调用将返回false。在api文档中说明interrupted()方法具有清除状态的功能。执行后具有将状态标识清除为false的功能。</p>
<p><em>this.isInterrupted()😗</em>测试线程是否已经中断，但是不能清除状态标识。</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        Thread thread = new Thread() &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(&quot;线程启动了&quot;);</span><br><span class="line">                while (!isInterrupted()) &#123;</span><br><span class="line">                    System.out.println(isInterrupted());//调用 interrupt 之后为true</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(&quot;线程结束了&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        thread.start();</span><br><span class="line"> </span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        thread.interrupt();</span><br><span class="line">        System.out.println(&quot;线程是否被中断：&quot; + thread.isInterrupted());//true</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://i.p04e.com/baid/i/2023/03/29/139pc.png"></p>
<p>来一个综合的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public class test1 &#123;</span><br><span class="line"> </span><br><span class="line">    static volatile boolean flag = true;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Thread thread = new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(&quot;开始休眠&quot;);</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(100 * 1000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(&quot;结束休眠，开始死循环&quot;);</span><br><span class="line">                while (flag) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(&quot;------------------子线程结束------------------&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line"> </span><br><span class="line">        Scanner scanner = new Scanner(System.in);</span><br><span class="line">        System.out.println(&quot;输入1抛出一个中断异常，输入2修改循环标志位，输入3判断线程是否阻塞，输入其他结束Scanner\n&quot;);</span><br><span class="line">        while (scanner.hasNext()) &#123;</span><br><span class="line">            String text = scanner.next();</span><br><span class="line">            System.out.println(&quot;你输入了：&quot; + text + &quot;\n&quot;);</span><br><span class="line">            if (&quot;1&quot;.equals(text)) &#123;</span><br><span class="line">                thread.interrupt();</span><br><span class="line">            &#125; else if (&quot;2&quot;.equals(text)) &#123;</span><br><span class="line">                flag = false; //如果不设为false，主线程结束后子线程仍在运行</span><br><span class="line">            &#125; else if (&quot;3&quot;.equals(text)) &#123;</span><br><span class="line">                System.out.println(thread.isInterrupted());</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                scanner.close();</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;------------------主线程结束------------------&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://i.p04e.com/baid/i/2023/03/29/13bl4.png"></p>
<p>不能结束的情况</p>
<p>注意下面这种是根本不能结束的情况！</p>
<figure class="highlight plaintext"><figcaption><span>class Test &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Thread thread = new Thread() &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(&quot;线程启动了&quot;);</span><br><span class="line">                while (true) &#123;//对于这种情况，即使线程调用了intentrupt()方法并且isInterrupted()，但线程还是会继续运行，根本停不下来！</span><br><span class="line">                    System.out.println(isInterrupted());//调用interrupt之后为true</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        thread.start();</span><br><span class="line">        thread.interrupt();//注意，此方法不会中断一个正在运行的线程，它的作用是：在线程受到阻塞时抛出一个中断信号，这样线程就得以退出阻塞的状态</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            System.out.println(&quot;是否isInterrupted：&quot; + thread.isInterrupted());//true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于interrupted()和isInterrupted()方法的注意事项说明</p>
<p><img src="https://i.p04e.com/baid/i/2023/03/29/7oeeh.png"></p>
<p><em>interrupted()是静态方法：*</em>内部实现是调用的当前线程的isInterrupted()，并且会重置当前线程的中断状态。</p>
<p>测试当前线程是否已经中断（静态方法）。返回的是上一次的中断状态，并且会清除该状态，所以连续调用两次，第一次返回true，第二次返回false。</p>
<p><strong>isInterrupted()是实例方法：</strong>是调用该方法的对象所表示的那个线程的isInterrupted()，不会重置当前线程的中断状态</p>
<p>测试线程当前是否已经中断，但是不能清除状态标识。</p>
<p>测试方法验证：</p>
<p><img src="https://i.p04e.com/baid/i/2023/03/29/5ng0.png"></p>
<p>第一个红框中断的线程是我们自己创建的thread线程，我调用的interrupted()，由上面源码可知是判断当前线程的中断状态，当前线程是main线程，我根本没有中断过main线程，所以2次调用均返回“false”。</p>
<p><img src="https://i.p04e.com/baid/i/2023/03/29/5nmo.png"></p>
<p>第一个红框中断的线程是当前线程（main线程），我调用的interrupted()，由上面源码可知是判断当前线程的中断状态，当前线程是main线程，所以第1次调用结果返回“true”，因为我确实中断了main线程。</p>
<p>由源码可知interrupted()调用的是isInterrupted()，并会重置中断状态，所以第一次调用之后把中断状态给重置了，从中断状态重置为非中断状态，所以第2次调用的结果返回“false” 。<br> <img src="https://i.p04e.com/baid/i/2023/03/29/13ekp.png"></p>
<p>个红框中断的线程是我们自己创建的thread线程，我调用的isInterrupted()，由上面源码可知是判断执行该方法的对象所表示线程的中断状态，也就是thread引用所表示的线程的中断状态，所以第1次调用结果返回“true”。</p>
<p>由源码可知isInterrupted()不会重置中断状态，所以第一次调用之后没有把中断状态给重置（从中断状态重置为非中断状态），所以第2次调用的结果还返回“true”。</p>
<h3 id="生产者和消费者的关系"><a href="#生产者和消费者的关系" class="headerlink" title="生产者和消费者的关系"></a>生产者和消费者的关系</h3><p>面试的：单例模式、排序算法、生产者和消费者、死锁。</p>
<p>Synchronized版本</p>
<figure class="highlight plaintext"><figcaption><span>com.guocl.pc;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 线程间的通信问题:生产者和消费者的问题!  等待唤醒 通知唤醒</span><br><span class="line"> * 线程交替执行  A B同时操作一个变量</span><br><span class="line"> * A num+1</span><br><span class="line"> * B num-1</span><br><span class="line"> */</span><br><span class="line">public class ConsumeAndProduct &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Data data = new Data();</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    data.increment();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,&quot;A&quot;).start();</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    data.increment();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,&quot;B&quot;).start();</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    data.decrement();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,&quot;C&quot;).start();</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    data.decrement();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,&quot;D&quot;).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//等待  业务  通知</span><br><span class="line">class Data&#123;</span><br><span class="line">    private int num = 0;</span><br><span class="line"></span><br><span class="line">    //生产者  +1</span><br><span class="line">    public synchronized void increment() throws InterruptedException &#123;</span><br><span class="line">        //判断等待</span><br><span class="line">        if (num != 0)&#123;</span><br><span class="line">            this.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        num++;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;=&gt;&quot; + num);</span><br><span class="line">        //通知其他线程 我执行完毕了</span><br><span class="line">        this.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //消费者 -1</span><br><span class="line">    public synchronized void decrement() throws InterruptedException &#123;</span><br><span class="line">        //判断等待</span><br><span class="line">        if (num == 0)&#123;</span><br><span class="line">            this.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        num--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;=&gt;&quot; + num);</span><br><span class="line">        // 通知其他线程 -1 执行完毕</span><br><span class="line">        this.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">C=&gt;0</span><br><span class="line">B=&gt;1</span><br><span class="line">A=&gt;2</span><br><span class="line">D=&gt;1</span><br><span class="line">D=&gt;0</span><br><span class="line">A=&gt;1</span><br><span class="line">B=&gt;2</span><br><span class="line">C=&gt;1</span><br><span class="line">C=&gt;0</span><br><span class="line">B=&gt;1</span><br><span class="line">A=&gt;2</span><br><span class="line">D=&gt;1</span><br><span class="line">D=&gt;0</span><br><span class="line">A=&gt;1</span><br><span class="line">B=&gt;2</span><br><span class="line">C=&gt;1</span><br><span class="line">C=&gt;0</span><br><span class="line">B=&gt;1</span><br><span class="line">A=&gt;2</span><br><span class="line">D=&gt;1</span><br><span class="line">D=&gt;0</span><br><span class="line">A=&gt;1</span><br><span class="line">B=&gt;2</span><br><span class="line">C=&gt;1</span><br><span class="line">C=&gt;0</span><br><span class="line">B=&gt;1</span><br><span class="line">A=&gt;2</span><br><span class="line">D=&gt;1</span><br><span class="line">D=&gt;0</span><br><span class="line">A=&gt;1</span><br><span class="line">B=&gt;2</span><br><span class="line">C=&gt;1</span><br><span class="line">C=&gt;0</span><br><span class="line">B=&gt;1</span><br><span class="line">A=&gt;2</span><br><span class="line">D=&gt;1</span><br><span class="line">D=&gt;0</span><br><span class="line">B=&gt;1</span><br><span class="line">C=&gt;0</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>
<p><strong>存在问题（虚假唤醒）</strong></p>
<h4 id="虚假唤醒"><a href="#虚假唤醒" class="headerlink" title="虚假唤醒"></a>虚假唤醒</h4><p>参考文章：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45668482/article/details/117373700">https://blog.csdn.net/weixin_45668482/article/details/117373700</a><img src="https://i.p04e.com/baid/i/2023/03/29/5ne9.png"></p>
<p>解决方式： if改在while即可，防止虚假唤醒</p>
<p>结论：wait方法执行时，当前对应的线程会释放获取的当前对象锁，并被加入wait Set中，在被唤醒后，当前线程会重新进入就绪状态准备抢占CPU时间片，在重新获取该对象后，该线程将在wait方法返回后恢复原来挂起前的状态，继续向下执行 ， 我们等待的方法是在if判断内的，如下述代码：<br><figure class="highlight plaintext"><figcaption><span>-1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void decrement() throws InterruptedException &#123;</span><br><span class="line">    //判断等待</span><br><span class="line">    if (num == 0)&#123;</span><br><span class="line">        this.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    num--;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + &quot;=&gt;&quot; + num);</span><br><span class="line">    // 通知其他线程 -1 执行完毕</span><br><span class="line">    this.notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们如果使用if判断的话，直接继续运行if代码块之后的代码，不会去重新判断if条件；而使用while的话，也会从wait之后的代码开始运行，但是唤醒后会重新判断循环条件（while语句会重新循环判断并执行），如果不成立才会执行while代码块之后的代码，成立的话继续执行wait。</p>
<p>while，如下述代码：</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//消费者 -1</span><br><span class="line">    public synchronized void decrement() throws InterruptedException &#123;</span><br><span class="line">        //判断等待</span><br><span class="line">        while (num == 0)&#123;</span><br><span class="line">            this.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        num--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;=&gt;&quot; + num);</span><br><span class="line">        // 通知其他线程 -1 执行完毕</span><br><span class="line">        this.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="Lock版"><a href="#Lock版" class="headerlink" title="Lock版"></a>Lock版</h4><p><img src="https://i.p04e.com/baid/i/2023/03/29/7q0iz.png"></p>
<p>Condition</p>
<p><img src="/C:/Users\Lenovo\AppData\Roaming\Typora\typora-user-images\1680097974324.png" alt="1680097974324"></p>
<p>实现生产者和消费者代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">package com.guocl.pc;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.locks.Condition;</span><br><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">public class LockCAP &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Data2 data2 = new Data2();</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">                data2.increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,&quot;A&quot;).start();</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">                data2.decrement();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;B&quot;).start();</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">                data2.increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;C&quot;).start();</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">                data2.decrement();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;D&quot;).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Data2&#123;</span><br><span class="line">    private int num = 0;</span><br><span class="line">    Lock lock = new ReentrantLock();</span><br><span class="line">    Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    public void increment()&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (num != 0) &#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            num++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;=&gt;&quot; + num);</span><br><span class="line">            // 通知其他线程 +1 执行完毕</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void decrement()&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (num == 0)&#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            num--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;=&gt;&quot; + num);</span><br><span class="line">            // 通知其他线程 +1 执行完毕</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="Condition的优势"><a href="#Condition的优势" class="headerlink" title="Condition的优势"></a>Condition的优势</h4><p><strong>精确的通知和唤醒线程</strong></p>
<p>如果我们要指定通知的下一个进行顺序怎么办呢？ 我们可以使用Condition来指定通知进程~</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">package com.guocl.pc;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.locks.Condition;</span><br><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">public class ConditionDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Data3 data3 = new Data3();</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">                data3.printA();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,&quot;A&quot;).start();</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">                data3.printB();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,&quot;B&quot;).start();</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">                data3.printC();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,&quot;C&quot;).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Data3&#123;</span><br><span class="line">    private Lock lock = new ReentrantLock();</span><br><span class="line">    private Condition condition1 = lock.newCondition();</span><br><span class="line">    private Condition condition2 = lock.newCondition();</span><br><span class="line">    private Condition condition3 = lock.newCondition();</span><br><span class="line">    private int num = 1;// 1A 2B 3C</span><br><span class="line"></span><br><span class="line">    public void printA()&#123;</span><br><span class="line">        System.out.println(&quot;进入了A方法&quot;);</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (num != 1)&#123;</span><br><span class="line">                System.out.println(&quot;------A方法等待&quot;);</span><br><span class="line">                condition1.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;==&gt; AAAA&quot; );</span><br><span class="line">            num = 2;</span><br><span class="line">            condition2.signal();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void printB()&#123;</span><br><span class="line">        System.out.println(&quot;进入了B方法&quot;);</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (num != 2) &#123;</span><br><span class="line">                System.out.println(&quot;------B方法等待&quot;);</span><br><span class="line">                condition2.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;==&gt; BBBB&quot; );</span><br><span class="line">            num = 3;</span><br><span class="line">            condition3.signal();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void printC()&#123;</span><br><span class="line">        System.out.println(&quot;进入了C方法&quot;);</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            while(num != 3)&#123;</span><br><span class="line">                System.out.println(&quot;------C方法等待&quot;);</span><br><span class="line">                condition3.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;==&gt; CCCC&quot; );</span><br><span class="line">            num = 1;</span><br><span class="line">            condition1.signal();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="8锁现象"><a href="#8锁现象" class="headerlink" title="8锁现象"></a>8锁现象</h4><p>如何平判断锁的是谁？</p>
<p><strong>锁会锁住：对象、Class</strong></p>
<p>深刻理解我们的锁</p>
<blockquote>
<p>问题1：两个同步方法，先执行发短息还是打电话？</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package com.guocl.lock8;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 问题1：两个同步方法，先执行发短信还是打电话</span><br><span class="line"> */</span><br><span class="line">public class LockPro1 &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Phone phone = new Phone();</span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;&#123;phone.sendMs();&#125;).start();</span><br><span class="line"></span><br><span class="line">        //睡一秒</span><br><span class="line">        TimeUnit.SECONDS.sleep(1);</span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;&#123;phone.call();&#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Phone&#123;</span><br><span class="line">    public synchronized void sendMs()&#123;</span><br><span class="line">        System.out.println(&quot;发短信&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void call()&#123;</span><br><span class="line">        System.out.println(&quot;打电话&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">发短信</span><br><span class="line">打电话</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>为什么？ 如果你认为是顺序在前？ 这个答案是错误的！</strong></p>
<blockquote>
<p>问题2：我们再来看：我们让发短信延迟4S</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">package com.guocl.lock8;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 问题1：两个同步方法，先执行发短信还是打电话</span><br><span class="line"> * 让短信延迟4S</span><br><span class="line"> */</span><br><span class="line">public class LockPro2 &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Phone2 phone2 = new Phone2();</span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                phone2.sendMs();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        //睡一秒</span><br><span class="line">        TimeUnit.SECONDS.sleep(1);</span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;&#123;phone2.call();&#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Phone2&#123;</span><br><span class="line">    public synchronized void sendMs() throws InterruptedException &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(4);</span><br><span class="line">        System.out.println(&quot;发短信&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void call()&#123;</span><br><span class="line">        System.out.println(&quot;打电话&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">发短信</span><br><span class="line">打电话</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">并不是顺序执行，而是synchronized锁住的对象是方法的调用！对于两个方法用的是同一个锁，谁先拿到谁先执行，另外一个等待。 ----》锁的new出来的对象。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>问题3：加一个普通方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">package com.guocl.lock8;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line">/**</span><br><span class="line"> * 问题1：两个同步方法，先执行发短信还是打电话</span><br><span class="line"> * 让短信延迟4S</span><br><span class="line"> * 加一个普通方法</span><br><span class="line"> */</span><br><span class="line">public class LockPro3 &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Phone3 phone3 = new Phone3();</span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                phone3.sendMs();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        //睡一秒</span><br><span class="line">        TimeUnit.SECONDS.sleep(1);</span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;&#123;phone3.hello();&#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Phone3&#123;</span><br><span class="line">    public synchronized void sendMs() throws InterruptedException &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(4);</span><br><span class="line">        System.out.println(&quot;发短信&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void call()&#123;</span><br><span class="line">        System.out.println(&quot;打电话&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void hello()&#123;</span><br><span class="line">        System.out.println(&quot;hello&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">发短信</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello是一个普通方法，不受synchronized锁的影响，不用等待锁的释放。 ----》锁的new出来的对象。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>问题4：我们使用的是两个对象，一个调用发短信，一个调用打电话，顺序如何？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">package com.guocl.lock8;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">public class LockPro4&#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Phone4 phone41 = new Phone4();</span><br><span class="line">        Phone4 phone42 = new Phone4();</span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                phone41.sendMs();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        //睡一秒</span><br><span class="line">        TimeUnit.SECONDS.sleep(1);</span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;&#123;phone42.call();&#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Phone4&#123;</span><br><span class="line">    public synchronized void sendMs() throws InterruptedException &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(4);</span><br><span class="line">        System.out.println(&quot;发短信&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void call()&#123;</span><br><span class="line">        System.out.println(&quot;打电话&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void hello()&#123;</span><br><span class="line">        System.out.println(&quot;hello&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">打电话</span><br><span class="line">发短信</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">两个对象两把锁，不会出现等待的情况，发短信睡了4秒，所以先执行打电话。 ----》锁的new出来的对象。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>两个对象两把锁，不会出现等待的情况，发短信睡了4秒，所以先执行打电话。 ——》锁的new出来的对象。</p>
<ul>
<li>一个对象</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">package com.guocl.lock8;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line">/**</span><br><span class="line"> * 问题3：两个同步方法，先执行发短信还是打电话</span><br><span class="line"> * 让短信延迟4S</span><br><span class="line"> * 两个静态方法，一个对象</span><br><span class="line"> */</span><br><span class="line">public class LockPro5 &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Phone5 phone5 = new Phone5();</span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                phone5.sendMs();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        //睡一秒</span><br><span class="line">        TimeUnit.SECONDS.sleep(1);</span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;&#123;phone5.call();&#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Phone5&#123;</span><br><span class="line">    public static synchronized void sendMs() throws InterruptedException &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(4);</span><br><span class="line">        System.out.println(&quot;发短信&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static synchronized void call()&#123;</span><br><span class="line">        System.out.println(&quot;打电话&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">发短信</span><br><span class="line">打电话</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>两个对象</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package com.guocl.lock8;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line">/**</span><br><span class="line"> * 问题3：两个同步方法，先执行发短信还是打电话</span><br><span class="line"> * 让短信延迟4S</span><br><span class="line"> * 两个静态方法，两个对象</span><br><span class="line"> */</span><br><span class="line">public class LockPro6 &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Phone6 phone61 = new Phone6();</span><br><span class="line">        Phone6 phone62 = new Phone6();</span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                phone61.sendMs();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        //睡一秒</span><br><span class="line">        TimeUnit.SECONDS.sleep(1);</span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;&#123;phone62.call();&#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Phone6&#123;</span><br><span class="line">    public static synchronized void sendMs() throws InterruptedException &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(4);</span><br><span class="line">        System.out.println(&quot;发短信&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static synchronized void call()&#123;</span><br><span class="line">        System.out.println(&quot;打电话&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">发短信</span><br><span class="line">打电话</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>原因是什么呢？</p>
<p>为什么加了static就始终前面一个对象先执行呢！什么后面会等待呢？</p>
<p>原因：对象static静态方法来说，类在加载的时候就加载了静态方法，对整个类Class来说只有一份，对于不同的对象使用的是同一个Class模板，相当于这个方法是属于这个类的，如果静态static方法使用synchronized 锁定，那么这个synchronized 锁会锁住Class模板，不管多少对象，这个静态的锁都只有一把，谁先拿到谁先执行。</p>
<p>问题7：我们使用一个静态同步方法，一个对象调用的顺序是什么？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">package com.guocl.lock8;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line">/**</span><br><span class="line"> * 问题3：两个同步方法，先执行发短信还是打电话</span><br><span class="line"> * 让短信延迟4S</span><br><span class="line"> * 一个静态方法，一个对象</span><br><span class="line"> */</span><br><span class="line">public class LockPro7 &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Phone7 phone7 = new Phone7();</span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                phone7.sendMs();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        //睡一秒</span><br><span class="line">        TimeUnit.SECONDS.sleep(1);</span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;&#123;phone7.call();&#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Phone7&#123;</span><br><span class="line">    public static synchronized void sendMs() throws InterruptedException &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(4);</span><br><span class="line">        System.out.println(&quot;发短信&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void call()&#123;</span><br><span class="line">        System.out.println(&quot;打电话&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">打电话</span><br><span class="line">发短信</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">static锁的是Class模板，非静态方法锁的是new出来的对象，互不影响，不存在等待。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>问题8：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package com.guocl.lock8;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line">/**</span><br><span class="line"> * 问题3：两个同步方法，先执行发短信还是打电话</span><br><span class="line"> * 让短信延迟4S</span><br><span class="line"> * 一个静态方法，两个对象</span><br><span class="line"> */</span><br><span class="line">public class LockPro8 &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Phone8 phone81 = new Phone8();</span><br><span class="line">        Phone8 phone82 = new Phone8();</span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                phone81.sendMs();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        //睡一秒</span><br><span class="line">        TimeUnit.SECONDS.sleep(1);</span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;&#123;phone82.call();&#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Phone8&#123;</span><br><span class="line">    public static synchronized void sendMs() throws InterruptedException &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(4);</span><br><span class="line">        System.out.println(&quot;发短信&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void call()&#123;</span><br><span class="line">        System.out.println(&quot;打电话&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">打电话</span><br><span class="line">发短信</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">两个对象也是同理，static锁的是Class模板，非静态方法锁的是new出来的对象，互不影响，不存在等待。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结</p>
</blockquote>
<ul>
<li><p>非静态方法锁的是new出来的对象，互不影响；</p>
</li>
<li><p>静态方法锁的是Class模板，唯一；</p>
<h3 id="集合不安全"><a href="#集合不安全" class="headerlink" title="集合不安全"></a>集合不安全</h3><p>面试知识点：工作中遇到哪些异常，并发修改异常，OOM内存溢出异常</p>
<h4 id="List不安全"><a href="#List不安全" class="headerlink" title="List不安全"></a>List不安全</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package com.guocl.Collections;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.UUID;</span><br><span class="line"></span><br><span class="line">// ConcurrentModificationException并发修改异常！</span><br><span class="line">public class CollectionsTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;Object&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt;= 30 ; i++) &#123;</span><br><span class="line">            new Thread(()-&gt;&#123;</span><br><span class="line">                list.add(UUID.randomUUID().toString().substring(0, 5));</span><br><span class="line">                System.out.println(list);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>会导致ConcurrentModificationException并发修改异常！</p>
<p><strong>ArrayList在并发情况下是不安全的!</strong></p>
<p>解决方案：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package com.guocl.Collections;</span><br><span class="line"></span><br><span class="line">import java.util.*;</span><br><span class="line">import java.util.concurrent.CopyOnWriteArrayList;</span><br><span class="line"></span><br><span class="line">public class CollectionsTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">//        List&lt;Object&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         *  1、Vector&lt;String&gt; list = new Vector&lt;&gt;();</span><br><span class="line">         *  2、List&lt;String&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;());</span><br><span class="line">         *  3、List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">         */</span><br><span class="line">        List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt;= 30 ; i++) &#123;</span><br><span class="line">            new Thread(()-&gt;&#123;</span><br><span class="line">                list.add(UUID.randomUUID().toString().substring(0, 5));</span><br><span class="line">                System.out.println(list);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>CopyOnWriteArrayList：**写入时复制！ COW 计算机程序设计领域的一种优化策略</p>
<p>多个线程调用的时候，list是唯一的，读取的时候list是固定的，写入的时候给list复制一份给调用者，调用者写入副本，副本再添加到唯一的list中。避免在写入的时候被覆盖，造成数据问题！</p>
<p>核心思想：如果有多个调用者（Callers）同时要求相同的资源（如内存或者是磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源，直到某个调用者视图修改资源内容时，系统才会真正复制一份专用副本（private copy）给该调用者，而其他调用者所见到的最初的资源仍然保持不变。这过程对其他的调用者都是透明的（transparently）。此做法主要的优点是如果调用者没有修改资源，就不会有副本（private copy）被创建，因此多个调用者只是读取操作时可以共享同一份资源。</p>
<p>读的时候不需要加锁，如果读的时候有多个线程正向CopyOnWriteArrayList添加数据，读还是会读到旧数据，因为写的时候不会锁住旧的CopyOnWriteArrayList。</p>
<p>CopyOnWriteArrayList比Vector厉害在哪里？</p>
<p>Vector底层是使用synchronized 关键字来实现的：效率特别低下。<br><img src="https://i.p04e.com/baid/i/2023/03/29/7v0mi.png"></p>
<p><strong>CopyOnWriteArrayList</strong> 使用的是Lock锁，效率会更加高效！</p>
<p><img src="https://i.p04e.com/baid/i/2023/03/29/5s28.png"></p>
<h3 id="set不安全"><a href="#set不安全" class="headerlink" title="set不安全"></a>set不安全</h3><p>Set和List同理可得：多线程情况下，普通的Set集合是线程不安全的；</p>
<p>解决方案有两种：</p>
<ul>
<li>使用Collections工具类的<strong>synchronized</strong> 包装的Set类；</li>
<li>使用CopyOnWriteArraySet 写入复制的 <strong>JUC</strong>解决方案；</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package com.guocl.Collections;</span><br><span class="line"></span><br><span class="line">import java.util.Collections;</span><br><span class="line">import java.util.HashSet;</span><br><span class="line">import java.util.Set;</span><br><span class="line">import java.util.UUID;</span><br><span class="line">import java.util.concurrent.CopyOnWriteArraySet;</span><br><span class="line"></span><br><span class="line">public class SetTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        /**</span><br><span class="line">         * 1、Set&lt;String&gt; set = Collections.synchronizedSet(new HashSet&lt;&gt;());</span><br><span class="line">         * 2、Set&lt;String&gt; set = new CopyOnWriteArraySet&lt;&gt;();</span><br><span class="line">         */</span><br><span class="line">        Set&lt;String&gt; set = new CopyOnWriteArraySet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt;= 30; i++) &#123;</span><br><span class="line">            new Thread(() -&gt; &#123;</span><br><span class="line">                set.add(UUID.randomUUID().toString().substring(0, 5));</span><br><span class="line">                System.out.println(set);</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>HashSet底层是什么？</strong></p>
<p>hashSet底层就是一个<strong>HashMap</strong>；</p>
<p><img src="https://i.p04e.com/baid/i/2023/03/29/14m8l.png"></p>
<h4 id="Map不安全"><a href="#Map不安全" class="headerlink" title="Map不安全"></a>Map不安全</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//map 是这样用的吗？  不是，工作中不使用这个</span><br><span class="line">//默认等价什么？ new HashMap&lt;&gt;(16,0.75);</span><br><span class="line">Map&lt;String, String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">//加载因子、初始化容量</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>默认 <strong>加载因子是0.75</strong> 默认的 <strong>初始容量是16</strong></p>
<p><img src="https://i.p04e.com/baid/i/2023/03/29/14o7r.png"></p>
<p>同样的HashMap基础类也存在并发异常！</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">package com.guocl.Collections;</span><br><span class="line"></span><br><span class="line">import java.util.Collections;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.UUID;</span><br><span class="line">import java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line">public class MapTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //map 是这样用的吗？  不是，工作中不使用这个</span><br><span class="line">        //默认等价什么？ new HashMap&lt;&gt;(16,0.75);</span><br><span class="line">        /**</span><br><span class="line">         *  Map&lt;String, String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">         * 解决方案</span><br><span class="line">         * 1、Map&lt;String, String&gt; map = Collections.synchronizedMap(new HashMap&lt;&gt;());</span><br><span class="line">         * 2、Map&lt;String, String&gt; map = new ConcurrentHashMap&lt;&gt;();</span><br><span class="line">         */</span><br><span class="line">        Map&lt;String, String&gt; map = new ConcurrentHashMap&lt;&gt;();</span><br><span class="line">        //加载因子、初始化容量</span><br><span class="line">        for (int i = 1; i &lt; 100; i++) &#123;</span><br><span class="line">            new Thread(() -&gt; &#123;</span><br><span class="line">                map.put(Thread.currentThread().getName(), UUID.randomUUID().toString().substring(0, 5));</span><br><span class="line">                System.out.println(map);</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>研究ConcurrentHashMap底层原理</p>
<h3 id="Callable（简单）"><a href="#Callable（简单）" class="headerlink" title="Callable（简单）"></a>Callable（简单）</h3><p><strong>1、callable的介绍</strong></p>
<p><img src="https://i.p04e.com/baid/i/2023/03/29/5ssz.png"></p>
<p><strong>callable和runnable的区别</strong></p>
<ul>
<li>callable可以有返回值</li>
<li>callable可以抛出异常</li>
<li>callable方法不同，run()/call()</li>
</ul>
<p><img src="https://i.p04e.com/baid/i/2023/03/29/5sae.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过源码分析：Callable接口的泛型就是call方法的返回值</span><br></pre></td></tr></table></figure>
<p><strong>3、分析Callable的启动</strong></p>
<p>我们通过Thread的源码分析Thread的参数只有Runnable，不能直接启动Callable</p>
<p>通过画图分析Callable怎么才能通过Thread启动呢？———》通过Runnable</p>
<p><img src="https://i.p04e.com/baid/i/2023/03/29/trr.png"><br><img src="https://i.p04e.com/baid/i/2023/03/29/14jgv.png"></p>
<p>Runnable接口中有一个FutureTask实现类</p>
<p><img src="https://i.p04e.com/baid/i/2023/03/29/5tgz.png"></p>
<p>FutureTask介绍</p>
<p><img src="https://i.p04e.com/baid/i/2023/03/29/14rsd.png"></p>
<p>FutureTask的构造方法中的参数中有Callable和Runnable</p>
<p><img src="https://i.p04e.com/baid/i/2023/03/29/tzw.png"></p>
<p>下面我们通过代码看一下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//我们通常使用Runnable的启动是</span><br><span class="line">new Thread(new Runnable()).start();</span><br><span class="line">//因为FutureTask是Runnable的实现类，所以上面的启动代码等价于下面的这行代码</span><br><span class="line">new Thread(new FutureTask&lt;V&gt;()).start();</span><br><span class="line">//Callable是FutureTask的参数，所以启动方式就为</span><br><span class="line">new Thread(new FutureTask&lt;V&gt;(Callable));</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>代码实例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package com.guocl.collable;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.Callable;</span><br><span class="line">import java.util.concurrent.ExecutionException;</span><br><span class="line">import java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line">public class CallableTest &#123;</span><br><span class="line">    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">        //我们通常使用Runnable的启动是</span><br><span class="line">        //new Thread(new Runnable()).start();</span><br><span class="line">        //因为FutureTask是Runnable的实现类，所以上面的启动代码等价于下面的这行代码</span><br><span class="line">        //new Thread(new FutureTask&lt;V&gt;()).start();</span><br><span class="line">        //Callable是FutureTask的参数，所以启动方式就为</span><br><span class="line">        //new Thread(new FutureTask&lt;V&gt;(Callable))</span><br><span class="line"></span><br><span class="line">        new Thread().start();//怎么启动Callable</span><br><span class="line">        // 步骤解析：</span><br><span class="line">        MyThread thread = new MyThread();</span><br><span class="line">        FutureTask futureTask = new FutureTask(thread);</span><br><span class="line"></span><br><span class="line">        //运行两个Thread，只会输出一次结果-------》  结果会被缓存，效率高</span><br><span class="line">        new Thread(futureTask, &quot;A&quot;).start();</span><br><span class="line">        new Thread(futureTask, &quot;B&quot;).start();</span><br><span class="line">        //返回值</span><br><span class="line">        //这个get方法很有可能会被阻塞，如果在call方法中是一个耗时的方法，就会等待很长时间。</span><br><span class="line">        //所以我们一般情况下回把这一行放到最后，或者使用异步通信</span><br><span class="line">        Integer o = (Integer) futureTask.get();</span><br><span class="line">        System.out.println(o);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyThread implements Callable&lt;Integer&gt;&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Integer call()&#123;</span><br><span class="line">        System.out.println(&quot;call()&quot;);</span><br><span class="line">        return 1024;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>结果会被缓存</li>
<li>输出线程返回值可能会被阻塞</li>
</ul>
<h3 id="常用的辅助类（必会）"><a href="#常用的辅助类（必会）" class="headerlink" title="常用的辅助类（必会）"></a>常用的辅助类（必会）</h3><h4 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h4><p>减法计数器</p>
<p>1、主要方法：</p>
<ul>
<li>countDown 减1操作；</li>
<li>await 等待计数器归零；</li>
</ul>
<p>await等待计数器归零，就唤醒，再继续向下运行。</p>
<p>2、代码实例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package com.guocl.threadUtil;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line">public class CountDownLatchDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        // 设置总数是6</span><br><span class="line">        CountDownLatch countDownLatch = new CountDownLatch(6);  </span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt;= 8 ; i++) &#123;</span><br><span class="line">            new Thread(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot;==&gt; Go Out&quot;);</span><br><span class="line">                countDownLatch.countDown();// 线程数量  -1</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        countDownLatch.await();// 等待计数器归零  然后向下执行</span><br><span class="line">        System.out.println(&quot;close door&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">0==&gt; Go Out</span><br><span class="line">1==&gt; Go Out</span><br><span class="line">2==&gt; Go Out</span><br><span class="line">3==&gt; Go Out</span><br><span class="line">4==&gt; Go Out</span><br><span class="line">5==&gt; Go Out</span><br><span class="line">6==&gt; Go Out</span><br><span class="line">close door</span><br><span class="line">8==&gt; Go Out</span><br><span class="line">7==&gt; Go Out</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="CyclickBarrier"><a href="#CyclickBarrier" class="headerlink" title="CyclickBarrier"></a>CyclickBarrier</h4><p><img src="https://i.p04e.com/baid/i/2023/03/29/5ujl.png"></p>
<p><strong>简称：加法计数器</strong></p>
<blockquote>
<p>代码实例</p>
</blockquote>
<figure class="highlight plaintext"><figcaption><span>com.guocl.threadUtil;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import java.util.concurrent.BrokenBarrierException;</span><br><span class="line">import java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line">public class CyclickBarrierDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 主线程</span><br><span class="line">        CyclicBarrier cyclicBarrier = new CyclicBarrier(7, () -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;召唤神龙&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt;= 7; i++) &#123;</span><br><span class="line">            // 子线程</span><br><span class="line">            int i1 = i;</span><br><span class="line">            new Thread(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot;收集了第&quot; + i1 + &quot;颗龙珠&quot;);</span><br><span class="line">                try &#123;</span><br><span class="line">                    cyclicBarrier.await();// 加法计数  等待</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; catch (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Thread-0收集了第0颗龙珠</span><br><span class="line">Thread-3收集了第3颗龙珠</span><br><span class="line">Thread-2收集了第2颗龙珠</span><br><span class="line">Thread-1收集了第1颗龙珠</span><br><span class="line">Thread-4收集了第4颗龙珠</span><br><span class="line">Thread-5收集了第5颗龙珠</span><br><span class="line">Thread-6收集了第6颗龙珠</span><br><span class="line">召唤神龙</span><br><span class="line">Thread-7收集了第7颗龙珠</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h4><p>原理：</p>
<p>semaphore.acquire() 获得资源，如果资源已经使用完了，就等待资源释放后再进行使用！<br>semaphore.release()释放 ，会释放当前的信号量，然后唤醒等待的线程！<br>作用：</p>
<p>多个资源互斥时使用！并发限流，控制最大的线程数！</p>
<p>代码实例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.Semaphore;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">public class SemaphoreDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        // 线程数量。停车位，限流</span><br><span class="line">        Semaphore semaphore = new Semaphore(3);</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; 6; i++) &#123;</span><br><span class="line">            new Thread(() -&gt; &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    semaphore.acquire(); // 得到</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot;抢到车位&quot;);</span><br><span class="line">                    TimeUnit.SECONDS.sleep(2);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot;离开车位&quot;);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    semaphore.release(); // 释放</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Thread-0抢到车位</span><br><span class="line">Thread-1抢到车位</span><br><span class="line">Thread-2抢到车位</span><br><span class="line">Thread-1离开车位</span><br><span class="line">Thread-2离开车位</span><br><span class="line">Thread-0离开车位</span><br><span class="line">Thread-3抢到车位</span><br><span class="line">Thread-5抢到车位</span><br><span class="line">Thread-4抢到车位</span><br><span class="line">Thread-3离开车位</span><br><span class="line">Thread-4离开车位</span><br><span class="line">Thread-5离开车位</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><h4 id="ReadWriteLock"><a href="#ReadWriteLock" class="headerlink" title="ReadWriteLock"></a>ReadWriteLock</h4><p>实现类:ReetrantReadWritelock</p>
<p>读可以被多个线程同时读，写的时候只能有一个线程去写。</p>
<p><img src="https://i.p04e.com/baid/i/2023/03/29/u5r.png"></p>
<ul>
<li>未加锁的代码实例</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class ReadWriteLockDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyCache myCatch = new MyCache();</span><br><span class="line">        for (int i = 1; i &lt;= 5; i++) &#123;</span><br><span class="line">            final int temp = i;</span><br><span class="line">            new Thread(() -&gt; &#123;</span><br><span class="line">                myCatch.put(temp+&quot;&quot; , temp+&quot;&quot;);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt;= 5; i++) &#123;</span><br><span class="line">            final int temp = i;</span><br><span class="line">            new Thread(() -&gt; &#123;</span><br><span class="line">                myCatch.get(temp+&quot;&quot;);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyCache&#123;</span><br><span class="line">    private volatile Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    //存</span><br><span class="line">    public void put(String key, Object value)&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;写入&quot; + value);</span><br><span class="line">        map.put(key, value);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;写入成功！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //取</span><br><span class="line">    public void get(String key)&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+&quot;读取&quot;+key);</span><br><span class="line">        Object o = map.get(key);</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+&quot;读取成功&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">2写入2</span><br><span class="line">1写入1</span><br><span class="line">1写入成功！</span><br><span class="line">2写入成功！</span><br><span class="line">3写入3</span><br><span class="line">5写入5</span><br><span class="line">5写入成功！</span><br><span class="line">3写入成功！</span><br><span class="line">4写入4</span><br><span class="line">4写入成功！</span><br><span class="line">1读取1</span><br><span class="line">2读取2</span><br><span class="line">1读取成功</span><br><span class="line">2读取成功</span><br><span class="line">3读取3</span><br><span class="line">3读取成功</span><br><span class="line">4读取4</span><br><span class="line">4读取成功</span><br><span class="line">5读取5</span><br><span class="line">5读取成功</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>结论：不加锁的情况下，多线程的读写会造成数据不可靠的问题。</p>
<p>我们也可以采用<strong>synchronized</strong>这种重量锁和轻量锁 <strong>lock</strong>去保证数据的可靠。</p>
<p>但是这次我们采用更细粒度的锁：<strong>ReadWriteLock</strong> 读写锁来保证</p>
<ul>
<li>加锁代码实例</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1写入1</span><br><span class="line">1写入成功！</span><br><span class="line">2写入2</span><br><span class="line">2写入成功！</span><br><span class="line">4写入4</span><br><span class="line">4写入成功！</span><br><span class="line">3写入3</span><br><span class="line">3写入成功！</span><br><span class="line">5写入5</span><br><span class="line">5写入成功！</span><br><span class="line">1读取1</span><br><span class="line">1读取成功</span><br><span class="line">2读取2</span><br><span class="line">2读取成功</span><br><span class="line">3读取3</span><br><span class="line">5读取5</span><br><span class="line">3读取成功</span><br><span class="line">5读取成功</span><br><span class="line">4读取4</span><br><span class="line">4读取成功</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><p><img src="https://i.p04e.com/baid/i/2023/03/29/7zyy4.png"><br><img src="https://i.p04e.com/baid/i/2023/03/29/15516.png"></p>
<p>BlockQueue<br>阻塞队列</p>
<p>是Collection的一个子类</p>
<p>什么情况下我们会用到阻塞队列</p>
<p>多线程并发处理、线程池</p>
<p>BlockingQueue有四组API</p>
<p>方式    抛出异常    不会抛出异常，有返回值    阻塞，等待    超时等待<br>添加    add()    offer()    put()    offer(timenum.timeUnit)<br>移出    remove()    poll()    take()    poll(timenum,timeUnit)<br>检测队首元素    element()    peek()<br>抛出异常</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 抛出异常</span><br><span class="line"> */</span><br><span class="line">public static void test1()&#123;</span><br><span class="line">    //需要初始化队列的大小</span><br><span class="line">    ArrayBlockingQueue blockingQueue = new ArrayBlockingQueue&lt;&gt;(3);</span><br><span class="line"></span><br><span class="line">    System.out.println(blockingQueue.add(&quot;a&quot;));</span><br><span class="line">    System.out.println(blockingQueue.add(&quot;b&quot;));</span><br><span class="line">    System.out.println(blockingQueue.add(&quot;c&quot;));</span><br><span class="line"></span><br><span class="line">    //抛出异常：java.lang.IllegalStateException: Queue full</span><br><span class="line">    //        System.out.println(blockingQueue.add(&quot;d&quot;));</span><br><span class="line"></span><br><span class="line">    System.out.println(blockingQueue.remove());</span><br><span class="line">    System.out.println(blockingQueue.remove());</span><br><span class="line">    System.out.println(blockingQueue.remove());</span><br><span class="line">    //如果多移除一个</span><br><span class="line">    //这也会造成 java.util.NoSuchElementException 抛出异常</span><br><span class="line">    System.out.println(blockingQueue.remove());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>不抛出异常，有返回值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 不抛出异常，有返回值</span><br><span class="line"> */</span><br><span class="line">public static void test2()&#123;</span><br><span class="line">    ArrayBlockingQueue&lt;Object&gt; blockingQueue = new ArrayBlockingQueue&lt;&gt;(3);</span><br><span class="line"></span><br><span class="line">    System.out.println(blockingQueue.offer(&quot;a&quot;));</span><br><span class="line">    System.out.println(blockingQueue.offer(&quot;b&quot;));</span><br><span class="line">    System.out.println(blockingQueue.offer(&quot;c&quot;));</span><br><span class="line">    //添加 一个不能添加的元素 使用offer只会返回false 不会抛出异常</span><br><span class="line">    System.out.println(blockingQueue.offer(&quot;d&quot;));</span><br><span class="line"></span><br><span class="line">    System.out.println(blockingQueue.poll());</span><br><span class="line">    System.out.println(blockingQueue.poll());</span><br><span class="line">    System.out.println(blockingQueue.poll());</span><br><span class="line">    //弹出 如果没有元素 只会返回null 不会抛出异常</span><br><span class="line">    System.out.println(blockingQueue.poll());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>阻塞，等待</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 等待 一直阻塞</span><br><span class="line"> */</span><br><span class="line">public static void test3() throws InterruptedException &#123;</span><br><span class="line">    ArrayBlockingQueue blockingQueue = new ArrayBlockingQueue&lt;&gt;(3);</span><br><span class="line"></span><br><span class="line">    //</span><br><span class="line">    blockingQueue.put(&quot;a&quot;);</span><br><span class="line">    blockingQueue.put(&quot;b&quot;);</span><br><span class="line">    blockingQueue.put(&quot;c&quot;);</span><br><span class="line">    //如果队列已经满了， 再进去一个元素  这种情况会一直等待这个队列 什么时候有了位置再进去，程序不会停止</span><br><span class="line">    //        blockingQueue.put(&quot;d&quot;);</span><br><span class="line"></span><br><span class="line">    System.out.println(blockingQueue.take());</span><br><span class="line">    System.out.println(blockingQueue.take());</span><br><span class="line">    System.out.println(blockingQueue.take());</span><br><span class="line">    //如果我们再来一个  这种情况也会等待，程序会一直运行 阻塞</span><br><span class="line">    System.out.println(blockingQueue.take());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>超时等待</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 等待 超时阻塞</span><br><span class="line"> * 这种情况也会等待队列有位置 或者有产品 但是会超时结束</span><br><span class="line"> */</span><br><span class="line">public static void test4() throws InterruptedException &#123;</span><br><span class="line">    ArrayBlockingQueue&lt;Object&gt; blockingQueue = new ArrayBlockingQueue&lt;&gt;(3);</span><br><span class="line"></span><br><span class="line">    blockingQueue.offer(&quot;a&quot;);</span><br><span class="line">    blockingQueue.offer(&quot;b&quot;);</span><br><span class="line">    blockingQueue.offer(&quot;c&quot;);</span><br><span class="line"></span><br><span class="line">    //超时时间2s 等待如果超过2s就结束等待</span><br><span class="line">    blockingQueue.offer(&quot;d&quot;, 2, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">    blockingQueue.poll();</span><br><span class="line">    blockingQueue.poll();</span><br><span class="line">    blockingQueue.poll();</span><br><span class="line">    //超过两秒 我们就不要等待了</span><br><span class="line">    blockingQueue.poll(2, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>SynchronousQueue<br>同步队列</p>
<p>特点：</p>
<p>同步队列没有容量，也可以视为容量为1的队列；<br>进去一个元素，必须等待取出来之后，才能再往里面放入一个元素；<br>put方法 和 take方法</p>
<p>SynchronousQueue和 其他的BlockingQueue 不一样 它不存储元素；</p>
<p>put了一个元素，就必须从里面先take出来，否则不能再put进去值！</p>
<p>并且SynchronousQueue 的take是使用了lock锁保证线程安全的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">package com.marchsoft.queue;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.BlockingDeque;</span><br><span class="line">import java.util.concurrent.BlockingQueue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class SynchronousQueue &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        BlockingQueue&lt;String&gt; synchronousQueue = new java.util.concurrent.SynchronousQueue&lt;&gt;();</span><br><span class="line">        // 网queue中添加元素</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot;put 01&quot;);</span><br><span class="line">                synchronousQueue.put(&quot;1&quot;);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot;put 02&quot;);</span><br><span class="line">                synchronousQueue.put(&quot;2&quot;);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot;put 03&quot;);</span><br><span class="line">                synchronousQueue.put(&quot;3&quot;);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        // 取出元素</span><br><span class="line">        new Thread(()-&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot;take&quot; + synchronousQueue.take());</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot;take&quot; + synchronousQueue.take());</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot;take&quot; + synchronousQueue.take());</span><br><span class="line">            &#125;catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="线程池（重点）"><a href="#线程池（重点）" class="headerlink" title="线程池（重点）"></a>线程池（重点）</h3><p>线程池：三大创建方式、七大参数、四种拒绝策略</p>
<p>池化技术</p>
<p>程序的运行，本质：占用系统的资源！ 我们需要去优化资源的使用 ====&gt; 池化技术</p>
<p>例如：线程池、JDBC的连接池、内存池、对象池等等…</p>
<p>资源的创建、销毁十分消耗资源</p>
<p>池化技术：事先准备好一些资源，如果有人要用，就来我这里拿，用完之后还给我，以此来提高效率。</p>
<h4 id="线程池的好处："><a href="#线程池的好处：" class="headerlink" title="线程池的好处："></a>线程池的好处：</h4><p>1、降低资源的消耗；</p>
<p>2、提高响应的速度；</p>
<p>3、方便管理；</p>
<p>线程复用、可以控制最大并发、管理线程；</p>
<h4 id="线程池：三大方法、七大参数、四种策略"><a href="#线程池：三大方法、七大参数、四种策略" class="headerlink" title="线程池：三大方法、七大参数、四种策略"></a>线程池：三大方法、七大参数、四种策略</h4><p>三大方法</p>
<p>ExecutorService threadPool = Executors.newSingleThreadExecutor();//单个线程<br>ExecutorService threadPool2 = Executors.newFixedThreadPool(5); //创建一个固定的线程池的大小<br>ExecutorService threadPool3 = Executors.newCachedThreadPool(); //可伸缩的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package com.guocl.ThreadPool;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line">public class ThreadPoolDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ExecutorService threadPool = Executors.newSingleThreadExecutor();// 单个线程</span><br><span class="line">        ExecutorService threadPool = Executors.newFixedThreadPool(5);// 创建一个固定的线程池的大小</span><br><span class="line">        ExecutorService threadPool = Executors.newCachedThreadPool();// 单个线程</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            for (int i = 1; i &lt;= 10; i++) &#123;</span><br><span class="line">                threadPool.execute(() -&gt; &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot;：OK&quot;);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>七大参数</p>
</blockquote>
<p>创建线程时，不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式。</p>
<p><img src="https://i.p04e.com/baid/i/2023/03/29/81oa1.png"></p>
<p>阿里巴巴的Java操作手册中明确说明：对于Integer.MAX_VALUE初始值较大，所以一般情况我们要使用底层的 <strong>ThreadPoolExecutor</strong>来创建线程池。</p>
<p>使用 <strong>ThreadPoolExecutor</strong>创建线程池！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">package com.guocl.ThreadPool;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line">public class ThreadPoolDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">//        ExecutorService threadPool = Executors.newSingleThreadExecutor();// 单个线程</span><br><span class="line">//        ExecutorService threadPool = Executors.newFixedThreadPool(5);// 创建一个固定的线程池的大小</span><br><span class="line">//        ExecutorService threadPool = Executors.newCachedThreadPool();// 单个线程</span><br><span class="line">        //获取cpu 的核数</span><br><span class="line">        int max = Runtime.getRuntime().availableProcessors();</span><br><span class="line">        //创建线程池</span><br><span class="line">        ExecutorService threadPool = new ThreadPoolExecutor(</span><br><span class="line">                2,</span><br><span class="line">                max,</span><br><span class="line">                3,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                new LinkedBlockingDeque&lt;&gt;(3),</span><br><span class="line">                Executors.defaultThreadFactory(),</span><br><span class="line">                new ThreadPoolExecutor.AbortPolicy()</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            for (int i = 1; i &lt;= 5; i++) &#123;</span><br><span class="line">                threadPool.execute(() -&gt; &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot;：OK&quot;);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们看了一下三种创建线程池方法的底层都是调用了<strong>ThreadPoolExecutor</strong>来创建的，<strong>ThreadPoolExecutor</strong>有七大参数，我们来看一下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public ThreadPoolExecutor(int corePoolSize,  //核心线程池大小</span><br><span class="line">                          int maximumPoolSize, //最大线程池的大小</span><br><span class="line">                          long keepAliveTime,  //超时时间，超过了就会释放线程</span><br><span class="line">                          TimeUnit unit, //超时单位</span><br><span class="line">                          BlockingQueue&lt;Runnable&gt; workQueue, //阻塞队列, 用来存储排队等待的线程</span><br><span class="line">                          ThreadFactory threadFactory, //线程工厂  创建线程的，我们一般不动</span><br><span class="line">                          RejectedExecutionHandler handler //拒绝策略，有四种</span><br><span class="line">                         ) &#123;</span><br><span class="line">    if (corePoolSize &lt; 0 ||</span><br><span class="line">        maximumPoolSize &lt;= 0 ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; 0)</span><br><span class="line">        throw new IllegalArgumentException();</span><br><span class="line">    if (workQueue == null || threadFactory == null || handler == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    this.corePoolSize = corePoolSize;</span><br><span class="line">    this.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    this.workQueue = workQueue;</span><br><span class="line">    this.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    this.threadFactory = threadFactory;</span><br><span class="line">    this.handler = handler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>四种拒绝策略</p>
<p>1.new ThreadPoolExecutor.AbortPolicy()： //该拒绝策略为：银行满了，还有人进来，不处理这个人的，并抛出异常</p>
<p>超出最大承载，就会抛出异常：队列容量大小+maxPoolSize。</p>
<p>new ThreadPoolExecutor.CallerRunsPolicy()： //该拒绝策略为：哪来的去哪里 main线程进行处理。</p>
<p>new ThreadPoolExecutor.DiscardPolicy(): //该拒绝策略为：队列满了,丢掉异常，不会抛出异常。</p>
<p>new ThreadPoolExecutor.DiscardOldestPolicy()： //该拒绝策略为：队列满了，尝试去和最早的进程竞争，不会抛出异常。</p>
<p>如果设置线程池的大小</p>
<p>1、CPU密集型：电脑的核数是几核就选择几；选择maximunPoolSiz 的大小</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 获取cpu 的核数</span><br><span class="line">int max = Runtime.getRuntime().availableProcessors();</span><br><span class="line">ExecutorService service =new ThreadPoolExecutor(</span><br><span class="line">    2,</span><br><span class="line">    max,</span><br><span class="line">    3,</span><br><span class="line">    TimeUnit.SECONDS,</span><br><span class="line">    new LinkedBlockingDeque&lt;&gt;(3),</span><br><span class="line">    Executors.defaultThreadFactory(),</span><br><span class="line">    new ThreadPoolExecutor.AbortPolicy()</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>2、I/O密集型：</p>
<p>在程序中有15个大型任务，IO十分占用资源；I/O密集型就是判断我们程序中十分耗I/O的线程数量，大约就是最大I/O的一倍到两倍之间。</p>
<h3 id="四大函数式接口"><a href="#四大函数式接口" class="headerlink" title="四大函数式接口"></a>四大函数式接口</h3><p>新时代的程序员： lambda表达式、链式编程、函数式接口、Stream流式计算</p>
<p>函数式接口：只有一个方法的接口<br><img src="https://i.p04e.com/baid/i/2023/03/29/80pou.png"></p>
<h4 id="Function函数型接口"><a href="#Function函数型接口" class="headerlink" title="Function函数型接口"></a>Function函数型接口</h4><p>Function函数型接口，有一个输入参数，有一个输出参数，只要是 函数型接口 可以用 lambda表达式简化。<img src="https://i.p04e.com/baid/i/2023/03/29/822tb.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package com.guocl.function;</span><br><span class="line"></span><br><span class="line">import java.util.function.Function;</span><br><span class="line"></span><br><span class="line">public class FunctionDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">//        Function function = new Function&lt;String, String&gt;() &#123;</span><br><span class="line">//            @Override</span><br><span class="line">//            public String apply(String str) &#123;</span><br><span class="line">//                System.out.println(str);</span><br><span class="line">//                return str;</span><br><span class="line">//            &#125;</span><br><span class="line">//        &#125;;</span><br><span class="line">        Function&lt;String, String&gt; function = (str)  -&gt; &#123;return str;&#125;;</span><br><span class="line">        System.out.println(function.apply(&quot;aaa&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="Predicate-断定型接口"><a href="#Predicate-断定型接口" class="headerlink" title="Predicate 断定型接口"></a>Predicate 断定型接口</h4><p><img src="https://i.p04e.com/baid/i/2023/03/29/5xhy.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import com.sun.xml.internal.ws.util.StringUtils;</span><br><span class="line"></span><br><span class="line">import java.util.function.Predicate;</span><br><span class="line"></span><br><span class="line">public class PredicateDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">//        Predicate predicate = new Predicate&lt;String&gt;() &#123;</span><br><span class="line">//            @Override</span><br><span class="line">//            public boolean test(String o) &#123;</span><br><span class="line">//                if (o != null)&#123;</span><br><span class="line">//                    return true;</span><br><span class="line">//                &#125;</span><br><span class="line">//                return false;</span><br><span class="line">//            &#125;</span><br><span class="line">//        &#125;;</span><br><span class="line"></span><br><span class="line">        Predicate&lt;String&gt; predicate = (str) -&gt; &#123; return true;&#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(predicate.test(&quot;A&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="Consumer-消费型接口"><a href="#Consumer-消费型接口" class="headerlink" title="Consumer 消费型接口"></a>Consumer 消费型接口</h4><p><img src="https://i.p04e.com/baid/i/2023/03/29/15jn3.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import java.util.function.Consumer;</span><br><span class="line">import java.util.function.Predicate;</span><br><span class="line"></span><br><span class="line">public class PredicateDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">//        Consumer consumer = new Consumer&lt;String&gt;() &#123;</span><br><span class="line">//            @Override</span><br><span class="line">//            public void accept(String o) &#123;</span><br><span class="line">//                System.out.println(&quot;1111&quot;);</span><br><span class="line">//            &#125;</span><br><span class="line">//        &#125;;</span><br><span class="line"></span><br><span class="line">        Consumer&lt;String&gt; consumer = (str) -&gt; &#123; System.out.println(&quot;1111&quot;);&#125;;</span><br><span class="line"></span><br><span class="line">        consumer.accept(&quot;A&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="Suppier-供给型接口"><a href="#Suppier-供给型接口" class="headerlink" title="Suppier 供给型接口"></a>Suppier 供给型接口</h4><p><img src="https://i.p04e.com/baid/i/2023/03/29/15lxm.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package com.guocl.function;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import com.sun.xml.internal.ws.util.StringUtils;</span><br><span class="line"></span><br><span class="line">import java.util.function.Consumer;</span><br><span class="line">import java.util.function.Predicate;</span><br><span class="line">import java.util.function.Supplier;</span><br><span class="line"></span><br><span class="line">public class PredicateDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">//        Supplier supplier = new Supplier&lt;String&gt;() &#123;</span><br><span class="line">//            @Override</span><br><span class="line">//            public String get() &#123;</span><br><span class="line">//                return &quot;1&quot;;</span><br><span class="line">//            &#125;</span><br><span class="line">//        &#125;;</span><br><span class="line"></span><br><span class="line">        Supplier&lt;String&gt; supplier = () -&gt; &#123;  return &quot;1&quot;;&#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(supplier.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Stream流式计算"><a href="#Stream流式计算" class="headerlink" title="Stream流式计算"></a>Stream流式计算</h3><blockquote>
<p>什么是Stream流式计算</p>
</blockquote>
<p>大数据：存储 + 计算</p>
<p>集合、Mysql本质都是存储东西的；</p>
<p>计算都应该交给流来操作！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">package com.guocl.stream;</span><br><span class="line"></span><br><span class="line">import com.guocl.stream.pojo.User;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Locale;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Description：</span><br><span class="line"> * 题目要求： 用一行代码实现</span><br><span class="line"> * 1. Id 必须是偶数</span><br><span class="line"> * 2.年龄必须大于23</span><br><span class="line"> * 3. 用户名转为大写</span><br><span class="line"> * 4. 用户名倒序</span><br><span class="line"> * 5. 只能输出一个用户</span><br><span class="line"> **/</span><br><span class="line">public class StreamDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        User u1 = new User(1, &quot;a&quot;, 23);</span><br><span class="line">        User u2 = new User(2, &quot;b&quot;, 23);</span><br><span class="line">        User u3 = new User(3, &quot;c&quot;, 23);</span><br><span class="line">        User u4 = new User(6, &quot;d&quot;, 24);</span><br><span class="line">        User u5 = new User(4, &quot;e&quot;, 25);</span><br><span class="line"></span><br><span class="line">        List&lt;User&gt; list = Arrays.asList(u1, u2, u3, u4, u5);</span><br><span class="line"></span><br><span class="line">        list.stream()</span><br><span class="line">                .filter(u -&gt; &#123;return u.getId() % 2 == 0;&#125;)</span><br><span class="line">                .filter(u -&gt; &#123;return u.getAge() &gt; 23;&#125;)</span><br><span class="line">                .map(u -&gt; &#123;return u.getName().toUpperCase();&#125;)</span><br><span class="line">                .sorted((uu1, uu2) -&gt; &#123;return uu2.compareTo(uu1);&#125;)</span><br><span class="line">                .limit(1)</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="ForkJoin"><a href="#ForkJoin" class="headerlink" title="ForkJoin"></a>ForkJoin</h3><p>ForkJoin 在JDK1.7中出现，并行执行任务！提高效率。在<strong>大数据量</strong>速率会更快！</p>
<p>大数据中： <strong>MapReduce 核心思想–&gt;把大任务拆分为小任务！</strong></p>
<p><img src="https://i.p04e.com/baid/i/2023/03/29/83mnx.png"></p>
<blockquote>
<p>ForkJoin特点：工作窃取</p>
</blockquote>
<p>实现原理： <strong>双端队列</strong> 从上面和下面都可以去拿到任务进行执行！</p>
<p><img src="https://i.p04e.com/baid/i/2023/03/29/15pcg.png"></p>
<blockquote>
<p>如何使用ForkJoin？</p>
</blockquote>
<p>1、通过<strong>ForkJoinPool</strong>来执行</p>
<p>2、计算任务 <strong>execute(ForkJoinTask&lt;?&gt; task)</strong></p>
<p>3、计算类要去继承 <strong>ForkJoinTask</strong></p>
<blockquote>
<p>ForkJoin的计算案例</p>
</blockquote>
<p>ForkJoin的计算类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">package com.guocl.ff;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.RecursiveTask;</span><br><span class="line"></span><br><span class="line">public class ForkJoinDemo extends RecursiveTask&lt;Long&gt; &#123;</span><br><span class="line">    private long start;</span><br><span class="line">    private long end;</span><br><span class="line">    //临界值</span><br><span class="line">    private long temp = 1000000L;</span><br><span class="line"></span><br><span class="line">    public ForkJoinDemo(long start, long end)&#123;</span><br><span class="line">        this.start = start;</span><br><span class="line">        this.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 计算方法</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    protected Long compute() &#123;</span><br><span class="line">        if ((end - start) &lt; temp)&#123;</span><br><span class="line">            Long sum = 0L;</span><br><span class="line">            for (Long i = start; i &lt; end; i++) &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">            return sum;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            // 使用ForkJoin 分而治之  计算</span><br><span class="line">            // 1、计算平均值</span><br><span class="line">            long middle = (start + end) / 2;</span><br><span class="line">            // 拆分任务，把线程压入线程队列</span><br><span class="line">            ForkJoinDemo forkJoinDemo1 = new ForkJoinDemo(start, middle);</span><br><span class="line">            forkJoinDemo1.fork();</span><br><span class="line">            ForkJoinDemo forkJoinDemo2 = new ForkJoinDemo(middle, end);</span><br><span class="line">            forkJoinDemo2.fork();</span><br><span class="line"></span><br><span class="line">            long taskSum = forkJoinDemo1.join() + forkJoinDemo2.join();</span><br><span class="line">            return taskSum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>测试类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">package com.guocl.ff;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.ExecutionException;</span><br><span class="line">import java.util.concurrent.ForkJoinPool;</span><br><span class="line">import java.util.concurrent.ForkJoinTask;</span><br><span class="line">import java.util.stream.LongStream;</span><br><span class="line"></span><br><span class="line">public class ForkJoinTest &#123;</span><br><span class="line">    private static final long SUM = 20_0000_0000;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">        //test1();</span><br><span class="line">        test2();</span><br><span class="line">        test3();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void test1()&#123;</span><br><span class="line">        long start = System.currentTimeMillis();</span><br><span class="line">        long sum = 0L;</span><br><span class="line">        for (int i = 0; i &lt; SUM; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        long end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">        System.out.println(&quot;时间：&quot; + (end - start));</span><br><span class="line">        System.out.println(&quot;----------------------&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void test2() throws ExecutionException, InterruptedException &#123;</span><br><span class="line">        long start = System.currentTimeMillis();</span><br><span class="line">        ForkJoinPool forkJoinPool = new ForkJoinPool();</span><br><span class="line">        ForkJoinTask&lt;Long&gt; task = new ForkJoinDemo(0L, SUM);</span><br><span class="line">        ForkJoinTask&lt;Long&gt; submit = forkJoinPool.submit(task);</span><br><span class="line">        Long along = submit.get();</span><br><span class="line"></span><br><span class="line">        System.out.println(along);</span><br><span class="line">        long end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;时间：&quot; + (end - start));</span><br><span class="line">        System.out.println(&quot;-----------&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void test3()&#123;</span><br><span class="line">        long start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        long sum = LongStream.range(0L, SUM).parallel().reduce(0, Long::sum);</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">        long end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;时间：&quot; + (end - start));</span><br><span class="line">        System.out.println(&quot;-----------&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1999999999000000000</span><br><span class="line">时间：20727</span><br><span class="line">-----------</span><br><span class="line">1999999999000000000</span><br><span class="line">时间：659</span><br><span class="line">-----------</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>.parallel().reduce(0, Long::sum)使用一个并行流去计算整个计算，提高效率。</strong></p>
<p><img src="https://i.p04e.com/baid/i/2023/03/29/b21dhd.png"></p>
<h3 id="异步回调"><a href="#异步回调" class="headerlink" title="异步回调"></a>异步回调</h3><blockquote>
<p>Future 设计的初衷：对将来的某个事件结果进行建模！</p>
</blockquote>
<p>其实就是前端 —》发送ajax异步请求给后端</p>
<p><img src="https://i.p04e.com/baid/i/2023/03/29/15m0t.png"></p>
<p>但是我们平时都使用<strong>CompletableFuture</strong></p>
<blockquote>
<p>没有返回值的runAsync异步回调</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package com.guocl.ff;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.CompletableFuture;</span><br><span class="line">import java.util.concurrent.ExecutionException;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">public class FutureDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">        // 发起 一个 请求</span><br><span class="line"></span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">        System.out.println(&quot;---------------------&quot;);</span><br><span class="line">        CompletableFuture&lt;Void&gt; future = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">            //发起一个异步任务</span><br><span class="line">            try &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(2);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;.....&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">        System.out.println(&quot;------------------------------&quot;);</span><br><span class="line">        //输出执行结果</span><br><span class="line">        System.out.println(future.get());  //获取执行结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1666602291181</span><br><span class="line">---------------------</span><br><span class="line">1666602291275</span><br><span class="line">------------------------------</span><br><span class="line">ForkJoinPool.commonPool-worker-1.....</span><br><span class="line">null</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>有返回值的supplyAsync异步回调</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">package com.guocl.ff;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.CompletableFuture;</span><br><span class="line">import java.util.concurrent.ExecutionException;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">public class FutureDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">//        // 发起 一个 请求</span><br><span class="line">//		成功的</span><br><span class="line">//        System.out.println(System.currentTimeMillis());</span><br><span class="line">//        System.out.println(&quot;---------------------&quot;);</span><br><span class="line">//        CompletableFuture&lt;Void&gt; future = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">//            //发起一个异步任务</span><br><span class="line">//            try &#123;</span><br><span class="line">//                TimeUnit.SECONDS.sleep(2);</span><br><span class="line">//            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">//                e.printStackTrace();</span><br><span class="line">//            &#125;</span><br><span class="line">//            System.out.println(Thread.currentThread().getName()+&quot;.....&quot;);</span><br><span class="line">//        &#125;);</span><br><span class="line">//        System.out.println(System.currentTimeMillis());</span><br><span class="line">//        System.out.println(&quot;------------------------------&quot;);</span><br><span class="line">//        //输出执行结果</span><br><span class="line">//        System.out.println(future.get());  //获取执行结果</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //失败的</span><br><span class="line">        CompletableFuture&lt;Integer&gt; completableFuture = CompletableFuture.supplyAsync( () -&gt; &#123;</span><br><span class="line">           System.out.println(Thread.currentThread().getName());</span><br><span class="line">            try &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(2);</span><br><span class="line">                int i=1/0;</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            return 1024;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(completableFuture.whenComplete((t, u) -&gt; &#123;</span><br><span class="line">            // success 回调</span><br><span class="line">            System.out.println(&quot;t=&gt;&quot; + t); //正常的返回结果</span><br><span class="line">            System.out.println(&quot;u=&gt;&quot; + u); //抛出异常的 错误信息</span><br><span class="line">        &#125;).exceptionally((e) -&gt; &#123;</span><br><span class="line">            // error回调</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">            return 404;</span><br><span class="line">        &#125;).get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">失败时候的返回值：</span><br><span class="line"></span><br><span class="line">ForkJoinPool.commonPool-worker-1</span><br><span class="line">t=&gt;null</span><br><span class="line">u=&gt;java.util.concurrent.CompletionException: java.lang.ArithmeticException: / by zero</span><br><span class="line">java.lang.ArithmeticException: / by zero</span><br><span class="line">404</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">成功时候的返回值：</span><br><span class="line"></span><br><span class="line">ForkJoinPool.commonPool-worker-1</span><br><span class="line">t=&gt;1024</span><br><span class="line">u=&gt;null</span><br><span class="line">1024</span><br></pre></td></tr></table></figure>
<p>whenComplete: 有两个参数，一个是t 一个是u</p>
<p>T：是代表的 正常返回的结果；</p>
<p>U：是代表的 抛出异常的错误信息；</p>
<p>如果发生了异常，get可以获取到exceptionally返回的值；</p>
<p>16、JMM<br>16.1、对Volatile的理解<br>Volatile 是Java虚拟机提供 轻量级的同步机制</p>
<p>提到Volatile我们就会想到它的三个特点！</p>
<p>1、保证可见性</p>
<p>2、不保证原子性</p>
<p>3、禁止指令重排</p>
<p>如何实现可见性</p>
<p>volatile变量修饰的共享变量在进行写操作的时候会多出一行汇编：</p>
<p>0x01a3de1d:movb $0×0，0×1104800（%esi）;0x01a3de24<strong>:lock</strong> addl $0×0,(%esp);</p>
<p>Lock前缀的指令在多核处理器下回引发两件事：</p>
<p>将当前处理器缓存行的数据写回到系统内存。<br>这个写回内存的操作会使其他CPU里缓存了该内存地址的数据无效。<br>多处理器总线嗅探：</p>
<p>为了提高处理速度，处理器不直接和内存进行通信，而是先将系统内存的数据读到内部缓存后再进行操作，但操作不知道何时会写回到内存。如果对声明了volatile的变量进行写操作，JVM就会向处理器发送一条lock前缀的指令，将这个变量所在缓存行的数据写回到系统内存。但是在 多处理器下 ，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议， 每个处理器通过嗅探在总线上传播的数据来检查自己的缓存是不是过期了，如果处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置无效状态 ，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读取到处理器缓存中。</p>
<p>16.2、什么是JMM<br><strong>JMM：</strong>JAVA内存模型，不存在的东西，是一个概念也是一个约定！</p>
<p>关于JMM的一些同步的约定</p>
<p>1、线程解锁前，必须把共享变量立刻刷回主存；</p>
<p>2、线程加锁前，必须 读取主存中的最新值到工作内存中；</p>
<p>3、加锁和解锁是同一把锁；</p>
<p>线程中分为 工作内存、主内存。</p>
<p>8种操作</p>
<p>Read（读取）：作用于主内存变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用；</p>
<p>load（载入）：作用于工作内存的变量，它把read操作从主存中变量放入工作内存中；</p>
<p>Use（使用）：作用于工作内存中的变量，它把工作内存中的变量传输给执行引擎，每当虚拟机遇到一个需要使用到变量的值，就会使用到这个指令；</p>
<p>assign（赋值）：作用于工作内存中的变量，它把一个从执行引擎中接受到的值放入工作内存的变量副本中；</p>
<p>store（存储）：作用于主内存中的变量，它把一个从工作内存中一个变量的值传送到主内存中，以便后续的write使用；</p>
<p>write（写入）：作用于主内存中的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中；</p>
<p>lock（锁定）：作用于主内存的变量，把一个变量标识为线程独占状态；</p>
<p>unlock（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定；</p>
<p><img src="https://i.p04e.com/baid/i/2023/03/29/5y53.png"></p>
<p>JMM对这8种操作给了相应的规定：</p>
<p>不允许read和load、store和write操作之一单独出现。即使用了read必须load，使用了store必须write；<br>不允许线程丢弃他最近的assign操作，即工作变量的数据改变了之后，必须告知主存；<br>不允许一个线程将没有assign的数据从工作内存同步回主内存;<br>一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是对变量实施use、store操作之前，必须经过assign和load操作;<br>一个变量同一时间只有一个线程能对其进行lock。多次lock后，必须执行相同次数的unlock才能解锁;<br>如果对一个变量进行lock操作，会清空所有工作内存中此变量的值，在执行引擎使用这个变量前，必须重新load或assign操作初始化变量的值;<br>如果一个变量没有被lock，就不能对其进行unlock操作。也不能unlock一个被其他线程锁住的变量;<br>对一个变量进行unlock操作之前，必须把此变量同步回主内存<br>遇到问题</p>
<p>这时会出现一个问题，如线程A和线程B同时使用了主存的一个数据，线程B修改了值，但是线程A不能及时可见。</p>
<p><img src="https://i.p04e.com/baid/i/2023/03/29/15t7v.png"></p>
<p>遇到问题：<strong>程序不知道主存中的值已经被修改过了！ 下面解答</strong></p>
<h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><h4 id="保证可见性"><a href="#保证可见性" class="headerlink" title="保证可见性"></a>保证可见性</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package com.guocl.volatileDemo;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">public class volatiletest &#123;</span><br><span class="line"></span><br><span class="line">    //如果不加volatile，程序会一直跑，因为开启的线程不知道主存的num变成了1</span><br><span class="line">    private volatile static Integer num = 0;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        //子线程</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            while (num == 0)&#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(2);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        num = 1;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="不保证原子性"><a href="#不保证原子性" class="headerlink" title="不保证原子性"></a>不保证原子性</h4><p>原子性：不可分割；</p>
<p>线程A在执行任务的时候，不能被打扰，也不能被分割，要么同时成功，要么同时失败。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package com.guocl.volatileDemo;</span><br><span class="line"></span><br><span class="line">public class VolatileTest2 &#123;</span><br><span class="line">    private volatile static Integer num = 0;</span><br><span class="line"></span><br><span class="line">    public static void add()&#123;</span><br><span class="line">        //++ 不是一个原子性操作</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for (int i = 0; i &lt; 20; i++) &#123;</span><br><span class="line">            new Thread(() -&gt; &#123;</span><br><span class="line">                for (int j = 1; j &lt; 100; j++) &#123;</span><br><span class="line">                    add();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while (Thread.activeCount() &gt; 2)&#123;</span><br><span class="line">            //当线程数小于2的时候就停止，因为有两个默认线程：mian、GC</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;, num=&quot; + num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main, num=1980</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>如果不加lock和synchronized ，怎么样保证原子性？</strong></p>
<p><img src="https://i.p04e.com/baid/i/2023/03/29/5zg6.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package com.guocl.volatileDemo;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line">public class VolatileTest2 &#123;</span><br><span class="line">    private static volatile AtomicInteger num = new AtomicInteger();</span><br><span class="line"></span><br><span class="line">    public static void add()&#123;</span><br><span class="line">        //底层是CAS保证原子性，效率很高</span><br><span class="line">        num.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for (int i = 0; i &lt; 20; i++) &#123;</span><br><span class="line">            new Thread(() -&gt; &#123;</span><br><span class="line">                for (int j = 1; j &lt;= 1000; j++) &#123;</span><br><span class="line">                    add();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while (Thread.activeCount() &gt; 2)&#123;</span><br><span class="line">            //当线程数小于2的时候就停止，因为有两个默认线程：mian、GC</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;, num=&quot; + num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这些原子类的底层都是直接和操作系统挂钩，是在内存中修改值的。</p>
<p>Unsafe类是一个很特殊的存在；</p>
<h3 id="禁止指令重排"><a href="#禁止指令重排" class="headerlink" title="禁止指令重排"></a>禁止指令重排</h3><blockquote>
<p>什么是指令重排</p>
</blockquote>
<p>我们写程序时，计算机并不是按照我们自己写的那样去执行的。</p>
<p>源代码–&gt;编译器优化–&gt;指令并行也可能会重排–&gt;内存系统也会重排–&gt;执行</p>
<p><strong>处理器在进行指令重排的时候，会考虑数据之间的依赖性！</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int x=1; //1</span><br><span class="line">int y=2; //2</span><br><span class="line">x=x+5;   //3</span><br><span class="line">y=x*x;   //4</span><br><span class="line"></span><br><span class="line">//我们期望的执行顺序是 1_2_3_4  可能执行的顺序会变成2134 1324</span><br><span class="line">//可不可能是 4123？ 不可能的</span><br><span class="line">1234567</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可能造成的影响结果：前提：a b x y这四个值 默认都是0</p>
<p>线程A    线程B<br>x=a    y=b<br>b=1    a=2<br>正常的结果： x = 0; y =0;</p>
<p>线程A    线程B<br>b=1    a=2<br>x=a    y=b<br>可能在线程A中会出现，先执行b=1,然后再执行x=a；</p>
<p>在B线程中可能会出现，先执行a=2，然后执行y=b；</p>
<p>那么就有可能结果如下：x=2; y=1.</p>
<p>Volatile可以避免指令重排</p>
<p>Volatile中会加一道内存的屏障，这个内存屏障可以保证在这个屏障中的指令顺序。</p>
<p>内存屏障：CPU指令。</p>
<p>作用：</p>
<p>1、保证特定的操作的执行顺序；</p>
<p>2、可以保证某些变量的内存可见性（利用这些特性，就可以保证volatile实现的可见性）<br><img src="https://i.p04e.com/baid/i/2023/03/29/4em.png"></p>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><ul>
<li>volatile可以保证可见性；</li>
<li>不能保证原子性</li>
<li>由于内存屏障，可以保证避免指令重排的现象发生</li>
</ul>
<p>面试官：那么你知道在哪里用这个内存屏障用得最多呢？<strong>单例模式</strong></p>
<h3 id="玩转单例模式"><a href="#玩转单例模式" class="headerlink" title="玩转单例模式"></a>玩转单例模式</h3><p>饿汉式 、懒汉式（DCL懒汉式）</p>
<h4 id="18-1、饿汉式"><a href="#18-1、饿汉式" class="headerlink" title="18.1、饿汉式"></a>18.1、饿汉式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package com.guocl.Singleton;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 饿汉式单例</span><br><span class="line"> */</span><br><span class="line">public class Hungry &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 可能会浪费空间</span><br><span class="line">     */</span><br><span class="line">    private byte[] data1 = new byte[1024*1024];</span><br><span class="line">    private byte[] data2 = new byte[1024*1024];</span><br><span class="line">    private byte[] data3 = new byte[1024*1024];</span><br><span class="line">    private byte[] data4 = new byte[1024*1024];</span><br><span class="line"></span><br><span class="line">    private Hungry()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private final static Hungry hungry = new Hungry();</span><br><span class="line"></span><br><span class="line">    public static Hungry getInstance()&#123;</span><br><span class="line">        return hungry;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="DCL懒汉式"><a href="#DCL懒汉式" class="headerlink" title="DCL懒汉式"></a>DCL懒汉式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">package com.guocl.Singleton;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Constructor;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line">public class LazyMan &#123;</span><br><span class="line"></span><br><span class="line">    private static boolean key = false;</span><br><span class="line"></span><br><span class="line">    private LazyMan()&#123;</span><br><span class="line">        //当用反射创建对象时，会破坏单例模式，这时我们需要在构造方法处 加锁</span><br><span class="line">        synchronized (LazyMan.class)&#123;</span><br><span class="line">            //当一个对象调用单例创建，其他对象用反射创建时，这时我们需要在构造方法处判断对象是否为空</span><br><span class="line">            //但是当两个对象都用反射创建时，此校验就没用了</span><br><span class="line">//            if (lazyMan != null)&#123;</span><br><span class="line">//                throw new RuntimeException(&quot;不要试图使用反射破坏异常&quot;);</span><br><span class="line">//            &#125;</span><br><span class="line">            //当两个对象都用反射创建时，我们使用红绿灯的方式来校验(标志位)</span><br><span class="line">            if (key==false)&#123;</span><br><span class="line">                key = true;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                throw new RuntimeException(&quot;不要试图使用反射破坏异常&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;OK&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private volatile static LazyMan lazyMan;</span><br><span class="line"></span><br><span class="line">    //双重检测模式的懒汉式单例， DCL单例</span><br><span class="line">    public static LazyMan getInstance()&#123;</span><br><span class="line">        if (lazyMan == null)&#123;</span><br><span class="line">            //当多线程调用时，会创建多个不同的对象，这时我们需要加锁</span><br><span class="line">            synchronized (LazyMan.class)&#123;</span><br><span class="line">                /**</span><br><span class="line">                 * new LazyMan();有三步</span><br><span class="line">                 * 1、分配内存空间</span><br><span class="line">                 * 2、执行构造方法，初始化对象</span><br><span class="line">                 * 3、把这个对象指向这个空间</span><br><span class="line">                 *</span><br><span class="line">                 * 这时有可能出现指令重排问题</span><br><span class="line">                 * 比如执行的顺序是1 3 2 等</span><br><span class="line">                 * 我们就可以添加volatile保证指令重排问题</span><br><span class="line">                 */</span><br><span class="line">                lazyMan = new LazyMan();//不是一个原子性操作</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return lazyMan;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        //多线程调用懒汉式单例模式，需要加锁</span><br><span class="line">//        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">//          new Thread(() -&gt; &#123;</span><br><span class="line">//              System.out.println(LazyMan.getInstance());</span><br><span class="line">//          &#125;).start();</span><br><span class="line">//        &#125;</span><br><span class="line"></span><br><span class="line">//        LazyMan lazyMan1 = LazyMan.getInstance();</span><br><span class="line">//        System.out.println(&quot;lazyMan1&quot; + lazyMan1);</span><br><span class="line"></span><br><span class="line">        //使用红绿灯的方式来校验单例，也是可以破解的。</span><br><span class="line">        //我们可以反编译这个类，看到红绿灯的变量名，无视标志位的私有化</span><br><span class="line">        Field key = LazyMan.class.getDeclaredField(&quot;key&quot;);</span><br><span class="line">        key.setAccessible(true);</span><br><span class="line">        // 使用反射来破解单例模式</span><br><span class="line">        // 反射私有的无参构造</span><br><span class="line">        Constructor&lt;LazyMan&gt; declaredConstructor = LazyMan.class.getDeclaredConstructor(null);</span><br><span class="line">        //无视私有的构造器</span><br><span class="line">        declaredConstructor.setAccessible(true);</span><br><span class="line">        LazyMan lazyMan1 = declaredConstructor.newInstance();</span><br><span class="line">        System.out.println(&quot;lazyMan1&quot; + lazyMan1);</span><br><span class="line">        //把key变量变成false</span><br><span class="line">        key.set(lazyMan1, false);</span><br><span class="line">        LazyMan lazyMan2 = declaredConstructor.newInstance();</span><br><span class="line">        System.out.println(&quot;lazyMan2&quot; + lazyMan2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>结论：懒汉式无论怎么检测都是不安全的，使用枚举才是安全的</p>
<h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package com.guocl.Singleton;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 静态内部类</span><br><span class="line"> */</span><br><span class="line">public class Holder &#123;</span><br><span class="line"></span><br><span class="line">    private Holder()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Holder getInstance()&#123;</span><br><span class="line">        return InnerClass.holder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class InnerClass&#123;</span><br><span class="line">        private static final Holder holder = new Holder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package com.guocl.Singleton;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Constructor;</span><br><span class="line">import java.lang.reflect.InvocationTargetException;</span><br><span class="line"></span><br><span class="line">//enum 是什么？  enum本身是一个Class类</span><br><span class="line">public enum EnumSingle &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    public EnumSingle getInstance()&#123;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Test&#123;</span><br><span class="line">    public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException &#123;</span><br><span class="line">        EnumSingle instance1 = EnumSingle.INSTANCE;</span><br><span class="line">        //开始我们看源码 枚举是一个无参构造，但是报的错不是我们 期望的。</span><br><span class="line">        //我们通过使用工具反编译，发现枚举默认的是一个两个参数的有参构造</span><br><span class="line">//        Constructor&lt;EnumSingle&gt; declaredConstructor = EnumSingle.class.getDeclaredConstructor(null);</span><br><span class="line">        Constructor&lt;EnumSingle&gt; declaredConstructor = EnumSingle.class.getDeclaredConstructor(String.class, int.class);</span><br><span class="line">        declaredConstructor.setAccessible(true);</span><br><span class="line"></span><br><span class="line">        EnumSingle instance2 = declaredConstructor.newInstance();</span><br><span class="line">        System.out.println(instance1);</span><br><span class="line">        System.out.println(instance2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用枚举，我们就可以防止反射破坏了.</p>
<p><img src="https://i.p04e.com/baid/i/2023/03/29/86swp.png"></p>
<p>枚举类型的最终反编译源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public final class EnumSingle extends Enum</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    public static EnumSingle[] values()</span><br><span class="line">    &#123;</span><br><span class="line">        return (EnumSingle[])$VALUES.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static EnumSingle valueOf(String name)</span><br><span class="line">    &#123;</span><br><span class="line">        return (EnumSingle)Enum.valueOf(com/ogj/single/EnumSingle, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private EnumSingle(String s, int i)</span><br><span class="line">    &#123;</span><br><span class="line">        super(s, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public EnumSingle getInstance()</span><br><span class="line">    &#123;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static final EnumSingle INSTANCE;</span><br><span class="line">    private static final EnumSingle $VALUES[];</span><br><span class="line"></span><br><span class="line">    static </span><br><span class="line">    &#123;</span><br><span class="line">        INSTANCE = new EnumSingle(&quot;INSTANCE&quot;, 0);</span><br><span class="line">        $VALUES = (new EnumSingle[] &#123;</span><br><span class="line">            INSTANCE</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="深入理解CAS"><a href="#深入理解CAS" class="headerlink" title="深入理解CAS"></a>深入理解CAS</h3><h4 id="什么是CAS"><a href="#什么是CAS" class="headerlink" title="什么是CAS"></a>什么是CAS</h4><p>大厂必须深入研究底层！！！！<strong>修内功！操作系统、计算机网络、组成原理、数据结构</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package com.guocl.cas;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line">public class CasDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        AtomicInteger atomicInteger = new AtomicInteger(2020);</span><br><span class="line"></span><br><span class="line">        // boolean compareAndSet(int expect, int update)</span><br><span class="line">        // 期望值、更新值</span><br><span class="line">        // 如果实际值 和 期望值相同，那么就会更新</span><br><span class="line">        // 如果实际值 和 期望值不相同，那么就不会更新</span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(2020, 2021));</span><br><span class="line">        System.out.println(atomicInteger.get());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        // ++操作  现在实际值为2021</span><br><span class="line">        atomicInteger.getAndIncrement();</span><br><span class="line">        // 因为期望值是2020  实际上是2021，所以修改失败</span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(2020, 2021));</span><br><span class="line">        System.out.println(atomicInteger.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>之前讲volatile的时候，谈到了Unsafe类。</p>
<blockquote>
<p>Unsafe类</p>
</blockquote>
<p><img src="https://i.p04e.com/baid/i/2023/03/29/15ttg.png"></p>
<p>java可以通过Unsafe 类来操作 内存</p>
<p><img src="https://i.p04e.com/baid/i/2023/03/29/860tj.png"></p>
<p>方法解释：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//该方法功能是Interger类型加1</span><br><span class="line">public final int getAndIncrement() &#123;</span><br><span class="line">    //主要看这个getAndAddInt方法</span><br><span class="line">    return unsafe.getAndAddInt(this, valueOffset, 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//var1 是this指针</span><br><span class="line">//var2 是地址偏移量</span><br><span class="line">//var4 是自增的数值，是自增1还是自增N</span><br><span class="line">public final int getAndAddInt(Object var1, long var2, int var4) &#123;</span><br><span class="line">    int var5;</span><br><span class="line">    do &#123;</span><br><span class="line">        //获取内存值，这是内存值已经是旧的，假设我们称作期望值E</span><br><span class="line">        var5 = this.getIntVolatile(var1, var2);</span><br><span class="line">        //compareAndSwapInt方法是重点，</span><br><span class="line">        //var5是期望值，var5 + var4是要更新的值</span><br><span class="line">        //这个操作就是调用CAS的JNI,每个线程将自己内存里的内存值M</span><br><span class="line">        //与var5期望值E作比较(其实就是var1和var5作比较)，如果相同将内存值M更新为var5 + var4,否则做自旋操作</span><br><span class="line">    &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    return var5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>CAS：比较当前工作内存中的值 和 主内存中的值，如果这个值时期望的，则执行操作！如果不是就一直循环，使用的就是自旋锁。</p>
<p><strong>缺点：</strong></p>
<ul>
<li>循环会耗时；</li>
<li>一次性只能保证一个共享变量的原子性；</li>
<li>它会存在ABA问题</li>
</ul>
<blockquote>
<p>CAS：ABA问题？(狸猫换太子)</p>
</blockquote>
<p><img src="https://i.p04e.com/baid/i/2023/03/29/60c2.png"></p>
<p>线程1：期望值是1，要变成2；</p>
<p>线程2：两个操作：</p>
<ul>
<li>1、期望值是1，变成3</li>
<li>2、期望是3，变成1</li>
</ul>
<p>所以对于线程1来说，A的值还是1，所以就出现了问题，骗过了线程1；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package com.guocl.cas;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line">public class AbaDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        AtomicInteger atomicInteger = new AtomicInteger(2020);</span><br><span class="line"></span><br><span class="line">        //捣乱线程</span><br><span class="line">        System.out.println(&quot;a1:&quot; + atomicInteger.compareAndSet(2020, 2021));</span><br><span class="line">        System.out.println(&quot;a2:&quot; + atomicInteger.compareAndSet(2021, 2020));</span><br><span class="line">        System.out.println(atomicInteger.get());</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;b1&quot; + atomicInteger.compareAndSet(2020, 2022));</span><br><span class="line">        System.out.println(atomicInteger.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a1:true</span><br><span class="line">a2:true</span><br><span class="line">2020</span><br><span class="line">b1true</span><br><span class="line">2022</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>解决CAS的ABA问题需要 原子引用，也就是乐观锁的思想</p>
<h3 id="原子引用"><a href="#原子引用" class="headerlink" title="原子引用"></a>原子引用</h3><p>解决ABA问题，对应的思想：就是使用乐观锁！！！</p>
<p>带版本号的原子操作！</p>
<p>当我们使用原子操作泛型为Integer时，注意一个大坑：</p>
<p>Integer 使用了对象缓存机制，默认范围是-128~127，推荐使用静态工厂方法valueOf获取对象实例，而不是new，因为valueOf使用缓存，而new一定会创建新的对象分配新的内存空间。</p>
<p><img src="https://i.p04e.com/baid/i/2023/03/29/87ipf.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">package com.guocl.cas;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line">import java.util.concurrent.atomic.AtomicStampedReference;</span><br><span class="line"></span><br><span class="line">public class AtoRef &#123;</span><br><span class="line"></span><br><span class="line">    /**AtomicStampedReference 注意，如果泛型是一个包装类，注意对象的引用问题</span><br><span class="line">     * 正常在业务操作，这里面比较的都是一个个对象</span><br><span class="line">     */</span><br><span class="line">    static AtomicStampedReference&lt;Integer&gt; atomicStampedReference = new AtomicStampedReference&lt;&gt;(1, 1);</span><br><span class="line"></span><br><span class="line">    // CAS compareAndSet : 比较并交换！</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            // 获得新版本号</span><br><span class="line">            int stamp = atomicStampedReference.getStamp();</span><br><span class="line">            System.out.println(&quot;a1=&gt;&quot; + stamp);</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(2);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            // 修改操作时，版本号更新 + 1</span><br><span class="line">            System.out.println(atomicStampedReference.compareAndSet(1, 2, stamp, atomicStampedReference.getStamp() + 1));</span><br><span class="line">            System.out.println(&quot;a2=&gt;&quot; + atomicStampedReference.getStamp());</span><br><span class="line"></span><br><span class="line">            // 重新把值改回去， 版本号更新 + 1</span><br><span class="line">            System.out.println(atomicStampedReference.compareAndSet(2, 1, atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + 1));</span><br><span class="line">            System.out.println(&quot;a3=&gt;&quot; + atomicStampedReference.getStamp());</span><br><span class="line"></span><br><span class="line">        &#125;, &quot;a&quot;).start();</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            //获得版本号</span><br><span class="line">            int stamp = atomicStampedReference.getStamp();</span><br><span class="line">            System.out.println(&quot;b1=&gt;&quot; + stamp);</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(3);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(atomicStampedReference.compareAndSet(1, 6, stamp, atomicStampedReference.getStamp() + 1));</span><br><span class="line">            System.out.println(&quot;b2=&gt;&quot; + atomicStampedReference.getStamp());</span><br><span class="line">        &#125;, &quot;b&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a1=&gt;1</span><br><span class="line">b1=&gt;1</span><br><span class="line">true</span><br><span class="line">a2=&gt;2</span><br><span class="line">true</span><br><span class="line">a3=&gt;3</span><br><span class="line">false</span><br><span class="line">b2=&gt;3</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="各种锁的理解"><a href="#各种锁的理解" class="headerlink" title="各种锁的理解"></a>各种锁的理解</h3><h4 id="公平锁、非公平锁"><a href="#公平锁、非公平锁" class="headerlink" title="公平锁、非公平锁"></a>公平锁、非公平锁</h4><p><strong>公平锁：</strong> 非常公平，不能够插队，必须先来后到！</p>
<p><strong>非公平锁：</strong>非常不公平，可以插队！</p>
<p>Synchronized和Lock锁默认的都是非公平锁，看下面代码实例！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 默认非公平锁</span><br><span class="line">public ReentrantLock() &#123;</span><br><span class="line">	sync = new NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 公平锁</span><br><span class="line">public ReentrantLock(boolean fair) &#123;</span><br><span class="line">	sync = fair ? new FairSync() : new NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁`"></a>可重入锁`</h4><p>又叫递归锁</p>
<p><img src="https://i.p04e.com/baid/i/2023/03/29/16ay5.png"></p>
<p>手写可重入锁</p>
<blockquote>
<p>Synchronized</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package com.guocl.Lock;</span><br><span class="line"></span><br><span class="line">public class Demo1 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Phone phone = new Phone();</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt;&#123;</span><br><span class="line">            phone.sms();</span><br><span class="line">        &#125;, &quot;A&quot;).start();</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            phone.call();</span><br><span class="line">        &#125;, &quot;B&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Phone&#123;</span><br><span class="line">    public synchronized void sms()&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;sms&quot;);</span><br><span class="line">        call();// 这里也有锁</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void call()&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;call&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Lock</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">package com.guocl.Lock;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">public class Demo2 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Phone2 phone2 = new Phone2();</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt;&#123;</span><br><span class="line">            phone2.sms();</span><br><span class="line">        &#125;, &quot;A&quot;).start();</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            phone2.call();</span><br><span class="line">        &#125;, &quot;B&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Phone2&#123;</span><br><span class="line">    Lock lock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">    public void sms()&#123;</span><br><span class="line">        lock.lock(); // 细节问题：lock.lock(); lock.unlock(); // lock 锁必须配对，否则就会死在里面</span><br><span class="line">        lock.lock();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;sms&quot;);</span><br><span class="line">            call();// 这里也有锁</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void call()&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;call&quot;);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Asms</span><br><span class="line">Acall</span><br><span class="line">Bcall</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>两个锁的执行结果相同，当A线程拿到第一个锁之后，就自动拿到下面的锁了，等这个线程的锁全部执行完才会释放锁。</p>
<h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><p>spinlock 自旋锁必须有CAS操作</p>
<p><img src="https://i.p04e.com/baid/i/2023/03/29/v54.png"></p>
<p>我们来自定义一个锁测试</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package com.guocl.Lock;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 自旋锁</span><br><span class="line"> */</span><br><span class="line">public class SpinlockDemo &#123;</span><br><span class="line"></span><br><span class="line">    // int 0</span><br><span class="line">    // Thread null</span><br><span class="line">    AtomicReference&lt;Thread&gt; atomicReference = new AtomicReference&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    // 加锁</span><br><span class="line">    public void myLock()&#123;</span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;==&gt; mylock&quot;);</span><br><span class="line"></span><br><span class="line">        //自旋锁 必须有CAS操作</span><br><span class="line">        while (!atomicReference.compareAndSet(null, thread))&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 解锁</span><br><span class="line">    public void myUnLock()&#123;</span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;==&gt; myUnLock&quot;);</span><br><span class="line">        atomicReference.compareAndSet(thread, null);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package com.guocl.Lock;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">public class SpinlockTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        // ReentrantLock reentrantLock = new ReentrantLock();</span><br><span class="line">        // reentrantLock.lock();</span><br><span class="line">        // reentrantLock.unlock();</span><br><span class="line"></span><br><span class="line">        // 底层使用的自旋锁CAS</span><br><span class="line">        SpinlockDemo lock = new SpinlockDemo();</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            lock.myLock();</span><br><span class="line">            try &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(5);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                lock.myUnLock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;T1&quot;).start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(1);</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            lock.myLock();</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(1);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                lock.myUnLock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;T2&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">执行结果：</span><br><span class="line"></span><br><span class="line">T1==&gt; mylock</span><br><span class="line">T2==&gt; mylock</span><br><span class="line">T1==&gt; myUnLock</span><br><span class="line">T2==&gt; myUnLock</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><blockquote>
<p>死锁是什么</p>
</blockquote>
<p><img src="https://i.p04e.com/baid/i/2023/03/29/16gtz.png"></p>
<p>死锁测试，怎么排除死锁：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">package com.guocl.Lock;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">public class DeadLockDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String lockA = &quot;lockA&quot;;</span><br><span class="line">        String lockB = &quot;lockB&quot;;</span><br><span class="line"></span><br><span class="line">        new Thread(new MyThread(lockA, lockB), &quot;T1&quot;).start();</span><br><span class="line">        new Thread(new MyThread(lockB, lockA), &quot;T1&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyThread implements Runnable&#123;</span><br><span class="line"></span><br><span class="line">    private String lockA;</span><br><span class="line">    private String lockB;</span><br><span class="line"></span><br><span class="line">    public MyThread(String lockA, String lockB)&#123;</span><br><span class="line">        this.lockA = lockA;</span><br><span class="line">        this.lockB = lockB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        synchronized (lockA)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;lock:&quot; + lockA + &quot;=&gt;get:&quot; + lockB);</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(2);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            synchronized (lockB)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot;lock:&quot; + lockB + &quot;=&gt;get:&quot; + lockA);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>解决死锁问题</p>
</blockquote>
<p>1、使用 <strong>jsp -l</strong> 定位进程号</p>
<p><img src="https://i.p04e.com/baid/i/2023/03/29/16c1z.png"></p>
<p>2、使用 <strong>jstack 进程号</strong> 找到死锁问题<img src="https://i.p04e.com/baid/i/2023/03/29/16b4l.png"></p>

    </div>

    
    
    
        <div class="reward-container">
  <div>有帮助的话可以来打赏一些或者经常来看看我哦，我在这里等你！</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.png" alt="白都 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.png" alt="白都 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Juc/" rel="tag"># Juc</a>
              <a href="/tags/%E7%94%9F%E4%BA%A7%E8%80%85%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85/" rel="tag"># 生产者和消费者</a>
              <a href="/tags/Lock/" rel="tag"># Lock</a>
              <a href="/tags/Callable/" rel="tag"># Callable</a>
              <a href="/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/" rel="tag"># 线程池</a>
              <a href="/tags/volatile/" rel="tag"># volatile</a>
              <a href="/tags/Stream/" rel="tag"># Stream</a>
              <a href="/tags/CAS/" rel="tag"># CAS</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/03/28/%E6%B3%A8%E8%A7%A3%E4%B8%8E%E5%8F%8D%E5%B0%84/" rel="prev" title="注解与反射">
      <i class="fa fa-chevron-left"></i> 注解与反射
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/04/25/Java%E6%95%B0%E7%BB%84%E6%89%A9%E5%AE%B9%E7%9A%84%E4%B8%89%E5%A4%A7%E6%96%B9%E5%BC%8F/" rel="next" title="Java数组扩容的三大方式">
      Java数组扩容的三大方式 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>
  

  <aside class="sidebar">
    <div class="sidebar-inner">
    <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=0&id=6660459076&auto=1&height=32"></iframe>
      

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B"><span class="nav-number">1.</span> <span class="nav-text">线程和进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFJUC"><span class="nav-number">2.</span> <span class="nav-text">什么是JUC</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81"><span class="nav-number">2.1.</span> <span class="nav-text">线程的状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#wait%E4%BA%8Esleep%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.2.</span> <span class="nav-text">wait于sleep的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Lock%E9%94%81%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="nav-number">3.</span> <span class="nav-text">Lock锁（重点）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%A0%E7%BB%9F%E7%9A%84Synchronized%E9%94%81"><span class="nav-number">3.1.</span> <span class="nav-text">传统的Synchronized锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Lock%E9%94%81%EF%BC%88%E6%8E%A5%E5%8F%A3%EF%BC%89"><span class="nav-number">3.2.</span> <span class="nav-text">Lock锁（接口）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Synchronized%E5%92%8CLock%E5%8C%BA%E5%88%AB"><span class="nav-number">3.3.</span> <span class="nav-text">Synchronized和Lock区别</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81synchronize%E5%92%8Clock%E7%9A%84%E7%94%A8%E6%B3%95%E5%8C%BA%E5%88%AB"><span class="nav-number">3.3.1.</span> <span class="nav-text">1、synchronize和lock的用法区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81synchronized%E5%92%8Clock%E6%80%A7%E8%83%BD%E5%8C%BA%E5%88%AB"><span class="nav-number">3.3.2.</span> <span class="nav-text">2、synchronized和lock性能区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81synchronized%E5%92%8Clock%E7%94%A8%E9%80%94%E5%8C%BA%E5%88%AB"><span class="nav-number">3.3.3.</span> <span class="nav-text">3、synchronized和lock用途区别</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">4.</span> <span class="nav-text">生产者和消费者的关系</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E5%81%87%E5%94%A4%E9%86%92"><span class="nav-number">4.1.</span> <span class="nav-text">虚假唤醒</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Lock%E7%89%88"><span class="nav-number">4.2.</span> <span class="nav-text">Lock版</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Condition%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="nav-number">4.3.</span> <span class="nav-text">Condition的优势</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8%E9%94%81%E7%8E%B0%E8%B1%A1"><span class="nav-number">4.4.</span> <span class="nav-text">8锁现象</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%86%E5%90%88%E4%B8%8D%E5%AE%89%E5%85%A8"><span class="nav-number">5.</span> <span class="nav-text">集合不安全</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#List%E4%B8%8D%E5%AE%89%E5%85%A8"><span class="nav-number">5.1.</span> <span class="nav-text">List不安全</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#set%E4%B8%8D%E5%AE%89%E5%85%A8"><span class="nav-number">6.</span> <span class="nav-text">set不安全</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Map%E4%B8%8D%E5%AE%89%E5%85%A8"><span class="nav-number">6.1.</span> <span class="nav-text">Map不安全</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Callable%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89"><span class="nav-number">7.</span> <span class="nav-text">Callable（简单）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E8%BE%85%E5%8A%A9%E7%B1%BB%EF%BC%88%E5%BF%85%E4%BC%9A%EF%BC%89"><span class="nav-number">8.</span> <span class="nav-text">常用的辅助类（必会）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#CountDownLatch"><span class="nav-number">8.1.</span> <span class="nav-text">CountDownLatch</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CyclickBarrier"><span class="nav-number">8.2.</span> <span class="nav-text">CyclickBarrier</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Semaphore"><span class="nav-number">8.3.</span> <span class="nav-text">Semaphore</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E9%94%81"><span class="nav-number">9.</span> <span class="nav-text">读写锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ReadWriteLock"><span class="nav-number">9.1.</span> <span class="nav-text">ReadWriteLock</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="nav-number">10.</span> <span class="nav-text">阻塞队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="nav-number">11.</span> <span class="nav-text">线程池（重点）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%A5%BD%E5%A4%84%EF%BC%9A"><span class="nav-number">11.1.</span> <span class="nav-text">线程池的好处：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9A%E4%B8%89%E5%A4%A7%E6%96%B9%E6%B3%95%E3%80%81%E4%B8%83%E5%A4%A7%E5%8F%82%E6%95%B0%E3%80%81%E5%9B%9B%E7%A7%8D%E7%AD%96%E7%95%A5"><span class="nav-number">11.2.</span> <span class="nav-text">线程池：三大方法、七大参数、四种策略</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9B%E5%A4%A7%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="nav-number">12.</span> <span class="nav-text">四大函数式接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Function%E5%87%BD%E6%95%B0%E5%9E%8B%E6%8E%A5%E5%8F%A3"><span class="nav-number">12.1.</span> <span class="nav-text">Function函数型接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Predicate-%E6%96%AD%E5%AE%9A%E5%9E%8B%E6%8E%A5%E5%8F%A3"><span class="nav-number">12.2.</span> <span class="nav-text">Predicate 断定型接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Consumer-%E6%B6%88%E8%B4%B9%E5%9E%8B%E6%8E%A5%E5%8F%A3"><span class="nav-number">12.3.</span> <span class="nav-text">Consumer 消费型接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Suppier-%E4%BE%9B%E7%BB%99%E5%9E%8B%E6%8E%A5%E5%8F%A3"><span class="nav-number">12.4.</span> <span class="nav-text">Suppier 供给型接口</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Stream%E6%B5%81%E5%BC%8F%E8%AE%A1%E7%AE%97"><span class="nav-number">13.</span> <span class="nav-text">Stream流式计算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ForkJoin"><span class="nav-number">14.</span> <span class="nav-text">ForkJoin</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E5%9B%9E%E8%B0%83"><span class="nav-number">15.</span> <span class="nav-text">异步回调</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#volatile"><span class="nav-number">16.</span> <span class="nav-text">volatile</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%9D%E8%AF%81%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="nav-number">16.1.</span> <span class="nav-text">保证可见性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="nav-number">16.2.</span> <span class="nav-text">不保证原子性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A6%81%E6%AD%A2%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92"><span class="nav-number">17.</span> <span class="nav-text">禁止指令重排</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="nav-number">17.1.</span> <span class="nav-text">总结：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8E%A9%E8%BD%AC%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="nav-number">18.</span> <span class="nav-text">玩转单例模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#18-1%E3%80%81%E9%A5%BF%E6%B1%89%E5%BC%8F"><span class="nav-number">18.1.</span> <span class="nav-text">18.1、饿汉式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DCL%E6%87%92%E6%B1%89%E5%BC%8F"><span class="nav-number">18.2.</span> <span class="nav-text">DCL懒汉式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">18.3.</span> <span class="nav-text">静态内部类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE"><span class="nav-number">19.</span> <span class="nav-text">枚举</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3CAS"><span class="nav-number">20.</span> <span class="nav-text">深入理解CAS</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFCAS"><span class="nav-number">20.1.</span> <span class="nav-text">什么是CAS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">20.2.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E5%BC%95%E7%94%A8"><span class="nav-number">21.</span> <span class="nav-text">原子引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%84%E7%A7%8D%E9%94%81%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">22.</span> <span class="nav-text">各种锁的理解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81%E3%80%81%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81"><span class="nav-number">22.1.</span> <span class="nav-text">公平锁、非公平锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81"><span class="nav-number">22.2.</span> <span class="nav-text">可重入锁&#96;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E6%97%8B%E9%94%81"><span class="nav-number">22.3.</span> <span class="nav-text">自旋锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%BB%E9%94%81"><span class="nav-number">22.4.</span> <span class="nav-text">死锁</span></a></li></ol></li></ol></div>
      </div>
      
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="白都"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">白都</p>
  <div class="site-description" itemprop="description">这是我的个人知识技术总结博客，欢迎大家的到来，博客会慢慢更新。 ------------有问题请通过邮箱2653751429@qq.com联系，评论功能是不会开启的。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">50</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">78</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
          
  <div id="sidebar-dimmer"></div>
  


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">白都</span>
</div>

        
<div class="busuanzi-count">
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="true"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  
<script src="/js/local-search.js"></script>













    <div id="pjax">
  

  

  

    </div>
</body>
</html>
