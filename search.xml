<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Linux命令学习和软件安装等</title>
    <url>/2022/09/22/Linux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E7%AD%89/</url>
    <content><![CDATA[<p>自主学习了一天很懒的打字了，大部分就用图片替代吧</p>
<h3 id="VMware安装"><a href="#VMware安装" class="headerlink" title="VMware安装"></a>VMware安装</h3><span id="more"></span>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/3bv.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/vq9g.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/4j8q.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/vq8s.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/3bv_1.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/nd1.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/ncf.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/4je9.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/nc7.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/4je7.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/nc2.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/vtp7.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/nd8.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/4jqh.png"></p>
<h3 id="Linux学习"><a href="#Linux学习" class="headerlink" title="Linux学习"></a>Linux学习</h3><h4 id="Linux目录介绍"><a href="#Linux目录介绍" class="headerlink" title="Linux目录介绍"></a>Linux目录介绍</h4><ul>
<li><code>bin 存放二进制可执行文件</code></li>
<li><code>boot存放系统引导时使用的各种文件</code></li>
<li>`dev存放设备文件</li>
<li><code>etc存放系统配置文件</code></li>
<li>`home存放系统用户的文件</li>
<li><code>lib存放程序运行所需的共享库和内核模块</code></li>
<li><code>opt额外安装的可选应用程序包所放置的位置</code></li>
<li>`root超级用户目录</li>
<li><code>sbin存放二进制可执行文件，只有root用户才能访问tmp存放临时文件</code></li>
<li><code>usr存放系统应用程序</code></li>
<li><code>var存放运行时需要改变数据的文件，例如日志文件</code></li>
</ul>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/4jro.png"></p>
<h4 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h4><p><img src="https://i.p04e.com/baid/i/2022/09/22/4jnd.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/54n6.png"></p>
<mg src="https://i.p04e.com/baid/i/2022/09/22/1cv9d5.png">

<p><img src="https://i.p04e.com/baid/i/2022/09/22/9i2le1.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/1cv9a2.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/1cv9ph.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/6zbte.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/54nf.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/9i2yg5.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/zwjj.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/zwjr.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/6zc0e.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/1cvct3.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/6zbyc.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/zwlb.png"><br><img src="https://i.p04e.com/baid/i/2022/09/22/6zc0z.png"><br><img src="https://i.p04e.com/baid/i/2022/09/22/1cvcwh.png"><br><img src="https://i.p04e.com/baid/i/2022/09/22/zwhl.png"><br><img src="https://i.p04e.com/baid/i/2022/09/22/54nj.png"></p>
<h3 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h3><p><img src="https://i.p04e.com/baid/i/2022/09/22/zwf7.png"><br><img src="https://i.p04e.com/baid/i/2022/09/22/54mm.png"></p>
<h3 id="安装Tomcat"><a href="#安装Tomcat" class="headerlink" title="安装Tomcat"></a>安装Tomcat</h3><p><img src="https://i.p04e.com/baid/i/2022/09/22/4ju0.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">防火墙操作:</span><br><span class="line">查看防火墙状态(systemctl status firewalld、 firewall-cmd --state)</span><br><span class="line"></span><br><span class="line">暂时关闭防火墙(systemctl stop firewalld)</span><br><span class="line"></span><br><span class="line">永久关闭防火墙(systemctl disable firewalld)</span><br><span class="line"></span><br><span class="line">开启防火墙(systemctl start firewalld)</span><br><span class="line"></span><br><span class="line">开放指定端口(firewall-cmd --zone=public --add-port=8080/tcp --permanent)</span><br><span class="line"></span><br><span class="line">关闭指定端口(firewall-cmd --zone=public --remove-port=8080/tcp --permanent)</span><br><span class="line"></span><br><span class="line">立即生效(firewall-cmd --reload)</span><br><span class="line"></span><br><span class="line">查看开放的端口(firewall-cmd --zone=public --list-ports)</span><br><span class="line"></span><br><span class="line">注意:</span><br><span class="line">1、 systemctl是管理Linux中服务的命令，可以对服务进行启动、停止、重启、查看状态等操作</span><br><span class="line"></span><br><span class="line">2、firewall-cmd是Linux中专门用于控制防火墙的命令</span><br><span class="line"></span><br><span class="line">3、为了保证系统安全，服务器的防火墙不建议关闭</span><br></pre></td></tr></table></figure>
<h3 id="安装Mysql"><a href="#安装Mysql" class="headerlink" title="安装Mysql"></a>安装Mysql</h3><p><img src="https://i.p04e.com/baid/i/2022/09/22/nez.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/nfg.png"><br><img src="https://i.p04e.com/baid/i/2022/09/22/vv1m.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/6zmgo.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/zy5i.png"></p>
<h3 id="安装lrzsz"><a href="#安装lrzsz" class="headerlink" title="安装lrzsz"></a>安装lrzsz</h3><p><img src="https://i.p04e.com/baid/i/2022/09/22/vxab.png"></p>
<h3 id="手动部署项目"><a href="#手动部署项目" class="headerlink" title="手动部署项目"></a>手动部署项目</h3><p><img src="https://i.p04e.com/baid/i/2022/09/22/ngn.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/4k8s.png"><br><img src="https://i.p04e.com/baid/i/2022/09/22/4kcp.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/4k7c.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/1d3qa3.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/w00d.png"></p>
<h3 id="通过shell脚本自动部署项目"><a href="#通过shell脚本自动部署项目" class="headerlink" title="通过shell脚本自动部署项目"></a>通过shell脚本自动部署项目</h3><p><img src="https://i.p04e.com/baid/i/2022/09/22/vyu0.png"><br><img src="https://i.p04e.com/baid/i/2022/09/22/nhj.png"><br><img src="https://i.p04e.com/baid/i/2022/09/22/nho.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/10453.png"><br><img src="https://i.p04e.com/baid/i/2022/09/22/70t09.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">echo =================================</span><br><span class="line">echo  自动化部署脚本启动</span><br><span class="line">echo =================================</span><br><span class="line"></span><br><span class="line">echo 停止原来运行中的工程</span><br><span class="line">APP_NAME=helloworld</span><br><span class="line"></span><br><span class="line">tpid=`ps -ef|grep $APP_NAME|grep -v grep|grep -v kill|awk &#x27;&#123;print $2&#125;&#x27;`</span><br><span class="line">if [ $&#123;tpid&#125; ]; then</span><br><span class="line">    echo &#x27;Stop Process...&#x27;</span><br><span class="line">    kill -15 $tpid</span><br><span class="line">fi</span><br><span class="line">sleep 2</span><br><span class="line">tpid=`ps -ef|grep $APP_NAME|grep -v grep|grep -v kill|awk &#x27;&#123;print $2&#125;&#x27;`</span><br><span class="line">if [ $&#123;tpid&#125; ]; then</span><br><span class="line">    echo &#x27;Kill Process!&#x27;</span><br><span class="line">    kill -9 $tpid</span><br><span class="line">else</span><br><span class="line">    echo &#x27;Stop Success!&#x27;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">echo 准备从Git仓库拉取最新代码</span><br><span class="line">cd /usr/local/helloworld</span><br><span class="line"></span><br><span class="line">echo 开始从Git仓库拉取最新代码</span><br><span class="line">git pull</span><br><span class="line">echo 代码拉取完成</span><br><span class="line"></span><br><span class="line">echo 开始打包</span><br><span class="line">output=`mvn clean package -Dmaven.test.skip=true`</span><br><span class="line"></span><br><span class="line">cd target</span><br><span class="line"></span><br><span class="line">echo 启动项目</span><br><span class="line">nohup java -jar helloworld-1.0-SNAPSHOT.jar &amp;&gt; helloworld.log &amp;</span><br><span class="line">echo 项目启动完成</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/vyxp.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/njj.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/njj_1.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/nj1.png"></p>
</mg>]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>防火墙命令</tag>
        <tag>Tomcat</tag>
        <tag>Mysql</tag>
        <tag>lrzsz</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux查看ip地址出错，ens33不显示inet解决</title>
    <url>/2022/09/20/Linux%E6%9F%A5%E7%9C%8Bip%E5%9C%B0%E5%9D%80%E5%87%BA%E9%94%99%EF%BC%8Cens33%E4%B8%8D%E6%98%BE%E7%A4%BAinet%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<p>问题：在 CentOS7中输入 ip addr 时，没有显示出局域网 IP</p>
<span id="more"></span>
<p>一下午尝试了网上各种的修改方法，还是不可以，这里就不一一赘述了。</p>
<h5 id="有两种解决办法"><a href="#有两种解决办法" class="headerlink" title="有两种解决办法"></a>有两种解决办法</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.暂时解决，重新启动虚拟机后ip地址还是会消失</span><br><span class="line"></span><br><span class="line">dhclient ens33  //ens33有时也是32，这里看自己具体的内容</span><br><span class="line"></span><br><span class="line">cd /etc/sysconfig/network-scripts/   </span><br><span class="line">ls</span><br><span class="line">进这个目录下可查看</span><br></pre></td></tr></table></figure>
<p>之后重启后发现ip地址继续隐藏</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi/etc/sysconfig/network-scripts/ifcfg-ens33</span><br><span class="line"></span><br><span class="line">改BOOTPROTO=static</span><br><span class="line">  ONBOOT=yes</span><br><span class="line">  </span><br><span class="line">  之后添加自己的网关掩码等等</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://i.p04e.com/baid/i/2022/09/20/7khnp.png"></p>
<h5 id="那怎么找到自己的DNS等等呢"><a href="#那怎么找到自己的DNS等等呢" class="headerlink" title="那怎么找到自己的DNS等等呢"></a>那怎么找到自己的DNS等等呢</h5><p><img src="https://i.p04e.com/baid/i/2022/09/20/5lp3.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/20/137wp.png"></p>
<p>以上为ip 掩码 网关</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查看文件</span><br><span class="line">/var/lib/dhclient/dhclient.leases</span><br></pre></td></tr></table></figure>
<p><img src="https://i.p04e.com/baid/i/2022/09/20/sqk.png"></p>
<p>即为DNS</p>
<p>此时填回ifcfg-ens33，再次 ip addr</p>
<p><img src="https://i.p04e.com/baid/i/2022/09/20/7nc56.png"></p>
<p>出现inet!</p>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>inet</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL主从同步故障：Slave_SQL_Running:NO</title>
    <url>/2022/10/03/MySQL%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E6%95%85%E9%9A%9C%EF%BC%9ASlave-SQL-Running-NO/</url>
    <content><![CDATA[<p><img src="https://i.p04e.com/baid/i/2022/10/03/3jdmr.png"></p>
<p>Slave_SQL_Running: No</p>
<span id="more"></span>
<p>1.程序可能在slave上进行了写操作</p>
<p>2.也可能是slave机器重起后，事务回滚造成的.</p>
<p>一般是事务回滚造成的：</p>
<p>解决办法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; stop slave ;</span><br><span class="line">mysql&gt; set GLOBAL SQL_SLAVE_SKIP_COUNTER=1;</span><br><span class="line">mysql&gt; start slave ;</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">change master to master_host=&#x27;------&#x27;,master_user=&#x27;xiaoming&#x27;,master_password=&#x27;Root@123456&#x27;,master_log_file=&#x27;mysql-bin.----&#x27;,master_log_pos=---;</span><br></pre></td></tr></table></figure>
<p>——都是自己的</p>
<p><img src="https://i.p04e.com/baid/i/2022/10/03/ifdz.png"></p>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>Mysql</tag>
        <tag>主从复制</tag>
        <tag>错误</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo+github做出一个属于自己的博客!</title>
    <url>/2022/08/26/hexo-github%E5%81%9A%E5%87%BA%E4%B8%80%E4%B8%AA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    博客是按照我自己的方式通过hexo+github搭建出来的，最后的域名是从华为云购买。我会一步步的从初学者的角度向大家讲解，也会解决一些我碰到的问题 ，如果有些问题是在解决不了可以通过我的邮箱联系。</p>
<p><code>这一篇为整体的搭建，问题的解决会在最后</code></p>
<span id="more"></span>
<h3 id="准备工具"><a href="#准备工具" class="headerlink" title="准备工具"></a>准备工具</h3><ul>
<li><p>下载<a href="http://nodejs.cn/download/">node.js</a>，node.js是使用和安装hexo。</p>
</li>
<li><p>下载<a href="https://npm.taobao.org/mirrors/git-for-windows/v2.22.0.windows.1/Git-2.22.0-64-bit.exe">Git</a>,此脚本所有测试都在都在git bash上运行。</p>
</li>
<li><p>并且需要一个github账号</p>
<p>下载的步骤和环境的搭建自行百度就可以，非常简单。</p>
</li>
</ul>
<h4 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h4><ol>
<li>装完之后打开终端 win+r，然后cmd。</li>
</ol>
<p>2.输入指令回车查看版本号(新版的Node.js已自带npm，安装Node.js时会一起安装)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br><span class="line">git --version</span><br></pre></td></tr></table></figure>
<p><img src="/images/01.png"></p>
<p>出现版本号，说明你的电脑上已经有nodejs，npm安装成功</p>
<h4 id="准备hexo"><a href="#准备hexo" class="headerlink" title="准备hexo"></a>准备hexo</h4><p>在命令框里输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line"></span><br><span class="line">////////////////</span><br><span class="line"></span><br><span class="line">hexo -v</span><br></pre></td></tr></table></figure>
<p><img src="/images/02.png"></p>
<p>出现版本号即为安装成功！</p>
<h3 id="登录github"><a href="#登录github" class="headerlink" title="登录github"></a>登录github</h3><p><code>我们要做的就是利用Github的仓库作为我们hexo的一个服务器，将hexo的内容都装进这个仓库里面,让所有的人都可以访问。</code></p>
<h4 id="建仓"><a href="#建仓" class="headerlink" title="建仓"></a>建仓</h4><p>打开github，点击new新建仓库</p>
<p><img src="/images/03.png"></p>
<p><img src="/images/04.png"></p>
<p><code>注意：仓库的名字是有规定的，为自己的名字+.github.io,从上图也可看出。</code></p>
<p><img src="/images/05.png"></p>
<p> <code>跟着我的点，最后创建</code></p>
<p><img src="/images/06.png"></p>
<p>此时就已经建成功了。</p>
<h3 id="将github与本地进行绑定"><a href="#将github与本地进行绑定" class="headerlink" title="将github与本地进行绑定"></a>将github与本地进行绑定</h3><h4 id="设置密钥"><a href="#设置密钥" class="headerlink" title="设置密钥"></a>设置密钥</h4><p>​    随意进入一个文件中，在空白区域右键，点出Git bash here,输入如下指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;邮件地址&quot;  //注意在git里面想要粘贴时，右键Paste,此时输入的邮件地址为绑定的github账号的邮件地址</span><br></pre></td></tr></table></figure>
<p><img src="/images/07.png"></p>
<p><code>此时输入命令后四次回车如图即可，如果出现overwrite时输入 y</code></p>
<p><img src="/images/08.png"></p>
<p>在电脑的这个位置找见.ssh里面以.pub为结尾的文件，以笔记本打开。打开后ctrl  + a  /c</p>
<p>打开github</p>
<p><img src="/images/09.png"></p>
<p>打开Setting</p>
<p><img src="/images/10.png"></p>
<p>打开SSH and GPG keys ，在点绿色的New SSH key</p>
<p><img src="/images/11.png"></p>
<p>可以随便起一个名字，然后将复制的钥匙粘贴进下面的大框。</p>
<p>最后在原来的git命令行输入一下代码，确定是否绑定成功。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>
<p> <img src="/images/12.png"></p>
<p>过程中有一次问答输入 yes ，最后出现 successfully即可。</p>
<h2 id="建立blog并且发布到Github"><a href="#建立blog并且发布到Github" class="headerlink" title="建立blog并且发布到Github"></a>建立blog并且发布到Github</h2><p>git在国外不稳定所以命令有时候还会有网络问题，多试两次或者选择换国内镜像源也可以。</p>
<p>创建一个自己的blog的空文件夹，进入后右键出git bush here；</p>
<p>输入一下命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo init       //初始化hexo  如果成功会发现自己的blog下面会多出很多的内容</span><br><span class="line"></span><br><span class="line">hexo s         //静态生成hexo本地的博客页面</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/images/13.png"></p>
<p>ctrl加点击<a href="http://localhost:4000">http://localhost:4000</a> 即可进入本地的hexo服务器</p>
<p>ctrl + c 即可停止服务器</p>
<p>进入你的blog文件找见下面的 _config.yml文件。打开后进入代码的最下面，将代码改为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: &#x27;git&#x27;</span><br><span class="line">  repository: </span><br><span class="line">  branch: main</span><br><span class="line">//注意冒号后面还有空格</span><br></pre></td></tr></table></figure>
<p><img src="/images/14.png"></p>
<p><img src="/images/15.png"></p>
<p>进入githun中的这个code，点击复制，然后粘贴在上面的 repository后 。</p>
<p>在你的博客文件夹下面点开git命令，输入以下命令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save  </span><br><span class="line"></span><br><span class="line">hexo g   //生成页面</span><br><span class="line"></span><br><span class="line">hexo d    //上传文件至仓库，需要输入账号密码，在此处可能会出现网络不稳定问题，多试几次</span><br></pre></td></tr></table></figure>
<p><img src="/images/16.png"></p>
<p>这个为github的用户名，输入之后会在让输密码。。。。。。。注意此时不能在输密码，进入上面提到过的github里的setting ,找到左侧的Developer settings,点击开发者设置。</p>
<p><img src="/images/17.png"></p>
<p>点击 Generate new token 创建一个新的令牌。</p>
<p><img src="/images/18.png"></p>
<p>随意取一个名字，并将所有选项选上，点击生成令牌。<img src="/images/19.png"></p>
<p>复制此处的序列号令牌到弹出的提示输入密码框内。</p>
<p><img src="/images/20.png"></p>
<p>即为上传成功！<img src="/images/20.png"></p>
<p>此时仓库的内容就发生了变化。此时通过 <a href="https://你的git名字.github.io/">https://你的git名字.github.io/</a>      即可从网址访问。</p>
<p><img src="/images/21.png"></p>
<p>此时博客的搭建已经差不多了，剩下的时博客的页面主题的更换和域名的绑定</p>
]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo主题的更换与优化和域名的配置</title>
    <url>/2022/08/28/hexo%E4%B8%BB%E9%A2%98%E7%9A%84%E6%9B%B4%E6%8D%A2%E4%B8%8E%E4%BC%98%E5%8C%96%E5%92%8C%E5%9F%9F%E5%90%8D%E7%9A%84%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="一、选择主题"><a href="#一、选择主题" class="headerlink" title="一、选择主题"></a>一、选择主题</h2><p>目前 Hexo 里面应用最多的主题基本就是 Next 主题了，我用的就是Next，另外它支持的插件和功能也极为丰富。</p>
<span id="more"></span>
<h2 id="二、下载主题"><a href="#二、下载主题" class="headerlink" title="二、下载主题"></a>二、下载主题</h2><p>我们可以直接到 Next 主题的 <a href="https://so.csdn.net/so/search?q=GitHub&amp;spm=1001.2101.3001.7020">GitHub</a> Repository 上把这个主题下载下来。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://github.com/theme-next/hexo-theme-next</span><br></pre></td></tr></table></figure>
<p>命令行进入到blog项目的根目录，执行如下命令即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>
<p>执行完毕之后 Next 主题的源码就会出现在项目的 themes/next 文件夹下。<br>然后需要修改下博客所用的主题名称，修改项目根目录下的 _config.yml 文件，找到 theme 字段，修改为 next 即可，修改如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure>
<p>然后本地重新开启服务，访问刷新下页面，就可以看到 next 主题就切换成功了</p>
<p>Next 主题内部也提供了一个配置文件，Next 主题里面所有的功能都可以通过这个配置文件来控制，下文所述的内容都是修改的 themes/next/_config.yml 文件。</p>
<h3 id="3-1-样式"><a href="#3-1-样式" class="headerlink" title="3.1 样式"></a>3.1 样式</h3><p>Next 主题还提供了多种样式，风格都是类似黑白的搭配，但整个布局位置不太一样，通过修改配置文件的 scheme 字段即可，我选了 Pisces 样式，修改 _config.yml （注意是 themes/next/_config.yml 文件）如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scheme: Pisces</span><br></pre></td></tr></table></figure>
<h3 id="3-2-favicon"><a href="#3-2-favicon" class="headerlink" title="3.2 favicon"></a>3.2 favicon</h3><p><code>https://realfavicongenerator.net/</code></p>
<p>avicon 就是站点标签栏的小图标，默认是用的 Hexo 的小图标，如果我们有站点 Logo 的图片的话，我们可以自己定制小图标。到这里上传一张图，便可以直接打包下载各种尺寸和适配不同设备的小图标。</p>
<p>图标下载下来之后把它放在 themes/next/source/images 目录下面。<br>然后在配置文件里面找到 favicon 配置项，把一些相关路径配置进去即可，示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">favicon:</span><br><span class="line">  small: /images/favicon-16x16.png</span><br><span class="line">  medium: /images/favicon-32x32.png</span><br><span class="line">  apple_touch_icon: /images/apple-touch-icon.png</span><br><span class="line">  safari_pinned_tab: /images/safari-pinned-tab.svg</span><br></pre></td></tr></table></figure>
<p>也可以将图标上传至网上通过链接获得</p>
<h4 id="3-2-1-将图片上传至网络"><a href="#3-2-1-将图片上传至网络" class="headerlink" title="3.2.1  将图片上传至网络"></a>3.2.1  将图片上传至网络</h4><p><code>[薄荷图床 首页 -图床外链生成器-亚马逊图片上传-无限流量-全球加速-无限数量-图片转链接-跨境电商图片空间-图片托管 (riyugo.com)](https://riyugo.com/)</code></p>
<p>上传后将路径改为地址即可</p>
<h3 id="3-3-avatar"><a href="#3-3-avatar" class="headerlink" title="3.3 avatar"></a>3.3 avatar</h3><p>将1.png 图片放置到 themes/next/source/images/1.png 路径，然后在主题 _config.yml 文件下编辑 avatar 的配置，修改为正确的路径即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Sidebar Avatar</span><br><span class="line">avatar:</span><br><span class="line">  # In theme directory (source/images): /images/avatar.gif</span><br><span class="line">  # In site directory (source/uploads): /uploads/avatar.gif</span><br><span class="line">  # You can also use other linking images.</span><br><span class="line">  url: /images/avatar.png</span><br><span class="line">  # If true, the avatar would be dispalyed in circle.</span><br><span class="line">  rounded: true</span><br><span class="line">  # If true, the avatar would be rotated with the cursor.</span><br><span class="line">  rotated: true</span><br></pre></td></tr></table></figure>
<h3 id="3-4-top"><a href="#3-4-top" class="headerlink" title="3.4 top"></a>3.4 top</h3><p>在浏览网页的时候，想快速返回到网站的上端，一般都是有一个按钮来辅助的，这里也支持它的配置，修改 _config.yml 的 back2top 字段即可，我的设置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">back2top:	</span><br><span class="line">  enable: true	</span><br><span class="line">  # Back to top in sidebar.	</span><br><span class="line">  sidebar: false	</span><br><span class="line">  # Scroll percent label in b2t button.	</span><br><span class="line">  scrollpercent: true</span><br></pre></td></tr></table></figure>
<h3 id="3-5-reading-process"><a href="#3-5-reading-process" class="headerlink" title="3.5 reading_process"></a>3.5 reading_process</h3><p>reading_process，阅读进度。大家可能注意到有些站点的最上侧会出现一个细细的进度条，代表页面加载进度和阅读进度 ，修改_config.yml 如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reading_progress:	</span><br><span class="line">  enable: true	</span><br><span class="line">  # Available values: top | bottom	</span><br><span class="line">  position: top	</span><br><span class="line">  color: &quot;#222&quot;	</span><br><span class="line">  height: 2px</span><br></pre></td></tr></table></figure>
<h3 id="3-6-pangu"><a href="#3-6-pangu" class="headerlink" title="3.6 pangu"></a>3.6 pangu</h3><p>希望写中文和英文的时候中间必须要留有间距，一个简单直接的方法就是中间加个空格。</p>
<p>pangu 就是来解决这个问题的，我们只需要在主题里面开启这个选项，在编译生成页面的时候，中英文之间就会自动添加空格，看起来更加美观。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pangu: true</span><br></pre></td></tr></table></figure>
<h3 id="3-7-pjax"><a href="#3-7-pjax" class="headerlink" title="3.7 pjax"></a>3.7 pjax</h3><p>pjax 这个技术实际上就是，利用 Ajax 技术实现了局部页面刷新，既可以实现 URL 的更换，有可以做到无刷新加载。</p>
<p>要开启这个功能需要先将 pjax 功能开启，然后安装对应的 pjax 依赖库，首先修改 _config.yml 修改如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pjax: true</span><br></pre></td></tr></table></figure>
<p>然后安装依赖库，切换到 next 主题下，然后安装依赖库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/theme-next/theme-next-pjax source/lib/pjax</span><br></pre></td></tr></table></figure>
<h2 id="四、发布文章"><a href="#四、发布文章" class="headerlink" title="四、发布文章"></a>四、发布文章</h2><h3 id="4-1、增加文章"><a href="#4-1、增加文章" class="headerlink" title="4.1、增加文章"></a>4.1、增加文章</h3><p>需要调用 Hexo 提供的命令即可，比如我们要新建一篇「HelloWorld」的文章，命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new hello-world</span><br></pre></td></tr></table></figure>
<h3 id="4-2、个性化设置"><a href="#4-2、个性化设置" class="headerlink" title="4.2、个性化设置"></a>4.2、个性化设置</h3><h4 id="4-2-1-标签页"><a href="#4-2-1-标签页" class="headerlink" title="4.2.1 标签页"></a>4.2.1 标签页</h4><p>按上路径创建 <strong>index.md</strong> </p>
<p><img src="https://s1.plumeta.com/i/2022/08/29/p5vqdl.jpg" alt></p>
<p>里面输入内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title: tags</span><br><span class="line">type: &quot;tags&quot;</span><br></pre></td></tr></table></figure>
<p>然后再在主题的 _config.yml 文件将这个页面的链接添加到主菜单里面，修改 menu 字段如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">menu:	</span><br><span class="line">  home: / || home	</span><br><span class="line">  #about: /about/ || user	</span><br><span class="line">  tags: /tags/ || tags	</span><br><span class="line">  #categories: /categories/ || th	</span><br><span class="line">  archives: /archives/ || archive	</span><br><span class="line">  #schedule: /schedule/ || calendar	</span><br><span class="line">  #sitemap: /sitemap.xml || sitemap	</span><br><span class="line">  #commonweal: /404/ || heartbeat</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>分类页和标签页是一样的。</p>
<h4 id="4-2-2-搜索页"><a href="#4-2-2-搜索页" class="headerlink" title="4.2.2 搜索页"></a>4.2.2 搜索页</h4><p>我们需要搜索全站的内容，所以一个搜索功能的支持也是很有必要的。</p>
<p>如果要添加搜索的支持，需要先安装一个插件，叫做 hexo-generator-searchdb，命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>
<p>然后在项目的 _config.yml 里面添加搜索设置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">search:	</span><br><span class="line">  path: search.xml	</span><br><span class="line">  field: post	</span><br><span class="line">  format: html	</span><br><span class="line">  limit: 10000</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在主题的 _config.yml 里面修改如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Local search	</span><br><span class="line"># Dependencies: https://github.com/wzpan/hexo-generator-search	</span><br><span class="line">local_search:	</span><br><span class="line">  enable: true	</span><br><span class="line">  # If auto, trigger search by changing input.	</span><br><span class="line">  # If manual, trigger search by pressing enter key or search button.	</span><br><span class="line">  trigger: auto	</span><br><span class="line">  # Show top n results per article, show all results by setting to -1	</span><br><span class="line">  top_n_per_article: 5	</span><br><span class="line">  # Unescape html strings to the readable one.	</span><br><span class="line">  unescape: false	</span><br><span class="line">  # Preload the search data when the page loads.	</span><br><span class="line">  preload: false</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="4-2-3-404页面"><a href="#4-2-3-404页面" class="headerlink" title="4.2.3 404页面"></a>4.2.3 404页面</h4><p>另外还需要添加一个 404 页面，直接在根目录 source 文件夹新建一个 404.md 文件即可，内容可以仿照如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---	</span><br><span class="line">title: 404 Not Found	</span><br><span class="line">date: 2019-09-22 10:41:27	</span><br><span class="line">---	</span><br><span class="line"> </span><br><span class="line">	</span><br><span class="line">&lt;center&gt;	</span><br><span class="line">对不起，您所访问的页面不存在或者已删除。	</span><br><span class="line">您可以&lt;a href=&quot;   &quot;&gt;点击此处&lt;/a&gt;返回首页。	</span><br><span class="line">&lt;/center&gt;	</span><br><span class="line"> </span><br><span class="line">	</span><br><span class="line">&lt;blockquote class=&quot;blockquote-center&quot;&gt;	</span><br><span class="line">    NightTeam	</span><br><span class="line">&lt;/blockquote&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里面的一些相关信息和链接可以替换成自己的。</p>
<h2 id="五、更新部署-amp-域名配置"><a href="#五、更新部署-amp-域名配置" class="headerlink" title="五、更新部署&amp;域名配置"></a>五、更新部署&amp;域名配置</h2><h3 id="5-1-Hexo更新"><a href="#5-1-Hexo更新" class="headerlink" title="5.1 Hexo更新"></a>5.1 Hexo更新</h3><p>通过博客上面的地址输入框进入  cmd</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean	</span><br><span class="line">hexo generate	</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>
<h3 id="5-2-自定义域名"><a href="#5-2-自定义域名" class="headerlink" title="5.2 自定义域名"></a>5.2 自定义域名</h3><p>我本人是在<a href="https://auth.huaweicloud.com/authui/login.html?service=https%3A%2F%2Fconsole.huaweicloud.com%2Fdns%2F%3FagencyId%3D1fb2d46c8a3e48dbbc4d41fb5b2cf34c%26region%3Dcn-east-3%26locale%3Dzh-cn%26cloud_route_state%3D%2Fdns%2Frecordset%2Fpublic%2Flist%3Fzoneid%3D8aace3b98282c2260182d8bd74236172%26zonename%3Dbaidu2001.top.%26zoneStatus%3DACTIVE#/login">华为云</a>下面买的域名</p>
<p>在 GitHub 的 Repository 里面设置域名，找到 Settings，拉到下面，可以看到有个 GitHub Pages 的配置项，如图所示</p>
<p><img src="https://i.p04e.com/baid/i/2022/09/02/74zzg.png"></p>
<p>下面有个 custom domain 的选项，输入想自定义的域名地址，然后添加 CNAME 解析就好了。</p>
<p>另外下面还有一个 Enforce HTTPS 的选项，GitHub Pages 会在我们配置自定义域名之后自动帮我们配置 HTTPS 服务。刚配置完自定义域名的时候可能这个选项是不可用的，一段时间后等到其可以勾选了，直接勾选即可，这样整个博客就会变成 HTTPS 的协议的了。</p>
<p>另外有一个值得注意的地方，如果配置了自定义域名，在目前的情况下，每次部署的时候这个自定义域名的设置是会被自动清除的。所以为了避免这个情况，我们需要在项目目录下面新建一个 CNAME 文件，路径为 source/CNAME，内容就是自定义域名。<br>我就在 source 目录下新建了一个 CNAME 文件，内容为自己的域名</p>
<p><img src="https://i.p04e.com/baid/i/2022/09/02/10q7p.png"></p>
<p>可以避免了每次部署的时候自定义域名被清除的情况了。</p>
]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>域名</tag>
        <tag>图片的免费上传</tag>
      </tags>
  </entry>
  <entry>
    <title>java.sql.SQLSyntaxErrorException: Unknown column &#39;is_deleted&#39; in &#39;field list&#39;</title>
    <url>/2022/09/02/java-sql-SQLSyntaxErrorException-Unknown-column-is-deleted-in-field-list/</url>
    <content><![CDATA[<p><img src="https://i.p04e.com/baid/i/2022/09/02/58a7.png"></p>
<p>今天做的是一个分页查询，结果无法显示，回到idea下面查找问题</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">: Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exceptison is org.springframework.jdbc.BadSqlGrammarException: </span><br><span class="line"></span><br><span class="line">### Error querying database.  Cause: java.sql.SQLSyntaxErrorException: Unknown column &#x27;is_deleted&#x27; in &#x27;field list&#x27;</span><br><span class="line">其实最重要的是后面这句，很明显是sql的问题 ，大概意思就是不知道 is_deleted 在表格中的什么什么</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">然后我在实体类中找到了这句</span><br><span class="line">    //是否删除</span><br><span class="line">    private Integer isDeleted;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我刚开始以为是驼峰命名法不对，结果改了后还是不对。</p>
<p>之后再数据库中发现这个表中并没有 is_deleted这个字段，是另一个表内的，由于实体类是找的网上资源自己懒的写就弄了一个大乌龙，删除掉以后就好了。</p>
]]></content>
      <tags>
        <tag>Mysql</tag>
        <tag>错误</tag>
      </tags>
  </entry>
  <entry>
    <title>redis软件安装和指令学习</title>
    <url>/2022/09/28/redis%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%92%8C%E6%8C%87%E4%BB%A4%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h3 id="Redis入门"><a href="#Redis入门" class="headerlink" title="Redis入门"></a>Redis入门</h3><h4 id="什么是-Redis"><a href="#什么是-Redis" class="headerlink" title="什么是 Redis ?"></a>什么是 Redis ?</h4><p>Redis是一个基于内存的key-value结构数据库。</p>
<p>基于内存存储，读写性能高</p>
<p>适合存储热点数据（热点商品、资讯、新闻)企业应用广泛</p>
<span id="more"></span>
<h4 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h4><p>Redis is an open source (BSD licensed), in-memory data structure store, used as a database, cache, andmessage broker，翻译为:Redis是一个开源的内存中的数据结构存储系统，它可以用作:数据库、缓存和消息中间件。官网: <a href="https://redis.io">https://redis.io</a><br>Redis是用C语言开发的一个开源的高性能键值对(key-value)数据库，官方提供的数据是可以达到100000+的QPS（(每秒内查询次数）。它存储的value类型比较丰富，也被称为结构化的NoSql数据库。<br>NoSql ( Not only sQL)，不仅仅是SQL，泛指非关系型数据库。NoSql数据库并不是要取代关系型数据库，而是关系型数据库的补充。</p>
<p>关系型数据库(RDBMS)</p>
<ul>
<li>Mysql</li>
<li>oracleDB2</li>
<li>sQLServer</li>
</ul>
<p>非关系型数据库(NoSql)</p>
<ul>
<li>Redis</li>
<li>Mongo </li>
<li>dbMemCached</li>
</ul>
<p>Redis应用场景</p>
<ul>
<li>缓存</li>
<li>任务队列</li>
<li>消息队列</li>
<li>分布式锁</li>
</ul>
<h4 id="Redis下载与安装"><a href="#Redis下载与安装" class="headerlink" title="Redis下载与安装"></a>Redis下载与安装</h4><p>Redis安装包分为windows版和Linux版:</p>
<p>Windows版下载地址:https:l/github.com/microsoftarchive/redis/releases</p>
<p>Linux版下载地址: <a href="https://download.redis.io/releasesl">https://download.redis.io/releasesl</a></p>
<p>在Linux系统安装Redis步骤:</p>
<p>1.将Redis安装包上传到Linux</p>
<p>⒉.解压安装包，命令: tar -zxvf redis-4.0.0.tar.gz-C /usr/local</p>
<p>3.安装Redis的依赖环境gcc，命令: yum install gcc-C++</p>
<p>4.进入/usr/local/redis-4.0.0，进行编译，命令: make</p>
<p>5.进入redis的src目录，进行安装，命令: make install</p>
<h4 id="Redis服务启动与停止"><a href="#Redis服务启动与停止" class="headerlink" title="Redis服务启动与停止"></a>Redis服务启动与停止</h4><p>Linux中redis服务启动，可以使用redis-server，默认端口号为6379</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">src/redis-server ./redis.conf</span><br><span class="line"></span><br><span class="line">src/redis-cli -p 6379 -a 123456</span><br><span class="line"></span><br><span class="line">//用本地服务器连接</span><br><span class="line">.\redis-cli.exe -h 192.168.81.128 -p 6379 -a 123456</span><br></pre></td></tr></table></figure>
<p>Ctrl+C停止Redis服务</p>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>介绍</p>
<p>Redis存储的是key-value结构的数据，其中key是字符串类型，value有5种常用的数据类型:</p>
<p>字符串string</p>
<p>哈希hash</p>
<p>列表list</p>
<p>集合set</p>
<p>有序集合sorted set</p>
<p><img src="https://i.p04e.com/baid/i/2022/09/28/12m8f.png"></p>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><h4 id="字符串string操作命令"><a href="#字符串string操作命令" class="headerlink" title="字符串string操作命令"></a>字符串string操作命令</h4><ul>
<li>SET key value    设置指定key的值</li>
<li>GET key    获取指定key的值</li>
<li>SETEX key seconds value    设置指定key的值，并将key 的过期时间设为seconds</li>
<li>SETNX key value    只有在key 不存在时设置key 的值</li>
</ul>
<h4 id="哈希hash操作命令"><a href="#哈希hash操作命令" class="headerlink" title="哈希hash操作命令"></a>哈希hash操作命令</h4><p>Redis hash 是一个string类型的field和value 的映射表，hash特别适合用于存储对象，常用命令:</p>
<ul>
<li>HSET key field value    将哈希表key 中的字段field的值设为value</li>
<li>HGET key field    获取存储在哈希表中指定字段的值</li>
<li>HDEL key field    删除存储在哈希表中的指定字段</li>
<li>HKEYS key    获取哈希表中所有字段</li>
<li>HVALS key    获取哈希表中所有值</li>
<li>HGETALL key    获取在哈希表中指定key的所有字段和值</li>
</ul>
<h4 id="列表list操作命令"><a href="#列表list操作命令" class="headerlink" title="列表list操作命令"></a>列表list操作命令</h4><ul>
<li><p>Redis列表是简单的字符串列表，按照插入顺序排序，常用命令:</p>
</li>
<li><p>LPUSH key value1 [value2]    将一个或多个值插入到列表头部</p>
</li>
<li><p>LRANGE key start stop    获取列表指定范围内的元素</p>
</li>
<li><p>RPOP key    移除并获取列表最后一个元素</p>
</li>
<li><p>LLEN key    获取列表长度</p>
</li>
<li><p>BRPOP key1 [key2 ] timeout    移出并获取列表的最后一个元素，如果列表没有元素会阻塞列表直到等待超</p>
<p>​                                   时或发现可弹出元素为止</p>
<p><img src="https://i.p04e.com/baid/i/2022/09/28/sl9.png"></p>
</li>
</ul>
<h4 id="集合set操作命令"><a href="#集合set操作命令" class="headerlink" title="集合set操作命令"></a>集合set操作命令</h4><p>Redis set 是string类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据，常用命令:</p>
<ul>
<li>SADD key member1 [member2]    向集合添加一个或多个成员</li>
<li>SMEMBERS key    返回集合中的所有成员</li>
<li>SCARD key    获取集合的成员数</li>
<li>SINTER key1 [key2]    返回给定所有集合的交集</li>
<li>SUNION key1 [key2]    返回所有给定集合的并集</li>
<li>SDIFF key1 [key2]    返回给定所有集合的差集</li>
<li>SREM key member1[member2]    移除集合中一个或多个成员</li>
</ul>
<p><img src="https://i.p04e.com/baid/i/2022/09/28/1h4x2d.png"></p>
<h4 id="有序集合sorted-set操作命令"><a href="#有序集合sorted-set操作命令" class="headerlink" title="有序集合sorted set操作命令"></a>有序集合sorted set操作命令</h4><p>Redis sorted set有序集合是string类型元素的集合，且不允许重复的成员。每个元素都会关联一个double类</p>
<p>型的分数(score)。redis正是通过分数来为集合中的成员进行从小到大排序。有序集合的成员是唯一的，但分</p>
<p>数却可以重复。常用命令:</p>
<ul>
<li>ZADD key score1 member1[score2 member2]    向有序集合添加一个或多个成员，或者更新已存在成员的分</li>
<li>数</li>
<li>ZRANGE key start stop [WITHSCORES]    通过索引区间返回有序集合中指定区间内的成员</li>
<li>zINCRBY key increment member    有序集合中对指定成员的分数加上增量increment</li>
<li>ZREM key member [member …]    移除有序集合中的一个或多个成员</li>
</ul>
<p><img src="https://i.p04e.com/baid/i/2022/09/28/7mbae.png"></p>
<h4 id="通用命令"><a href="#通用命令" class="headerlink" title="通用命令"></a>通用命令</h4><ul>
<li>KEYs pattern    查找所有符合给定模式( pattern)的 key</li>
<li>EXISTs key    检查给定key是否存在</li>
<li>TYPE key    返回key所储存的值的类型</li>
<li>TTL key    返回给定key的剩余生存时间(TTL, time to live)，以秒为单位</li>
<li>DEL key    该命令用于在key存在是删除key</li>
</ul>
<h3 id="在Java中操作Redis"><a href="#在Java中操作Redis" class="headerlink" title="在Java中操作Redis"></a>在Java中操作Redis</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>Redis 的Java客户端很多，官方推荐的有三种:</p>
<ul>
<li>Jedis</li>
<li>Lettuce</li>
<li>Redisson</li>
</ul>
<p>Spring对Redis客户端进行了整合，提供了Spring Data Redis，在Spring Boot项目中还提供了对应的</p>
<p>Starter，即spring-boot-starter-data-redis</p>
<h4 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h4><p>Jedis的maven坐标:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;groupld&gt;redis.clients&lt;/groupld&gt;</span><br><span class="line"></span><br><span class="line">&lt;artifactld&gt;jedis&lt;lartifactld&gt;</span><br><span class="line"></span><br><span class="line">&lt;version&gt;2.8.O&lt;/version&gt;</span><br><span class="line"></span><br><span class="line">&lt;/ dependency&gt;</span><br></pre></td></tr></table></figure>
<p>使用Jedis操作Redis的步骤:</p>
<ul>
<li>获取连接</li>
<li>执行操作</li>
<li>关闭连接</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.test;</span><br><span class="line"></span><br><span class="line">import org.junit.Test;</span><br><span class="line">import redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 使用Jedis操作Redis</span><br><span class="line"> */</span><br><span class="line">public class JedisTest &#123;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testRedis()&#123;</span><br><span class="line">        //1 获取连接</span><br><span class="line">        Jedis jedis = new Jedis(&quot;localhost&quot;,6379);</span><br><span class="line">        </span><br><span class="line">        //2 执行具体的操作</span><br><span class="line">        jedis.set(&quot;username&quot;,&quot;xiaoming&quot;);</span><br><span class="line"></span><br><span class="line">        String value = jedis.get(&quot;username&quot;);</span><br><span class="line">        System.out.println(value);</span><br><span class="line"></span><br><span class="line">        //jedis.del(&quot;username&quot;);</span><br><span class="line"></span><br><span class="line">        jedis.hset(&quot;myhash&quot;,&quot;addr&quot;,&quot;bj&quot;);</span><br><span class="line">        String hValue = jedis.hget(&quot;myhash&quot;, &quot;addr&quot;);</span><br><span class="line">        System.out.println(hValue);</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; keys = jedis.keys(&quot;*&quot;);</span><br><span class="line">        for (String key : keys) &#123;</span><br><span class="line">            System.out.println(key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //3 关闭连接</span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="Spring-Data-Redis"><a href="#Spring-Data-Redis" class="headerlink" title="Spring Data Redis"></a>Spring Data Redis</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在Spring Boot项目中，可以使用Spring Data Redis来简化Redis操作，maven坐标:</span><br><span class="line">	&lt;dependency&gt;</span><br><span class="line">&lt;groupld&gt;org.springframework.boot&lt;/groupld&gt;</span><br><span class="line">&lt;artifactld&gt;spring-boot-starter-data-redis&lt;/artifactld&gt;</span><br><span class="line">	&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>Spring Data Redis中提供了一个高度封装的类: RedisTemplate，针对jedis客户端中大量ap进行了归类封装,</p>
<p>将同一类型操作封装为operation接口，具体分类如下:</p>
<ul>
<li>valueOperations:简单K-V操作</li>
<li>SetOperations: set类型数据操作</li>
<li>ZSetOperations: zset类型数据操作</li>
<li>HashOperations:针对map类型的数据操作</li>
<li>Listoperations:针对list类型的数据操作</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: springdataredis_demo</span><br><span class="line">  #Redis相关配置</span><br><span class="line">  redis:</span><br><span class="line">    host: localhost</span><br><span class="line">    port: 6379</span><br><span class="line">    #password: 123456</span><br><span class="line">    database: 0 #操作的是0号数据库</span><br><span class="line">    jedis:</span><br><span class="line">      #Redis连接池配置</span><br><span class="line">      pool:</span><br><span class="line">        max-active: 8 #最大连接数</span><br><span class="line">        max-wait: 1ms #连接池最大阻塞等待时间</span><br><span class="line">        max-idle: 4 #连接池中的最大空闲连接</span><br><span class="line">        min-idle: 0 #连接池中的最小空闲连接</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.test;</span><br><span class="line"></span><br><span class="line">import org.junit.Test;</span><br><span class="line">import org.junit.runner.RunWith;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line">import org.springframework.data.redis.connection.DataType;</span><br><span class="line">import org.springframework.data.redis.core.*;</span><br><span class="line">import org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Set;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">@SpringBootTest</span><br><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">public class SpringDataRedisTest &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 操作String类型数据</span><br><span class="line">     */</span><br><span class="line">    @Test</span><br><span class="line">    public void testString()&#123;</span><br><span class="line">        redisTemplate.opsForValue().set(&quot;city123&quot;,&quot;beijing&quot;);</span><br><span class="line"></span><br><span class="line">        String value = (String) redisTemplate.opsForValue().get(&quot;city123&quot;);</span><br><span class="line">        System.out.println(value);</span><br><span class="line"></span><br><span class="line">        redisTemplate.opsForValue().set(&quot;key1&quot;,&quot;value1&quot;,10l, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        Boolean aBoolean = redisTemplate.opsForValue().setIfAbsent(&quot;city1234&quot;, &quot;nanjing&quot;);</span><br><span class="line">        System.out.println(aBoolean);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 操作Hash类型数据</span><br><span class="line">     */</span><br><span class="line">    @Test</span><br><span class="line">    public void testHash()&#123;</span><br><span class="line">        HashOperations hashOperations = redisTemplate.opsForHash();</span><br><span class="line"></span><br><span class="line">        //存值</span><br><span class="line">        hashOperations.put(&quot;002&quot;,&quot;name&quot;,&quot;xiaoming&quot;);</span><br><span class="line">        hashOperations.put(&quot;002&quot;,&quot;age&quot;,&quot;20&quot;);</span><br><span class="line">        hashOperations.put(&quot;002&quot;,&quot;address&quot;,&quot;bj&quot;);</span><br><span class="line"></span><br><span class="line">        //取值</span><br><span class="line">        String age = (String) hashOperations.get(&quot;002&quot;, &quot;age&quot;);</span><br><span class="line">        System.out.println(age);</span><br><span class="line"></span><br><span class="line">        //获得hash结构中的所有字段</span><br><span class="line">        Set keys = hashOperations.keys(&quot;002&quot;);</span><br><span class="line">        for (Object key : keys) &#123;</span><br><span class="line">            System.out.println(key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //获得hash结构中的所有值</span><br><span class="line">        List values = hashOperations.values(&quot;002&quot;);</span><br><span class="line">        for (Object value : values) &#123;</span><br><span class="line">            System.out.println(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 操作List类型的数据</span><br><span class="line">     */</span><br><span class="line">    @Test</span><br><span class="line">    public void testList()&#123;</span><br><span class="line">        ListOperations listOperations = redisTemplate.opsForList();</span><br><span class="line"></span><br><span class="line">        //存值</span><br><span class="line">        listOperations.leftPush(&quot;mylist&quot;,&quot;a&quot;);</span><br><span class="line">        listOperations.leftPushAll(&quot;mylist&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;);</span><br><span class="line"></span><br><span class="line">        //取值</span><br><span class="line">        List&lt;String&gt; mylist = listOperations.range(&quot;mylist&quot;, 0, -1);</span><br><span class="line">        for (String value : mylist) &#123;</span><br><span class="line">            System.out.println(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //获得列表长度 llen</span><br><span class="line">        Long size = listOperations.size(&quot;mylist&quot;);</span><br><span class="line">        int lSize = size.intValue();</span><br><span class="line">        for (int i = 0; i &lt; lSize; i++) &#123;</span><br><span class="line">            //出队列</span><br><span class="line">            String element = (String) listOperations.rightPop(&quot;mylist&quot;);</span><br><span class="line">            System.out.println(element);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 操作Set类型的数据</span><br><span class="line">     */</span><br><span class="line">    @Test</span><br><span class="line">    public void testSet()&#123;</span><br><span class="line">        SetOperations setOperations = redisTemplate.opsForSet();</span><br><span class="line"></span><br><span class="line">        //存值</span><br><span class="line">        setOperations.add(&quot;myset&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;a&quot;);</span><br><span class="line"></span><br><span class="line">        //取值</span><br><span class="line">        Set&lt;String&gt; myset = setOperations.members(&quot;myset&quot;);</span><br><span class="line">        for (String o : myset) &#123;</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //删除成员</span><br><span class="line">        setOperations.remove(&quot;myset&quot;,&quot;a&quot;,&quot;b&quot;);</span><br><span class="line"></span><br><span class="line">        //取值</span><br><span class="line">        myset = setOperations.members(&quot;myset&quot;);</span><br><span class="line">        for (String o : myset) &#123;</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 操作ZSet类型的数据</span><br><span class="line">     */</span><br><span class="line">    @Test</span><br><span class="line">    public void testZset()&#123;</span><br><span class="line">        ZSetOperations zSetOperations = redisTemplate.opsForZSet();</span><br><span class="line"></span><br><span class="line">        //存值</span><br><span class="line">        zSetOperations.add(&quot;myZset&quot;,&quot;a&quot;,10.0);</span><br><span class="line">        zSetOperations.add(&quot;myZset&quot;,&quot;b&quot;,11.0);</span><br><span class="line">        zSetOperations.add(&quot;myZset&quot;,&quot;c&quot;,12.0);</span><br><span class="line">        zSetOperations.add(&quot;myZset&quot;,&quot;a&quot;,13.0);</span><br><span class="line"></span><br><span class="line">        //取值</span><br><span class="line">        Set&lt;String&gt; myZset = zSetOperations.range(&quot;myZset&quot;, 0, -1);</span><br><span class="line">        for (String s : myZset) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //修改分数</span><br><span class="line">        zSetOperations.incrementScore(&quot;myZset&quot;,&quot;b&quot;,20.0);</span><br><span class="line"></span><br><span class="line">        //取值</span><br><span class="line">        myZset = zSetOperations.range(&quot;myZset&quot;, 0, -1);</span><br><span class="line">        for (String s : myZset) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //删除成员</span><br><span class="line">        zSetOperations.remove(&quot;myZset&quot;,&quot;a&quot;,&quot;b&quot;);</span><br><span class="line"></span><br><span class="line">        //取值</span><br><span class="line">        myZset = zSetOperations.range(&quot;myZset&quot;, 0, -1);</span><br><span class="line">        for (String s : myZset) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 通用操作，针对不同的数据类型都可以操作</span><br><span class="line">     */</span><br><span class="line">    @Test</span><br><span class="line">    public void testCommon()&#123;</span><br><span class="line">        //获取Redis中所有的key</span><br><span class="line">        Set&lt;String&gt; keys = redisTemplate.keys(&quot;*&quot;);</span><br><span class="line">        for (String key : keys) &#123;</span><br><span class="line">            System.out.println(key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //判断某个key是否存在</span><br><span class="line">        Boolean itcast = redisTemplate.hasKey(&quot;itcast&quot;);</span><br><span class="line">        System.out.println(itcast);</span><br><span class="line"></span><br><span class="line">        //删除指定key</span><br><span class="line">        redisTemplate.delete(&quot;myZset&quot;);</span><br><span class="line"></span><br><span class="line">        //获取指定key对应的value的数据类型</span><br><span class="line">        DataType dataType = redisTemplate.type(&quot;myset&quot;);</span><br><span class="line">        System.out.println(dataType.name());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>Reids</tag>
      </tags>
  </entry>
  <entry>
    <title>白都的一封信</title>
    <url>/2022/08/26/%E4%BF%A1/</url>
    <content><![CDATA[<p>已至凌晨却无论如何都睡不着了，心里藏着很多事情。</p>
<span id="more"></span>
<hr>
<p>​    可对于已经发生过的事情，我们无能为力，能做好的只有接下来的事情。</p>
<p>​    <code>小时候经常仰望着星空，渴望着自己成为逆转时空的飞人</code></p>
<p>​    </p>
<hr>
<p>​    <code>黑还是白并不重要</code></p>
<hr>
<p>​    在痛苦开心的过程中会慢慢的触摸到心中真正的所想所愿。那是一种奇妙的感觉，很像是悟道一样的感觉。</p>
<p>​    <code>每天每天每月每月，实现那个梦</code></p>
<hr>
<p>​    生命的所有，都来自于想象力。</p>
<p>所有的可能，所有的道都来自于想象力。</p>
]]></content>
      <tags>
        <tag>念想</tag>
      </tags>
  </entry>
  <entry>
    <title>个人博客网站问题解决</title>
    <url>/2022/08/29/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<h2 id="一、Hexo-Next-实现全局播放背景音乐"><a href="#一、Hexo-Next-实现全局播放背景音乐" class="headerlink" title="一、Hexo + Next 实现全局播放背景音乐"></a>一、Hexo + Next 实现全局播放背景音乐</h2><p>进入网页版的网易云，进入你想选的歌单，按F12键进入开发人员工具，在元素里面 按ctrl + F 进行搜索生成外链，</p>
<span id="more"></span>
<p>记住前面的那一行数字，新开一个网页输入</p>
<p><code>https://music.163.com/#/outchain/0/</code>733122887         并将那行数字加载在 / 的后面。</p>
<p>打开我们主题文件：<code>themes\next\layout\_macro\sidebar.swig</code>找到<code>sidebar-inner</code>，复制下面代码粘贴到此<code>&lt;div&gt;</code>标签后即可。</p>
<ul>
<li>打开<code>themes\next\layout</code>文件夹找到<code>_layout.swig</code></li>
<li>在<code>&lt;\head&gt;</code>标签前添加下面代码，并保存。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;head&gt;   //粘贴到这里</span><br><span class="line">    </span><br><span class="line">  &lt;!--pjax：防止跳转页面音乐暂停--&gt;</span><br><span class="line">  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.js&quot;&gt;&lt;/script&gt; </span><br><span class="line">&lt;/head&gt; </span><br></pre></td></tr></table></figure>
<ul>
<li>在主题的配置文件中找到<code>pajx</code>，将它设置为<code>true</code>，并保存。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Easily enable fast Ajax navigation on your website.</span><br><span class="line"># Dependencies: https://github.com/theme-next/theme-next-pjax</span><br><span class="line">pjax: true</span><br></pre></td></tr></table></figure>
<h2 id="二、部署hexo时遇到报错ERROR-Deployer-not-found-git"><a href="#二、部署hexo时遇到报错ERROR-Deployer-not-found-git" class="headerlink" title="二、部署hexo时遇到报错ERROR Deployer not found: git"></a>二、部署hexo时遇到报错ERROR Deployer not found: git</h2><p>这是因为没有安装<code>hexo-deployer-git</code>插件,在<strong>站点目录</strong>下输入下面的命令安装插件就好了。执行下面这行命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<h2 id="三、使用命令npm-install-g-hexo-cli-安装Hexo报错bash-hexo-command-not-found问题解决"><a href="#三、使用命令npm-install-g-hexo-cli-安装Hexo报错bash-hexo-command-not-found问题解决" class="headerlink" title="三、使用命令npm install -g hexo-cli 安装Hexo报错bash: hexo: command not found问题解决"></a>三、使用命令npm install -g hexo-cli 安装Hexo报错bash: hexo: command not found问题解决</h2><p>选择一个磁盘，简历一个文件夹，取名为blog</p>
<p>然后按照下面的指令一步步输入</p>
<p><strong>在命令的前面加上npx。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npx hexo init blog</span><br><span class="line">cd blog</span><br><span class="line">npm install</span><br><span class="line">npx hexo server</span><br></pre></td></tr></table></figure>
<p>最后解释一下，为啥要在前面加上npx。</p>
<p>在大牛<a href="http://www.ruanyifeng.com/blog/2019/02/npx.html">阮一峰的网络日志</a>中，他是这么描述的：“<strong>npx 想要解决的主要问题，就是调用项目内部安装的模块</strong>”，所以可以理解为在命令行下调用，可以让项目内部安装的模块用起来更方便，npx运行的时候，会到<code>node_modules/.bin</code>路径和环境变量<code>$PATH</code>里面，检查命令是否存在。</p>
<p>如果还是不可以就手动加载路径</p>
<p>注意你的博客目录下应该有两个 <code>node_modules</code> 文件夹，要添加到 Path 里面的是与 _config.yml 在同一个目录的 node_modules 文件夹！</p>
<p>环境变量添加好了之后重新打开 git 即可运行 hexo 命令，如果此时仍然无法执行 hexo 命令，那就只能拿出终极绝招了，运行命令 <code>npm install hexo-cli -g</code> 重新安装 hexo 即可！</p>
]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>外卖管理平台删除套餐</title>
    <url>/2022/09/14/%E5%A4%96%E5%8D%96%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0%E5%88%A0%E9%99%A4%E5%A5%97%E9%A4%90/</url>
    <content><![CDATA[<h3 id="一、需求分析"><a href="#一、需求分析" class="headerlink" title="一、需求分析"></a>一、需求分析</h3><p>在套餐管理列表页面点击删除按钮，可以删除对应的套餐信息。也可以通过复选框选择多个套餐，点击批量删除按钮一次删除多个套餐。注意，对于状态为售卖中的套餐不能删除，需要先停售，然后才能删除。</p>
<span id="more"></span>
<h3 id="二、代码开发-梳理交互过程"><a href="#二、代码开发-梳理交互过程" class="headerlink" title="二、代码开发-梳理交互过程"></a>二、代码开发-梳理交互过程</h3><p>在开发代码之前，需要梳理一下删除套餐时前端页面和服务端的交互过程:</p>
<p>1、删除单个套餐时，页面发送ajax请求，根据套餐id删除对应套餐</p>
<p><img src="https://i.p04e.com/baid/i/2022/09/15/2lii.png"></p>
<p>2、删除多个套餐时，页面发送ajax请求，根据提交的多个套餐id删除对应套餐</p>
<p><img src="https://i.p04e.com/baid/i/2022/09/15/i6q6.png"></p>
<p>开发删除套餐功能，其实就是在服务端编写代码去处理前端页面发送的这2次请求即可。</p>
<p>观察删除单个套餐和批量删除套餐的请求信息可以发现，两种请求的地址和请求方式都是相同的，不同的则是传递的id个数，所以在服务端可以提供一个方法来统一处理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.service;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.extension.service.IService;</span><br><span class="line">import com.itheima.reggie.dto.SetmealDto;</span><br><span class="line">import com.itheima.reggie.entity.Setmeal;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public interface SetmealService extends IService&lt;Setmeal&gt; &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 新增套餐，同时需要保存套餐和菜品的关系</span><br><span class="line">     * @param setmealDto</span><br><span class="line">     */</span><br><span class="line">    public void saveWithDish(SetmealDto setmealDto);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 删除套餐，同时需要删除套餐和菜品的关联数据</span><br><span class="line">     * @param ids</span><br><span class="line">     */</span><br><span class="line">    public void removeWithDish(List&lt;Long&gt; ids);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 删除套餐，同时需要删除套餐和菜品的关联数据</span><br><span class="line"> * @param ids</span><br><span class="line"> */</span><br><span class="line">@Transactional</span><br><span class="line">public void removeWithDish(List&lt;Long&gt; ids) &#123;</span><br><span class="line">    //select count(*) from setmeal where id in (1,2,3) and status = 1</span><br><span class="line">    //查询套餐状态，确定是否可用删除</span><br><span class="line">    LambdaQueryWrapper&lt;Setmeal&gt; queryWrapper = new LambdaQueryWrapper();</span><br><span class="line">    queryWrapper.in(Setmeal::getId,ids);</span><br><span class="line">    queryWrapper.eq(Setmeal::getStatus,1);</span><br><span class="line"></span><br><span class="line">    int count = this.count(queryWrapper);</span><br><span class="line">    if(count &gt; 0)&#123;</span><br><span class="line">        //如果不能删除，抛出一个业务异常</span><br><span class="line">        throw new CustomException(&quot;套餐正在售卖中，不能删除&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //如果可以删除，先删除套餐表中的数据---setmeal</span><br><span class="line">    this.removeByIds(ids);</span><br><span class="line"></span><br><span class="line">    //delete from setmeal_dish where setmeal_id in (1,2,3)</span><br><span class="line">    LambdaQueryWrapper&lt;SetmealDish&gt; lambdaQueryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">    lambdaQueryWrapper.in(SetmealDish::getSetmealId,ids);</span><br><span class="line">    //删除关系表中的数据----setmeal_dish</span><br><span class="line">    setmealDishService.remove(lambdaQueryWrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 删除套餐</span><br><span class="line"> * @param ids</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">@DeleteMapping</span><br><span class="line">public R&lt;String&gt; delete(@RequestParam List&lt;Long&gt; ids)&#123;</span><br><span class="line">    log.info(&quot;ids:&#123;&#125;&quot;,ids);</span><br><span class="line"></span><br><span class="line">    setmealService.removeWithDish(ids);</span><br><span class="line"></span><br><span class="line">    return R.success(&quot;套餐数据删除成功&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>springboot - 外卖平台</tag>
        <tag>项目开发</tag>
        <tag>删除套餐</tag>
        <tag>mybatis plus</tag>
      </tags>
  </entry>
  <entry>
    <title>外卖管理平台修改菜品</title>
    <url>/2022/09/12/%E5%A4%96%E5%8D%96%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0%E4%BF%AE%E6%94%B9%E8%8F%9C%E5%93%81/</url>
    <content><![CDATA[<h3 id="一、需求分析"><a href="#一、需求分析" class="headerlink" title="一、需求分析"></a>一、需求分析</h3><p>在菜品管理列表页面点击修改按钮，跳转到修改菜品页面，在修改页面回显菜品相关信息并进行修改，最后点击确定按钮完成修改操作</p>
<span id="more"></span>
<h3 id="二、修改菜品"><a href="#二、修改菜品" class="headerlink" title="二、修改菜品"></a>二、修改菜品</h3><h4 id="代码开发-梳理交互过程"><a href="#代码开发-梳理交互过程" class="headerlink" title="代码开发-梳理交互过程"></a>代码开发-梳理交互过程</h4><p>在开发代码之前，需要梳理一下修改菜品时前端页面( add.html)和服务端的交互过程:</p>
<p>1、页面发送ajax请求，请求服务端获取分类数据，用于菜品分类下拉框中数据展示</p>
<p>2、页面发送ajax请求，请求服务端，根据id查询当前菜品信息，用于菜品信息回显</p>
<p>3、页面发送请求，请求服务端进行图片下载，用于页图片回显</p>
<p>4、点击保存按钮，页面发送ajax请求，将修改后的菜品相关数据以json形式提交到服务端</p>
<p><code>开发修改菜品功能，其实就是在服务端编写代码去处理前端页面发送的这4次请求即可。</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.service;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.extension.service.IService;</span><br><span class="line">import com.itheima.reggie.dto.DishDto;</span><br><span class="line">import com.itheima.reggie.entity.Dish;</span><br><span class="line"></span><br><span class="line">public interface DishService extends IService&lt;Dish&gt; &#123;</span><br><span class="line"></span><br><span class="line">    //新增菜品，同时插入菜品对应的口味数据，需要同时操作两张表： dish,dish_flavor</span><br><span class="line">    public void saveWithFlavor(DishDto dishDto);</span><br><span class="line"></span><br><span class="line">    //根据id来查询菜品信息和对应的口味信息</span><br><span class="line">    public DishDto getByIdwithFlavor(Long id);</span><br><span class="line"></span><br><span class="line">    //更新菜品信息，同时更新对应的口味信息</span><br><span class="line">    public void updateWithFlaovr(DishDto dishDto);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.service.impl;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;</span><br><span class="line">import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;</span><br><span class="line">import com.itheima.reggie.dto.DishDto;</span><br><span class="line">import com.itheima.reggie.entity.Dish;</span><br><span class="line">import com.itheima.reggie.entity.DishFlavor;</span><br><span class="line">import com.itheima.reggie.mapper.DishMapper;</span><br><span class="line">import com.itheima.reggie.service.DishFlavorService;</span><br><span class="line">import com.itheima.reggie.service.DishService;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.beans.BeanUtils;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line">import org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line">import java.util.Collections;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">@Slf4j</span><br><span class="line">public class DishServiceImpl extends ServiceImpl&lt;DishMapper,Dish&gt; implements DishService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private DishFlavorService dishFlavorService;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 新增菜品，同时保存对应的口味数据</span><br><span class="line">     * @param dishDto</span><br><span class="line">     */</span><br><span class="line">    @Transactional</span><br><span class="line">    public void saveWithFlavor(DishDto dishDto) &#123;</span><br><span class="line">        //保存菜品的基本信息到菜品表dish</span><br><span class="line">        this.save(dishDto);</span><br><span class="line"></span><br><span class="line">        Long dishId = dishDto.getId();//菜品id</span><br><span class="line"></span><br><span class="line">        //菜品口味</span><br><span class="line">        List&lt;DishFlavor&gt; flavors = dishDto.getFlavors();</span><br><span class="line">        flavors = flavors.stream().map((item) -&gt; &#123;</span><br><span class="line">            item.setDishId(dishId);</span><br><span class="line">            return item;</span><br><span class="line">        &#125;).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        //保存菜品口味数据到菜品口味表dish_flavor</span><br><span class="line">        dishFlavorService.saveBatch(flavors);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据id查询菜品信息和对应的口味信息</span><br><span class="line">     * @param id</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    public DishDto getByIdwithFlavor(Long id) &#123;</span><br><span class="line">        //查询菜品基本信息，从dish表查询</span><br><span class="line">        Dish dish = this.getById(id);</span><br><span class="line"></span><br><span class="line">        DishDto dishDto = new DishDto();</span><br><span class="line">        BeanUtils.copyProperties(dish,dishDto);</span><br><span class="line"></span><br><span class="line">        //查询当前菜品对应的口味信息，从dish_flavor表查询</span><br><span class="line">        LambdaQueryWrapper&lt;DishFlavor&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">        queryWrapper.eq(DishFlavor::getDishId,dish.getId());</span><br><span class="line">        List&lt;DishFlavor&gt; flavors = dishFlavorService.list(queryWrapper);</span><br><span class="line">        dishDto.setFlavors(flavors);</span><br><span class="line"></span><br><span class="line">        return dishDto;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    @Transactional</span><br><span class="line">    public void updateWithFlaovr(DishDto dishDto) &#123;</span><br><span class="line">        //更新dish表基本信息</span><br><span class="line">        this.updateById(dishDto);</span><br><span class="line"></span><br><span class="line">        //清理当前菜品对应口味数据---dish_flavor表的delete操作</span><br><span class="line">        LambdaQueryWrapper&lt;DishFlavor&gt; queryWrapper = new LambdaQueryWrapper();</span><br><span class="line">        queryWrapper.eq(DishFlavor::getDishId,dishDto.getId());</span><br><span class="line"></span><br><span class="line">        dishFlavorService.remove(queryWrapper);</span><br><span class="line"></span><br><span class="line">        //添加当前提交过来的口味数据---dish_flavor表的insert操作</span><br><span class="line">        List&lt;DishFlavor&gt; flavors = dishDto.getFlavors();</span><br><span class="line"></span><br><span class="line">        flavors = flavors.stream().map((item) -&gt; &#123;</span><br><span class="line">            item.setDishId(dishDto.getId());</span><br><span class="line">            return item;</span><br><span class="line">        &#125;).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        dishFlavorService.saveBatch(flavors);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.controller;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;</span><br><span class="line">import com.baomidou.mybatisplus.extension.plugins.pagination.Page;</span><br><span class="line">import com.itheima.reggie.common.R;</span><br><span class="line">import com.itheima.reggie.dto.DishDto;</span><br><span class="line">import com.itheima.reggie.entity.Category;</span><br><span class="line">import com.itheima.reggie.entity.Dish;</span><br><span class="line">import com.itheima.reggie.service.CategoryService;</span><br><span class="line">import com.itheima.reggie.service.DishFlavorService;</span><br><span class="line">import com.itheima.reggie.service.DishService;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.beans.BeanUtils;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/dish&quot;)</span><br><span class="line">@Slf4j</span><br><span class="line">public class DishController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private DishService dishService;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private DishFlavorService dishFlavorService;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private CategoryService categoryService;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 新增菜品</span><br><span class="line">     * @param dishDto</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @PostMapping</span><br><span class="line">    public R&lt;String&gt; save(@RequestBody DishDto dishDto) &#123;</span><br><span class="line"></span><br><span class="line">        log.info(dishDto.toString());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        dishService.saveWithFlavor(dishDto);</span><br><span class="line">        return R.success(&quot;新增菜品成功&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 菜品信息分页</span><br><span class="line">     * @param page</span><br><span class="line">     * @param pageSize</span><br><span class="line">     * @param name</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @GetMapping(&quot;/page&quot;)</span><br><span class="line">    public R&lt;Page&gt; page(int page, int pageSize, String name) &#123;</span><br><span class="line"></span><br><span class="line">        //构造分页构造器</span><br><span class="line">        Page&lt;Dish&gt; pageInfo = new Page&lt;&gt;(page,pageSize);</span><br><span class="line">        Page&lt;DishDto&gt; dishDtoPage = new Page&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        //条件构造器</span><br><span class="line">        LambdaQueryWrapper&lt;Dish&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        //添加过滤条件</span><br><span class="line">        queryWrapper.like(name != null,Dish::getName, name);</span><br><span class="line"></span><br><span class="line">        //添加排序条件</span><br><span class="line">        queryWrapper.orderByDesc(Dish::getUpdateTime);</span><br><span class="line"></span><br><span class="line">        //执行分页查询</span><br><span class="line">        dishService.page(pageInfo, queryWrapper);</span><br><span class="line"></span><br><span class="line">        //对象拷贝</span><br><span class="line">        BeanUtils.copyProperties(pageInfo,dishDtoPage,&quot;records&quot;);</span><br><span class="line"></span><br><span class="line">        List&lt;Dish&gt; records = pageInfo.getRecords();</span><br><span class="line">        List&lt;DishDto&gt; list = records.stream().map((item) -&gt;  &#123;</span><br><span class="line">            DishDto dishDto = new DishDto();</span><br><span class="line"></span><br><span class="line">            BeanUtils.copyProperties(item, dishDto);</span><br><span class="line"></span><br><span class="line">            Long categoryId = item.getCategoryId();</span><br><span class="line"></span><br><span class="line">            //根据id查询分类对象</span><br><span class="line">            Category category = categoryService.getById(categoryId);</span><br><span class="line"></span><br><span class="line">            if (category != null) &#123;</span><br><span class="line">                String categoryName = category.getName();</span><br><span class="line">                dishDto.setCategoryName(categoryName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            return dishDto;</span><br><span class="line">        &#125;).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        dishDtoPage.setRecords(list);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        return R.success(dishDtoPage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">    public R&lt;DishDto&gt; get(@PathVariable Long id) &#123;</span><br><span class="line"></span><br><span class="line">        DishDto dishDto = dishService.getByIdwithFlavor(id);</span><br><span class="line"></span><br><span class="line">        return R.success(dishDto);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 修改菜品</span><br><span class="line">     * @param dishDto</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @PutMapping</span><br><span class="line">    public R&lt;String&gt; update(@RequestBody DishDto dishDto) &#123;</span><br><span class="line"></span><br><span class="line">        log.info(dishDto.toString());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        dishService.updateWithFlaovr(dishDto);</span><br><span class="line"></span><br><span class="line">        return R.success(&quot;修改菜品成功&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据条件查询对应的菜品数据</span><br><span class="line">     * @param dish</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @GetMapping(&quot;/list&quot;)</span><br><span class="line">    public R&lt;List&lt;Dish&gt;&gt; list(Dish dish) &#123;</span><br><span class="line"></span><br><span class="line">        //构造查询条件</span><br><span class="line">        LambdaQueryWrapper&lt;Dish&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">        queryWrapper.eq(dish.getCategoryId() != null , Dish::getCategoryId, dish.getCategoryId());</span><br><span class="line">        //查询状态为1</span><br><span class="line">        queryWrapper.eq(Dish::getStatus,1);</span><br><span class="line">        //添加一个排序条件</span><br><span class="line">        queryWrapper.orderByAsc(Dish::getSort).orderByDesc(Dish::getUpdateTime);</span><br><span class="line"></span><br><span class="line">        List&lt;Dish&gt; list = dishService.list(queryWrapper);</span><br><span class="line">        return R.success(list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>springboot - 外卖平台</tag>
        <tag>项目开发</tag>
        <tag>mybatis plus</tag>
        <tag>修改菜品</tag>
      </tags>
  </entry>
  <entry>
    <title>外卖管理平台套餐信息分页查询</title>
    <url>/2022/09/14/%E5%A4%96%E5%8D%96%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0%E5%A5%97%E9%A4%90%E4%BF%A1%E6%81%AF%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<h3 id="一、需求分析"><a href="#一、需求分析" class="headerlink" title="一、需求分析"></a>一、需求分析</h3><p>系统中的套餐数据很多的时候，如果在一个页面中全部展示出来会显得比较乱，不便于查看，所以一般的系统中都会以分页的方式来展示列表数据。</p>
<span id="more"></span>
<h3 id="二、代码开发-梳理交互过程"><a href="#二、代码开发-梳理交互过程" class="headerlink" title="二、代码开发-梳理交互过程"></a>二、代码开发-梳理交互过程</h3><p>在开发代码之前，需要梳理一下套餐分页查询时前端页面和服务端的交互过程:</p>
<p>1、页面(backend/page/combo/list.html)发送ajax请求，将分页查询参数(page. pageSize、</p>
<p>name)提交到服务端，获取分页数据</p>
<p>2、页面发送请求，请求服务端进行图片下载，用于页面图片展示</p>
<p>开发套餐信息分页查询功能，其实就是在服务端编写代码去处理前端页面发送的这2次请求即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.controller;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *套餐分页查询</span><br><span class="line">     * @param page</span><br><span class="line">     * @param pageSize</span><br><span class="line">     * @param name</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @GetMapping(&quot;/page&quot;)</span><br><span class="line">    public R&lt;Page&gt; page(int page, int pageSize, String name) &#123;</span><br><span class="line">        //分页构造器对象</span><br><span class="line">        Page&lt;Setmeal&gt; pageInfo = new Page&lt;&gt;(page, pageSize);</span><br><span class="line">        Page&lt;SetmealDto&gt; dtoPage = new Page&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        LambdaQueryWrapper&lt;Setmeal&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">        //添加查询条件，根据name进行like模糊查询</span><br><span class="line">        queryWrapper.like(name != null, Setmeal::getName, name);</span><br><span class="line">        //添加排序条件，根据更新时间降序排列</span><br><span class="line">        queryWrapper.orderByDesc(Setmeal::getUpdateTime);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        setmealService.page(pageInfo,queryWrapper);</span><br><span class="line"></span><br><span class="line">        //对象拷贝</span><br><span class="line">        BeanUtils.copyProperties(pageInfo, dtoPage,&quot;records&quot;);</span><br><span class="line">        List&lt;Setmeal&gt; records = pageInfo.getRecords();</span><br><span class="line"></span><br><span class="line">        List&lt;SetmealDto&gt; list = records.stream().map((item) -&gt; &#123;</span><br><span class="line">            SetmealDto setmealDto = new SetmealDto();</span><br><span class="line">            //对象拷贝</span><br><span class="line">            BeanUtils.copyProperties(item,setmealDto);</span><br><span class="line">            //分类id</span><br><span class="line">            Long categoryId = item.getCategoryId();</span><br><span class="line">            //根据分类id查询分类对象</span><br><span class="line">            Category category = categoryService.getById(categoryId);</span><br><span class="line">            if (category != null) &#123;</span><br><span class="line">                //分类名称</span><br><span class="line">                String categoryName = category.getName();</span><br><span class="line">                setmealDto.setCategoryName(categoryName);</span><br><span class="line">            &#125;</span><br><span class="line">            return setmealDto;</span><br><span class="line">        &#125;).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        dtoPage.setRecords(list);</span><br><span class="line">        return R.success(dtoPage);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>springboot - 外卖平台</tag>
        <tag>项目开发</tag>
        <tag>mybatis plus</tag>
        <tag>套餐信息分页查询</tag>
      </tags>
  </entry>
  <entry>
    <title>外卖管理平台文件上传下载</title>
    <url>/2022/09/09/%E5%A4%96%E5%8D%96%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD/</url>
    <content><![CDATA[<h3 id="一、文件上传介绍"><a href="#一、文件上传介绍" class="headerlink" title="一、文件上传介绍"></a>一、文件上传介绍</h3><p>文件上传，也称为upload，是指将本地图片、视频、音频等文件上传到服务器上，可以供其他用户浏览或下载的过程。文件上传在项目中应用非常广泛，我们经常发微博、发微信朋友圈都用到了文件上传功能。</p>
<span id="more"></span>
<p>文件上传时，对页面的form表单有如下要求:</p>
<ul>
<li><p>method=”post”              采用post方式提交数据</p>
</li>
<li><p>enctype=”multipart/form-data”            采用multipart格式上传文件</p>
</li>
<li><p>type=”file”        使用input的file控件上传</p>
</li>
</ul>
<p>  举例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;form method=&quot;post&quot;action=&quot; /common/upload&quot; enctype=&quot;multipart/form-data&quot;&gt;&lt;input name=&quot;myFile&quot; type=&quot;file&quot;/&gt;</span><br><span class="line">&lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;&lt;/form&gt;</span><br></pre></td></tr></table></figure>
<p>目前一些前端组件库也提供了相应的上传组件，但是底层原理还是基于form表单的文件上传。例如ElementUI中提供的upload上传组件:</p>
<p><img src="https://i.p04e.com/baid/i/2022/09/09/13n.png"></p>
<p>服务端要接收客户端页面上传的文件，通常都会使用Apache的两个组件:</p>
<ul>
<li>commons-fileupload</li>
<li>commons-io</li>
</ul>
<p>Spring框架在spring-web包中对文件上传进行了封装，大大简化了服务端代码，我们只需要在Controller的方法中声明一个MultipartFile类型的参数即可接收上传的文件，例如:</p>
<p><img src="https://i.p04e.com/baid/i/2022/09/09/1oku.png"></p>
<p>文件下载，也称为download，是指将文件从服务器传输到本地计算机的过程。</p>
<p>通过浏览器进行文件下载，通常有两种表现形式:</p>
<p>以附件形式下载，弹出保存对话框，将文件保存到指定磁盘目录直接在浏览器中打开</p>
<p>通过浏览器进行文件下载，本质上就是服务端将文件以流的形式写回浏览器的过程。</p>
<p>文件上传，页面端可以使用ElementUI提供的上传组件。</p>
<p>可以直接使用资料中提供的上传页面，位置:资料/文件上传下载页面/upload.html</p>
<p><img src="https://i.p04e.com/baid/i/2022/09/09/3h39j.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.controller;</span><br><span class="line"></span><br><span class="line">import com.itheima.reggie.common.R;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.beans.factory.annotation.Value;</span><br><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line">import org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line">import org.springframework.web.multipart.MultipartFile;</span><br><span class="line"></span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.UUID;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 文件上传和下载</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/common&quot;)</span><br><span class="line">@Slf4j</span><br><span class="line">public class CommonController &#123;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;reggie.path&#125;&quot;)</span><br><span class="line">    private String basePath;</span><br><span class="line">    /**</span><br><span class="line">     * 文件上传</span><br><span class="line">     * @param file</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @PostMapping(&quot;/upload&quot;)</span><br><span class="line">    public R&lt;String&gt; upload (MultipartFile file) &#123;</span><br><span class="line">        //file是一个临时文件，需要转存到指定位置，否则本次请求完成后临时文件将被删除</span><br><span class="line">        log.info(file.toString());</span><br><span class="line"></span><br><span class="line">        //获得原始文件名</span><br><span class="line">        String originalFilename = file.getOriginalFilename();</span><br><span class="line">        String suffix = originalFilename.substring((originalFilename.lastIndexOf(&quot;.&quot;)));</span><br><span class="line"></span><br><span class="line">        //使用UUID重新生成文件名，防止文件名称重复造成文件覆盖</span><br><span class="line">        String fileName = UUID.randomUUID().toString() + suffix;</span><br><span class="line"></span><br><span class="line">        //创建一个目录对象</span><br><span class="line">        File dir = new File(basePath);</span><br><span class="line">        //判断目录是否存在</span><br><span class="line">        if (!dir.exists()) &#123;</span><br><span class="line">            //目录不存在需要创建</span><br><span class="line">            dir.mkdir();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            file.transferTo(new File(basePath + fileName));</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return R.success(fileName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="二、文件上传下载"><a href="#二、文件上传下载" class="headerlink" title="二、文件上传下载"></a>二、文件上传下载</h3><p><code>文件下载代码实现</code></p>
<p>文件下载，页面端可以使用<img>标签展示下载的图片</p>
<p><img v-if="imageUrl" :src="imageUr1" class="avatar"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">handleAvatarSuccess (response，file，fileList) &#123;</span><br><span class="line">this. imageUrl =`/common/download?name=$ &#123;response.data&#125;`</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 文件下载</span><br><span class="line"> * @param name</span><br><span class="line"> * @param response</span><br><span class="line"> */</span><br><span class="line">@GetMapping(&quot;/download&quot;)</span><br><span class="line">public void downLoad(String name, HttpServletResponse response) &#123;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        //输入流，通过输入流读取文件内容</span><br><span class="line"></span><br><span class="line">        FileInputStream fileInputStream = new FileInputStream(new File(basePath + name));</span><br><span class="line"></span><br><span class="line">        //通过输出流将文件写回浏览器，在浏览器展示图片</span><br><span class="line"></span><br><span class="line">        ServletOutputStream outputStream = response.getOutputStream();</span><br><span class="line"></span><br><span class="line">        response.setContentType(&quot;image/jpeg&quot;);</span><br><span class="line"></span><br><span class="line">        int len = 0;</span><br><span class="line">        byte[] bytes = new byte[1024];</span><br><span class="line">        while ( (len = fileInputStream.read(bytes)) != -1) &#123;</span><br><span class="line">            outputStream.write(bytes,0,len);</span><br><span class="line">            outputStream.flush();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //关闭资源</span><br><span class="line">        outputStream.close();</span><br><span class="line">        fileInputStream.close();</span><br><span class="line"></span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>springboot - 外卖平台</tag>
        <tag>项目开发</tag>
        <tag>mybatis plus</tag>
        <tag>文件上传下载</tag>
      </tags>
  </entry>
  <entry>
    <title>外卖管理平台新增套餐</title>
    <url>/2022/09/13/%E5%A4%96%E5%8D%96%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0%E6%96%B0%E5%A2%9E%E5%A5%97%E9%A4%90/</url>
    <content><![CDATA[<h3 id="一、需求分析"><a href="#一、需求分析" class="headerlink" title="一、需求分析"></a>一、需求分析</h3><p>套餐就是菜品的集合。</p>
<p>后台系统中可以管理套餐信息，通过新增套餐功能来添加一个新的套餐，在添加套餐时需要选择当前套餐所属的套餐分类和包含的菜品，并且需要上传套餐对应的图片，在移动端会按照套餐分类来展示对应的套餐。</p>
<span id="more"></span>
<h4 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h4><p>新增套餐，其实就是将新增页面录入的套餐信息插入到setmeal表，还需要向setmeal_dish表插入套餐和菜品关联数据。</p>
<p>所以在新增套餐时，涉及到两个表:</p>
<p>setmeal    套餐表</p>
<p>setmeal_dish套餐菜品关系表</p>
<h3 id="二、代码开发-准备工作"><a href="#二、代码开发-准备工作" class="headerlink" title="二、代码开发 - 准备工作"></a>二、代码开发 - 准备工作</h3><p>在开发业务功能前,先将需要用到的类和接口基本结构创建好:</p>
<ul>
<li>实体类SetmealDish</li>
<li>DTO SetmealDto</li>
<li>Mapper接口SetmealDishMapper</li>
<li>业务层接口SetmealDishService</li>
<li>业务层实现类SetmealDishServicelmpl</li>
<li>控制层SetmealController</li>
</ul>
<h4 id="梳理交互过程"><a href="#梳理交互过程" class="headerlink" title="梳理交互过程"></a>梳理交互过程</h4><p>在开发代码之前，需要梳理一下新增套餐时前端页面和服务端的交互过程:</p>
<p>1、页面(backend/page/comboladd.html)发送ajax请求，请求服务端获取套餐分类数据并展示到下拉框中2、页面发送ajax请求，请求服务端获取菜品分类数据并展示到添加菜品窗口中</p>
<p>3、页面发送ajax请求，请求服务端，根据菜品分类查询对应的菜品数据并展示到添加菜品窗口中</p>
<p>4、页面发送请求进行图片上传，请求服务端将图片保存到服务器</p>
<p>5、页面发送请求进行图片下载，将上传的图片进行回显</p>
<p>6、点击保存按钮，发送ajax请求，将套餐相关数据以json形式提交到服务端</p>
<p>开发新增套餐功能，其实就是在服务端编写代码去处理前端页面发送的这6次请求即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 根据条件查询对应的菜品数据</span><br><span class="line"> * @param dish</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">@GetMapping(&quot;/list&quot;)</span><br><span class="line">public R&lt;List&lt;Dish&gt;&gt; list(Dish dish) &#123;</span><br><span class="line"></span><br><span class="line">    //构造查询条件</span><br><span class="line">    LambdaQueryWrapper&lt;Dish&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">    queryWrapper.eq(dish.getCategoryId() != null , Dish::getCategoryId, dish.getCategoryId());</span><br><span class="line">    //查询状态为1</span><br><span class="line">    queryWrapper.eq(Dish::getStatus,1);</span><br><span class="line">    //添加一个排序条件</span><br><span class="line">    queryWrapper.orderByAsc(Dish::getSort).orderByDesc(Dish::getUpdateTime);</span><br><span class="line"></span><br><span class="line">    List&lt;Dish&gt; list = dishService.list(queryWrapper);</span><br><span class="line">    return R.success(list);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.controller;</span><br><span class="line"></span><br><span class="line">import com.itheima.reggie.common.R;</span><br><span class="line">import com.itheima.reggie.dto.SetmealDto;</span><br><span class="line">import com.itheima.reggie.service.CategoryService;</span><br><span class="line">import com.itheima.reggie.service.SetmealDishService;</span><br><span class="line">import com.itheima.reggie.service.SetmealService;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestBody;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 套餐管理</span><br><span class="line"> */</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/setmeal&quot;)</span><br><span class="line">@Slf4j</span><br><span class="line">public class SetmealController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private SetmealService setmealService;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private CategoryService categoryService;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private SetmealDishService setmealDishService;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 新增套餐</span><br><span class="line">     * @param setmealDto</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @PostMapping</span><br><span class="line">    public R&lt;String&gt; save(@RequestBody SetmealDto setmealDto)&#123;</span><br><span class="line">        log.info(&quot;套餐信息：&#123;&#125;&quot;,setmealDto);</span><br><span class="line"></span><br><span class="line">        setmealService.saveWithDish(setmealDto);</span><br><span class="line"></span><br><span class="line">        return R.success(&quot;新增套餐成功&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.service;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.extension.service.IService;</span><br><span class="line">import com.itheima.reggie.dto.SetmealDto;</span><br><span class="line">import com.itheima.reggie.entity.Setmeal;</span><br><span class="line"></span><br><span class="line">public interface SetmealService extends IService&lt;Setmeal&gt; &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 新增套餐，同时需要保存套餐和菜品的关系</span><br><span class="line">     * @param setmealDto</span><br><span class="line">     */</span><br><span class="line">    public void saveWithDish(SetmealDto setmealDto);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.service.impl;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;</span><br><span class="line">import com.itheima.reggie.dto.SetmealDto;</span><br><span class="line">import com.itheima.reggie.entity.Setmeal;</span><br><span class="line">import com.itheima.reggie.entity.SetmealDish;</span><br><span class="line">import com.itheima.reggie.mapper.SetmealMapper;</span><br><span class="line">import com.itheima.reggie.service.SetmealDishService;</span><br><span class="line">import com.itheima.reggie.service.SetmealService;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line">import org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">@Slf4j</span><br><span class="line">public class SetmealServiceImpl extends ServiceImpl&lt;SetmealMapper, Setmeal&gt; implements SetmealService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private SetmealDishService setmealDishService;</span><br><span class="line">    /**</span><br><span class="line">     * 新增套餐，同时需要保存套餐和菜品的关系</span><br><span class="line">     * @param setmealDto</span><br><span class="line">     */</span><br><span class="line">    @Transactional</span><br><span class="line">    public void saveWithDish(SetmealDto setmealDto) &#123;</span><br><span class="line">        //保存套餐的基本信息，执行insert操作</span><br><span class="line">        this.save(setmealDto);</span><br><span class="line">        List&lt;SetmealDish&gt; setmealDishes = setmealDto.getSetmealDishes();</span><br><span class="line">        setmealDishes.stream().map((item) -&gt; &#123;</span><br><span class="line">            item.setSetmealId(setmealDto.getId());</span><br><span class="line">            return item;</span><br><span class="line">        &#125;).collect(Collectors.toList());</span><br><span class="line">        //保存套餐和菜品的关联信息，操作setmeal_dish,执行insert操作</span><br><span class="line">        setmealDishService.saveBatch(setmealDishes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>springboot - 外卖平台</tag>
        <tag>项目开发</tag>
        <tag>mybatis plus</tag>
        <tag>新增套餐</tag>
      </tags>
  </entry>
  <entry>
    <title>外卖管理平台新增菜品</title>
    <url>/2022/09/10/%E5%A4%96%E5%8D%96%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0%E6%96%B0%E5%A2%9E%E8%8F%9C%E5%93%81/</url>
    <content><![CDATA[<h3 id="一、需求分析"><a href="#一、需求分析" class="headerlink" title="一、需求分析"></a>一、需求分析</h3><p>后台系统中可以管理菜品信息，通过新增功能来添加一个新的菜品，在添加菜品时需要选择当前菜品所属的菜品分类，并且需要上传菜品图片，在移动端会按照菜品分类来展示对应的菜品信息。</p>
<span id="more"></span>
<h4 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h4><p>新增菜品，其实就是将新增页面录入的菜品信息插入到dish表，如果添加了口味做法，还需要向dish_flavor表插入数据.所以在新增菜品时，涉及到两个表:</p>
<ul>
<li>dish    菜品表</li>
<li>dish_flavor菜品口味表</li>
</ul>
<h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><p>在开发业务功能前，先将需要用到的类和接口基本结构创建好︰</p>
<ul>
<li>实体类DishFlavor</li>
<li>Mapper接口DishFlavorMapper</li>
<li>业务层接口DishFlavorService</li>
<li>业务层实现类DishFlavorServicelmpl控制层DishController</li>
</ul>
<h3 id="二、代码开发-梳理交互过程"><a href="#二、代码开发-梳理交互过程" class="headerlink" title="二、代码开发-梳理交互过程"></a>二、代码开发-梳理交互过程</h3><p>在开发代码之前，需要梳理一下新增菜品时前端页面和服务端的交互过程:</p>
<p>代码开发-梳理交互过程<br>在开发代码之前，需要梳理一下新增菜品时前端页面和服务端的交互过程:</p>
<p> 1、页面(backend/page/food/add.html)发送ajax请求，请求服务端获取菜品分类数据并展示到下拉框中</p>
<p>2、页面发送请求进行图片上传，请求服务端将图片保存到服务器<br>3、页面发送请求进行图片下载，将上传的图片进行回显<br>4、点击保存按钮，发送ajax请求，将菜品相关数据以json形式提交到服务端</p>
<p><code>开发新增菜品功能，其实就是在服务端编写代码去处理前端页面发送的这4次请求即可。</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据条件查询分类数据</span><br><span class="line">     * @param category</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @GetMapping(&quot;/list&quot;)</span><br><span class="line">    public R&lt;List&lt;Category&gt;&gt; list(Category category) &#123;</span><br><span class="line">        //条件构造器</span><br><span class="line">LambdaQueryWrapper&lt;Category&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">        //添加条件</span><br><span class="line">queryWrapper.eq(category.getType() != null, Category::getType, category.getType());</span><br><span class="line">        //添加排序条件</span><br><span class="line">        queryWrapper.orderByAsc(Category::getSort).orderByDesc(Category::getUpdateTime);</span><br><span class="line"></span><br><span class="line">        List&lt;Category&gt; list = categoryService.list(queryWrapper);</span><br><span class="line">        return R.success(list);</span><br></pre></td></tr></table></figure>
<h4 id="导入DTO"><a href="#导入DTO" class="headerlink" title="导入DTO"></a>导入DTO</h4><p>导入DishDto，用于封装页面提交的数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class DishDto extends Dish &#123;</span><br><span class="line">private List&lt;DishFlavor&gt; flavors = new ArrayList&lt;&gt; () ;</span><br><span class="line">private String categoryName;</span><br><span class="line">private Integer copies;</span><br></pre></td></tr></table></figure>
<p><code>注意事项</code><br><code>DTO，全称为Data Transfer Object，即数据传输对象，一般用于展示层与服务层之同的数据传输。</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.dto;</span><br><span class="line"></span><br><span class="line">import com.itheima.reggie.entity.Dish;</span><br><span class="line">import com.itheima.reggie.entity.DishFlavor;</span><br><span class="line">import lombok.Data;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">@Data</span><br><span class="line">public class DishDto extends Dish &#123;</span><br><span class="line"></span><br><span class="line">    private List&lt;DishFlavor&gt; flavors = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    private String categoryName;</span><br><span class="line"></span><br><span class="line">    private Integer copies;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.controller;</span><br><span class="line"></span><br><span class="line">import com.itheima.reggie.common.R;</span><br><span class="line">import com.itheima.reggie.dto.DishDto;</span><br><span class="line">import com.itheima.reggie.service.DishFlavorService;</span><br><span class="line">import com.itheima.reggie.service.DishService;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestBody;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/dish&quot;)</span><br><span class="line">@Slf4j</span><br><span class="line">public class DishController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private DishService dishService;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private DishFlavorService dishFlavorService;</span><br><span class="line"></span><br><span class="line">    @PostMapping</span><br><span class="line">    public R&lt;String&gt; save(@RequestBody DishDto dishDto) &#123;</span><br><span class="line"></span><br><span class="line">        log.info(dishDto.toString());</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.service.impl;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;</span><br><span class="line">import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;</span><br><span class="line">import com.itheima.reggie.dto.DishDto;</span><br><span class="line">import com.itheima.reggie.entity.Dish;</span><br><span class="line">import com.itheima.reggie.entity.DishFlavor;</span><br><span class="line">import com.itheima.reggie.mapper.DishMapper;</span><br><span class="line">import com.itheima.reggie.service.DishFlavorService;</span><br><span class="line">import com.itheima.reggie.service.DishService;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.beans.BeanUtils;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line">import org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line">import java.util.Collections;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">@Slf4j</span><br><span class="line">public class DishServiceImpl extends ServiceImpl&lt;DishMapper,Dish&gt; implements DishService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private DishFlavorService dishFlavorService;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 新增菜品，同时保存对应的口味数据</span><br><span class="line">     * @param dishDto</span><br><span class="line">     */</span><br><span class="line">    @Transactional</span><br><span class="line">    public void saveWithFlavor(DishDto dishDto) &#123;</span><br><span class="line">        //保存菜品的基本信息到菜品表dish</span><br><span class="line">        this.save(dishDto);</span><br><span class="line"></span><br><span class="line">        Long dishId = dishDto.getId();//菜品id</span><br><span class="line"></span><br><span class="line">        //菜品口味</span><br><span class="line">        List&lt;DishFlavor&gt; flavors = dishDto.getFlavors();</span><br><span class="line">        flavors = flavors.stream().map((item) -&gt; &#123;</span><br><span class="line">            item.setDishId(dishId);</span><br><span class="line">            return item;</span><br><span class="line">        &#125;).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        //保存菜品口味数据到菜品口味表dish_flavor</span><br><span class="line">        dishFlavorService.saveBatch(flavors);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据id查询菜品信息和对应的口味信息</span><br><span class="line">     * @param id</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public DishDto getByIdWithFlavor(Long id) &#123;</span><br><span class="line">        //查询菜品基本信息，从dish表查询</span><br><span class="line">        Dish dish = this.getById(id);</span><br><span class="line"></span><br><span class="line">        DishDto dishDto = new DishDto();</span><br><span class="line">        BeanUtils.copyProperties(dish,dishDto);</span><br><span class="line"></span><br><span class="line">        //查询当前菜品对应的口味信息，从dish_flavor表查询</span><br><span class="line">        LambdaQueryWrapper&lt;DishFlavor&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">        queryWrapper.eq(DishFlavor::getDishId,dish.getId());</span><br><span class="line">        List&lt;DishFlavor&gt; flavors = dishFlavorService.list(queryWrapper);</span><br><span class="line">        dishDto.setFlavors(flavors);</span><br><span class="line"></span><br><span class="line">        return dishDto;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Transactional</span><br><span class="line">    public void updateWithFlavor(DishDto dishDto) &#123;</span><br><span class="line">        //更新dish表基本信息</span><br><span class="line">        this.updateById(dishDto);</span><br><span class="line"></span><br><span class="line">        //清理当前菜品对应口味数据---dish_flavor表的delete操作</span><br><span class="line">        LambdaQueryWrapper&lt;DishFlavor&gt; queryWrapper = new LambdaQueryWrapper();</span><br><span class="line">        queryWrapper.eq(DishFlavor::getDishId,dishDto.getId());</span><br><span class="line"></span><br><span class="line">        dishFlavorService.remove(queryWrapper);</span><br><span class="line"></span><br><span class="line">        //添加当前提交过来的口味数据---dish_flavor表的insert操作</span><br><span class="line">        List&lt;DishFlavor&gt; flavors = dishDto.getFlavors();</span><br><span class="line"></span><br><span class="line">        flavors = flavors.stream().map((item) -&gt; &#123;</span><br><span class="line">            item.setDishId(dishDto.getId());</span><br><span class="line">            return item;</span><br><span class="line">        &#125;).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        dishFlavorService.saveBatch(flavors);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.controller;</span><br><span class="line"></span><br><span class="line">import com.itheima.reggie.common.R;</span><br><span class="line">import com.itheima.reggie.dto.DishDto;</span><br><span class="line">import com.itheima.reggie.service.DishFlavorService;</span><br><span class="line">import com.itheima.reggie.service.DishService;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestBody;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/dish&quot;)</span><br><span class="line">@Slf4j</span><br><span class="line">public class DishController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private DishService dishService;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private DishFlavorService dishFlavorService;</span><br><span class="line"></span><br><span class="line">    @PostMapping</span><br><span class="line">    public R&lt;String&gt; save(@RequestBody DishDto dishDto) &#123;</span><br><span class="line"></span><br><span class="line">        log.info(dishDto.toString());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        dishService.saveWithFlavor(dishDto);</span><br><span class="line">        return R.success(&quot;新增菜品成功&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line">import org.springframework.boot.web.servlet.ServletComponentScan;</span><br><span class="line">import org.springframework.transaction.annotation.EnableTransactionManagement;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Slf4j</span><br><span class="line">@SpringBootApplication</span><br><span class="line">@ServletComponentScan</span><br><span class="line">@EnableTransactionManagement</span><br><span class="line">public class ReggieApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(ReggieApplication.class,args);</span><br><span class="line">        log.info(&quot;项目启动成功...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>springboot - 外卖平台</tag>
        <tag>项目开发</tag>
        <tag>mybatis plus</tag>
        <tag>新增菜品</tag>
      </tags>
  </entry>
  <entry>
    <title>外卖管理平台短信发送</title>
    <url>/2022/09/14/%E5%A4%96%E5%8D%96%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0%E7%9F%AD%E4%BF%A1%E5%8F%91%E9%80%81/</url>
    <content><![CDATA[<h3 id="一、短信服务介绍"><a href="#一、短信服务介绍" class="headerlink" title="一、短信服务介绍"></a>一、短信服务介绍</h3><p>目前市面上有很多第三方提供的短信服务，这些第三方短信服务会和各个运营商（移动、联通、电信）对接，我们只需要注册成为会员并且按照提供的开发文档进行调用就可以发送短信。需要说明的是，这些短信服务一般都是收费服务。</p>
<span id="more"></span>
<p>常用短信服务:</p>
<ul>
<li>阿里云</li>
<li>华为云</li>
<li>腾讯云</li>
<li>京东</li>
<li>梦网</li>
<li>乐信</li>
</ul>
<h4 id="阿里云短信服务-介绍"><a href="#阿里云短信服务-介绍" class="headerlink" title="阿里云短信服务-介绍"></a>阿里云短信服务-介绍</h4><p>阿里云短信服务（Short Message Service)是广大企业客户快速触达手机用户所优选使用的通信能力。调用API或用群发助手，即可发送验证码、通知类和营销类短信;国内验证短信秒级触达，到达率最高可达99%;国际/港澳台短信覆盖200多个国家和地区，安全稳定，广受出海企业选用。</p>
<p>应用场景:</p>
<ul>
<li>验证码</li>
<li>短信通知</li>
<li>推广短信</li>
</ul>
<h4 id="阿里云短信服务-注册账号"><a href="#阿里云短信服务-注册账号" class="headerlink" title="阿里云短信服务-注册账号"></a>阿里云短信服务-注册账号</h4><p>阿里云官网: https:// www.aliyun.com/</p>
<p>点击官网首页注册按钮，跳转到如下注册页面:</p>
<p><img src="https://i.p04e.com/baid/i/2022/09/18/uub.png"></p>
<h4 id="阿里云短信服务-设置短信签名"><a href="#阿里云短信服务-设置短信签名" class="headerlink" title="阿里云短信服务-设置短信签名"></a>阿里云短信服务-设置短信签名</h4><p>注册成功后，点击登录按钮进行登录。登录后进入短信服务管理页面，选择国内消息菜单:</p>
<p><img src="https://i.p04e.com/baid/i/2022/09/18/n3tp.png"></p>
<p>短信签名是短信发送者的署名，表示发送方的身份。</p>
<h4 id="阿里云短信服务-设置短信模板"><a href="#阿里云短信服务-设置短信模板" class="headerlink" title="阿里云短信服务-设置短信模板"></a>阿里云短信服务-设置短信模板</h4><p>切换到【模板管理】标签页:</p>
<p><img src="https://i.p04e.com/baid/i/2022/09/18/y3t7.png"></p>
<h4 id="阿里云短信服务-设置AccessKey"><a href="#阿里云短信服务-设置AccessKey" class="headerlink" title="阿里云短信服务-设置AccessKey"></a>阿里云短信服务-设置AccessKey</h4><p>光标移动到用户头像上，在弹出的窗口中点击【AccessKey管理】∶</p>
<p><img src="https://i.p04e.com/baid/i/2022/09/18/2r.png"></p>
<p>选择子用户。</p>
<p>使用阿里云短信服务发送短信，可以参照官方提供的<a href="https://help.aliyun.com/product/44282.html?spm=5176.25163407.help.dexternal.51a7bb6e9O0uQU">文档</a>即可。</p>
<p>具体开发步骤:</p>
<p>1、导入maven坐标</p>
<p>2、调用API</p>
<p><img src="https://i.p04e.com/baid/i/2022/09/18/9m94.png"></p>
<h3 id="二、需求分析"><a href="#二、需求分析" class="headerlink" title="二、需求分析"></a>二、需求分析</h3><p>为了方便用户登录，移动端通常都会提供通过手机验证码登录的功能。<br>心</p>
<p>手机验证码登录的优点:</p>
<ul>
<li>方便快捷，无需注册，直接登录</li>
<li>使用短信验证码作为登录凭证，无需记忆密码</li>
<li>安全<br>登录流程:<br>输入手机号&gt;获取验证码&gt;输入验证码&gt;点击登录&gt;登录成功<br><code>注意:通过手机验证码登录，手机号是区分不同用户的标识。</code></li>
</ul>
<h4 id="三、代码开发-梳理交互过程"><a href="#三、代码开发-梳理交互过程" class="headerlink" title="三、代码开发-梳理交互过程"></a>三、代码开发-梳理交互过程</h4><p>在开发代码之前，需要梳理一下登录时前端页面和服务端的交互过程:</p>
<p>1、在登录页面(front/page/login.html)输入手机号，点击【获取验证码】按钮，页面发送ajax请求，在服务端调用短信服务API给指定手机号发送验证码短信</p>
<p>2、在登录页面输入验证码，点击【登录】按钮，发送ajax请求，在服务端处理登录请求</p>
<p>开发手机验证码登录功能，其实就是在服务端编写代码去处理前端页面发送的这2次请求即可。</p>
<h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><p>在开发业务功能前，先将需要用到的类和接口基本结构创建好:实体类User（</p>
<p>Mapper接口UserMapper</p>
<p>业务层接口UserService</p>
<p>业务层实现类UserServicelmpl控制层Usercontroller</p>
<p>工具类SMSutils、ValidateCodeutils</p>
<h4 id="代码开发-修改LoginCheckFilter"><a href="#代码开发-修改LoginCheckFilter" class="headerlink" title="代码开发-修改LoginCheckFilter"></a>代码开发-修改LoginCheckFilter</h4><p>前面我们已经完成了LoginCheckFilter过滤器的开发，此过滤器用于检查用户的登录状态。我们在进行手机验证码登录时，发送的请求需要在此过滤器处理时直接放行。</p>
<p><img src="https://i.p04e.com/baid/i/2022/09/18/d0i.png"></p>
<p>在LoginCheckFilter过滤器中扩展逻辑，判断移动端用户登录状态:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//4-1、判断登录状态，如果已登录，则直接放行</span><br><span class="line">        if(request.getSession().getAttribute(&quot;employee&quot;) != null)&#123;</span><br><span class="line">            log.info(&quot;用户已登录，用户id为：&#123;&#125;&quot;,request.getSession().getAttribute(&quot;employee&quot;));</span><br><span class="line"></span><br><span class="line">            Long empId = (Long) request.getSession().getAttribute(&quot;employee&quot;);</span><br><span class="line">            BaseContext.setCurrentId(empId);</span><br><span class="line"></span><br><span class="line">            filterChain.doFilter(request,response);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //4-2、判断登录状态，如果已登录，则直接放行</span><br><span class="line">        if(request.getSession().getAttribute(&quot;user&quot;) != null)&#123;</span><br><span class="line">            log.info(&quot;用户已登录，用户id为：&#123;&#125;&quot;,request.getSession().getAttribute(&quot;user&quot;));</span><br><span class="line"></span><br><span class="line">            Long userId = (Long) request.getSession().getAttribute(&quot;user&quot;);</span><br><span class="line">            BaseContext.setCurrentId(userId);</span><br><span class="line"></span><br><span class="line">            filterChain.doFilter(request,response);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        log.info(&quot;用户未登录&quot;);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.controller;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;</span><br><span class="line">import com.itheima.reggie.common.R;</span><br><span class="line">import com.itheima.reggie.entity.User;</span><br><span class="line">import com.itheima.reggie.service.UserService;</span><br><span class="line">import com.itheima.reggie.utils.ValidateCodeUtils;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.apache.commons.lang.StringUtils;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestBody;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">import javax.servlet.http.HttpSession;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/user&quot;)</span><br><span class="line">@Slf4j</span><br><span class="line">public class UserController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private UserService userService;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 发送手机短信验证码</span><br><span class="line">     * @param user</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @PostMapping(&quot;/sendMsg&quot;)</span><br><span class="line">    public R&lt;String&gt; sendMsg(@RequestBody User user, HttpSession session)&#123;</span><br><span class="line">        //获取手机号</span><br><span class="line">        String phone = user.getPhone();</span><br><span class="line"></span><br><span class="line">        if(StringUtils.isNotEmpty(phone))&#123;</span><br><span class="line">            //生成随机的4位验证码</span><br><span class="line">            String code = ValidateCodeUtils.generateValidateCode(4).toString();</span><br><span class="line">            log.info(&quot;code=&#123;&#125;&quot;,code);</span><br><span class="line"></span><br><span class="line">            //调用阿里云提供的短信服务API完成发送短信</span><br><span class="line">            //SMSUtils.sendMessage(&quot;瑞吉外卖&quot;,&quot;&quot;,phone,code);</span><br><span class="line"></span><br><span class="line">            //需要将生成的验证码保存到Session</span><br><span class="line">            session.setAttribute(phone,code);</span><br><span class="line"></span><br><span class="line">            return R.success(&quot;手机验证码短信发送成功&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return R.error(&quot;短信发送失败&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 移动端用户登录</span><br><span class="line">     * @param map</span><br><span class="line">     * @param session</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @PostMapping(&quot;/login&quot;)</span><br><span class="line">    public R&lt;User&gt; login(@RequestBody Map map, HttpSession session)&#123;</span><br><span class="line">        log.info(map.toString());</span><br><span class="line"></span><br><span class="line">        //获取手机号</span><br><span class="line">        String phone = map.get(&quot;phone&quot;).toString();</span><br><span class="line"></span><br><span class="line">        //获取验证码</span><br><span class="line">        String code = map.get(&quot;code&quot;).toString();</span><br><span class="line"></span><br><span class="line">        //从Session中获取保存的验证码</span><br><span class="line">        Object codeInSession = session.getAttribute(phone);</span><br><span class="line"></span><br><span class="line">        //进行验证码的比对（页面提交的验证码和Session中保存的验证码比对）</span><br><span class="line">        if(codeInSession != null &amp;&amp; codeInSession.equals(code))&#123;</span><br><span class="line">            //如果能够比对成功，说明登录成功</span><br><span class="line"></span><br><span class="line">            LambdaQueryWrapper&lt;User&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">            queryWrapper.eq(User::getPhone,phone);</span><br><span class="line"></span><br><span class="line">            User user = userService.getOne(queryWrapper);</span><br><span class="line">            if(user == null)&#123;</span><br><span class="line">                //判断当前手机号对应的用户是否为新用户，如果是新用户就自动完成注册</span><br><span class="line">                user = new User();</span><br><span class="line">                user.setPhone(phone);</span><br><span class="line">                user.setStatus(1);</span><br><span class="line">                userService.save(user);</span><br><span class="line">            &#125;</span><br><span class="line">            session.setAttribute(&quot;user&quot;,user.getId());</span><br><span class="line">            return R.success(user);</span><br><span class="line">        &#125;</span><br><span class="line">        return R.error(&quot;登录失败&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>springboot - 外卖平台</tag>
        <tag>项目开发</tag>
        <tag>mybatis plus</tag>
        <tag>短信发送</tag>
      </tags>
  </entry>
  <entry>
    <title>外卖管理平台用户下单</title>
    <url>/2022/09/19/%E5%A4%96%E5%8D%96%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0%E7%94%A8%E6%88%B7%E4%B8%8B%E5%8D%95/</url>
    <content><![CDATA[<h3 id="一、需求分析"><a href="#一、需求分析" class="headerlink" title="一、需求分析"></a>一、需求分析</h3><p>移动端用户将菜品或者套餐加入购物车后，可以点击购物车中的去结算按钮，页面跳转到订单确认页面，点<br>击去支付按钮则完成下单操作。</p>
<span id="more"></span>
<h4 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h4><p>用户下单业务对应的数据表为orders表和order_detail表:</p>
<ul>
<li>orders:订单表</li>
<li>order_detail:订单明细表</li>
</ul>
<h3 id="二、代码开发-梳理交互过程"><a href="#二、代码开发-梳理交互过程" class="headerlink" title="二、代码开发-梳理交互过程"></a>二、代码开发-梳理交互过程</h3><p>在开发代码之前，需要梳理一下用户下单操作时前端页面和服务端的交互过程:</p>
<p>1、在购物车中点击按钮，页面跳转到订单确认页面</p>
<p>2、在订单确认页面，发送ajax请求，请求服务端获取当前登录用户的默认地址</p>
<p>3、在订单确认页面，发送ajax请求，请求服务端获取当前登录用户的购物车数据</p>
<p>4、在订单确认页面点击去支付按钮，发送ajax请求，请求服务端完成下单操作</p>
<p>开发用户下单功能，其实就是在服务端编写代码去处理前端页面发送的请求即可。</p>
<h4 id="代码开发-准备工作"><a href="#代码开发-准备工作" class="headerlink" title="代码开发-准备工作"></a>代码开发-准备工作</h4><p>在开发业务功能前，先将需要用到的类和接口基本结构创建好:</p>
<ul>
<li>实体类Orders、OrderDetail </li>
<li>Mapper接口OrderMapper、OrderDetailMapper</li>
<li>业务层接口OrderService.OrderDetailService</li>
<li>业务层实现类QrderServicelmpl、OrderDetailServicelmpl</li>
<li>控制层OrderController、OrderDetailController</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.controller;</span><br><span class="line"></span><br><span class="line">import com.itheima.reggie.common.R;</span><br><span class="line">import com.itheima.reggie.entity.Orders;</span><br><span class="line">import com.itheima.reggie.service.OrderService;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestBody;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 订单</span><br><span class="line"> */</span><br><span class="line">@Slf4j</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/order&quot;)</span><br><span class="line">public class OrderController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private OrderService orderService;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 用户下单</span><br><span class="line">     * @param orders</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @PostMapping(&quot;/submit&quot;)</span><br><span class="line">    public R&lt;String&gt; submit(@RequestBody Orders orders)&#123;</span><br><span class="line">        log.info(&quot;订单数据：&#123;&#125;&quot;,orders);</span><br><span class="line">        orderService.submit(orders);</span><br><span class="line">        return R.success(&quot;下单成功&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.service;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.extension.service.IService;</span><br><span class="line">import com.itheima.reggie.entity.Orders;</span><br><span class="line"></span><br><span class="line">public interface OrderService extends IService&lt;Orders&gt; &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 用户下单</span><br><span class="line">     * @param orders</span><br><span class="line">     */</span><br><span class="line">    public void submit(Orders orders);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.service.impl;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;</span><br><span class="line">import com.baomidou.mybatisplus.core.toolkit.IdWorker;</span><br><span class="line">import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;</span><br><span class="line">import com.itheima.reggie.common.BaseContext;</span><br><span class="line">import com.itheima.reggie.common.CustomException;</span><br><span class="line">import com.itheima.reggie.entity.*;</span><br><span class="line">import com.itheima.reggie.mapper.OrderMapper;</span><br><span class="line">import com.itheima.reggie.service.*;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line">import org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line">import java.math.BigDecimal;</span><br><span class="line">import java.time.LocalDateTime;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line">import java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">@Slf4j</span><br><span class="line">public class OrderServiceImpl extends ServiceImpl&lt;OrderMapper, Orders&gt; implements OrderService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private ShoppingCartService shoppingCartService;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private UserService userService;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private AddressBookService addressBookService;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private OrderDetailService orderDetailService;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 用户下单</span><br><span class="line">     * @param orders</span><br><span class="line">     */</span><br><span class="line">    @Transactional</span><br><span class="line">    public void submit(Orders orders) &#123;</span><br><span class="line">        //获得当前用户id</span><br><span class="line">        Long userId = BaseContext.getCurrentId();</span><br><span class="line"></span><br><span class="line">        //查询当前用户的购物车数据</span><br><span class="line">        LambdaQueryWrapper&lt;ShoppingCart&gt; wrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">        wrapper.eq(ShoppingCart::getUserId,userId);</span><br><span class="line">        List&lt;ShoppingCart&gt; shoppingCarts = shoppingCartService.list(wrapper);</span><br><span class="line"></span><br><span class="line">        if(shoppingCarts == null || shoppingCarts.size() == 0)&#123;</span><br><span class="line">            throw new CustomException(&quot;购物车为空，不能下单&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //查询用户数据</span><br><span class="line">        User user = userService.getById(userId);</span><br><span class="line"></span><br><span class="line">        //查询地址数据</span><br><span class="line">        Long addressBookId = orders.getAddressBookId();</span><br><span class="line">        AddressBook addressBook = addressBookService.getById(addressBookId);</span><br><span class="line">        if(addressBook == null)&#123;</span><br><span class="line">            throw new CustomException(&quot;用户地址信息有误，不能下单&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        long orderId = IdWorker.getId();//订单号</span><br><span class="line"></span><br><span class="line">        AtomicInteger amount = new AtomicInteger(0);</span><br><span class="line"></span><br><span class="line">        List&lt;OrderDetail&gt; orderDetails = shoppingCarts.stream().map((item) -&gt; &#123;</span><br><span class="line">            OrderDetail orderDetail = new OrderDetail();</span><br><span class="line">            orderDetail.setOrderId(orderId);</span><br><span class="line">            orderDetail.setNumber(item.getNumber());</span><br><span class="line">            orderDetail.setDishFlavor(item.getDishFlavor());</span><br><span class="line">            orderDetail.setDishId(item.getDishId());</span><br><span class="line">            orderDetail.setSetmealId(item.getSetmealId());</span><br><span class="line">            orderDetail.setName(item.getName());</span><br><span class="line">            orderDetail.setImage(item.getImage());</span><br><span class="line">            orderDetail.setAmount(item.getAmount());</span><br><span class="line">            amount.addAndGet(item.getAmount().multiply(new BigDecimal(item.getNumber())).intValue());</span><br><span class="line">            return orderDetail;</span><br><span class="line">        &#125;).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        orders.setId(orderId);</span><br><span class="line">        orders.setOrderTime(LocalDateTime.now());</span><br><span class="line">        orders.setCheckoutTime(LocalDateTime.now());</span><br><span class="line">        orders.setStatus(2);</span><br><span class="line">        orders.setAmount(new BigDecimal(amount.get()));//总金额</span><br><span class="line">        orders.setUserId(userId);</span><br><span class="line">        orders.setNumber(String.valueOf(orderId));</span><br><span class="line">        orders.setUserName(user.getName());</span><br><span class="line">        orders.setConsignee(addressBook.getConsignee());</span><br><span class="line">        orders.setPhone(addressBook.getPhone());</span><br><span class="line">        orders.setAddress((addressBook.getProvinceName() == null ? &quot;&quot; : addressBook.getProvinceName())</span><br><span class="line">                + (addressBook.getCityName() == null ? &quot;&quot; : addressBook.getCityName())</span><br><span class="line">                + (addressBook.getDistrictName() == null ? &quot;&quot; : addressBook.getDistrictName())</span><br><span class="line">                + (addressBook.getDetail() == null ? &quot;&quot; : addressBook.getDetail()));</span><br><span class="line">        //向订单表插入数据，一条数据</span><br><span class="line">        this.save(orders);</span><br><span class="line"></span><br><span class="line">        //向订单明细表插入数据，多条数据</span><br><span class="line">        orderDetailService.saveBatch(orderDetails);</span><br><span class="line"></span><br><span class="line">        //清空购物车数据</span><br><span class="line">        shoppingCartService.remove(wrapper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>springboot - 外卖平台</tag>
        <tag>项目开发</tag>
        <tag>mybatis plus</tag>
        <tag>用户下单</tag>
      </tags>
  </entry>
  <entry>
    <title>外卖管理平台菜品信息分页查询</title>
    <url>/2022/09/11/%E5%A4%96%E5%8D%96%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0%E8%8F%9C%E5%93%81%E4%BF%A1%E6%81%AF%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><h3 id="一、需求分析"><a href="#一、需求分析" class="headerlink" title="一、需求分析"></a>一、需求分析</h3><p>系统中的菜品数据很多的时候，如果在一个页面中全部展示出来会显得比较乱，不便于查看，所以一般的系统中都会以分页的方式来展示列表数据。</p>
<span id="more"></span>
<h3 id="二、代码开发"><a href="#二、代码开发" class="headerlink" title="二、代码开发"></a>二、代码开发</h3><h4 id="梳理交互过程"><a href="#梳理交互过程" class="headerlink" title="梳理交互过程"></a>梳理交互过程</h4><p>在开发代码之前，需要梳理一下菜品分页查询时前端页面和服务端的交互过程:</p>
<p>1、页面(backend/page/food/list.html)发送ajax请求，将分页查询参数(page、pageSize、name)提交到服务端，获取分页数据</p>
<p>2、页面发送请求，请求服务端进行图片下载，用于页面图片展示</p>
<p>开发菜品信息分页查询功能，其实就是在服务端编写代码去处理前端页面发送的这2次请求即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.controller;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;</span><br><span class="line">import com.baomidou.mybatisplus.extension.plugins.pagination.Page;</span><br><span class="line">import com.itheima.reggie.common.R;</span><br><span class="line">import com.itheima.reggie.dto.DishDto;</span><br><span class="line">import com.itheima.reggie.entity.Category;</span><br><span class="line">import com.itheima.reggie.entity.Dish;</span><br><span class="line">import com.itheima.reggie.service.CategoryService;</span><br><span class="line">import com.itheima.reggie.service.DishFlavorService;</span><br><span class="line">import com.itheima.reggie.service.DishService;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.beans.BeanUtils;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/dish&quot;)</span><br><span class="line">@Slf4j</span><br><span class="line">public class DishController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private DishService dishService;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private DishFlavorService dishFlavorService;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private CategoryService categoryService;</span><br><span class="line"></span><br><span class="line">    @PostMapping</span><br><span class="line">    public R&lt;String&gt; save(@RequestBody DishDto dishDto) &#123;</span><br><span class="line"></span><br><span class="line">        log.info(dishDto.toString());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        dishService.saveWithFlavor(dishDto);</span><br><span class="line">        return R.success(&quot;新增菜品成功&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 菜品信息分页</span><br><span class="line">     * @param page</span><br><span class="line">     * @param pageSize</span><br><span class="line">     * @param name</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @GetMapping(&quot;/page&quot;)</span><br><span class="line">    public R&lt;Page&gt; page(int page, int pageSize, String name) &#123;</span><br><span class="line"></span><br><span class="line">        //构造分页构造器</span><br><span class="line">        Page&lt;Dish&gt; pageInfo = new Page&lt;&gt;(page,pageSize);</span><br><span class="line">        Page&lt;DishDto&gt; dishDtoPage = new Page&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        //条件构造器</span><br><span class="line">        LambdaQueryWrapper&lt;Dish&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        //添加过滤条件</span><br><span class="line">        queryWrapper.like(name != null,Dish::getName, name);</span><br><span class="line"></span><br><span class="line">        //添加排序条件</span><br><span class="line">        queryWrapper.orderByDesc(Dish::getUpdateTime);</span><br><span class="line"></span><br><span class="line">        //执行分页查询</span><br><span class="line">        dishService.page(pageInfo, queryWrapper);</span><br><span class="line"></span><br><span class="line">        //对象拷贝</span><br><span class="line">        BeanUtils.copyProperties(pageInfo,dishDtoPage,&quot;records&quot;);</span><br><span class="line"></span><br><span class="line">        List&lt;Dish&gt; records = pageInfo.getRecords();</span><br><span class="line">        List&lt;DishDto&gt; list = records.stream().map((item) -&gt;  &#123;</span><br><span class="line">            DishDto dishDto = new DishDto();</span><br><span class="line"></span><br><span class="line">            BeanUtils.copyProperties(item, dishDto);</span><br><span class="line"></span><br><span class="line">            Long categoryId = item.getCategoryId();</span><br><span class="line"></span><br><span class="line">            //根据id查询分类对象</span><br><span class="line">            Category category = categoryService.getById(categoryId);</span><br><span class="line"></span><br><span class="line">            if (category != null) &#123;</span><br><span class="line">                String categoryName = category.getName();</span><br><span class="line">                dishDto.setCategoryName(categoryName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            return dishDto;</span><br><span class="line">        &#125;).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        dishDtoPage.setRecords(list);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        return R.success(dishDtoPage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>springboot - 外卖平台</tag>
        <tag>项目开发</tag>
        <tag>mybatis plus</tag>
        <tag>菜品信息分页查询</tag>
      </tags>
  </entry>
  <entry>
    <title>外卖管理平台菜品展示</title>
    <url>/2022/09/19/%E5%A4%96%E5%8D%96%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0%E8%8F%9C%E5%93%81%E5%B1%95%E7%A4%BA/</url>
    <content><![CDATA[<h3 id="一、菜品展示"><a href="#一、菜品展示" class="headerlink" title="一、菜品展示"></a>一、菜品展示</h3><p>用户登录成功后跳转到系统首页，在首页需要根据分类来展示菜品和套餐。如果菜品设置了口味信息，需要展示<code>选择规格</code>按钮，否则显示<code>+</code>按钮。</p>
<span id="more"></span>
<h3 id="二、代码开发-梳理交互过程"><a href="#二、代码开发-梳理交互过程" class="headerlink" title="二、代码开发-梳理交互过程"></a>二、代码开发-梳理交互过程</h3><p>在开发代码之前，需要梳理一下前端页面和服务端的交互过程:</p>
<p>在开发代码之前，需要梳理一下前端页面和服务端的交互过程:<br>1、页面(front/index.html)发送ajax请求，获取分类数据（菜品分类和套餐分类)</p>
<p>2、页面发送ajax请求，获取第一个分类下的菜品或者套餐</p>
<p>开发菜品展示功能，其实就是在服务端编写代码去处理前端页面发送的这2次请求即可。</p>
<p>注意:首页加载完成后，还发送了一次ajax请求用于加载购物车数据，此处可以将这次请求的地址暂时修改一下，从静态json文件获取数据，等后续开发购物车功能时再修改回来，如下:</p>
<p><img src="https://i.p04e.com/baid/i/2022/09/19/3puk7.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 根据条件查询对应的菜品数据</span><br><span class="line">     * @param dish</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    /*@GetMapping(&quot;/list&quot;)</span><br><span class="line">    public R&lt;List&lt;Dish&gt;&gt; list(Dish dish)&#123;</span><br><span class="line">        //构造查询条件</span><br><span class="line">        LambdaQueryWrapper&lt;Dish&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">        queryWrapper.eq(dish.getCategoryId() != null ,Dish::getCategoryId,dish.getCategoryId());</span><br><span class="line">        //添加条件，查询状态为1（起售状态）的菜品</span><br><span class="line">        queryWrapper.eq(Dish::getStatus,1);</span><br><span class="line"></span><br><span class="line">        //添加排序条件</span><br><span class="line">        queryWrapper.orderByAsc(Dish::getSort).orderByDesc(Dish::getUpdateTime);</span><br><span class="line"></span><br><span class="line">        List&lt;Dish&gt; list = dishService.list(queryWrapper);</span><br><span class="line"></span><br><span class="line">        return R.success(list);</span><br><span class="line">    &#125;*/</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/list&quot;)</span><br><span class="line">    public R&lt;List&lt;DishDto&gt;&gt; list(Dish dish)&#123;</span><br><span class="line">        //构造查询条件</span><br><span class="line">        LambdaQueryWrapper&lt;Dish&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">        queryWrapper.eq(dish.getCategoryId() != null ,Dish::getCategoryId,dish.getCategoryId());</span><br><span class="line">        //添加条件，查询状态为1（起售状态）的菜品</span><br><span class="line">        queryWrapper.eq(Dish::getStatus,1);</span><br><span class="line"></span><br><span class="line">        //添加排序条件</span><br><span class="line">        queryWrapper.orderByAsc(Dish::getSort).orderByDesc(Dish::getUpdateTime);</span><br><span class="line"></span><br><span class="line">        List&lt;Dish&gt; list = dishService.list(queryWrapper);</span><br><span class="line"></span><br><span class="line">        List&lt;DishDto&gt; dishDtoList = list.stream().map((item) -&gt; &#123;</span><br><span class="line">            DishDto dishDto = new DishDto();</span><br><span class="line"></span><br><span class="line">            BeanUtils.copyProperties(item,dishDto);</span><br><span class="line"></span><br><span class="line">            Long categoryId = item.getCategoryId();//分类id</span><br><span class="line">            //根据id查询分类对象</span><br><span class="line">            Category category = categoryService.getById(categoryId);</span><br><span class="line"></span><br><span class="line">            if(category != null)&#123;</span><br><span class="line">                String categoryName = category.getName();</span><br><span class="line">                dishDto.setCategoryName(categoryName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //当前菜品的id</span><br><span class="line">            Long dishId = item.getId();</span><br><span class="line">            LambdaQueryWrapper&lt;DishFlavor&gt; lambdaQueryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">            lambdaQueryWrapper.eq(DishFlavor::getDishId,dishId);</span><br><span class="line">            //SQL:select * from dish_flavor where dish_id = ?</span><br><span class="line">            List&lt;DishFlavor&gt; dishFlavorList = dishFlavorService.list(lambdaQueryWrapper);</span><br><span class="line">            dishDto.setFlavors(dishFlavorList);</span><br><span class="line">            return dishDto;</span><br><span class="line">        &#125;).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        return R.success(dishDtoList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 根据条件查询分类数据</span><br><span class="line"> * @param category</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">@GetMapping(&quot;/list&quot;)</span><br><span class="line">public R&lt;List&lt;Category&gt;&gt; list(Category category) &#123;</span><br><span class="line">    //条件构造器</span><br><span class="line">    LambdaQueryWrapper&lt;Category&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">    //添加条件</span><br><span class="line">    queryWrapper.eq(category.getType() != null, Category::getType, category.getType());</span><br><span class="line">    //添加排序条件</span><br><span class="line">    queryWrapper.orderByAsc(Category::getSort).orderByDesc(Category::getUpdateTime);</span><br><span class="line"></span><br><span class="line">    List&lt;Category&gt; list = categoryService.list(queryWrapper);</span><br><span class="line">    return R.success(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据条件查询套餐数据</span><br><span class="line">     * @param setmeal</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @GetMapping(&quot;/list&quot;)</span><br><span class="line">    public R&lt;List&lt;Setmeal&gt;&gt; list(Setmeal setmeal)&#123;</span><br><span class="line">        LambdaQueryWrapper&lt;Setmeal&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">        queryWrapper.eq(setmeal.getCategoryId() != null,Setmeal::getCategoryId,setmeal.getCategoryId());</span><br><span class="line">        queryWrapper.eq(setmeal.getStatus() != null,Setmeal::getStatus,setmeal.getStatus());</span><br><span class="line">        queryWrapper.orderByDesc(Setmeal::getUpdateTime);</span><br><span class="line"></span><br><span class="line">        List&lt;Setmeal&gt; list = setmealService.list(queryWrapper);</span><br><span class="line"></span><br><span class="line">        return R.success(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>springboot - 外卖平台</tag>
        <tag>项目开发</tag>
        <tag>mybatis plus</tag>
        <tag>菜品展示</tag>
      </tags>
  </entry>
  <entry>
    <title>外卖管理平台购物车</title>
    <url>/2022/09/19/%E5%A4%96%E5%8D%96%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0%E8%B4%AD%E7%89%A9%E8%BD%A6/</url>
    <content><![CDATA[<h3 id="一、需求分析"><a href="#一、需求分析" class="headerlink" title="一、需求分析"></a>一、需求分析</h3><p>移动端用户可以将菜品或者套餐添加到购物车。对于菜品来说，如果设置了口味信息，则需要选择规格后才能加入购物车;对于套餐来说，可以直接点击将当前套餐加入购物车。在购物车中可以修改菜品和套餐的数量，也可以清空购物车。</p>
<span id="more"></span>
<h3 id="二、代码开发-梳理交互过程"><a href="#二、代码开发-梳理交互过程" class="headerlink" title="二、代码开发-梳理交互过程"></a>二、代码开发-梳理交互过程</h3><p>在开发代码之前，需要梳理一下购物车操作时前端页面和服务端的交互过程:</p>
<p>1、点击加入购物或者按钮+，页面发送ajax请求，请求服务端，将菜品或者套餐添加到购物车</p>
<p>2、点击购物车图标，页面发送ajax请求，请求服务端查询购物车中的菜品和套餐</p>
<p>3、点击清空购物车按钮，页面发送ajax请求，请求服务端来执行清空购物车操作</p>
<p>开发购物车功能，其实就是在服务端编写代码去处理前端页面发送的这3次请求即可。</p>
<h4 id="代码开发-准备工作"><a href="#代码开发-准备工作" class="headerlink" title="代码开发-准备工作"></a>代码开发-准备工作</h4><p>在开发业务功能前，先将需要用到的类和接口基本结构创建好:</p>
<ul>
<li>实体类ShoppingCart(直接从课程资料中导入即可)</li>
<li>Mapper接口ShoppingCartMapper</li>
<li>业务层接口ShoppingCartservice</li>
<li>业务层实现类ShoppingCartServicelmpl控制层 ShoppingcartController</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.controller;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;</span><br><span class="line">import com.itheima.reggie.common.BaseContext;</span><br><span class="line">import com.itheima.reggie.common.R;</span><br><span class="line">import com.itheima.reggie.entity.ShoppingCart;</span><br><span class="line">import com.itheima.reggie.service.ShoppingCartService;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line">import java.time.LocalDateTime;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 购物车</span><br><span class="line"> */</span><br><span class="line">@Slf4j</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/shoppingCart&quot;)</span><br><span class="line">public class ShoppingCartController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private ShoppingCartService shoppingCartService;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 添加购物车</span><br><span class="line">     * @param shoppingCart</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @PostMapping(&quot;/add&quot;)</span><br><span class="line">    public R&lt;ShoppingCart&gt; add(@RequestBody ShoppingCart shoppingCart)&#123;</span><br><span class="line">        log.info(&quot;购物车数据:&#123;&#125;&quot;,shoppingCart);</span><br><span class="line"></span><br><span class="line">        //设置用户id，指定当前是哪个用户的购物车数据</span><br><span class="line">        Long currentId = BaseContext.getCurrentId();</span><br><span class="line">        shoppingCart.setUserId(currentId);</span><br><span class="line"></span><br><span class="line">        Long dishId = shoppingCart.getDishId();</span><br><span class="line"></span><br><span class="line">        LambdaQueryWrapper&lt;ShoppingCart&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">        queryWrapper.eq(ShoppingCart::getUserId,currentId);</span><br><span class="line"></span><br><span class="line">        if(dishId != null)&#123;</span><br><span class="line">            //添加到购物车的是菜品</span><br><span class="line">            queryWrapper.eq(ShoppingCart::getDishId,dishId);</span><br><span class="line"></span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            //添加到购物车的是套餐</span><br><span class="line">            queryWrapper.eq(ShoppingCart::getSetmealId,shoppingCart.getSetmealId());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //查询当前菜品或者套餐是否在购物车中</span><br><span class="line">        //SQL:select * from shopping_cart where user_id = ? and dish_id/setmeal_id = ?</span><br><span class="line">        ShoppingCart cartServiceOne = shoppingCartService.getOne(queryWrapper);</span><br><span class="line"></span><br><span class="line">        if(cartServiceOne != null)&#123;</span><br><span class="line">            //如果已经存在，就在原来数量基础上加一</span><br><span class="line">            Integer number = cartServiceOne.getNumber();</span><br><span class="line">            cartServiceOne.setNumber(number + 1);</span><br><span class="line">            shoppingCartService.updateById(cartServiceOne);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            //如果不存在，则添加到购物车，数量默认就是一</span><br><span class="line">            shoppingCart.setNumber(1);</span><br><span class="line">            shoppingCart.setCreateTime(LocalDateTime.now());</span><br><span class="line">            shoppingCartService.save(shoppingCart);</span><br><span class="line">            cartServiceOne = shoppingCart;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return R.success(cartServiceOne);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 查看购物车</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @GetMapping(&quot;/list&quot;)</span><br><span class="line">    public R&lt;List&lt;ShoppingCart&gt;&gt; list()&#123;</span><br><span class="line">        log.info(&quot;查看购物车...&quot;);</span><br><span class="line"></span><br><span class="line">        LambdaQueryWrapper&lt;ShoppingCart&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">        queryWrapper.eq(ShoppingCart::getUserId,BaseContext.getCurrentId());</span><br><span class="line">        queryWrapper.orderByAsc(ShoppingCart::getCreateTime);</span><br><span class="line"></span><br><span class="line">        List&lt;ShoppingCart&gt; list = shoppingCartService.list(queryWrapper);</span><br><span class="line"></span><br><span class="line">        return R.success(list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 清空购物车</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @DeleteMapping(&quot;/clean&quot;)</span><br><span class="line">    public R&lt;String&gt; clean()&#123;</span><br><span class="line">        //SQL:delete from shopping_cart where user_id = ?</span><br><span class="line"></span><br><span class="line">        LambdaQueryWrapper&lt;ShoppingCart&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">        queryWrapper.eq(ShoppingCart::getUserId,BaseContext.getCurrentId());</span><br><span class="line"></span><br><span class="line">        shoppingCartService.remove(queryWrapper);</span><br><span class="line"></span><br><span class="line">        return R.success(&quot;清空购物车成功&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>springboot - 外卖平台</tag>
        <tag>项目开发</tag>
        <tag>mybatis plus</tag>
        <tag>购物车</tag>
      </tags>
  </entry>
  <entry>
    <title>外卖项目优化之使用git管理代码</title>
    <url>/2022/09/20/%E5%A4%96%E5%8D%96%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96%E4%B9%8B%E4%BD%BF%E7%94%A8git%E7%AE%A1%E7%90%86%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<h3 id="一、配置ssh公钥"><a href="#一、配置ssh公钥" class="headerlink" title="一、配置ssh公钥"></a>一、配置ssh公钥</h3><p>在原来项目的基础上做出优化，先将代码移至gitee好管理代码。</p>
<span id="more"></span>
<h4 id="先配置好ssh公钥"><a href="#先配置好ssh公钥" class="headerlink" title="先配置好ssh公钥"></a>先配置好ssh公钥</h4><ul>
<li>在GitBash界面按照如下命令生成公匙</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;xxxxx@xxxxx.com&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><p>按照提示完成三次回车，即可生成 ssh key。</p>
</li>
<li><p>通过查看 ~/.ssh/id_rsa.pub文件内容，获取到你的 public key。</p>
</li>
<li><p>复制id_rsa.pub文件中中生成的sshkey</p>
</li>
<li><p>在 [个人用户] -&gt; [设置] -&gt; [安全设置] -&gt; [ssh公匙] 页面添加sshkey</p>
</li>
<li><p>将复制的sshkey添加到公匙输入框中，设置标题，确定即可添加公匙</p>
<h4 id="验证ssh公匙"><a href="#验证ssh公匙" class="headerlink" title="验证ssh公匙"></a>验证ssh公匙</h4><p>输入<code>ssh -T git@gitee.com</code></p>
<p>首次使用需要确认并添加主机到本机SSH可信列表。<br> 若返回 Hi XXX! You’ve successfully authenticated, but Gitee.com does not provide shell access. 内容，则证明添加成功。</p>
</li>
</ul>
<h3 id="二、使用gitee管理代码"><a href="#二、使用gitee管理代码" class="headerlink" title="二、使用gitee管理代码"></a>二、使用gitee管理代码</h3><p><img src="https://i.p04e.com/baid/i/2022/09/20/l2.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/20/5kl7.png"><br><img src="https://i.p04e.com/baid/i/2022/09/20/sxj.png"><br><img src="https://i.p04e.com/baid/i/2022/09/20/t41.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在根目录下添加.gitgnore文件，因为不是所有的文件都需要上传到gitee</span><br><span class="line">.git</span><br><span class="line">logs</span><br><span class="line">rebel.xml</span><br><span class="line">target/</span><br><span class="line">!.mvn/wrapper/maven-wrapper.jar</span><br><span class="line">log.path_IS_UNDEFINED</span><br><span class="line">.DS_Store</span><br><span class="line">offline_user.md</span><br><span class="line"></span><br><span class="line">### STS ###</span><br><span class="line">.apt_generated</span><br><span class="line">.classpath</span><br><span class="line">.factorypath</span><br><span class="line">.project</span><br><span class="line">.settings</span><br><span class="line">.springBeans</span><br><span class="line"></span><br><span class="line">### IntelliJ IDEA ###</span><br><span class="line">.idea</span><br><span class="line">*.iws</span><br><span class="line">*.iml</span><br><span class="line">*.ipr</span><br><span class="line"></span><br><span class="line">### NetBeans ###</span><br><span class="line">nbproject/private/</span><br><span class="line">build/</span><br><span class="line">nbbuild/</span><br><span class="line">dist/</span><br><span class="line">nbdist/</span><br><span class="line">.nb-gradle/</span><br><span class="line">generatorConfig.xml</span><br><span class="line"></span><br><span class="line">### nacos ###</span><br><span class="line">third-party/nacos/derby.log</span><br><span class="line">third-party/nacos/data/</span><br><span class="line">third-party/nacos/work/</span><br><span class="line"></span><br><span class="line">file/</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://i.p04e.com/baid/i/2022/09/20/aqjg.png"><br><img src="https://i.p04e.com/baid/i/2022/09/20/7w1.png"><br><img src="https://i.p04e.com/baid/i/2022/09/20/1j7t.png"><br><img src="https://i.p04e.com/baid/i/2022/09/20/23809.png"><br><img src="https://i.p04e.com/baid/i/2022/09/20/7w9.png"><br><img src="https://i.p04e.com/baid/i/2022/09/20/1j9d.png"><br><img src="https://i.p04e.com/baid/i/2022/09/20/7w3.png"><br><img src="https://i.p04e.com/baid/i/2022/09/20/237q6.png"><br><img src="https://i.p04e.com/baid/i/2022/09/20/ar6a.png"><br><img src="https://i.p04e.com/baid/i/2022/09/20/1jaq.png"><br><img src="https://i.p04e.com/baid/i/2022/09/20/ar1g.png"></p>
]]></content>
      <tags>
        <tag>springboot - 外卖平台</tag>
        <tag>项目开发</tag>
        <tag>mybatis plus</tag>
        <tag>使用git管理代码</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>外卖项目优化之环境搭建</title>
    <url>/2022/09/20/%E5%A4%96%E5%8D%96%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96%E4%B9%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>外卖管理平台新增分类代码开发</title>
    <url>/2022/09/02/%E5%A4%96%E5%8D%96%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0%E6%96%B0%E5%A2%9E%E5%88%86%E7%B1%BB%E4%BB%A3%E7%A0%81%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h3 id="一、新增分类"><a href="#一、新增分类" class="headerlink" title="一、新增分类"></a>一、新增分类</h3><p>在开发代码之前，需要梳理一下整个程序的执行过程:</p>
<span id="more"></span>
<p>1、页面(backend/page/category/list.html)发送ajax请求，将新增分类窗口输入的数据以json形式提交到服务端</p>
<p>2、服务端Controller接收页面提交的数据并调用Service将数据进行保存</p>
<p>3、Service调用Mapper操作数据库，保存数据</p>
<p>可以先将大概的框架写出，后面在完善</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.entity;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.annotation.FieldFill;</span><br><span class="line">import com.baomidou.mybatisplus.annotation.IdType;</span><br><span class="line">import com.baomidou.mybatisplus.annotation.TableField;</span><br><span class="line">import com.baomidou.mybatisplus.annotation.TableId;</span><br><span class="line">import lombok.Data;</span><br><span class="line">import lombok.Getter;</span><br><span class="line">import lombok.Setter;</span><br><span class="line">import java.io.Serializable;</span><br><span class="line">import java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 分类</span><br><span class="line"> */</span><br><span class="line">@Data</span><br><span class="line">public class Category implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID = 1L;</span><br><span class="line"></span><br><span class="line">    private Long id;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //类型 1 菜品分类 2 套餐分类</span><br><span class="line">    private Integer type;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //分类名称</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //顺序</span><br><span class="line">    private Integer sort;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //创建时间</span><br><span class="line">    @TableField(fill = FieldFill.INSERT)</span><br><span class="line">    private LocalDateTime createTime;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //更新时间</span><br><span class="line">    @TableField(fill = FieldFill.INSERT_UPDATE)</span><br><span class="line">    private LocalDateTime updateTime;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //创建人</span><br><span class="line">    @TableField(fill = FieldFill.INSERT)</span><br><span class="line">    private Long createUser;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //修改人</span><br><span class="line">    @TableField(fill = FieldFill.INSERT_UPDATE)</span><br><span class="line">    private Long updateUser;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.mapper;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.core.mapper.BaseMapper;</span><br><span class="line">import com.itheima.reggie.entity.Category;</span><br><span class="line">import org.apache.ibatis.annotations.Mapper;</span><br><span class="line"></span><br><span class="line">@Mapper</span><br><span class="line">public interface CategoryMapper extends BaseMapper&lt;Category&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.service;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.extension.service.IService;</span><br><span class="line">import com.itheima.reggie.entity.Category;</span><br><span class="line"></span><br><span class="line">public interface CategoryService extends IService&lt;Category&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.service.impl;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;</span><br><span class="line">import com.itheima.reggie.entity.Category;</span><br><span class="line">import com.itheima.reggie.mapper.CategoryMapper;</span><br><span class="line">import com.itheima.reggie.service.CategoryService;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class CategoryServiceImpl extends ServiceImpl&lt;CategoryMapper, Category&gt; implements CategoryService &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.controller;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import com.itheima.reggie.service.CategoryService;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/category&quot;)</span><br><span class="line">public class CategoryController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private CategoryService categoryService;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到新增菜品分类和新增套餐分类请求的服务端地址和提交的json数据结构相同，所以服务端只需要提供一个方法统一处理即可：</p>
<p><img src="https://i.p04e.com/baid/i/2022/09/02/5955.png"></p>
<h3 id="二、分类信息分页查询"><a href="#二、分类信息分页查询" class="headerlink" title="二、分类信息分页查询"></a>二、分类信息分页查询</h3><h4 id="1、需求分析"><a href="#1、需求分析" class="headerlink" title="1、需求分析"></a>1、需求分析</h4><p>系统中的分类很多的时候，如果在一个页面中全部展示出来会显得比较乱，不便于查看，所以一般的系统中都会以分页的方式来展示列表数据。</p>
<h4 id="2、代码开发"><a href="#2、代码开发" class="headerlink" title="2、代码开发"></a>2、代码开发</h4><p>在开发代码之前，需要梳理一下整个程序的执行过程:</p>
<p>1、页面发送ajax请求，将分页查询参数(page.pageSize)提交到服务端</p>
<p>2、服务端Controller接收页面提交的数据并调用Service查询数据</p>
<p>3、Service调用Mapper操作数据库，查询分页数据</p>
<p>4、Controller将查询到的分页数据响应给页面</p>
<p>5、页面接收到分页数据并通过Elementul的Table组件展示到页面上</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.controller;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;</span><br><span class="line">import com.baomidou.mybatisplus.extension.plugins.pagination.Page;</span><br><span class="line">import com.itheima.reggie.common.R;</span><br><span class="line">import com.itheima.reggie.entity.Category;</span><br><span class="line">import com.itheima.reggie.service.CategoryService;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 分类管理</span><br><span class="line"> */</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/category&quot;)</span><br><span class="line">@Slf4j</span><br><span class="line">public class CategoryController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private CategoryService categoryService;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 新增分类</span><br><span class="line">     * @param category</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @PostMapping</span><br><span class="line">    public R&lt;String&gt; save(@RequestBody Category category)&#123;</span><br><span class="line">        log.info(&quot;category:&#123;&#125;&quot;,category);</span><br><span class="line">        categoryService.save(category);</span><br><span class="line">        return R.success(&quot;新增分类成功&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 分页查询</span><br><span class="line">     * @param page</span><br><span class="line">     * @param pageSize</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @GetMapping(&quot;/page&quot;)</span><br><span class="line">    public R&lt;Page&gt; page(int page,int pageSize)&#123;</span><br><span class="line">        //分页构造器</span><br><span class="line">        Page&lt;Category&gt; pageInfo = new Page&lt;&gt;(page,pageSize);</span><br><span class="line">        //条件构造器</span><br><span class="line">        LambdaQueryWrapper&lt;Category&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">        //添加排序条件，根据sort进行排序</span><br><span class="line">        queryWrapper.orderByAsc(Category::getSort);</span><br><span class="line"></span><br><span class="line">        //分页查询</span><br><span class="line">        categoryService.page(pageInfo,queryWrapper);</span><br><span class="line">        return R.success(pageInfo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最后就可以显示出来了。</p>
<p><img src="https://i.p04e.com/baid/i/2022/09/02/5cgu.png"></p>
<h3 id="三、删除分类"><a href="#三、删除分类" class="headerlink" title="三、删除分类"></a>三、删除分类</h3><h4 id="1、需求分析-1"><a href="#1、需求分析-1" class="headerlink" title="1、需求分析"></a>1、需求分析</h4><p>在分类管理列表页面，可以对某个分类进行删除操作。需要注意的是当分类关联了菜品或者套餐时，此分类不允许删除。</p>
<h4 id="2、代码开发-1"><a href="#2、代码开发-1" class="headerlink" title="2、代码开发"></a>2、代码开发</h4><p>在开发代码之前，需要梳理一下整个程序的执行过程:</p>
<p>1、页面发送ajax请求，将参数(id)提交到服务端</p>
<p>2、服务端Controller接收页面提交的数据并调用Service删除数据</p>
<p>3、Service调用Mapper操作数据库</p>
<p><img src="https://i.p04e.com/baid/i/2022/09/03/ycuv.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 根据id删除分类</span><br><span class="line"> * @param id</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">@DeleteMapping</span><br><span class="line">public R&lt;String&gt; delete(Long id) &#123;</span><br><span class="line">    log.info(&quot;删除分类，id为：&#123;&#125;&quot;,id);</span><br><span class="line"></span><br><span class="line">    categoryService.removeById(id);</span><br><span class="line">    return R.success(&quot;分类信息删除成功&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3、功能完善"><a href="#3、功能完善" class="headerlink" title="3、功能完善"></a>3、功能完善</h4><p>前面我们已经实现了根据id删除分类的功能，但是并没有检查删除的分类是否关联了菜品或者套餐，所以我们需要进行功能完善。</p>
<p>要完善分类删除功能，需要先准备基础的类和接口:1、实体类Dish和Setmeal (从课程资料中复制即可)</p>
<p>2、Mapper接口DishMapper和SetmealMapper</p>
<p>3、Service接口DishService和SetmealService</p>
<p>4、Service实现类DishServicelmpl和SetmealServicelmpl</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.entity;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.annotation.FieldFill;</span><br><span class="line">import com.baomidou.mybatisplus.annotation.IdType;</span><br><span class="line">import com.baomidou.mybatisplus.annotation.TableField;</span><br><span class="line">import com.baomidou.mybatisplus.annotation.TableId;</span><br><span class="line">import lombok.Data;</span><br><span class="line">import java.io.Serializable;</span><br><span class="line">import java.math.BigDecimal;</span><br><span class="line">import java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> 菜品</span><br><span class="line"> */</span><br><span class="line">@Data</span><br><span class="line">public class Dish implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID = 1L;</span><br><span class="line"></span><br><span class="line">    private Long id;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //菜品名称</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //菜品分类id</span><br><span class="line">    private Long categoryId;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //菜品价格</span><br><span class="line">    private BigDecimal price;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //商品码</span><br><span class="line">    private String code;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //图片</span><br><span class="line">    private String image;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //描述信息</span><br><span class="line">    private String description;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //0 停售 1 起售</span><br><span class="line">    private Integer status;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //顺序</span><br><span class="line">    private Integer sort;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @TableField(fill = FieldFill.INSERT)</span><br><span class="line">    private LocalDateTime createTime;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @TableField(fill = FieldFill.INSERT_UPDATE)</span><br><span class="line">    private LocalDateTime updateTime;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @TableField(fill = FieldFill.INSERT)</span><br><span class="line">    private Long createUser;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @TableField(fill = FieldFill.INSERT_UPDATE)</span><br><span class="line">    private Long updateUser;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //是否删除</span><br><span class="line">    private Integer isDeleted;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.entity;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.annotation.FieldFill;</span><br><span class="line">import com.baomidou.mybatisplus.annotation.IdType;</span><br><span class="line">import com.baomidou.mybatisplus.annotation.TableField;</span><br><span class="line">import com.baomidou.mybatisplus.annotation.TableId;</span><br><span class="line">import lombok.Data;</span><br><span class="line">import java.io.Serializable;</span><br><span class="line">import java.math.BigDecimal;</span><br><span class="line">import java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 套餐</span><br><span class="line"> */</span><br><span class="line">@Data</span><br><span class="line">public class Setmeal implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID = 1L;</span><br><span class="line"></span><br><span class="line">    private Long id;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //分类id</span><br><span class="line">    private Long categoryId;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //套餐名称</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //套餐价格</span><br><span class="line">    private BigDecimal price;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //状态 0:停用 1:启用</span><br><span class="line">    private Integer status;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //编码</span><br><span class="line">    private String code;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //描述信息</span><br><span class="line">    private String description;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //图片</span><br><span class="line">    private String image;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @TableField(fill = FieldFill.INSERT)</span><br><span class="line">    private LocalDateTime createTime;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @TableField(fill = FieldFill.INSERT_UPDATE)</span><br><span class="line">    private LocalDateTime updateTime;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @TableField(fill = FieldFill.INSERT)</span><br><span class="line">    private Long createUser;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @TableField(fill = FieldFill.INSERT_UPDATE)</span><br><span class="line">    private Long updateUser;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //是否删除</span><br><span class="line">    private Integer isDeleted;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.mapper;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.core.mapper.BaseMapper;</span><br><span class="line">import com.itheima.reggie.entity.Dish;</span><br><span class="line">import org.apache.ibatis.annotations.Mapper;</span><br><span class="line"></span><br><span class="line">@Mapper</span><br><span class="line">public interface DishMapper extends BaseMapper&lt;Dish&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.mapper;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.core.mapper.BaseMapper;</span><br><span class="line">import com.itheima.reggie.entity.Setmeal;</span><br><span class="line">import org.apache.ibatis.annotations.Mapper;</span><br><span class="line"></span><br><span class="line">@Mapper</span><br><span class="line">public interface SetmealMapper extends BaseMapper&lt;Setmeal&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.service;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.extension.service.IService;</span><br><span class="line">import com.itheima.reggie.entity.Dish;</span><br><span class="line"></span><br><span class="line">public interface DishService extends IService&lt;Dish&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.service;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.extension.service.IService;</span><br><span class="line">import com.itheima.reggie.entity.Setmeal;</span><br><span class="line"></span><br><span class="line">public interface SetmealService extends IService&lt;Setmeal&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.service.impl;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;</span><br><span class="line">import com.itheima.reggie.entity.Dish;</span><br><span class="line">import com.itheima.reggie.mapper.DishMapper;</span><br><span class="line">import com.itheima.reggie.service.DishService;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">@Slf4j</span><br><span class="line">public class DishServiceImpl extends ServiceImpl&lt;DishMapper, Dish&gt; implements DishService &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.service.impl;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;</span><br><span class="line">import com.itheima.reggie.entity.Setmeal;</span><br><span class="line">import com.itheima.reggie.mapper.SetmealMapper;</span><br><span class="line">import com.itheima.reggie.service.SetmealService;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">@Slf4j</span><br><span class="line">public class SetmealServiceImpl extends ServiceImpl&lt;SetmealMapper, Setmeal&gt; implements SetmealService &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.controller;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;</span><br><span class="line">import com.baomidou.mybatisplus.extension.plugins.pagination.Page;</span><br><span class="line">import com.itheima.reggie.common.R;</span><br><span class="line">import com.itheima.reggie.entity.Category;</span><br><span class="line">import com.itheima.reggie.service.CategoryService;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 分类管理</span><br><span class="line"> */</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/category&quot;)</span><br><span class="line">@Slf4j</span><br><span class="line">public class CategoryController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private CategoryService categoryService;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 新增分类</span><br><span class="line">     * @param category</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @PostMapping</span><br><span class="line">    public R&lt;String&gt; save(@RequestBody Category category)&#123;</span><br><span class="line">        log.info(&quot;category:&#123;&#125;&quot;,category);</span><br><span class="line">        categoryService.save(category);</span><br><span class="line">        return R.success(&quot;新增分类成功&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 分页查询</span><br><span class="line">     * @param page</span><br><span class="line">     * @param pageSize</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @GetMapping(&quot;/page&quot;)</span><br><span class="line">    public R&lt;Page&gt; page(int page,int pageSize)&#123;</span><br><span class="line">        //分页构造器</span><br><span class="line">        Page&lt;Category&gt; pageInfo = new Page&lt;&gt;(page,pageSize);</span><br><span class="line">        //条件构造器</span><br><span class="line">        LambdaQueryWrapper&lt;Category&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">        //添加排序条件，根据sort进行排序</span><br><span class="line">        queryWrapper.orderByAsc(Category::getSort);</span><br><span class="line"></span><br><span class="line">        //分页查询</span><br><span class="line">        categoryService.page(pageInfo,queryWrapper);</span><br><span class="line">        return R.success(pageInfo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据id删除分类</span><br><span class="line">     * @param id</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @DeleteMapping</span><br><span class="line">    public R&lt;String&gt; delete(Long id) &#123;</span><br><span class="line">        log.info(&quot;删除分类，id为：&#123;&#125;&quot;,id);</span><br><span class="line"></span><br><span class="line">        //categoryService.removeById(id);</span><br><span class="line">        categoryService.remove(id);</span><br><span class="line">        return R.success(&quot;分类信息删除成功&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.service.impl;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;</span><br><span class="line">import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;</span><br><span class="line">import com.itheima.reggie.common.CustomException;</span><br><span class="line">import com.itheima.reggie.entity.Category;</span><br><span class="line">import com.itheima.reggie.entity.Dish;</span><br><span class="line">import com.itheima.reggie.entity.Setmeal;</span><br><span class="line">import com.itheima.reggie.mapper.CategoryMapper;</span><br><span class="line">import com.itheima.reggie.service.CategoryService;</span><br><span class="line">import com.itheima.reggie.service.DishService;</span><br><span class="line">import com.itheima.reggie.service.SetmealService;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class CategoryServiceImpl extends ServiceImpl&lt;CategoryMapper, Category&gt; implements CategoryService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private DishService dishService;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private SetmealService setmealService;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据id删除分类,删除之前需要进行判断</span><br><span class="line">     * @param id</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void remove(Long id) &#123;</span><br><span class="line">        LambdaQueryWrapper&lt;Dish&gt; dishLambdaQueryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">        //添加查询条件，根据分类id进行查询</span><br><span class="line">        dishLambdaQueryWrapper.eq(Dish::getCategoryId, id);</span><br><span class="line">        int count1 = dishService.count(dishLambdaQueryWrapper);</span><br><span class="line">        //查询当前分类是否关联了菜品，如果已经关联，抛出一个业务异常</span><br><span class="line">        if (count1 &gt; 0) &#123;</span><br><span class="line">            //已经关联菜品，抛出一个业务异常</span><br><span class="line">            throw new CustomException(&quot;当前分类下关联了分类菜品，不能删除&quot;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //查询当前分类是否关联了套餐，如果已经关联，抛出一个业务异常</span><br><span class="line">        LambdaQueryWrapper&lt;Setmeal&gt; setmealLambdaQueryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">        int count2 = setmealService.count(setmealLambdaQueryWrapper);</span><br><span class="line">        if (count2 &gt; 0) &#123;</span><br><span class="line">            //已经关联套餐，抛出一个业务异常</span><br><span class="line">            throw new CustomException(&quot;当前分类下关联了套餐，不能删除&quot;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //正常删除分类</span><br><span class="line">        super.removeById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.common;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 自定义业务异常</span><br><span class="line"> */</span><br><span class="line">public class CustomException extends RuntimeException&#123;</span><br><span class="line">    public CustomException(String message) &#123;</span><br><span class="line">        super(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.common;</span><br><span class="line"></span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line">import org.springframework.web.bind.annotation.ControllerAdvice;</span><br><span class="line">import org.springframework.web.bind.annotation.ExceptionHandler;</span><br><span class="line">import org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">import java.sql.SQLIntegrityConstraintViolationException;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 全局异常处理</span><br><span class="line"> */</span><br><span class="line">@ControllerAdvice(annotations = &#123;RestController.class, Controller.class&#125;)</span><br><span class="line">@ResponseBody</span><br><span class="line">@Slf4j</span><br><span class="line">public class GlobalExceptionHandler &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 异常处理方法</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @ExceptionHandler(SQLIntegrityConstraintViolationException.class)</span><br><span class="line">    public R&lt;String&gt; exceptionHandler(SQLIntegrityConstraintViolationException ex)&#123;</span><br><span class="line">        log.error(ex.getMessage());</span><br><span class="line"></span><br><span class="line">        if(ex.getMessage().contains(&quot;Duplicate entry&quot;))&#123;</span><br><span class="line">            String[] split = ex.getMessage().split(&quot; &quot;);</span><br><span class="line">            String msg = split[2] + &quot;已存在&quot;;</span><br><span class="line">            return R.error(msg);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return R.error(&quot;未知错误&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 异常处理方法</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @ExceptionHandler(CustomException.class)</span><br><span class="line">    public R&lt;String&gt; exceptionHandler(CustomException ex)&#123;</span><br><span class="line">        log.error(ex.getMessage());</span><br><span class="line"></span><br><span class="line">        return R.error(ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="四、修改分类"><a href="#四、修改分类" class="headerlink" title="四、修改分类"></a>四、修改分类</h3><h4 id="1、需求分析-2"><a href="#1、需求分析-2" class="headerlink" title="1、需求分析"></a>1、需求分析</h4><p>在分类管理列表页面点击修改按钮，弹出修改窗口，在修改窗口回显分类信息并进行修改，最后点击确定按钮完成修改操作</p>
<h4 id="2、代码开发-2"><a href="#2、代码开发-2" class="headerlink" title="2、代码开发"></a>2、代码开发</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 根据id修改分类信息</span><br><span class="line"> * @param category</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">@PutMapping</span><br><span class="line">public R&lt;String&gt; update(@RequestBody Category category)&#123;</span><br><span class="line">    log.info(&quot;修改分类信息：&#123;&#125;&quot;,category);</span><br><span class="line"></span><br><span class="line">    categoryService.updateById(category);</span><br><span class="line"></span><br><span class="line">    return R.success(&quot;修改分类信息成功&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>springboot - 外卖平台</tag>
        <tag>项目开发</tag>
        <tag>mybatis plus</tag>
        <tag>新增分类</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker实用篇</title>
    <url>/2022/11/22/Docker%E5%AE%9E%E7%94%A8%E7%AF%87/</url>
    <content><![CDATA[<h1 id="Docker实用篇"><a href="#Docker实用篇" class="headerlink" title="Docker实用篇"></a>Docker实用篇</h1><span id="more"></span>
<h1 id="0-学习目标"><a href="#0-学习目标" class="headerlink" title="0.学习目标"></a>0.学习目标</h1><h1 id="1-初识Docker"><a href="#1-初识Docker" class="headerlink" title="1.初识Docker"></a>1.初识Docker</h1><h2 id="1-1-什么是Docker"><a href="#1-1-什么是Docker" class="headerlink" title="1.1.什么是Docker"></a>1.1.什么是Docker</h2><p>微服务虽然具备各种各样的优势，但服务的拆分通用给部署带来了很大的麻烦。</p>
<ul>
<li>分布式系统中，依赖的组件非常多，不同组件之间部署时往往会产生一些冲突。</li>
<li>在数百上千台服务中重复部署，环境不一定一致，会遇到各种问题</li>
</ul>
<h3 id="1-1-1-应用部署的环境问题"><a href="#1-1-1-应用部署的环境问题" class="headerlink" title="1.1.1.应用部署的环境问题"></a>1.1.1.应用部署的环境问题</h3><p>大型项目组件较多，运行环境也较为复杂，部署时会碰到一些问题：</p>
<ul>
<li>依赖关系复杂，容易出现兼容性问题</li>
<li>开发、测试、生产环境有差异</li>
</ul>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/voq.png"></p>
<p>例如一个项目中，部署时需要依赖于node.js、Redis、RabbitMQ、MySQL等，这些服务部署时所需要的函数库、依赖项各不相同，甚至会有冲突。给部署带来了极大的困难。</p>
<h3 id="1-1-2-Docker解决依赖兼容问题"><a href="#1-1-2-Docker解决依赖兼容问题" class="headerlink" title="1.1.2.Docker解决依赖兼容问题"></a>1.1.2.Docker解决依赖兼容问题</h3><p>而Docker确巧妙的解决了这些问题，Docker是如何实现的呢？</p>
<p>Docker为了解决依赖的兼容问题的，采用了两个手段：</p>
<ul>
<li>将应用的Libs（函数库）、Deps（依赖）、配置与应用一起打包</li>
<li>将每个应用放到一个隔离<strong>容器</strong>去运行，避免互相干扰</li>
</ul>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/vjp.png"></p>
<p>这样打包好的应用包中，既包含应用本身，也保护应用所需要的Libs、Deps，无需再操作系统上安装这些，自然就不存在不同应用之间的兼容问题了。</p>
<p>虽然解决了不同应用的兼容问题，但是开发、测试等环境会存在差异，操作系统版本也会有差异，怎么解决这些问题呢？</p>
<h3 id="1-1-3-Docker解决操作系统环境差异"><a href="#1-1-3-Docker解决操作系统环境差异" class="headerlink" title="1.1.3.Docker解决操作系统环境差异"></a>1.1.3.Docker解决操作系统环境差异</h3><p>要解决不同操作系统环境差异问题，必须先了解操作系统结构。以一个Ubuntu操作系统为例，结构如下：</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/66x0.png"></p>
<p>结构包括：</p>
<ul>
<li>计算机硬件：例如CPU、内存、磁盘等</li>
<li>系统内核：所有Linux发行版的内核都是Linux，例如CentOS、Ubuntu、Fedora等。内核可以与计算机硬件交互，对外提供<strong>内核指令</strong>，用于操作计算机硬件。</li>
<li>系统应用：操作系统本身提供的应用、函数库。这些函数库是对内核指令的封装，使用更加方便。</li>
</ul>
<p>应用于计算机交互的流程如下：</p>
<p>1）应用调用操作系统应用（函数库），实现各种功能</p>
<p>2）系统函数库是对内核指令集的封装，会调用内核指令</p>
<p>3）内核指令操作计算机硬件</p>
<p>Ubuntu和CentOSpringBoot都是基于Linux内核，无非是系统应用不同，提供的函数库有差异：</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/67g7.png"></p>
<p>此时，如果将一个Ubuntu版本的MySQL应用安装到CentOS系统，MySQL在调用Ubuntu函数库时，会发现找不到或者不匹配，就会报错了：</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/w0g.png"></p>
<p>Docker如何解决不同系统环境的问题？</p>
<ul>
<li>Docker将用户程序与所需要调用的系统(比如Ubuntu)函数库一起打包</li>
<li>Docker运行到不同操作系统时，直接基于打包的函数库，借助于操作系统的Linux内核来运行</li>
</ul>
<p>如图：</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/67vy.png"></p>
<h3 id="1-1-4-小结"><a href="#1-1-4-小结" class="headerlink" title="1.1.4.小结"></a>1.1.4.小结</h3><p>Docker如何解决大型项目依赖关系复杂，不同组件依赖的兼容性问题？</p>
<ul>
<li>Docker允许开发中将应用、依赖、函数库、配置一起<strong>打包</strong>，形成可移植镜像</li>
<li>Docker应用运行在容器中，使用沙箱机制，相互<strong>隔离</strong></li>
</ul>
<p>Docker如何解决开发、测试、生产环境有差异的问题？</p>
<ul>
<li>Docker镜像中包含完整运行环境，包括系统函数库，仅依赖系统的Linux内核，因此可以在任意Linux操作系统上运行</li>
</ul>
<p>Docker是一个快速交付应用、运行应用的技术，具备下列优势：</p>
<ul>
<li>可以将程序及其依赖、运行环境一起打包为一个镜像，可以迁移到任意Linux操作系统</li>
<li>运行时利用沙箱机制形成隔离容器，各个应用互不干扰</li>
<li>启动、移除都可以通过一行命令完成，方便快捷</li>
</ul>
<h2 id="1-2-Docker和虚拟机的区别"><a href="#1-2-Docker和虚拟机的区别" class="headerlink" title="1.2.Docker和虚拟机的区别"></a>1.2.Docker和虚拟机的区别</h2><p>Docker可以让一个应用在任何操作系统中非常方便的运行。而以前我们接触的虚拟机，也能在一个操作系统中，运行另外一个操作系统，保护系统中的任何应用。</p>
<p>两者有什么差异呢？</p>
<p><strong>虚拟机</strong>（virtual machine）是在操作系统中<strong>模拟</strong>硬件设备，然后运行另一个操作系统，比如在 Windows 系统里面运行 Ubuntu 系统，这样就可以运行任意的Ubuntu应用了。</p>
<p><strong>Docker</strong>仅仅是封装函数库，并没有模拟完整的操作系统，如图：</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/672v.png"></p>
<p>对比来看：</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/vvg.png"></p>
<p>小结：</p>
<p>Docker和虚拟机的差异：</p>
<ul>
<li>docker是一个系统进程；虚拟机是在操作系统中的操作系统</li>
<li>docker体积小、启动速度快、性能好；虚拟机体积大、启动速度慢、性能一般</li>
</ul>
<h2 id="1-3-Docker架构"><a href="#1-3-Docker架构" class="headerlink" title="1.3.Docker架构"></a>1.3.Docker架构</h2><h3 id="1-3-1-镜像和容器"><a href="#1-3-1-镜像和容器" class="headerlink" title="1.3.1.镜像和容器"></a>1.3.1.镜像和容器</h3><p>Docker中有几个重要的概念：</p>
<p><strong>镜像（Image）</strong>：Docker将应用程序及其所需的依赖、函数库、环境、配置等文件打包在一起，称为镜像。</p>
<p><strong>容器（Container）</strong>：镜像中的应用程序运行后形成的进程就是<strong>容器</strong>，只是Docker会给容器进程做隔离，对外不可见。</p>
<p>一切应用最终都是代码组成，都是硬盘中的一个个的字节形成的<strong>文件</strong>。只有运行时，才会加载到内存，形成进程。</p>
<p>而<strong>镜像</strong>，就是把一个应用在硬盘上的文件、及其运行环境、部分系统函数库文件一起打包形成的文件包。这个文件包是只读的。</p>
<p><strong>容器</strong>呢，就是将这些文件中编写的程序、函数加载到内存中允许，形成进程，只不过要隔离起来。因此一个镜像可以启动多次，形成多个容器进程。</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/8prb.png"></p>
<p>例如你下载了一个QQ，如果我们将QQ在磁盘上的运行<strong>文件</strong>及其运行的操作系统依赖打包，形成QQ镜像。然后你可以启动多次，双开、甚至三开QQ，跟多个妹子聊天。</p>
<h3 id="1-3-2-DockerHub"><a href="#1-3-2-DockerHub" class="headerlink" title="1.3.2.DockerHub"></a>1.3.2.DockerHub</h3><p>开源应用程序非常多，打包这些应用往往是重复的劳动。为了避免这些重复劳动，人们就会将自己打包的应用镜像，例如Redis、MySQL镜像放到网络上，共享使用，就像GitHub的代码共享一样。</p>
<ul>
<li>DockerHub：DockerHub是一个官方的Docker镜像的托管平台。这样的平台称为Docker Registry。</li>
<li>国内也有类似于DockerHub 的公开服务，比如 <a href="https://c.163yun.com/hub">网易云镜像服务</a>、<a href="https://cr.console.aliyun.com/">阿里云镜像库</a>等。</li>
</ul>
<p>我们一方面可以将自己的镜像共享到DockerHub，另一方面也可以从DockerHub拉取镜像：</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/18vy.png"></p>
<h3 id="1-3-3-Docker架构"><a href="#1-3-3-Docker架构" class="headerlink" title="1.3.3.Docker架构"></a>1.3.3.Docker架构</h3><p>我们要使用Docker来操作镜像、容器，就必须要安装Docker。</p>
<p>Docker是一个CS架构的程序，由两部分组成：</p>
<ul>
<li>服务端(server)：Docker守护进程，负责处理Docker指令，管理镜像、容器等</li>
<li>客户端(client)：通过命令或RestAPI向Docker服务端发送指令。可以在本地或远程向服务端发送指令。</li>
</ul>
<p>如图：</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/1p8x0.png"></p>
<h3 id="1-3-4-小结"><a href="#1-3-4-小结" class="headerlink" title="1.3.4.小结"></a>1.3.4.小结</h3><p>镜像：</p>
<ul>
<li>将应用程序及其依赖、环境、配置打包在一起</li>
</ul>
<p>容器：</p>
<ul>
<li>镜像运行起来就是容器，一个镜像可以运行多个容器</li>
</ul>
<p>Docker结构：</p>
<ul>
<li>服务端：接收命令或远程请求，操作镜像或容器</li>
<li>客户端：发送命令或者请求到Docker服务端</li>
</ul>
<p>DockerHub：</p>
<ul>
<li>一个镜像托管的服务器，类似的还有阿里云镜像服务，统称为DockerRegistry</li>
</ul>
<h2 id="1-4-安装Docker"><a href="#1-4-安装Docker" class="headerlink" title="1.4.安装Docker"></a>1.4.安装Docker</h2><p>企业部署一般都是采用Linux操作系统，而其中又数CentOS发行版占比最多，因此我们在CentOS下安装Docker。</p>
<h1 id="2-Docker的基本操作"><a href="#2-Docker的基本操作" class="headerlink" title="2.Docker的基本操作"></a>2.Docker的基本操作</h1><h2 id="2-1-镜像操作"><a href="#2-1-镜像操作" class="headerlink" title="2.1.镜像操作"></a>2.1.镜像操作</h2><h3 id="2-1-1-镜像名称"><a href="#2-1-1-镜像名称" class="headerlink" title="2.1.1.镜像名称"></a>2.1.1.镜像名称</h3><p>首先来看下镜像的名称组成：</p>
<ul>
<li>镜名称一般分两部分组成：[repository]:[tag]。</li>
<li>在没有指定tag时，默认是latest，代表最新版本的镜像</li>
</ul>
<p>如图：</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/8r3w.png"></p>
<p>这里的mysql就是repository，5.7就是tag，合一起就是镜像名称，代表5.7版本的MySQL镜像。</p>
<h3 id="2-1-2-镜像命令"><a href="#2-1-2-镜像命令" class="headerlink" title="2.1.2.镜像命令"></a>2.1.2.镜像命令</h3><p>常见的镜像操作命令如图：</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/190c.png"></p>
<h3 id="2-1-3-案例1-拉取、查看镜像"><a href="#2-1-3-案例1-拉取、查看镜像" class="headerlink" title="2.1.3.案例1-拉取、查看镜像"></a>2.1.3.案例1-拉取、查看镜像</h3><p>需求：从DockerHub中拉取一个nginx镜像并查看</p>
<p>1）首先去镜像仓库搜索nginx镜像，比如<a href="https://hub.docker.com/">DockerHub</a>:</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/6fi.png"></p>
<p>2）根据查看到的镜像名称，拉取自己需要的镜像，通过命令：docker pull nginx</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/191y.png"></p>
<p>3）通过命令：docker images 查看拉取到的镜像</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/1v2hq.png"></p>
<h3 id="2-1-4-案例2-保存、导入镜像"><a href="#2-1-4-案例2-保存、导入镜像" class="headerlink" title="2.1.4.案例2-保存、导入镜像"></a>2.1.4.案例2-保存、导入镜像</h3><p>需求：利用docker save将nginx镜像导出磁盘，然后再通过load加载回来</p>
<p>1）利用docker xx —help命令查看docker save和docker load的语法</p>
<p>例如，查看save命令用法，可以输入命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker save --<span class="built_in">help</span></span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/9l3f.png"></p>
<p>命令格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker save -o [保存的目标文件名称] [镜像名称]</span><br></pre></td></tr></table></figure>
<p>2）使用docker save导出镜像到磁盘 </p>
<p>运行命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker save -o nginx.tar nginx:latest</span><br></pre></td></tr></table></figure>
<p>结果如图：</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/9l58.png"></p>
<p>3）使用docker load加载镜像</p>
<p>先删除本地的nginx镜像：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker rmi nginx:latest</span><br></pre></td></tr></table></figure>
<p>然后运行命令，加载本地文件：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker load -i nginx.tar</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/9lam.png"></p>
<h3 id="2-1-5-练习"><a href="#2-1-5-练习" class="headerlink" title="2.1.5.练习"></a>2.1.5.练习</h3><p>需求：去DockerHub搜索并拉取一个Redis镜像</p>
<p>目标：</p>
<p>1）去DockerHub搜索Redis镜像</p>
<p>2）查看Redis镜像的名称和版本</p>
<p>3）利用docker pull命令拉取镜像</p>
<p>4）利用docker save命令将 redis:latest打包为一个redis.tar包</p>
<p>5）利用docker rmi 删除本地的redis:latest</p>
<p>6）利用docker load 重新加载 redis.tar文件</p>
<h2 id="2-2-容器操作"><a href="#2-2-容器操作" class="headerlink" title="2.2.容器操作"></a>2.2.容器操作</h2><h3 id="2-2-1-容器相关命令"><a href="#2-2-1-容器相关命令" class="headerlink" title="2.2.1.容器相关命令"></a>2.2.1.容器相关命令</h3><p>容器操作的命令如图：</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/9lcs.png"></p>
<p>容器保护三个状态：</p>
<ul>
<li>运行：进程正常运行</li>
<li>暂停：进程暂停，CPU不再运行，并不释放内存</li>
<li>停止：进程终止，回收进程占用的内存、CPU等资源</li>
</ul>
<p>其中：</p>
<ul>
<li>docker run：创建并运行一个容器，处于运行状态</li>
<li>docker pause：让一个运行的容器暂停</li>
<li>docker unpause：让一个容器从暂停状态恢复运行</li>
<li>docker stop：停止一个运行的容器</li>
<li>docker start：让一个停止的容器再次运行</li>
<li>docker rm：删除一个容器</li>
</ul>
<h3 id="2-2-2-案例-创建并运行一个容器"><a href="#2-2-2-案例-创建并运行一个容器" class="headerlink" title="2.2.2.案例-创建并运行一个容器"></a>2.2.2.案例-创建并运行一个容器</h3><p>创建并运行nginx容器的命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run --name containerName -p 80:80 -d nginx</span><br></pre></td></tr></table></figure>
<p>命令解读：</p>
<ul>
<li>docker run ：创建并运行一个容器</li>
<li>—name : 给容器起一个名字，比如叫做mn</li>
<li>-p ：将宿主机端口与容器端口映射，冒号左侧是宿主机端口，右侧是容器端口</li>
<li>-d：后台运行容器</li>
<li>nginx：镜像名称，例如nginx</li>
</ul>
<p>这里的<code>-p</code>参数，是将容器端口映射到宿主机端口。</p>
<p>默认情况下，容器是隔离环境，我们直接访问宿主机的80端口，肯定访问不到容器中的nginx。</p>
<p>现在，将容器的80与宿主机的80关联起来，当我们访问宿主机的80端口时，就会被映射到容器的80，这样就能访问到nginx了：</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/d25l1.png"></p>
<h3 id="2-2-3-案例-进入容器，修改文件"><a href="#2-2-3-案例-进入容器，修改文件" class="headerlink" title="2.2.3.案例-进入容器，修改文件"></a>2.2.3.案例-进入容器，修改文件</h3><p><strong>需求</strong>：进入Nginx容器，修改HTML文件内容，添加“传智教育欢迎您”</p>
<p><strong>提示</strong>：进入容器要用到docker exec命令。</p>
<p><strong>步骤</strong>：</p>
<p>1）进入容器。进入我们刚刚创建的nginx容器的命令为：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it mn bash</span><br></pre></td></tr></table></figure>
<p>命令解读：</p>
<ul>
<li>docker exec ：进入容器内部，执行一个命令</li>
<li>-it : 给当前进入的容器创建一个标准输入、输出终端，允许我们与容器交互</li>
<li>mn ：要进入的容器的名称</li>
<li>bash：进入容器后执行的命令，bash是一个linux终端交互命令</li>
</ul>
<p>2）进入nginx的HTML所在目录 /usr/share/nginx/html</p>
<p>容器内部会模拟一个独立的Linux文件系统，看起来如同一个linux服务器一样：</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/1v6lg.png"></p>
<p>nginx的环境、配置、运行文件全部都在这个文件系统中，包括我们要修改的html文件。</p>
<p>查看DockerHub网站中的nginx页面，可以知道nginx的html目录位置在<code>/usr/share/nginx/html</code></p>
<p>我们执行命令，进入该目录：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/share/nginx/html</span><br></pre></td></tr></table></figure>
<p> 查看目录下文件：</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/9llt.png"></p>
<p>3）修改index.html的内容</p>
<p>容器内没有vi命令，无法直接修改，我们用下面的命令来修改：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sed -i -e <span class="string">&#x27;s#Welcome to nginx#传智教育欢迎您#g&#x27;</span> -e <span class="string">&#x27;s#&lt;head&gt;#&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;#g&#x27;</span> index.html</span><br></pre></td></tr></table></figure>
<p>在浏览器访问自己的虚拟机地址即可看到结果：</p>
<h3 id="2-2-4-小结"><a href="#2-2-4-小结" class="headerlink" title="2.2.4.小结"></a>2.2.4.小结</h3><p>docker run命令的常见参数有哪些？</p>
<ul>
<li>—name：指定容器名称</li>
<li>-p：指定端口映射</li>
<li>-d：让容器后台运行</li>
</ul>
<p>查看容器日志的命令：</p>
<ul>
<li>docker logs</li>
<li>添加 -f 参数可以持续查看日志</li>
</ul>
<p>查看容器状态：</p>
<ul>
<li>docker ps</li>
<li>docker ps -a 查看所有容器，包括已经停止的</li>
</ul>
<h2 id="2-3-数据卷（容器数据管理）"><a href="#2-3-数据卷（容器数据管理）" class="headerlink" title="2.3.数据卷（容器数据管理）"></a>2.3.数据卷（容器数据管理）</h2><p>在之前的nginx案例中，修改nginx的html页面时，需要进入nginx内部。并且因为没有编辑器，修改文件也很麻烦。</p>
<p>这就是因为容器与数据（容器内文件）耦合带来的后果。</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/19hv.png"></p>
<p>要解决这个问题，必须将数据与容器解耦，这就要用到数据卷了。</p>
<h3 id="2-3-1-什么是数据卷"><a href="#2-3-1-什么是数据卷" class="headerlink" title="2.3.1.什么是数据卷"></a>2.3.1.什么是数据卷</h3><p><strong>数据卷（volume）</strong>是一个虚拟目录，指向宿主机文件系统中的某个目录。</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/6gy.png"></p>
<p>一旦完成数据卷挂载，对容器的一切操作都会作用在数据卷对应的宿主机目录了。</p>
<p>这样，我们操作宿主机的/var/lib/docker/volumes/html目录，就等于操作容器内的/usr/share/nginx/html目录了</p>
<h3 id="2-3-2-数据集操作命令"><a href="#2-3-2-数据集操作命令" class="headerlink" title="2.3.2.数据集操作命令"></a>2.3.2.数据集操作命令</h3><p>数据卷操作的基本语法如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker volume [COMMAND]</span><br></pre></td></tr></table></figure>
<p>docker volume命令是数据卷操作，根据命令后跟随的command来确定下一步的操作：</p>
<ul>
<li>create 创建一个volume</li>
<li>inspect 显示一个或多个volume的信息</li>
<li>ls 列出所有的volume</li>
<li>prune 删除未使用的volume</li>
<li>rm 删除一个或多个指定的volume</li>
</ul>
<h3 id="2-3-3-创建和查看数据卷"><a href="#2-3-3-创建和查看数据卷" class="headerlink" title="2.3.3.创建和查看数据卷"></a>2.3.3.创建和查看数据卷</h3><p><strong>需求</strong>：创建一个数据卷，并查看数据卷在宿主机的目录位置</p>
<p>① 创建数据卷</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker volume create html</span><br></pre></td></tr></table></figure>
<p>② 查看所有数据</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker volume <span class="built_in">ls</span></span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/6hz.png"></p>
<p>③ 查看数据卷详细信息卷</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker volume inspect html</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/8t97.png"></p>
<p>可以看到，我们创建的html这个数据卷关联的宿主机目录为<code>/var/lib/docker/volumes/html/_data</code>目录。</p>
<p><strong>小结</strong>：</p>
<p>数据卷的作用：</p>
<ul>
<li>将容器与数据分离，解耦合，方便操作容器内数据，保证数据安全</li>
</ul>
<p>数据卷操作：</p>
<ul>
<li>docker volume create：创建数据卷</li>
<li>docker volume ls：查看所有数据卷</li>
<li>docker volume inspect：查看数据卷详细信息，包括关联的宿主机目录位置</li>
<li>docker volume rm：删除指定数据卷</li>
<li>docker volume prune：删除所有未使用的数据卷</li>
</ul>
<h3 id="2-3-4-挂载数据卷"><a href="#2-3-4-挂载数据卷" class="headerlink" title="2.3.4.挂载数据卷"></a>2.3.4.挂载数据卷</h3><p>我们在创建容器时，可以通过 -v 参数来挂载一个数据卷到某个容器内目录，命令格式如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run \</span><br><span class="line">  --name mn \</span><br><span class="line">  -v html:/root/html \</span><br><span class="line">  -p 8080:80</span><br><span class="line">  nginx \</span><br></pre></td></tr></table></figure>
<p>这里的-v就是挂载数据卷的命令：</p>
<ul>
<li><code>-v html:/root/htm</code> ：把html数据卷挂载到容器内的/root/html这个目录中</li>
</ul>
<h3 id="2-3-5-案例-给nginx挂载数据卷"><a href="#2-3-5-案例-给nginx挂载数据卷" class="headerlink" title="2.3.5.案例-给nginx挂载数据卷"></a>2.3.5.案例-给nginx挂载数据卷</h3><p><strong>需求</strong>：创建一个nginx容器，修改容器内的html目录内的index.html内容</p>
<p><strong>分析</strong>：上个案例中，我们进入nginx容器内部，已经知道nginx的html目录所在位置/usr/share/nginx/html ，我们需要把这个目录挂载到html这个数据卷上，方便操作其中的内容。</p>
<p><strong>提示</strong>：运行容器时使用 -v 参数挂载数据卷</p>
<p>步骤：</p>
<p>① 创建容器并挂载数据卷到容器内的HTML目录</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run --name mn -v html:/usr/share/nginx/html -p 80:80 -d nginx</span><br></pre></td></tr></table></figure>
<p>② 进入html数据卷所在位置，并修改HTML内容</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看html数据卷的位置</span></span><br><span class="line">docker volume inspect html</span><br><span class="line"><span class="comment"># 进入该目录</span></span><br><span class="line"><span class="built_in">cd</span> /var/lib/docker/volumes/html/_data</span><br><span class="line"><span class="comment"># 修改文件</span></span><br><span class="line">vi index.html</span><br></pre></td></tr></table></figure>
<h3 id="2-3-6-案例-给MySQL挂载本地目录"><a href="#2-3-6-案例-给MySQL挂载本地目录" class="headerlink" title="2.3.6.案例-给MySQL挂载本地目录"></a>2.3.6.案例-给MySQL挂载本地目录</h3><p>容器不仅仅可以挂载数据卷，也可以直接挂载到宿主机目录上。关联关系如下：</p>
<ul>
<li>带数据卷模式：宿主机目录 —&gt; 数据卷 —-&gt; 容器内目录</li>
<li>直接挂载模式：宿主机目录 —-&gt; 容器内目录</li>
</ul>
<p>如图：</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/8uwz.png"></p>
<p><strong>语法</strong>：</p>
<p>目录挂载与数据卷挂载的语法是类似的：</p>
<ul>
<li>-v [宿主机目录]:[容器内目录]</li>
<li>-v [宿主机文件]:[容器内文件]</li>
</ul>
<p><strong>需求</strong>：创建并运行一个MySQL容器，将宿主机目录直接挂载到容器</p>
<p>实现思路如下：</p>
<p>1）在将课前资料中的mysql.tar文件上传到虚拟机，通过load命令加载为镜像</p>
<p>2）创建目录/tmp/mysql/data</p>
<p>3）创建目录/tmp/mysql/conf，将课前资料提供的hmy.cnf文件上传到/tmp/mysql/conf</p>
<p>4）去DockerHub查阅资料，创建并运行MySQL容器，要求：</p>
<p>① 挂载/tmp/mysql/data到mysql容器内数据存储目录</p>
<p>② 挂载/tmp/mysql/conf/hmy.cnf到mysql容器的配置文件</p>
<p>③ 设置MySQL密码</p>
<h3 id="2-3-7-小结"><a href="#2-3-7-小结" class="headerlink" title="2.3.7.小结"></a>2.3.7.小结</h3><p>docker run的命令中通过 -v 参数挂载文件或目录到容器中：</p>
<ul>
<li>-v volume名称:容器内目录</li>
<li>-v 宿主机文件:容器内文</li>
<li>-v 宿主机目录:容器内目录</li>
</ul>
<p>数据卷挂载与目录直接挂载的</p>
<ul>
<li>数据卷挂载耦合度低，由docker来管理目录，但是目录较深，不好找</li>
<li>目录挂载耦合度高，需要我们自己管理目录，不过目录容易寻找查看</li>
</ul>
<h1 id="3-Dockerfile自定义镜像"><a href="#3-Dockerfile自定义镜像" class="headerlink" title="3.Dockerfile自定义镜像"></a>3.Dockerfile自定义镜像</h1><p>常见的镜像在DockerHub就能找到，但是我们自己写的项目就必须自己构建镜像了。</p>
<p>而要自定义镜像，就必须先了解镜像的结构才行。</p>
<h2 id="3-1-镜像结构"><a href="#3-1-镜像结构" class="headerlink" title="3.1.镜像结构"></a>3.1.镜像结构</h2><p>镜像是将应用程序及其需要的系统函数库、环境、配置、依赖打包而成。</p>
<p>我们以MySQL为例，来看看镜像的组成结构：</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/6ik.png"></p>
<p>简单来说，镜像就是在系统函数库、运行环境基础上，添加应用程序文件、配置文件、依赖文件等组合，然后编写好启动脚本打包在一起形成的文件。</p>
<p>我们要构建镜像，其实就是实现上述打包的过程。</p>
<h2 id="3-2-Dockerfile语法"><a href="#3-2-Dockerfile语法" class="headerlink" title="3.2.Dockerfile语法"></a>3.2.Dockerfile语法</h2><p>构建自定义的镜像时，并不需要一个个文件去拷贝，打包。</p>
<p>我们只需要告诉Docker，我们的镜像的组成，需要哪些BaseImage、需要拷贝什么文件、需要安装什么依赖、启动脚本是什么，将来Docker会帮助我们构建镜像。</p>
<p>而描述上述信息的文件就是Dockerfile文件。</p>
<p><strong>Dockerfile</strong>就是一个文本文件，其中包含一个个的<strong>指令(Instruction)</strong>，用指令来说明要执行什么操作来构建镜像。每一个指令都会形成一层Layer。</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/19ok.png"></p>
<p>更新详细语法说明，请参考官网文档： <a href="https://docs.docker.com/engine/reference/builder">https://docs.docker.com/engine/reference/builder</a></p>
<h2 id="3-3-构建Java项目"><a href="#3-3-构建Java项目" class="headerlink" title="3.3.构建Java项目"></a>3.3.构建Java项目</h2><h3 id="3-3-1-基于Ubuntu构建Java项目"><a href="#3-3-1-基于Ubuntu构建Java项目" class="headerlink" title="3.3.1.基于Ubuntu构建Java项目"></a>3.3.1.基于Ubuntu构建Java项目</h3><p>需求：基于Ubuntu镜像构建一个新镜像，运行一个java项目</p>
<ul>
<li><p>步骤1：新建一个空文件夹docker-demo</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/1mhj.png"></p>
</li>
<li><p>步骤2：拷贝课前资料中的docker-demo.jar文件到docker-demo这个目录</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/bcq9.png"></p>
</li>
<li><p>步骤3：拷贝课前资料中的jdk8.tar.gz文件到docker-demo这个目录</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/bdf2.png"></p>
</li>
<li><p>步骤4：拷贝课前资料提供的Dockerfile到docker-demo这个目录</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/bdf2.png"></p>
<p>其中的内容如下：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">16.04</span></span><br><span class="line"><span class="comment"># 配置环境变量，JDK的安装目录</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_DIR=/usr/local</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝jdk和java项目的包</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./jdk8.tar.gz <span class="variable">$JAVA_DIR</span>/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./docker-demo.jar /tmp/app.jar</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装JDK</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">cd</span> <span class="variable">$JAVA_DIR</span> \</span></span><br><span class="line"><span class="language-bash"> &amp;&amp; tar -xf ./jdk8.tar.gz \</span></span><br><span class="line"><span class="language-bash"> &amp;&amp; <span class="built_in">mv</span> ./jdk1.8.0_144 ./java8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_HOME=$JAVA_DIR/java8</span><br><span class="line"><span class="keyword">ENV</span> PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 暴露端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8090</span></span><br><span class="line"><span class="comment"># 入口，java项目的启动命令</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> java -jar /tmp/app.jar</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>步骤5：进入docker-demo</p>
<p>将准备好的docker-demo上传到虚拟机任意目录，然后进入docker-demo目录下</p>
</li>
<li><p>步骤6：运行命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker build -t javaweb:1.0 .</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>最后访问 <a href="http://192.168.150.101:8090/hello/count，其中的ip改成你的虚拟机ip">http://192.168.150.101:8090/hello/count，其中的ip改成你的虚拟机ip</a></p>
<h3 id="3-3-2-基于java8构建Java项目"><a href="#3-3-2-基于java8构建Java项目" class="headerlink" title="3.3.2.基于java8构建Java项目"></a>3.3.2.基于java8构建Java项目</h3><p>虽然我们可以基于Ubuntu基础镜像，添加任意自己需要的安装包，构建镜像，但是却比较麻烦。所以大多数情况下，我们都可以在一些安装了部分软件的基础镜像上做改造。</p>
<p>例如，构建java项目的镜像，可以在已经准备了JDK的基础镜像基础上构建。</p>
<p>需求：基于java:8-alpine镜像，将一个Java项目构建为镜像</p>
<p>实现思路如下：</p>
<ul>
<li><p>① 新建一个空的目录，然后在目录中新建一个文件，命名为Dockerfile</p>
</li>
<li><p>② 拷贝课前资料提供的docker-demo.jar到这个目录中</p>
</li>
<li><p>③ 编写Dockerfile文件：</p>
<ul>
<li><p>a ）基于java:8-alpine作为基础镜像</p>
</li>
<li><p>b ）将app.jar拷贝到镜像中</p>
</li>
<li><p>c ）暴露端口</p>
</li>
<li><p>d ）编写入口ENTRYPOINT</p>
<p>内容如下：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> java:<span class="number">8</span>-alpine</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./app.jar /tmp/app.jar</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8090</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> java -jar /tmp/app.jar</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>④ 使用docker build命令构建镜像</p>
</li>
<li><p>⑤ 使用docker run创建容器并运行</p>
</li>
</ul>
<h2 id="3-4-小结"><a href="#3-4-小结" class="headerlink" title="3.4.小结"></a>3.4.小结</h2><p>小结：</p>
<ol>
<li>Dockerfile的本质是一个文件，通过指令描述镜像的构建过程</li>
<li>Dockerfile的第一行必须是FROM，从一个基础镜像来构建</li>
<li>基础镜像可以是基本操作系统，如Ubuntu。也可以是其他人制作好的镜像，例如：java:8-alpine</li>
</ol>
<h1 id="4-Docker-Compose"><a href="#4-Docker-Compose" class="headerlink" title="4.Docker-Compose"></a>4.Docker-Compose</h1><p>Docker Compose可以基于Compose文件帮我们快速的部署分布式应用，而无需手动一个个创建和运行容器！</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/8bp.png"></p>
<h2 id="4-1-初识DockerCompose"><a href="#4-1-初识DockerCompose" class="headerlink" title="4.1.初识DockerCompose"></a>4.1.初识DockerCompose</h2><p>Compose文件是一个文本文件，通过指令定义集群中的每个容器如何运行。格式如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">version<span class="punctuation">:</span> <span class="string">&quot;3.8&quot;</span></span><br><span class="line"> services<span class="punctuation">:</span></span><br><span class="line">  mysql<span class="punctuation">:</span></span><br><span class="line">    image<span class="punctuation">:</span> mysql<span class="punctuation">:</span><span class="number">5.7</span><span class="number">.25</span></span><br><span class="line">    environment<span class="punctuation">:</span></span><br><span class="line">     MYSQL_ROOT_PASSWORD<span class="punctuation">:</span> <span class="number">123</span> </span><br><span class="line">    volumes<span class="punctuation">:</span></span><br><span class="line">     - <span class="string">&quot;/tmp/mysql/data:/var/lib/mysql&quot;</span></span><br><span class="line">     - <span class="string">&quot;/tmp/mysql/conf/hmy.cnf:/etc/mysql/conf.d/hmy.cnf&quot;</span></span><br><span class="line">  web<span class="punctuation">:</span></span><br><span class="line">    build<span class="punctuation">:</span> .</span><br><span class="line">    ports<span class="punctuation">:</span></span><br><span class="line">     - <span class="string">&quot;8090:8090&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面的Compose文件就描述一个项目，其中包含两个容器：</p>
<ul>
<li>mysql：一个基于<code>mysql:5.7.25</code>镜像构建的容器，并且挂载了两个目录</li>
<li>web：一个基于<code>docker build</code>临时构建的镜像容器，映射端口时8090</li>
</ul>
<p>DockerCompose的详细语法参考官网：<a href="https://docs.docker.com/compose/compose-file/">https://docs.docker.com/compose/compose-file/</a></p>
<p>其实DockerCompose文件可以看做是将多个docker run命令写到一个文件，只是语法稍有差异。</p>
<h2 id="4-2-安装DockerCompose"><a href="#4-2-安装DockerCompose" class="headerlink" title="4.2.安装DockerCompose"></a>4.2.安装DockerCompose</h2><p>参考课前资料</p>
<h2 id="4-3-部署微服务集群"><a href="#4-3-部署微服务集群" class="headerlink" title="4.3.部署微服务集群"></a>4.3.部署微服务集群</h2><p><strong>需求</strong>：将之前学习的cloud-demo微服务集群利用DockerCompose部署</p>
<p><strong>实现思路</strong>：</p>
<p>① 查看课前资料提供的cloud-demo文件夹，里面已经编写好了docker-compose文件</p>
<p>② 修改自己的cloud-demo项目，将数据库、nacos地址都命名为docker-compose中的服务名</p>
<p>③ 使用maven打包工具，将项目中的每个微服务都打包为app.jar</p>
<p>④ 将打包好的app.jar拷贝到cloud-demo中的每一个对应的子目录中</p>
<p>⑤ 将cloud-demo上传至虚拟机，利用 docker-compose up -d 来部署</p>
<h3 id="4-3-1-compose文件"><a href="#4-3-1-compose文件" class="headerlink" title="4.3.1.compose文件"></a>4.3.1.compose文件</h3><p>查看课前资料提供的cloud-demo文件夹，里面已经编写好了docker-compose文件，而且每个微服务都准备了一个独立的目录：</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/bbur.png"></p>
<p>内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">nacos:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nacos/nacos-server</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MODE:</span> <span class="string">standalone</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8848:8848&quot;</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:5.7.25</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="number">123</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;$PWD/mysql/data:/var/lib/mysql&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;$PWD/mysql/conf:/etc/mysql/conf.d/&quot;</span></span><br><span class="line">  <span class="attr">userservice:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">./user-service</span></span><br><span class="line">  <span class="attr">orderservice:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">./order-service</span></span><br><span class="line">  <span class="attr">gateway:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">./gateway</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;10010:10010&quot;</span></span><br></pre></td></tr></table></figure>
<p>可以看到，其中包含5个service服务：</p>
<ul>
<li><code>nacos</code>：作为注册中心和配置中心<ul>
<li><code>image: nacos/nacos-server</code>： 基于nacos/nacos-server镜像构建</li>
<li><code>environment</code>：环境变量<ul>
<li><code>MODE: standalone</code>：单点模式启动</li>
</ul>
</li>
<li><code>ports</code>：端口映射，这里暴露了8848端口</li>
</ul>
</li>
<li><code>mysql</code>：数据库<ul>
<li><code>image: mysql:5.7.25</code>：镜像版本是mysql:5.7.25</li>
<li><code>environment</code>：环境变量<ul>
<li><code>MYSQL_ROOT_PASSWORD: 123</code>：设置数据库root账户的密码为123</li>
</ul>
</li>
<li><code>volumes</code>：数据卷挂载，这里挂载了mysql的data、conf目录，其中有我提前准备好的数据</li>
</ul>
</li>
<li><code>userservice</code>、<code>orderservice</code>、<code>gateway</code>：都是基于Dockerfile临时构建的</li>
</ul>
<p>查看mysql目录，可以看到其中已经准备好了cloud_order、cloud_user表：</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/bd7c.png"></p>
<p>查看微服务目录，可以看到都包含Dockerfile文件：</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/bd3h.png"></p>
<p>内容如下：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> java:<span class="number">8</span>-alpine</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./app.jar /tmp/app.jar</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> java -jar /tmp/app.jar</span></span><br></pre></td></tr></table></figure>
<h3 id="4-3-2-修改微服务配置"><a href="#4-3-2-修改微服务配置" class="headerlink" title="4.3.2.修改微服务配置"></a>4.3.2.修改微服务配置</h3><p>因为微服务将来要部署为docker容器，而容器之间互联不是通过IP地址，而是通过容器名。这里我们将order-service、user-service、gateway服务的mysql、nacos地址都修改为基于容器名的访问。</p>
<p>如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://mysql:3306/cloud_order?useSSL=false</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">orderservice</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">nacos:8848</span> <span class="comment"># nacos服务地址</span></span><br></pre></td></tr></table></figure>
<h3 id="4-3-3-打包"><a href="#4-3-3-打包" class="headerlink" title="4.3.3.打包"></a>4.3.3.打包</h3><p>接下来需要将我们的每个微服务都打包。因为之前查看到Dockerfile中的jar包名称都是app.jar，因此我们的每个微服务都需要用这个名称。</p>
<p>可以通过修改pom.xml中的打包名称来实现，每个微服务都需要修改：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 服务打包的最终名称 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>app<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>打包后：</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/bcbv.png"></p>
<h3 id="4-3-4-拷贝jar包到部署目录"><a href="#4-3-4-拷贝jar包到部署目录" class="headerlink" title="4.3.4.拷贝jar包到部署目录"></a>4.3.4.拷贝jar包到部署目录</h3><p>编译打包好的app.jar文件，需要放到Dockerfile的同级目录中。注意：每个微服务的app.jar放到与服务名称对应的目录，别搞错了。</p>
<p>user-service：</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/8bw.png"></p>
<p>order-service：</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/1mg8.png"></p>
<p>gateway：</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/bcuz.png"></p>
<h3 id="4-3-5-部署"><a href="#4-3-5-部署" class="headerlink" title="4.3.5.部署"></a>4.3.5.部署</h3><p>最后，我们需要将文件整个cloud-demo文件夹上传到虚拟机中，理由DockerCompose部署。</p>
<p>上传到任意目录：</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/bdac.png"></p>
<p>部署：</p>
<p>进入cloud-demo目录，然后运行下面的命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>
<h1 id="5-Docker镜像仓库"><a href="#5-Docker镜像仓库" class="headerlink" title="5.Docker镜像仓库"></a>5.Docker镜像仓库</h1><h2 id="5-1-搭建私有镜像仓库"><a href="#5-1-搭建私有镜像仓库" class="headerlink" title="5.1.搭建私有镜像仓库"></a>5.1.搭建私有镜像仓库</h2><p>参考课前资料《CentOS7安装Docker.md》</p>
<h2 id="5-2-推送、拉取镜像"><a href="#5-2-推送、拉取镜像" class="headerlink" title="5.2.推送、拉取镜像"></a>5.2.推送、拉取镜像</h2><p>推送镜像到私有镜像服务必须先tag，步骤如下：</p>
<p>① 重新tag本地镜像，名称前缀为私有仓库的地址：192.168.150.101:8080/</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker tag nginx:latest 192.168.150.101:8080/nginx:1.0 </span><br></pre></td></tr></table></figure>
<p>② 推送镜像</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker push 192.168.150.101:8080/nginx:1.0 </span><br></pre></td></tr></table></figure>
<p>③ 拉取镜像</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker pull 192.168.150.101:8080/nginx:1.0 </span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Docker</tag>
        <tag>镜像仓库</tag>
        <tag>数据卷</tag>
      </tags>
  </entry>
  <entry>
    <title>Nacos-服务发现与配置管理v1.0</title>
    <url>/2023/01/06/Nacos-%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E4%B8%8E%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86v1-0/</url>
    <content><![CDATA[<h1 id="Nacos-服务发现和配置管理"><a href="#Nacos-服务发现和配置管理" class="headerlink" title="Nacos - 服务发现和配置管理"></a>Nacos - 服务发现和配置管理</h1><h2 id="1-理解服务发现"><a href="#1-理解服务发现" class="headerlink" title="1 理解服务发现"></a>1 <strong>理解服务发现</strong></h2><h3 id="1-1-微服务架构"><a href="#1-1-微服务架构" class="headerlink" title="1.1 微服务架构"></a>1.1 <strong>微服务架构</strong></h3><p>为适应企业的业务发展，提高软件研发的生产力，降低软件研发的成本，软件架构也作了升级和优化，将一个独立 的系统拆分成若干小的服务，每个小服务运行在不同的进程中，服务与服务之间采用RESTful、RPC等协议传输数    据，每个服务所拥有的功能具有独立性强的特点，这样的设计就实现了单个服务的高内聚，服务与服务之间的低耦 合效果，这些小服务就是微服务，基于这种方法设计的系统架构即微服务架构。</p>
<span id="more"></span>
<p>下图是基于微服务架构的电商系统：</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/06/5het.png"></p>
<p>特点：</p>
<p>1、服务层按业务拆分为一个一个的微服务。</p>
<p>2、微服务的职责单一。</p>
<p>3、微服务之间采用RESTful、RPC等轻量级协议传输。</p>
<p>4、有利于采用前后端分离架构。</p>
<h3 id="1-2理解服务发现"><a href="#1-2理解服务发现" class="headerlink" title="1.2理解服务发现"></a>1.2<strong>理解服务发现</strong></h3><h4 id="1-2-1-测试环境"><a href="#1-2-1-测试环境" class="headerlink" title="1.2.1 测试环境"></a>1.2.1 <strong>测试环境</strong></h4><p>在微服务架构中，整个系统会按职责能力划分为多个服务，通过服务之间协作来实现业务目标。这样在我们的代码 中免不了要进行服务间的远程调用，服务的消费方要调用服务的生产方，为了完成一次请求，消费方需要知道服务 生产方的网络位置(IP地址和端口号)。</p>
<p>我们的代码可以通过读取配置文件的方式读取服务生产方网络位置，如下：</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/06/62i4.png"></p>
<p>我们通过Spring boot技术很容易实现： </p>
<p><strong>1</strong>、创建nacos-discovery父工程</p>
<p>pom.xml如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF‐8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema‐instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0</span><br><span class="line">http://maven.apache.org/xsd/maven‐4.0.0.xsd&quot;&gt;</span><br><span class="line">&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">&lt;groupId&gt;com.itheima.nacos&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;nacos‐discovery&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.0‐SNAPSHOT&lt;/version&gt;</span><br><span class="line">&lt;packaging&gt;pom&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring‐boot‐dependencies&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;2.1.3.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">&lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line">&lt;/dependencyManagement&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>
<p>2、Service B（服务生产者）</p>
<p>创建服务提供者 nacos-restful-provider。</p>
<p>pom.xml如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF‐8&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema‐instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0</span><br><span class="line">http://maven.apache.org/xsd/maven‐4.0.0.xsd&quot;&gt;</span><br><span class="line">&lt;parent&gt;</span><br><span class="line">&lt;artifactId&gt;nacos‐discovery&lt;/artifactId&gt;</span><br><span class="line">&lt;groupId&gt;com.itheima.nacos&lt;/groupId&gt;</span><br><span class="line">&lt;version&gt;1.0‐SNAPSHOT&lt;/version&gt;</span><br><span class="line">&lt;/parent&gt;</span><br><span class="line">&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">&lt;artifactId&gt;nacos‐restful‐provider&lt;/artifactId&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring‐boot‐starter‐web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>
<p>1、创建Controller</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.nacos.provider.controller;</span><br><span class="line"></span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">public class RestProviderController &#123; @GetMapping(value = &quot;/service&quot;) //暴露服务public String service()&#123;</span><br><span class="line">System.out.println(&quot;provider invoke&quot;); return &quot;provider invoke&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、创建启动类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class SpringRestProviderBootstrap &#123; public static void main(String[] args) &#123;</span><br><span class="line">SpringApplication.run(SpringRestProviderBootstrap.class, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置文件：</p>
<p>创建application.yml，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server：</span><br><span class="line">port：56010</span><br></pre></td></tr></table></figure>
<p><strong>3</strong>、<strong>Service</strong> <strong>A</strong>（服务消费者）</p>
<p>创建nacos-restful-consumer 服务消费工程。</p>
<p>pom.xml如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF‐8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema‐instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0</span><br><span class="line">http://maven.apache.org/xsd/maven‐4.0.0.xsd&quot;&gt;</span><br><span class="line">&lt;parent&gt;</span><br><span class="line">&lt;artifactId&gt;nacos‐discovery&lt;/artifactId&gt;</span><br><span class="line">&lt;groupId&gt;com.itheima.nacos&lt;/groupId&gt;</span><br><span class="line">&lt;version&gt;1.0‐SNAPSHOT&lt;/version&gt;</span><br><span class="line">&lt;/parent&gt;</span><br><span class="line">&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">&lt;artifactId&gt;nacos‐restful‐consumer&lt;/artifactId&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring‐boot‐starter‐web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>
<p>实现代码：</p>
<p>1、创建controller</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.nacos.consumer.controller;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.annotation.Value; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; import org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">public class RestConsumerController &#123; @Value(&quot;$&#123;provider.address&#125;&quot;) private String providerAddress;</span><br><span class="line">@GetMapping(value = &quot;/service&quot;)</span><br><span class="line">public String service()&#123;</span><br><span class="line">RestTemplate restTemplate = new RestTemplate();</span><br><span class="line">//调用服务</span><br><span class="line">String providerResult = restTemplate.getForObject(&quot;http://&quot; + providerAddress + &quot;/service&quot;,String.class);</span><br><span class="line">return &quot;consumer invoke | &quot; + providerResult;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、创建启动类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class SpringRestConsumerBootstrap &#123; public static void main(String[] args) &#123;</span><br><span class="line">SpringApplication.run(SpringRestConsumerBootstrap.class, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置文件：</p>
<p>创建application.yml，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server.port = 56020 # 服务生产方地址</span><br><span class="line">provider.address = 127.0.0.1:56010</span><br></pre></td></tr></table></figure>
<p>访问<a href="http://127.0.0.1:56020/service，输出以下内容：">http://127.0.0.1:56020/service，输出以下内容：</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">consumer invoke | provider invoke</span><br></pre></td></tr></table></figure>
<h4 id="1-2-2-服务发现流程"><a href="#1-2-2-服务发现流程" class="headerlink" title="1.2.2 服务发现流程"></a>1.2.2 <strong>服务发现流程</strong></h4><p>上边的例子看上去很完美，但是，仔细考虑以下，此方案对于微服务应用而言行不通。首先，微服务可能是部署在 云环境的，服务实例的网络位置或许是动态分配的。另外，每一个服务一般会有多个实例来做负载均衡，由于宕机 或升级，服务实例网络地址会经常动态改变。再者，每一个服务也可能应对临时访问压力增加新的服务节点。正如 下图所示：</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/06/tib.png"></p>
<p>基于以上的问题，服务之间如何相互发现？服务如何管理？这就是服务发现的问题了。</p>
<p>服务发现就是服务消费方通过服务发现中心智能发现服务提供方，从而进行远程调用的过程。 如下图：</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/06/z5c.png"></p>
<p>上图中服务实例本身并不记录服务生产方的网络地址，所有服务实例内部都会包含<strong>服务发现客户端</strong>。</p>
<p>（1） 在每个服务启动时会向<strong>服务发现中心</strong>上报自己的网络位置。这样，在服务发现中心内部会形成一个<strong>服务注册</strong> <strong>表</strong>，<strong>服务注册表</strong>是服务发现的核心部分，是包含所有服务实例的网络地址的数据库。</p>
<p>（2） <strong>服务发现客户端</strong>会定期从<strong>服务发现中心</strong>同步<strong>服务注册表</strong>   ，并缓存在客户端。</p>
<p>（3） 当需要对某服务进行请求时，服务实例通过该注册表，定位目标服务网络地址。若目标服务存在多个网络地 址，则使用负载均衡算法从多个服务实例中选择出一个，然后发出请求。</p>
<p>总结，在微服务环境中，由于服务运行实例的网络地址是不断动态变化的，服务实例数量的动态变化   ，因此无法使用固定的配置文件来记录服务提供方的网络地址，必须使用动态的服务发现机制用于实现微服务间的<strong>相互感知</strong>。 各服务实例会上报自己的网络地址，这样服务中心就形成了一个完整的服务注册表，各服务实例会通过<strong>服务发现中</strong> <strong>心</strong>来获取访问目标服务的网络地址，从而实现<strong>服务发现</strong>的机制。</p>
<h2 id="2-Nacos-服务发现"><a href="#2-Nacos-服务发现" class="headerlink" title="2 Nacos 服务发现"></a>2 <strong>Nacos</strong> <strong>服务发现</strong></h2><h3 id="2-1-Nacos特性"><a href="#2-1-Nacos特性" class="headerlink" title="2.1. Nacos特性"></a>2.1. <strong>Nacos</strong>特性</h3><p>Nacos主要提供以下四大功能：</p>
<ol>
<li><strong>服务发现与服务健康检查</strong></li>
</ol>
<p>Nacos使服务更容易注册，并通过DNS或HTTP接口发现其他服务，Nacos还提供服务的实时健康检查，以防 止向不健康的主机或服务实例发送请求。</p>
<ol>
<li><strong>动态配置管理</strong></li>
</ol>
<p>动态配置服务允许您在所有环境中以集中和动态的方式管理所有服务的配置。Nacos消除了在更新配置时重新 部署应用程序，这使配置的更改更加高效和灵活。</p>
<ol>
<li><strong>动态DNS服务</strong></li>
</ol>
<p>Nacos提供基于DNS   协议的服务发现能力，旨在支持异构语言的服务发现，支持将注册在Nacos上的服务以域名的方式暴露端点，让三方应用方便的查阅及发现。</p>
<ol>
<li><strong>服务和元数据管理</strong></li>
</ol>
<p>Nacos 能让您从微服务平台建设的视角管理数据中心的所有服务及元数据，包括管理服务的描述、生命周期、服务的静态依赖分析、服务的健康状态、服务的流量管理、路由及安全策略。</p>
<h3 id="2-2-启动服务器"><a href="#2-2-启动服务器" class="headerlink" title="2.2 启动服务器"></a>2.2 <strong>启动服务器</strong></h3><p>nacos的默认端口是8848，需要保证8848默认端口没有被其他进程占用。 进入安装程序的bin目录：</p>
<p><strong>Windows</strong>启动方式： 启动命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmd startup.cmd</span><br></pre></td></tr></table></figure>
<p>或者双击startup.cmd运行文件。</p>
<p>启动成功，可通过浏览器访问   <a href="http://127.0.0.1:8848/nacos">http://127.0.0.1:8848/nacos</a>   ，打开如下nacos控制台登录页面：</p>
<p>启动成功，可通过浏览器访问   <a href="http://127.0.0.1:8848/nacos">http://127.0.0.1:8848/nacos</a>   ，打开如下nacos控制台登录页面：</p>
<h3 id="2-3外部mysql数据库支持"><a href="#2-3外部mysql数据库支持" class="headerlink" title="2.3外部mysql数据库支持"></a>2.3<strong>外部</strong>mysql<strong>数据库支持</strong></h3><p>单机模式时nacos默认使用嵌入式数据库实现数据的存储，若想使用外部mysql存储nacos数据，需要进行以下步 骤：</p>
<ol>
<li><p>安装数据库，版本要求：5.6.5+ ，mysql 8 以下</p>
</li>
<li><p>初始化mysql数据库，新建数据库nacos_conﬁg，数据库初始化文件：${nacoshome}/conf/nacos- mysql.sql</p>
</li>
<li><p>修改${nacoshome}/conf/application.properties文件，增加支持mysql数据源配置（目前只支持mysql），添加mysql数据源的url、用户名和密码。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring.datasource.platform=mysql</span><br><span class="line"></span><br><span class="line">db.num=1 db.url.0=jdbc:mysql://11.162.196.16:3306/nacos_config?</span><br><span class="line">characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true db.user=nacos_devtest</span><br><span class="line">db.password=youdontknow</span><br></pre></td></tr></table></figure>
<h3 id="2-4-服务注册"><a href="#2-4-服务注册" class="headerlink" title="2.4 服务注册"></a>2.4 <strong>服务注册</strong></h3><p>在服务提供工程中配置nacos服务发现相关的配置： </p>
<p>服务提供：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">application:</span><br><span class="line">name: nacos‐restful‐provider cloud:</span><br><span class="line">nacos:</span><br><span class="line">discovery:</span><br><span class="line">server‐addr: 127.0.0.1:8848</span><br></pre></td></tr></table></figure>
<p>启动nacos</p>
<p>启动服务提供</p>
<p>观察nacos服务列表，nacos-restful-provider注册成功</p>
<h2 id="3-服务发现数据模型"><a href="#3-服务发现数据模型" class="headerlink" title="3. 服务发现数据模型"></a>3. <strong>服务发现数据模型</strong></h2><h3 id="3-1-Namespace-隔离设计"><a href="#3-1-Namespace-隔离设计" class="headerlink" title="3.1 Namespace 隔离设计"></a>3.1 <strong>Namespace</strong> <strong>隔离设计</strong></h3><p><strong>命名空间**</strong>(Namespace)**用于进行租户粒度的隔离，Namespace    的常用场景之一是不同环境的隔离，例如开发测试环境和生产环境的资源（如配置、服务）隔离等。</p>
<p>从一个租户(用户)的角度来看，如果有多套不同的环境，那么这个时候可以根据指定的环境来创建不同的namespce，以此来实现多环境的隔离。例如，你可能有开发，测试和生产三个不同的环境，那么使用一套nacos 集群可以分别建以下三个不同的 namespace。如下图所示：</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/06/1lu2.png"></p>
<p>从多个租户(用户)的角度来看，每个租户(用户)可能会有自己的 namespace,每个租户(用户)的配置数据以及注册的服务数据都会归属到自己的 namespace 下，以此来实现多租户间的数据隔离。例如超级管理员分配了三个租户，分别为张三、李四和王五。分配好了之后，各租户用自己的账户名和密码登录后，创建自己的命名   空间。如下图所示：</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/06/1j07.png"></p>
<h3 id="3-2-命名空间管理"><a href="#3-2-命名空间管理" class="headerlink" title="3.2 命名空间管理"></a>3.2 <strong>命名空间管理</strong></h3><p>前面已经介绍过，命名空间(Namespace)是用于隔离多个环境的（如开发、测试、生产），而每个应用在不同环    境的同一个配置（如数据库数据源）的值是不一样的。因此，我们应针对企业项目实际研发流程、环境进行规划。 如某软件公司拥有开发、测试、生产三套环境，那么我们应该针对这三个环境分别建立三个namespace。</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/06/cpmx.png"></p>
<p>建立好所有namespace后，在<strong>配置管理</strong>与<strong>服务管理</strong>模块下所有页面，都会包含用于切换namespace(环境)的tab按   钮，如下图：</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/06/cwvj.png"></p>
<h2 id="4-Nacos配置管理"><a href="#4-Nacos配置管理" class="headerlink" title="4. Nacos配置管理"></a>4. <strong>Nacos</strong>配置管理</h2><p>首先在nacos发布配置，nacos-restful-consumer服务从nacos读取配置。</p>
<p>浏览器访问 <a href="http://127.0.0.1:8848/nacos">http://127.0.0.1:8848/nacos</a> ，打开nacos控制台，并点击菜单<strong>配置管理**</strong>-&gt;<strong>**配置列表</strong>： 在Nacos添加如下的配置：</p>
<p>nacos-restful-consumer:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Namespace: public</span><br><span class="line">Data ID:	nacos‐restful‐consumer.yaml Group :	DEFAULT_GROUP</span><br><span class="line">配置格式:	YAML</span><br><span class="line">配置内容：	common:</span><br><span class="line">name: application1 config</span><br></pre></td></tr></table></figure>
<p><img src="https://i.p04e.com/baid/i/2023/01/06/20rj.png"><br><img src="https://i.p04e.com/baid/i/2023/01/06/20rz.png"></p>
<p>要想从配置中心获取配置添加nacos-conﬁg的依赖：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring‐cloud‐starter‐alibaba‐nacos‐config&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>在bootstrap.yml添加配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">cloud:</span><br><span class="line">nacos:</span><br><span class="line">config:</span><br><span class="line">server‐addr: 127.0.0.1:8848 # 配置中心地址</span><br><span class="line">file‐extension: yaml group: DEFAULT_GROUP</span><br></pre></td></tr></table></figure>
<p>注意：要使用配置中心就要在bootstrap.yml中来配置，bootstrap.yml配置文件的加载顺序要比application.yml要优先。</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/06/et8n.png"></p>
<h2 id="5-定义扩展的-Data-Id-配置"><a href="#5-定义扩展的-Data-Id-配置" class="headerlink" title="5 定义扩展的 Data Id 配置"></a>5 <strong>定义扩展的</strong> <strong>Data</strong> <strong>Id</strong> <strong>配置</strong></h2><h3 id="5-1-ext-conﬁg扩展配置"><a href="#5-1-ext-conﬁg扩展配置" class="headerlink" title="5.1 ext-conﬁg扩展配置"></a>5.1 <strong>ext-conﬁg</strong>扩展配置</h3><p>Spring Cloud Alibaba Nacos Conﬁg可支持自定义 Data Id 的配置。 一个完整的配置案例如下所示：</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/06/1ynu.png"></p>
<p>扩展配置优先级是spring.cloud.nacos.config.ext-config[n].data-id中 n 的值越大，优先级越高。</p>
<p>通过内部相关规则(应用名、扩展名 )自动生成相关的 Data Id 配置的优先级最大。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h1><p>Nacos用来干什么？</p>
<p>Nacos是阿里巴巴公司开源的项目，它用来实现配置中心和服务注册中心。 什么是服务发现？</p>
<p>在微服务架构中一个业务流程需要多个微服务通过网络接口调用完成业务处理，服务消费方从服务注册中心获取服 务提供方的地址，从而进行远程调用，这个过程叫做服务发现。</p>
<p>服务发现的流程是什么？</p>
<p>1、服务发现的客户端从服务注册中心获取服务列表</p>
<p>2、服务消费方通过客户端负载均衡获取服务实例地址，进行远程调用。什么是配置中心？</p>
<p>在微服务架构中为了统一管理各各微服务的配置信息专门设置配置中心，配置中心就是一种统一管理各种应用配置 的基础服务组件。</p>
<p>配置中心的应用流程是什么？</p>
<p>1、发布配置，将配置信息发布到配置中心。</p>
<p>2、获取配置，配置中心客户端得到配置中心的通知，从配置中心获取配置。</p>
<p>Spring Cloud是什么？</p>
<p>Spring Cloud是一套微服务开发框架集合，包括微服务开发的方方页面，Spring   Cloud是一套微服务开发的标准， 集成了很多优秀的开源框架，比如有名的Netﬂix公司的众多项目。</p>
<p>Spring Cloud Alibaba是什么？</p>
<p>Spring Cloud Alibaba是阿里巴巴公司基于Spring Cloud标准实现一套微服务开发框架集合，它和Netﬂix一样都是Spring Cloud微服务开发实现方案。</p>
<p>Dubbo服务开发流程是什么？ 1、定义api工程。</p>
<p>方便其它服务原来api工程，远程调用dubbo服务。</p>
<p>2、定义api实现工程。</p>
<p>service实现类使用  @org.apache.dubbo.conﬁg.annotation.Service注解标记为dubbo服务。</p>
<p>3、服务消费方开发</p>
<p>引入api工程依赖</p>
<p>使用org.apache.dubbo.conﬁg.annotation.Reference注解注入service，发起远程调用</p>
]]></content>
      <tags>
        <tag>nacos</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis-Plus</title>
    <url>/2023/01/06/Mybatis-Plus/</url>
    <content><![CDATA[<h1 id="1-Mybatis-Plus介绍"><a href="#1-Mybatis-Plus介绍" class="headerlink" title="1 Mybatis-Plus介绍"></a>1 <strong>Mybatis-Plus</strong>介绍</h1><p>MyBatis-Plus（简称 MP）是一个 MyBatis 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发 提高效率而生。该框架由baomidou（苞米豆）组织开发并且开源的。我们的愿景是成为 MyBatis 最好的搭档，就像 魂斗罗 中的 1P 2P，基友搭配，效率翻倍。</p>
<span id="more"></span>
<h2 id="1-1-支持的数据库"><a href="#1-1-支持的数据库" class="headerlink" title="1.1 支持的数据库"></a>1.1 <strong>支持的数据库</strong></h2><p>MyBatisPlus支持如下数据库：</p>
<p>mysql mariadb  oracle  db2  h2  hsql  sqlite  postgresql  sqlserver</p>
<p>数据库 虚谷数据库 人大金仓数据库</p>
<h2 id="1-1-特性"><a href="#1-1-特性" class="headerlink" title="1.1 特性"></a>1.1 <strong>特性</strong></h2><p>无侵入<strong>：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑   </strong>损耗小**：启动即会自动注入基本 CRUD，性能基本无损耗，直接面向对象操作</p>
<p><strong>强大的</strong> <strong>CRUD</strong> <strong>操作</strong>：内置通用 Mapper 通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作， 更有强大的条件构造器，满足各类使用需求</p>
<p><strong>支持</strong> <strong>Lambda</strong> <strong>形式调用</strong>：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错</p>
<p><strong>支持多种数据库</strong>：支持 MySQL MariaDB Oracle DB2 H2 HSQL SQLite Postgre SQLServer2005 SQLServer</p>
<p>等多种数据库</p>
<p><strong>支持主键自动生成</strong>：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题1</p>
<p><strong>支持</strong> <strong>XML</strong> <strong>热加载</strong>：Mapper 对应的 XML 支持热加载，对于简单的 CRUD 操作，甚至可以无 XML 启动</p>
<p><strong>支持</strong> <strong>ActiveRecord</strong> <strong>模式</strong>：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD</p>
<p>操作</p>
<p><strong>支持自定义全局通用操作</strong>：支持全局通用方法注入（ Write once, use anywhere ）</p>
<p><strong>支持关键词自动转义</strong>：支持数据库关键词（order key    ）自动转义，还可自定义关键词</p>
<p><strong>内置代码生成器</strong>：采用代码或者 Maven 插件可快速生成 Mapper Model Service Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用</p>
<p><strong>内置分页插件</strong>：基于   MyBatis   物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通</p>
<p>List 查询</p>
<p><strong>内置性能分析插件</strong>：可输出 Sql 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询<strong>内置全局拦截插件</strong>：提供全表 delete     update 操作智能分析阻断，也可自定义拦截规则，预防误操作<strong>内置</strong> <strong>Sql</strong> <strong>注入剥离器</strong>：支持 Sql 注入剥离，有效预防 Sql 注入攻击</p>
<h2 id="1-1-架构"><a href="#1-1-架构" class="headerlink" title="1.1 架构"></a>1.1 <strong>架构</strong></h2><p><img src="https://i.p04e.com/baid/i/2023/01/06/2r80.png"></p>
<p>Mybatis主要包含以下模块：</p>
<p><strong>核心功能**</strong>(core)**，基于Mybatis的封装，提供了Mybatis Plus的基础配置类与核心功能，如内置通用 Mapper， Lambda 表达式查询等。</p>
<p><strong>注解**</strong>(annotation)**，提供了Mybatis Plus中注解的定义。</p>
<p><strong>扩展功能**</strong>(extension)**，提供扩展及插件功能，包括分页插件 通用 Service扩展 性能分析插件等。</p>
<p><strong>代码生成器**</strong>(generator)**：通过代码生成器可以快速生成 Mapper接口 Entity实体类 Mapper XML Service Controller 等各个模块的代码，极大的提升了开发效率。</p>
<p>执行流程：</p>
<p>（1） 扫描注解Entity，反射提取注解信息如：表名称   字段名称等信息。</p>
<p>（2） 分析注解信息并基于com.baomidou.mybatisplus.core.enums的SQL模板生成基本CRUD       SQL。</p>
<p>（3） 最后将这些SQL注入到Mybatis环境中。</p>
<p>因此Mybatis plus无需编写CRUD SQL语句，只需继承BaseMapper，就有了CRUD功能(通用CRUD)。</p>
<h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><h3 id="创建user表插入数据"><a href="#创建user表插入数据" class="headerlink" title="创建user表插入数据"></a>创建user表插入数据</h3><h3 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h3><p>新建一个<code>springboot</code>，<code>maven</code>项目</p>
<h3 id="引入对应依赖"><a href="#引入对应依赖" class="headerlink" title="引入对应依赖"></a>引入对应依赖</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 数据库驱动 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- lombok 简化set get toString --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- mybatis-plus --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.4.3.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="链接数据库-同mybatis"><a href="#链接数据库-同mybatis" class="headerlink" title="链接数据库(同mybatis)"></a>链接数据库(同mybatis)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    url: jdbc:mysql://localhost:3306/mybatis_plus?useUnicode=true&amp;useSSL=false&amp;characterEncoding=utf8&amp;serverTimezone=Asia/Shanghai</span><br><span class="line">    username: root</span><br><span class="line">    password: 123456</span><br><span class="line">#其中url中，数据库名称？是否使用安全链接，字符集编码，是否使用解码，设置时区</span><br><span class="line"></span><br><span class="line">#mysql数据库用的是gbk编码，而项目数据库用的是utf-8编码。这时候如果添加了useUnicode=true&amp;characterEncoding=UTF-8</span><br><span class="line">#存数据时：</span><br><span class="line">#数据库在存放项目数据的时候会先用UTF-8格式将数据解码成字节码，然后再将解码后的字节码重新使用GBK编码存放到数据库中。</span><br><span class="line">#取数据时：</span><br><span class="line">#在从数据库中取数据的时候，数据库会先将数据库中的数据按GBK格式解码成字节码，然后再将解码后的字节码重新按UTF-8格式编码数据，最后再将数据返回给客户端。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="使用mybatis-plus"><a href="#使用mybatis-plus" class="headerlink" title="使用mybatis-plus"></a>使用mybatis-plus</h3><p>创建pojo类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Data</span><br><span class="line">@AllArgsConstructor #有参构造器</span><br><span class="line">@NoArgsConstructor  #无参构造器</span><br><span class="line">public class User &#123;</span><br><span class="line">    //常见的数据库中主键自动设置方法有（uuid、自增id、雪花算法、redis生成、zookeeper生成）</span><br><span class="line">    private Long id;</span><br><span class="line">    private String name;</span><br><span class="line">    private Integer age;</span><br><span class="line">    private String email;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在启动类加上<code>@mapper</code>注解,扫描<code>mapper</code>文件夹</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@MapperScan(&quot;com.jdw.mapper&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>mapper接口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//在对应的Mapper 接口上 基础基本的 BaseMapper&lt;T&gt; T是对应的pojo类</span><br><span class="line">@Repository   //告诉容器你是持久层的 @Repository是spring提供的注释，能够将该类注册成Bean</span><br><span class="line">public interface UserMapper extends BaseMapper&lt;User&gt; &#123;</span><br><span class="line">    //所有的crud都编写完成了</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>支持，<code>mybatis-plus</code>已经配置完成，可以直接使用，<code>CRUD</code>。</li>
<li>使用测试类<code>@Test</code>测试</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//继承了BaseMapper ,所有方法来自父类，可扩展</span><br><span class="line">@Autowired</span><br><span class="line">private UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">void contextLoads() &#123;</span><br><span class="line">    System.out.println((&quot;----- selectAll method test 测试查询所有用户方法 ------&quot;));</span><br><span class="line">    //selectList 的参数wrapper 是条件构造器，可以先写null</span><br><span class="line">    List&lt;User&gt; userList = userMapper.selectList(null);</span><br><span class="line">    //forEach 的参数是 Consumer类型的 语法糖</span><br><span class="line">    userList.forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="日志配置"><a href="#日志配置" class="headerlink" title="日志配置"></a>日志配置</h1><p>使用yml添加日志配置项</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mybatis-plus:</span><br><span class="line">  configuration:</span><br><span class="line">    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行查询方法查看分析日志</p>
<p>执行上面的查询所有用户的方法查看日志</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/06/3xr0z.png"></p>
<p>插入测试</p>
<p>插入及日志分析</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//测试插入</span><br><span class="line">@Test</span><br><span class="line">public void testInsert()&#123;</span><br><span class="line">    User user = new User();</span><br><span class="line">    user.setName(&quot;小蒋&quot;);</span><br><span class="line">    user.setAge(3);</span><br><span class="line">    user.setEmail(&quot;24749559@qq.com&quot;);</span><br><span class="line">    //没有设置ID却自动生成的ID</span><br><span class="line">    int result = userMapper.insert(user);</span><br><span class="line">    System.out.println(&quot;result = &quot; + result);</span><br><span class="line">    System.out.println(&quot;user = &quot; + user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>日志分析</strong></p>
<p>我们可以看到，并没有给user设置id，数据库自动插入了id=1453311479846608897，</p>
<h3 id="主键生成策略"><a href="#主键生成策略" class="headerlink" title="主键生成策略"></a>主键生成策略</h3><p>因为在最开始建表的sql语句中就指明了，id是数据库的主键，主键不能唯空，</p>
<p>常见的数据库中主键自动设置方法有（uuid、自增id、雪花算法、redis生成、zookeeper生成）</p>
<h4 id="雪花算法"><a href="#雪花算法" class="headerlink" title="雪花算法"></a>雪花算法</h4><p>这里生成的id默认采用的是<strong>雪花算法</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">snowflake是Twitter开源的分布式ID生成算法，结果是一个long型的ID。其核心思想是：使用41bit作为毫秒数，10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID），12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 ID），最后还有一个符号位，永远是0。具体实现的代码可以参看https://github.com/twitter/snowflake。雪花算法支持的TPS可以达到419万左右（2^22*1000）,几乎保证全球唯一。</span><br><span class="line"></span><br><span class="line">雪花算法在工程实现上有单机版本和分布式版本。单机版本如下，分布式版本可以参看美团leaf算法：https://github.com/Meituan-Dianping/Leaf</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以在User类的id属性上加入注解TableId更改和查看策略</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type = IdType.ASSIGN_ID，全局唯一id，雪花算法</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line">    @TableId(type = IdType.ASSIGN_ID,value = &quot;id&quot;)//枚举注解,使用ID_WORKER策略,全局唯一ID，数据库设置自增也没用</span><br><span class="line">    private Long id;</span><br><span class="line">    private String name;</span><br><span class="line">    private Integer age;</span><br><span class="line">    private String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进入这个注解</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Documented</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(&#123;ElementType.FIELD&#125;)  //枚举注解</span><br><span class="line">public @interface TableId &#123;</span><br><span class="line">    //可以设置以下两个参数</span><br><span class="line">    String value() default &quot;&quot;;</span><br><span class="line">    IdType type() default IdType.NONE; //ID策略</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="主键自增策略"><a href="#主键自增策略" class="headerlink" title="主键自增策略"></a>主键自增策略</h4><p>要是自增策略，在id上加入下列代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@TableId(type = IdType.AUTO)</span><br><span class="line">private Long id;</span><br></pre></td></tr></table></figure>
<p>同时数据库设计时，一定要将id设计为自增，这样自增id会设置在最大值上加1</p>
<h1 id="更新测试"><a href="#更新测试" class="headerlink" title="更新测试"></a>更新测试</h1><h3 id="更新及日志分析"><a href="#更新及日志分析" class="headerlink" title="更新及日志分析"></a>更新及日志分析</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//更新测试</span><br><span class="line">@Test</span><br><span class="line">   public void testUpdateByID() &#123;</span><br><span class="line">       User user = new User();</span><br><span class="line">       user.setId(7L);</span><br><span class="line">       user.setName(&quot;小小&quot;);</span><br><span class="line">       user.setAge(18);//这一行后加</span><br><span class="line">       int i = userMapper.updateById(user);//受影响的行数,参数是一个user不是id,点击看源码</span><br><span class="line">       System.out.println(&quot;i = &quot; + i);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我可以发现，先只更新了名字，后面更新名字和年龄。mybatis-plus通过条件自动把我们进行了动态sql拼接</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/06/41dx0.png"></p>
<p>自动填充<br>创建时间、更新时间！这个操作是自动化完成的，不要手动更新！</p>
<p>gmt_create、gmt_modified几乎在所有表都要配置上，而且自动化填充。gmt是时间时间的意思</p>
<h4 id="方式一、数据库级别（不建议）"><a href="#方式一、数据库级别（不建议）" class="headerlink" title="方式一、数据库级别（不建议）"></a>方式一、数据库级别（不建议）</h4><p>在数据库种添加字段gmt_create、gmt_modified，然后在pojo类中添加这两个属性，下次就可以查看了.(博主使用的是Navigat)<br><img src="https://i.p04e.com/baid/i/2023/01/06/kxnm.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private Data gmtCreate;</span><br><span class="line">private Data gmtModified;</span><br></pre></td></tr></table></figure>
<h4 id="方式二、代码级别"><a href="#方式二、代码级别" class="headerlink" title="方式二、代码级别"></a>方式二、代码级别</h4><p>1、在数据库中删除掉根据当前时间戳更新的选项</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/06/438ai.png"></p>
<p>2、在实体类的成员变量上添加注解<code>@TableField</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//字段添加填充内容</span><br><span class="line">@TableField(fill = FieldFill.INSERT ,value = &quot;create_time&quot;)</span><br><span class="line">private LocalDateTime createTime;</span><br><span class="line">@TableField(fill = FieldFill.INSERT_UPDATE ,value = &quot;update_time&quot;)</span><br><span class="line">private LocalDateTime updateTime;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>3、编写处理器来处理这个注解</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Slf4j //日志</span><br><span class="line">@Component//以组件的形式把这个处理器注册到IOC容器中</span><br><span class="line">public class MyMetaObjectHandler implements MetaObjectHandler &#123;</span><br><span class="line"></span><br><span class="line">    //插入时启动  第三个参数 LocalDateTime 一定要和 createTime成员变量的值的类型一致，不然是null 如果是date就都设置date</span><br><span class="line">    @Override</span><br><span class="line">    public void insertFill(MetaObject metaObject) &#123;</span><br><span class="line">        log.info(&quot;start insert fill ....&quot;);</span><br><span class="line">        this.strictInsertFill(metaObject, &quot;createTime&quot;, LocalDateTime.class, LocalDateTime.now()); // 起始版本 3.3.0(推荐使用)</span><br><span class="line">        this.strictUpdateFill(metaObject, &quot;updateTime&quot;, LocalDateTime.class, LocalDateTime.now()); // 起始版本 3.3.0(推荐)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //更新时候启动</span><br><span class="line">    @Override</span><br><span class="line">    public void updateFill(MetaObject metaObject) &#123;</span><br><span class="line">        log.info(&quot;start update fill ....&quot;);</span><br><span class="line">        this.strictUpdateFill(metaObject, &quot;updateTime&quot;, LocalDateTime.class, LocalDateTime.now()); // 起始版本 3.3.0(推荐)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>接下来的代码执行插入、更新时都会自动设置时间了</p>
<h1 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h1><h3 id="乐观锁原理"><a href="#乐观锁原理" class="headerlink" title="乐观锁原理"></a>乐观锁原理</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当要更新一条记录的时候，希望这条记录没有被别人更新</span><br><span class="line"></span><br><span class="line">乐观锁实现方式：</span><br><span class="line"></span><br><span class="line">取出记录时，获取当前version</span><br><span class="line">更新时，带上这个version</span><br><span class="line">执行更新时， set version = newVersion where version = oldVersion</span><br><span class="line">如果version不对，就更新失败</span><br></pre></td></tr></table></figure>
<p>相当于给每一个记录都加一个version字段。当我们要改记录时，把version字段拿出来看一看，对比一下这个version 有没有在你操作数据时被其他线程更改，如果依然等于oldVersion，你就对数据进行操作同时把 version = newVersion 更新（比如+1），以此你在改数据的途中告诉其他线程不要读了脏数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--A 线程</span><br><span class="line">update user set name = &quot;jdw&quot; ,version = version + 1   --version = newVersion  version有默认值比如1 </span><br><span class="line">where id = 2 and version = 1  -- version = oldVersion</span><br><span class="line">--B 线程 抢先完成，此时version=2,导致A线程的  version = oldVersion 不匹配A的oldVersion A将会修改失败,防止数据库产生脏数据</span><br><span class="line">update user set name = &quot;jdw&quot; ,version = version + 1   --version = newVersion  version有默认值比如1 </span><br><span class="line">where id = 2 and version = 1  -- version = oldVersion</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="乐观锁的应用"><a href="#乐观锁的应用" class="headerlink" title="乐观锁的应用"></a>乐观锁的应用</h3><h4 id="测试更新"><a href="#测试更新" class="headerlink" title="测试更新"></a>测试更新</h4><p>1、在数据库添加version字段，int型,默认0,长度10,不自增</p>
<p>2、在User类中添加对应属性：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Version //乐观锁注解</span><br><span class="line">private int version;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">说明: Version</span><br><span class="line"></span><br><span class="line">支持的数据类型只有:int,Integer,long,Long,Date,Timestamp,LocalDateTime</span><br><span class="line">整数类型下 newVersion = oldVersion + 1</span><br><span class="line">newVersion 会回写到 entity 中</span><br><span class="line">仅支持 updateById(id) 与 update(entity, wrapper) 方法</span><br><span class="line">在 update(entity, wrapper) 方法下, wrapper 不能复用!!!</span><br></pre></td></tr></table></figure>
<p>3、在config下注册组件，开启乐观锁拦截器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@EnableTransactionManagement  //开启事务</span><br><span class="line">@Configuration  //配置类注解</span><br><span class="line">public class MybatisPlusConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public MybatisPlusInterceptor mybatisPlusInterceptor() &#123;</span><br><span class="line">        MybatisPlusInterceptor mybatisPlusInterceptor = new MybatisPlusInterceptor();</span><br><span class="line">        mybatisPlusInterceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor());//乐观锁插件拦截器OptimisticLockerInnerInterceptor</span><br><span class="line">        return mybatisPlusInterceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>4.测试乐观锁</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testOptimisticLocker()&#123;</span><br><span class="line">    //1、查询用户信息</span><br><span class="line">    User user = userMapper.selectById(1L);</span><br><span class="line">    //2、修改用户信息</span><br><span class="line">    user.setEmail(&quot;123@qq.com&quot;);</span><br><span class="line">    user.setName(&quot;小&quot;);</span><br><span class="line">    //3、更新操作</span><br><span class="line">    userMapper.updateById(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在测试代码中我们并没有更新version数据库的version已经变成2了</p>
<p>5.模拟多线程下乐观锁失败案例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">   public void testOptimisticLocker2()&#123;</span><br><span class="line">       //模拟多线程</span><br><span class="line">       User user = userMapper.selectById(3L);</span><br><span class="line">       user.setEmail(&quot;123jdw@qq.com&quot;);</span><br><span class="line">       user.setName(&quot;帅小伙111&quot;);//我们在这里对线程1修改值</span><br><span class="line"></span><br><span class="line">       //线程2插队</span><br><span class="line">       User user2 = userMapper.selectById(3L);</span><br><span class="line">       user2.setEmail(&quot;321jdw@qq.com&quot;);</span><br><span class="line">       user2.setName(&quot;帅小伙222&quot;);</span><br><span class="line">       userMapper.updateById(user2); //线程2抢先提交</span><br><span class="line"></span><br><span class="line">       userMapper.updateById(user);//线程1失败，乐观锁在这种情况下防止了脏数据存在，没有乐观锁就会有覆盖掉线程2的操作</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="测试查询"><a href="#测试查询" class="headerlink" title="测试查询"></a>测试查询</h4><p>1、查询单用户</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//查询单用户</span><br><span class="line">@Test</span><br><span class="line">public void testSelectBatchId()&#123;</span><br><span class="line">    User user = userMapper.selectById(1L);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>2、多用户查询</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//查询指定多用户</span><br><span class="line">@Test</span><br><span class="line">public void testSelectBatchIds() &#123;</span><br><span class="line">    //Arrays.asList()创建了一个固定大小的集合   </span><br><span class="line">    List&lt;User&gt; users = userMapper.selectBatchIds(Arrays.asList(1, 2, 3));//参数Collection的集合</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//  selectBatchIds 源码</span><br><span class="line">/**</span><br><span class="line"> * 查询（根据ID 批量查询）</span><br><span class="line"> *</span><br><span class="line"> * @param idList 主键ID列表(不能为 null 以及 empty)</span><br><span class="line"> */</span><br><span class="line">List&lt;T&gt; selectBatchIds(@Param(Constants.COLLECTION) Collection&lt;? extends Serializable&gt; idList);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>日志分析：内部解析的是一个 IN 条件</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/06/tfyee.png"></p>
<p>3、条件查询</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//条件查询，-- HashMap</span><br><span class="line">@Test</span><br><span class="line">public void testSelectByMap() &#123;</span><br><span class="line">    HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">    //定义查询条件</span><br><span class="line">    map.put(&quot;name&quot;, &quot;小蒋&quot;); //where k = v</span><br><span class="line">    map.put(&quot;age&quot;,3);</span><br><span class="line">    List&lt;User&gt; users = userMapper.selectByMap(map);</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>日志分析</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/06/tl57e.png"></p>
<h1 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h1><p>1、配置拦截器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MybatisPlusConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public MybatisPlusInterceptor mybatisPlusInterceptor() &#123;</span><br><span class="line">        MybatisPlusInterceptor mybatisPlusInterceptor = new MybatisPlusInterceptor();</span><br><span class="line">        mybatisPlusInterceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor());//创建乐观锁拦截器 OptimisticLockerInnerInterceptor</span><br><span class="line">        mybatisPlusInterceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL)); //插件分页拦截器，我的是mysql</span><br><span class="line">        return mybatisPlusInterceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>2、使用page对象即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//测试分页查询</span><br><span class="line">@Test</span><br><span class="line">public void testPage() &#123;</span><br><span class="line">    Page&lt;User&gt; page = new Page&lt;&gt;(1,5); //开启拦截器后，会注册一个page对象  当前页，每页条数</span><br><span class="line">    //方法源码：   &lt;P extends IPage&lt;T&gt;&gt; P selectPage(P page, @Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);</span><br><span class="line">    userMapper.selectPage(page,null); //分页查询</span><br><span class="line">    page.getRecords().forEach(System.out::println); //获取分页后的数据 打印</span><br><span class="line">    System.out.println(page.getTotal()); //获取记录总数</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**源码</span><br><span class="line"> * 分页构造函数</span><br><span class="line"> *</span><br><span class="line"> * @param current 当前页</span><br><span class="line"> * @param size    每页显示条数</span><br><span class="line"> */</span><br><span class="line">public Page(long current, long size) &#123;</span><br><span class="line">    this(current, size, 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="删除测试"><a href="#删除测试" class="headerlink" title="删除测试"></a>删除测试</h1><h3 id="常见删除"><a href="#常见删除" class="headerlink" title="常见删除"></a>常见删除</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//删除测试</span><br><span class="line">@Test</span><br><span class="line">public void testDeleteById()&#123;</span><br><span class="line">    userMapper.deleteById(1453324799370616833L);</span><br><span class="line">	// userMapper.delete(null); //全部删除</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从上往下分别是：根据id删除，根据 entity 条件删除记录，通过多个id批量删除，根据map条件删除</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/06/491ek.png"></p>
<h3 id="逻辑删除"><a href="#逻辑删除" class="headerlink" title="逻辑删除"></a>逻辑删除</h3><p>物理删除：在数据库中移除</p>
<p>逻辑删除：数据库中没有移除，而是在代码中使用一个变量来使他失效！(如：delete = 0 =&gt; delete = 1; )</p>
<p>就比如，管理员可以查看被删除的记录！防止数据丢失。类似于回收站。用户就没法查看删除记录。</p>
<p>1、在数据库添加deleted字段</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/06/49poj.png"></p>
<p>2、同步实体类中，同时添加<code>@TableLogic//逻辑删除</code>注解</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@TableLogic//逻辑删除</span><br><span class="line">private Integer deleted;</span><br></pre></td></tr></table></figure>
<p>3、在配置文件yml中配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mybatis-plus:</span><br><span class="line">  global-config:</span><br><span class="line">    db-config:</span><br><span class="line">      logic-delete-field: flag  # 全局逻辑删除的实体字段名(since 3.3.0,配置后可以不加步骤2的注解)</span><br><span class="line">      logic-delete-value: 1 # 逻辑已删除值(默认为 1)</span><br><span class="line">      logic-not-delete-value: 0 # 逻辑未删除值(默认为 0)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>4、测试删除</p>
<p>执行删除操作，实际上是执行更新操作，把deleted字段改为1了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    @Test</span><br><span class="line">public void testDeleteById()&#123;</span><br><span class="line">    userMapper.deleteById(1L);</span><br><span class="line">	// userMapper.delete(null); //全部删除</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://i.p04e.com/baid/i/2023/01/06/48zas.png"></p>
<p>数据库中也是没被删，改了值而已</p>
<p>如果我们再去查询这个id=1的用户发现，查不到，mybatis-plus 自动拼接了deleted字段在where中判断。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testSelectBatchId() &#123;</span><br><span class="line">    User user = userMapper.selectById(1L);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://i.p04e.com/baid/i/2023/01/06/twyz6.png"></p>
<p>性能分析插件<br>官方使用的p6spy性能有损耗，推荐使用其他第三方性能分析插件，比如阿里巴巴的Druid。</p>
<p>条件构造器Wrapper（重点）<br>之前我们写crud时候经常碰到一个参数叫做wrapper，我们写的都是null，他到底是什么。</p>
<p>官方链接，条件构造器</p>
<p>我们之前一直是增删改查，没有一个是带条件的，而这个条件构造器就相当于sql中加了一个where,</p>
<p>QueryWrapper和 UpdateWrapper,分别是用于生成查和改 的 sql 的 where 条件</p>
<p>例如, 查询多条记录与单条记录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   @Test</span><br><span class="line">   void contextLoads() &#123;</span><br><span class="line">       //----------查询多个</span><br><span class="line">       //查询一个复杂的，比如查询用户name、邮箱不为空，年龄大于20的用户</span><br><span class="line">       QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;(); //首先新建一个 QueryWrapper</span><br><span class="line">       //链式编程 添加查询条件</span><br><span class="line">       wrapper.isNotNull(&quot;name&quot;)</span><br><span class="line">               .eq(&quot;email&quot;,&quot;2455555659@qq.com&quot;)</span><br><span class="line">               .ge(&quot;age&quot;,12);  </span><br><span class="line">       userMapper.selectList(wrapper).forEach(System.out::println); </span><br><span class="line">	//----------查询单个</span><br><span class="line">       User user = userMapper.selectOne(wrapper); //出现多个结果会报错，查询一个</span><br><span class="line">       System.out.println(&quot;user = &quot; + user);</span><br><span class="line">   &#125;</span><br><span class="line">//        eq相等   ne不相等，   gt大于，    lt小于         ge大于等于       le 小于等于</span><br><span class="line">//        equal/ not equal/ greater than/ less than/ less than or equal/ great than or equal/</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>日志分析，就是在where中添加了多个条件</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/06/m1z7.png"></p>
<p>区间查询与计数，between()，selectCount()</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">void test2() &#123;</span><br><span class="line">    //查询区间内的记录</span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;();</span><br><span class="line">    wrapper.between(&quot;age&quot;,20,30);</span><br><span class="line">    Integer count = userMapper.selectCount(wrapper);</span><br><span class="line">    System.out.println(&quot;count = &quot; + count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">void test3() &#123;</span><br><span class="line">    //模糊查询</span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;();</span><br><span class="line">    wrapper.like(&quot;name&quot;,99)         //  名字中 存在 99</span><br><span class="line">            .notLike(&quot;name&quot;,6)      //  名字中 不存在 6</span><br><span class="line">            .likeRight(&quot;email&quot;,2)   //  邮箱 最右边是m  %m</span><br><span class="line">            .likeLeft(&quot;email&quot;,&quot;m&quot;); //  邮箱 最左边是2  2%</span><br><span class="line">    userMapper.selectMaps(wrapper);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://i.p04e.com/baid/i/2023/01/06/u3nbr.png"></p>
<p>子查询（多表查询）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void test4() &#123;</span><br><span class="line">    //子查询</span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;();</span><br><span class="line">    wrapper.inSql(&quot;id&quot;,&quot;select id from table where id &lt;2&quot;);</span><br><span class="line">    userMapper.selectObjs(wrapper).forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://i.p04e.com/baid/i/2023/01/06/m70o.png"></p>
<p>排序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">void test5() &#123;</span><br><span class="line">    //排序 </span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;();</span><br><span class="line">    wrapper.orderByAsc(&quot;id&quot;);  //根据id升序排列   降序orderByDesc()略</span><br><span class="line">    userMapper.selectList(wrapper).forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://i.p04e.com/baid/i/2023/01/06/4bnd9.png"></p>
<p>分组，条件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">void test7() &#123;</span><br><span class="line">    //分组排序</span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;();</span><br><span class="line">    wrapper.groupBy(&quot;version&quot;).having(&quot;version = 1&quot;);</span><br><span class="line">    userMapper.selectList(wrapper).forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://i.p04e.com/baid/i/2023/01/06/4c1xj.png"></p>
<h1 id="代码自动生成器（重点）"><a href="#代码自动生成器（重点）" class="headerlink" title="代码自动生成器（重点）"></a>代码自动生成器（重点）</h1><p>AutoGenerator 是 MyBatis-Plus 的代码生成器，通过 AutoGenerator 可以快速生成 Entity、Mapper、Mapper XML、Service、Controller 等各个模块的代码，极大的提升了开发效率。</p>
<p><strong>使用步骤</strong></p>
<p><strong>配置依赖，添加如下依赖</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- mp 代码生成器 依赖 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;com.baomidou&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;3.4.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- 导入swagger --&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;io.swagger&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;swagger-annotations&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;1.5.20&lt;/version&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">&lt;!-- 添加模板引擎，thymeleaf 还有freemarker都是模板引擎 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在任意文件夹新建立一个类进行配置</p>
<p>类的代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.jdw;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.annotation.DbType;</span><br><span class="line">import com.baomidou.mybatisplus.annotation.FieldFill;</span><br><span class="line">import com.baomidou.mybatisplus.annotation.IdType;</span><br><span class="line">import com.baomidou.mybatisplus.core.exceptions.MybatisPlusException;</span><br><span class="line">import com.baomidou.mybatisplus.core.toolkit.StringPool;</span><br><span class="line">import com.baomidou.mybatisplus.core.toolkit.StringUtils;</span><br><span class="line">import com.baomidou.mybatisplus.generator.AutoGenerator;</span><br><span class="line">import com.baomidou.mybatisplus.generator.InjectionConfig;</span><br><span class="line">import com.baomidou.mybatisplus.generator.config.*;</span><br><span class="line">import com.baomidou.mybatisplus.generator.config.po.TableFill;</span><br><span class="line">import com.baomidou.mybatisplus.generator.config.po.TableInfo;</span><br><span class="line">import com.baomidou.mybatisplus.generator.config.rules.DateType;</span><br><span class="line">import com.baomidou.mybatisplus.generator.config.rules.NamingStrategy;</span><br><span class="line">import com.baomidou.mybatisplus.generator.engine.FreemarkerTemplateEngine;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">// 演示例子，执行 main 方法控制台输入模块表名回车自动生成对应项目目录中</span><br><span class="line">public class CodeGenerator &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * 读取控制台内容</span><br><span class="line">     * &lt;/p&gt;</span><br><span class="line">     */</span><br><span class="line">    public static String scanner(String tip) &#123;</span><br><span class="line">        Scanner scanner = new Scanner(System.in);</span><br><span class="line">        StringBuilder help = new StringBuilder();</span><br><span class="line">        help.append(&quot;请输入&quot; + tip + &quot;：&quot;);</span><br><span class="line">        System.out.println(help.toString());</span><br><span class="line">        if (scanner.hasNext()) &#123;</span><br><span class="line">            String ipt = scanner.next();</span><br><span class="line">            if (StringUtils.isNotBlank(ipt)) &#123;</span><br><span class="line">                return ipt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        throw new MybatisPlusException(&quot;请输入正确的&quot; + tip + &quot;！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 代码生成器</span><br><span class="line">        //构建一个代码自动生成器对象</span><br><span class="line">        AutoGenerator mpg = new AutoGenerator();</span><br><span class="line"></span><br><span class="line">        // 1、创建全局配置类的对象</span><br><span class="line">        GlobalConfig gc = new GlobalConfig();</span><br><span class="line">        //获取当前项目路径</span><br><span class="line">        String projectPath = System.getProperty(&quot;user.dir&quot;);</span><br><span class="line">        System.out.println(&quot;projectPath = &quot; + projectPath);</span><br><span class="line">        //自动生成代码存放的路径</span><br><span class="line">        gc.setOutputDir(projectPath + &quot;/src/main/java&quot;);</span><br><span class="line">        //设置 --作者注释</span><br><span class="line">        gc.setAuthor(&quot;jdw&quot;);</span><br><span class="line">        //是否打开文件夹</span><br><span class="line">        gc.setOpen(false);</span><br><span class="line">        //是否覆盖已有文件</span><br><span class="line">        gc.setFileOverride(false);</span><br><span class="line">        //各层文件名称方式，例如： %sAction 生成 UserAction  %s占位符</span><br><span class="line">        gc.setServiceName(&quot;%sService&quot;);</span><br><span class="line">        //设置日期策略  date类型</span><br><span class="line">        gc.setDateType(DateType.ONLY_DATE);</span><br><span class="line">        //设置主键策略 雪花算法</span><br><span class="line">        gc.setIdType(IdType.ASSIGN_ID);</span><br><span class="line">        //设置开启 swagger2 模式</span><br><span class="line">        gc.setSwagger2(true);</span><br><span class="line">        //把全局配置放入代码生成器</span><br><span class="line">        mpg.setGlobalConfig(gc);</span><br><span class="line"></span><br><span class="line">        // 2、数据源配置</span><br><span class="line">        DataSourceConfig dsc = new DataSourceConfig();</span><br><span class="line">        dsc.setUrl(&quot;jdbc:mysql://localhost:3306/vueblog?useUnicode=true&amp;useSSL=false&amp;characterEncoding=utf8&amp;serverTimezone=Asia/Shanghai&quot;);</span><br><span class="line">        dsc.setDriverName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><span class="line">        dsc.setUsername(&quot;root&quot;);</span><br><span class="line">        dsc.setPassword(&quot;123456&quot;);</span><br><span class="line">        dsc.setDbType(DbType.MYSQL);</span><br><span class="line">        mpg.setDataSource(dsc); //把数据源配置加入到代码生成器</span><br><span class="line"></span><br><span class="line">        // 3、包配置</span><br><span class="line">        PackageConfig pc = new PackageConfig();</span><br><span class="line">        pc.setParent(&quot;com.jdw&quot;);</span><br><span class="line">        pc.setEntity(&quot;entity&quot;);</span><br><span class="line">        pc.setMapper(&quot;mapper&quot;);</span><br><span class="line">        pc.setService(&quot;service&quot;);</span><br><span class="line">        pc.setController(&quot;controller&quot;);</span><br><span class="line">        // ...  有默认值，点击查看源码</span><br><span class="line">        mpg.setPackageInfo(pc);//包加入代码生成器</span><br><span class="line"></span><br><span class="line">        // 4、策略配置</span><br><span class="line">        StrategyConfig strategy = new StrategyConfig();</span><br><span class="line">        //下划线转驼峰命名  表</span><br><span class="line">        strategy.setNaming(NamingStrategy.underline_to_camel);</span><br><span class="line">        // 下划线转驼峰命名字段</span><br><span class="line">        strategy.setColumnNaming(NamingStrategy.underline_to_camel);</span><br><span class="line">        //实体类是否加上lombok注解</span><br><span class="line">        strategy.setEntityLombokModel(true);</span><br><span class="line">        //控制层采用RestControllerStyle注解</span><br><span class="line">        strategy.setRestControllerStyle(true);</span><br><span class="line">        // RequestMapping中 驼峰转连字符 -</span><br><span class="line">        strategy.setControllerMappingHyphenStyle(true);</span><br><span class="line">        //要映射的数据库表名  （重点）</span><br><span class="line">        strategy.setInclude(scanner(&quot;表名，多个英文逗号分割&quot;).split(&quot;,&quot;));</span><br><span class="line">        //添加表名前缀</span><br><span class="line">        //strategy.setTablePrefix(&quot;m_&quot;); //自动拼接上m_</span><br><span class="line">        //逻辑删除字段名</span><br><span class="line">        strategy.setLogicDeleteFieldName(&quot;deleted&quot;);</span><br><span class="line">        //乐观锁字段名</span><br><span class="line">        strategy.setVersionFieldName(&quot;version&quot;);</span><br><span class="line">        // -------自动填充策略</span><br><span class="line">        ArrayList&lt;TableFill&gt; fillList = new ArrayList&lt;&gt;();</span><br><span class="line">        fillList.add(new TableFill(&quot;createTime&quot;, FieldFill.INSERT));</span><br><span class="line">        fillList.add(new TableFill(&quot;updateTime&quot;,FieldFill.INSERT_UPDATE));</span><br><span class="line">        // 参数是 List&lt;TableFill&gt; 的链表</span><br><span class="line">        strategy.setTableFillList(fillList);</span><br><span class="line">        mpg.setStrategy(strategy);</span><br><span class="line"></span><br><span class="line">        //---------------------------------</span><br><span class="line">        // 自定义配置</span><br><span class="line">        InjectionConfig cfg = new InjectionConfig() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void initMap() &#123;</span><br><span class="line">                // to do nothing</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        // 如果模板引擎是 freemarker</span><br><span class="line">        String templatePath = &quot;/templates/mapper.xml.ftl&quot;;</span><br><span class="line">        // 如果模板引擎是 velocity</span><br><span class="line">        // String templatePath = &quot;/templates/mapper.xml.vm&quot;;</span><br><span class="line"></span><br><span class="line">        // 自定义输出配置</span><br><span class="line">        List&lt;FileOutConfig&gt; focList = new ArrayList&lt;&gt;();</span><br><span class="line">        // 自定义配置会被优先输出</span><br><span class="line">        focList.add(new FileOutConfig(templatePath) &#123;</span><br><span class="line">            @Override </span><br><span class="line">            //输出了 静态资源下的 Mapper</span><br><span class="line">            public String outputFile(TableInfo tableInfo) &#123;</span><br><span class="line">                // 自定义输出文件名 ， 如果你 Entity 设置了前后缀、此处注意 xml 的名称会跟着发生变化！！</span><br><span class="line">                return projectPath + &quot;/src/main/resources/mapper/&quot; + pc.getModuleName()</span><br><span class="line">                        + &quot;/&quot; + tableInfo.getEntityName() + &quot;Mapper&quot; + StringPool.DOT_XML;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        cfg.setFileOutConfigList(focList);</span><br><span class="line">        mpg.setCfg(cfg);</span><br><span class="line"></span><br><span class="line">        //        FreemarkerTemplateEngine模板引擎</span><br><span class="line">        mpg.setTemplateEngine(new FreemarkerTemplateEngine());</span><br><span class="line">        mpg.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Mybatis-Plus</tag>
        <tag>乐观锁</tag>
        <tag>CRUD</tag>
        <tag>代码生成器</tag>
      </tags>
  </entry>
  <entry>
    <title>API接口文档利器：Swagger,Postman</title>
    <url>/2023/01/06/API%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3%E5%88%A9%E5%99%A8%EF%BC%9ASwagger-Postman/</url>
    <content><![CDATA[<h2 id="API接口文档利器：Swagger"><a href="#API接口文档利器：Swagger" class="headerlink" title="API接口文档利器：Swagger"></a><strong>API</strong>接口文档利器：Swagger</h2><h3 id="Swagger介绍"><a href="#Swagger介绍" class="headerlink" title="Swagger介绍"></a><strong>Swagger</strong>介绍</h3><p>Swagger 是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务</p>
<p>(<a href="https://swagger.io/">https://swagger.io/</a>)。 它的主要作用是：<span id="more"></span></p>
<ol>
<li><p>使得前后端分离开发更加方便，有利于团队协作</p>
</li>
<li><p>接口的文档在线自动生成，降低后端开发人员编写接口文档的负担</p>
</li>
<li><p>功能测试</p>
</li>
</ol>
<p>Spring已经将Swagger纳入自身的标准，建立了Spring-swagger项目，现在叫Springfox。通过在项目中引入Springfox ，即可非常简单快捷的使用Swagger。</p>
<h3 id="SpringBoot集成Swagger"><a href="#SpringBoot集成Swagger" class="headerlink" title="SpringBoot集成Swagger"></a><strong>SpringBoot</strong>集成Swagger</h3><p>项目中添加依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!‐‐ Swagger依赖 ‐‐&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;springfox‐swagger2&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;springfox‐swagger‐ui&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>工程的conﬁg包中添加一个Swagger配置类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.shanjupay.merchant.config;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty; import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration; import springfox.documentation.builders.ApiInfoBuilder; import springfox.documentation.builders.PathSelectors;</span><br><span class="line">import springfox.documentation.builders.RequestHandlerSelectors; import springfox.documentation.service.ApiInfo;</span><br><span class="line">import springfox.documentation.service.Contact; import springfox.documentation.spi.DocumentationType;</span><br><span class="line">import springfox.documentation.spring.web.plugins.Docket;</span><br><span class="line">import springfox.documentation.swagger2.annotations.EnableSwagger2;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">@ConditionalOnProperty(prefix = &quot;swagger&quot;,value = &#123;&quot;enable&quot;&#125;,havingValue = &quot;true&quot;) @EnableSwagger2</span><br><span class="line">public class SwaggerConfiguration &#123;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public Docket buildDocket() &#123;</span><br><span class="line">return new Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">.apiInfo(buildApiInfo())</span><br><span class="line">.select()</span><br><span class="line">// 要扫描的API(Controller)基础包</span><br><span class="line"></span><br><span class="line">.apis(RequestHandlerSelectors.basePackage(&quot;com.shanjupay.merchant.controller&quot;))</span><br><span class="line">.paths(PathSelectors.any())</span><br><span class="line">.build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">*@param</span><br><span class="line"></span><br><span class="line">*@return springfox.documentation.service.ApiInfo</span><br><span class="line">*@Title: 构建API基本信息</span><br><span class="line">*@methodName: buildApiInfo</span><br><span class="line">*/</span><br><span class="line">private ApiInfo buildApiInfo() &#123;</span><br><span class="line">Contact contact = new Contact(&quot;开发者&quot;,&quot;&quot;,&quot;&quot;); return new ApiInfoBuilder()</span><br><span class="line">.title(&quot;闪聚支付‐商户应用API文档&quot;)</span><br><span class="line">.description(&quot;&quot;)</span><br><span class="line">.contact(contact)</span><br><span class="line">.version(&quot;1.0.0&quot;).build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加SpringMVC配置类：WebMvcConﬁg，让外部可直接访问Swagger文档</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.shanjupay.merchant.config;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line">import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry; import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">public class WebMvcConfig implements WebMvcConfigurer &#123;</span><br><span class="line">/**</span><br><span class="line">*添加静态资源文件，外部可以直接访问地址</span><br><span class="line">*</span><br><span class="line">*@param registry</span><br><span class="line">*/ @Override</span><br><span class="line">public void addResourceHandlers(ResourceHandlerRegistry registry) &#123; registry.addResourceHandler(&quot;/**&quot;).addResourceLocations(&quot;classpath:/static/&quot;);</span><br><span class="line"></span><br><span class="line">registry.addResourceHandler(&quot;swagger‐ui.html&quot;)</span><br><span class="line">.addResourceLocations(&quot;classpath:/META‐INF/resources/&quot;);</span><br><span class="line"></span><br><span class="line">registry.addResourceHandler(&quot;/webjars/**&quot;)</span><br><span class="line">.addResourceLocations(&quot;classpath:/META‐INF/resources/webjars/&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Swagger常用注解"><a href="#Swagger常用注解" class="headerlink" title="Swagger常用注解"></a><strong>Swagger</strong>常用注解</h3><p>在Java类中添加Swagger的注解即可生成Swagger接口文档，常用Swagger注解如下：</p>
<p>@Api：修饰整个类，描述Controller的作用 @ApiOperation：描述一个类的一个方法，或者说一个接口@ApiParam：单个参数的描述信息</p>
<p>@ApiModel：用对象来接收参数</p>
<p>@ApiModelProperty：用对象接收参数时，描述对象的一个字段@ApiResponse：HTTP响应其中1个描述</p>
<p>在Java类中添加Swagger的注解即可生成Swagger接口文档，常用Swagger注解如下：</p>
<p>@Api：修饰整个类，描述Controller的作用 @ApiOperation：描述一个类的一个方法，或者说一个接口@ApiParam：单个参数的描述信息</p>
<p>@ApiModel：用对象来接收参数</p>
<p>@ApiModelProperty：用对象接收参数时，描述对象的一个字段@ApiResponse：HTTP响应其中1个描述</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>属性</strong></th>
<th><strong>取值</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>paramType</td>
<td></td>
<td>查询参数类型</td>
</tr>
<tr>
<td></td>
<td>path</td>
<td>以地址的形式提交数据</td>
</tr>
<tr>
<td></td>
<td>query</td>
<td>直接跟参数完成自动映射赋值</td>
</tr>
<tr>
<td></td>
<td>body</td>
<td>以流的形式提交 仅支持POST</td>
</tr>
<tr>
<td></td>
<td>header</td>
<td>参数在request headers 里边提交</td>
</tr>
<tr>
<td></td>
<td>form</td>
<td>以form表单的形式提交 仅支持POST</td>
</tr>
<tr>
<td>dataType</td>
<td></td>
<td>参数的数据类型 只作为标志说明，并没有实际验证</td>
</tr>
<tr>
<td></td>
<td>Long</td>
<td></td>
</tr>
<tr>
<td></td>
<td>String</td>
<td></td>
</tr>
<tr>
<td>name</td>
<td></td>
<td>接收参数名</td>
</tr>
<tr>
<td>value</td>
<td></td>
<td>接收参数的意义描述</td>
</tr>
<tr>
<td>required</td>
<td></td>
<td>参数是否必填</td>
</tr>
<tr>
<td></td>
<td>true</td>
<td>必填</td>
</tr>
<tr>
<td></td>
<td>false</td>
<td>非必填</td>
</tr>
<tr>
<td>defaultValue</td>
<td></td>
<td>默认值</td>
</tr>
</tbody>
</table>
</div>
<p>上边的属性后边编写程序时用到哪个我再详细讲解，下边写一个swagger的简单例子，我们在MerchantController   中添加Swagger注解，代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Api(value = &quot;商户平台‐商户相关&quot;, tags = &quot;商户平台‐商户相关&quot;, description = &quot;商户平台‐商户相关&quot;) @RestController</span><br><span class="line">public class MerchantController &#123;</span><br><span class="line"></span><br><span class="line">@Reference</span><br><span class="line">private MerchantService merchantService;</span><br></pre></td></tr></table></figure>
<p>Swagger生成API文档的工作原理：</p>
<p>1、shanjupay-merchant-application启动时会扫描到SwaggerConﬁguration类</p>
<p>2、在此类中指定了扫描包路径com.shanjupay.merchant.controller，会找到在此包下及子包下标记有@RestController注解的controller类</p>
<p>3、根据controller类中的Swagger注解生成API文档</p>
<h2 id="接口调试利器Postman"><a href="#接口调试利器Postman" class="headerlink" title="接口调试利器Postman"></a><strong>接口调试利器</strong>Postman</h2><p>Postman是一款功能强大的http接口测试工具，使用Postman可以完成http各种请求的功能测试。作为服务器端   开发人员，当一个业务功能开发完毕后，应该用Postman进行功能测试。</p>
<p>1、请自行在本机安装Postman</p>
<p>2、新建集合(建议一个微服务新建一个对应的集合)：商户应用</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/06/4nrlz.png"><br><img src="https://i.p04e.com/baid/i/2023/01/06/nysy.png"></p>
<p>填写新建商户接口地址和请求类型后，点击Send发送请求</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/06/6cromn.png"></p>
]]></content>
      <tags>
        <tag>Swagger</tag>
        <tag>Postman</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot系列：运行原理</title>
    <url>/2023/01/09/SpringBoot%E7%B3%BB%E5%88%97%EF%BC%9A%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>《SpringBoot系列部分摘于网络，仅供个人笔记学习使用》</p>
<h2 id="运行原理："><a href="#运行原理：" class="headerlink" title="运行原理："></a>运行原理：</h2><p>一个普通的HelloSpringBoot，是怎么运行的呢？</p>
<span id="more"></span>
<h3 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h3><p>父依赖</p>
<p>依赖于父项目，管理项目的资源过滤及插件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.2.5.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">&lt;/parent&gt;</span><br></pre></td></tr></table></figure>
<p>点进去，发现还有一个父依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.2.5.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;relativePath&gt;../../spring-boot-dependencies&lt;/relativePath&gt;</span><br><span class="line">&lt;/parent&gt;</span><br></pre></td></tr></table></figure>
<p>这是真正管理SpringBoot应用里面所有依赖版本的地方，SpringBoot的版本控制中心；</p>
<p><strong>以后我们导入依赖默认是不需要写版本；</strong></p>
<p><strong>但如果导入的包没有在依赖中管理着就需要手动配置版本了；</strong></p>
<h2 id="启动器-spring-boot-starter"><a href="#启动器-spring-boot-starter" class="headerlink" title="启动器 spring-boot-starter"></a>启动器 spring-boot-starter</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p><strong>springboot-boot-starter-xxx</strong>：就是spring-boot的场景启动器</p>
<p><strong>spring-boot-starter-web</strong>：帮我们导入了web模块正常运行所依赖的组件；</p>
<p>SpringBoot将所有的功能场景都抽取出来，做成一个个的starter （启动器），只需要在项目中引入这些starter即可，所有相关的依赖都会导入进来 ， 我们要用什么功能就导入什么样的场景启动器即可 ；我们未来也可以自己自定义 starter；</p>
<h2 id="主启动类"><a href="#主启动类" class="headerlink" title="主启动类"></a><strong>主启动类</strong></h2><p>分析完了 pom.xml 来看看这个启动类</p>
<h3 id="默认的主启动类"><a href="#默认的主启动类" class="headerlink" title="默认的主启动类"></a>默认的主启动类</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/@SpringBootApplication 来标注一个主程序类</span><br><span class="line">//说明这是一个Spring Boot应用</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class SpringbootApplication &#123;</span><br><span class="line"></span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">     //以为是启动了一个方法，没想到启动了一个服务</span><br><span class="line">      SpringApplication.run(SpringbootApplication.class, args);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是<strong>一个简单的启动类并不简单！</strong>我们来分析一下这些注解都干了什么</p>
<h3 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h3><p>作用：标注在某个类上说明这个类是SpringBoot的主配置类 ， SpringBoot就应该运行这个类的main方法来启动SpringBoot应用；</p>
<p>进入这个注解：可以看到上面还有很多其他注解！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SpringBootConfiguration</span><br><span class="line">@EnableAutoConfiguration</span><br><span class="line">@ComponentScan(</span><br><span class="line">    excludeFilters = &#123;@Filter(</span><br><span class="line">    type = FilterType.CUSTOM,</span><br><span class="line">    classes = &#123;TypeExcludeFilter.class&#125;</span><br><span class="line">), @Filter(</span><br><span class="line">    type = FilterType.CUSTOM,</span><br><span class="line">    classes = &#123;AutoConfigurationExcludeFilter.class&#125;</span><br><span class="line">)&#125;</span><br><span class="line">)</span><br><span class="line">public @interface SpringBootApplication &#123;</span><br><span class="line">    // ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h3><p>这个注解在Spring中很重要 ,它对应XML配置中的元素。</p>
<p>作用：自动扫描并加载符合条件的组件或者bean ， 将这个bean定义加载到IOC容器中</p>
<h3 id="SpringBootConfiguration"><a href="#SpringBootConfiguration" class="headerlink" title="@SpringBootConfiguration"></a>@SpringBootConfiguration</h3><p>作用：SpringBoot的配置类 ，标注在某个类上 ， 表示这是一个SpringBoot的配置类；</p>
<p>我们继续进去这个注解查看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">// 点进去得到下面的 @Component</span><br><span class="line">@Configuration</span><br><span class="line">public @interface SpringBootConfiguration &#123;&#125;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">public @interface Configuration &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 @Configuration，说明这是一个配置类 ，配置类就是对应Spring的xml 配置文件；</p>
<p>里面的 @Component 这就说明，启动类本身也是Spring中的一个组件而已，负责启动应用！</p>
<p>我们回到 SpringBootApplication 注解中继续看。</p>
<h3 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h3><p><strong>@EnableAutoConfiguration ：开启自动配置功能</strong></p>
<p>以前我们需要自己配置的东西，而现在SpringBoot可以自动帮我们配置 ；@EnableAutoConfiguration告诉SpringBoot开启自动配置功能，这样自动配置才能生效；</p>
<p>点进注解接续查看：</p>
<p><strong>@AutoConfigurationPackage ：自动配置包</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@Import(&#123;Registrar.class&#125;)</span><br><span class="line">public @interface AutoConfigurationPackage &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>@import</strong> ：Spring底层注解@import ， 给容器中导入一个组件</p>
<p>Registrar.class 作用：将主启动类的所在包及包下面所有子包里面的所有组件扫描到Spring容器 ；</p>
<p>这个分析完了，退到上一步，继续看</p>
<p><strong>@Import({AutoConfigurationImportSelector.class}) ：给容器导入组件 ；</strong></p>
<p>AutoConfigurationImportSelector ：自动配置导入选择器，那么它会导入哪些组件的选择器呢？我们点击去这个类看源码：</p>
<p>1、这个类中有一个这样的方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">// 获得候选的配置</span><br><span class="line">protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) &#123;</span><br><span class="line">    //这里的getSpringFactoriesLoaderFactoryClass（）方法</span><br><span class="line">    //返回的就是我们最开始看的启动自动导入配置文件的注解类；EnableAutoConfiguration</span><br><span class="line">    List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader());</span><br><span class="line">    Assert.notEmpty(configurations, &quot;No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.&quot;);</span><br><span class="line">    return configurations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、这个方法又调用了  SpringFactoriesLoader 类的静态方法！我们进入SpringFactoriesLoader类loadFactoryNames() 方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryClass, @Nullable ClassLoader classLoader) &#123;</span><br><span class="line">    String factoryClassName = factoryClass.getName();</span><br><span class="line">    //这里它又调用了 loadSpringFactories 方法</span><br><span class="line">    return (List)loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、我们继续点击查看 loadSpringFactories 方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">private static Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(@Nullable ClassLoader classLoader) &#123;</span><br><span class="line">    //获得classLoader ， 我们返回可以看到这里得到的就是EnableAutoConfiguration标注的类本身</span><br><span class="line">    MultiValueMap&lt;String, String&gt; result = (MultiValueMap)cache.get(classLoader);</span><br><span class="line">    if (result != null) &#123;</span><br><span class="line">        return result;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            //去获取一个资源 &quot;META-INF/spring.factories&quot;</span><br><span class="line">            Enumeration&lt;URL&gt; urls = classLoader != null ? classLoader.getResources(&quot;META-INF/spring.factories&quot;) : ClassLoader.getSystemResources(&quot;META-INF/spring.factories&quot;);</span><br><span class="line">            LinkedMultiValueMap result = new LinkedMultiValueMap();</span><br><span class="line"></span><br><span class="line">            //将读取到的资源遍历，封装成为一个Properties</span><br><span class="line">            while(urls.hasMoreElements()) &#123;</span><br><span class="line">                URL url = (URL)urls.nextElement();</span><br><span class="line">                UrlResource resource = new UrlResource(url);</span><br><span class="line">                Properties properties = PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line">                Iterator var6 = properties.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">                while(var6.hasNext()) &#123;</span><br><span class="line">                    Entry&lt;?, ?&gt; entry = (Entry)var6.next();</span><br><span class="line">                    String factoryClassName = ((String)entry.getKey()).trim();</span><br><span class="line">                    String[] var9 = StringUtils.commaDelimitedListToStringArray((String)entry.getValue());</span><br><span class="line">                    int var10 = var9.length;</span><br><span class="line"></span><br><span class="line">                    for(int var11 = 0; var11 &lt; var10; ++var11) &#123;</span><br><span class="line">                        String factoryName = var9[var11];</span><br><span class="line">                        result.add(factoryClassName, factoryName.trim());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            cache.put(classLoader, result);</span><br><span class="line">            return result;</span><br><span class="line">        &#125; catch (IOException var13) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;Unable to load factories from location [META-INF/spring.factories]&quot;, var13);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4、发现一个多次出现的文件：spring.factories，全局搜索它</p>
<h2 id="spring-factories"><a href="#spring-factories" class="headerlink" title="spring.factories"></a>spring.factories</h2><p>我们根据源头打开spring.factories ， 看到了很多自动配置的文件；这就是自动配置根源所在！</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/09/4309.png"></p>
<p><strong>WebMvcAutoConfiguration</strong></p>
<p>我们在上面的自动配置类随便找一个打开看看，比如 ：WebMvcAutoConfiguration</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/09/ucko.png"></p>
<p>可以看到这些一个个的都是JavaConfig配置类，而且都注入了一些Bean，可以找一些自己认识的类，看着熟悉一下！</p>
<p>所以，自动配置真正实现是从classpath中搜寻所有的META-INF/spring.factories配置文件 ，并将其中对应的 org.springframework.boot.autoconfigure. 包下的配置项，通过反射实例化为对应标注了 @Configuration的JavaConfig形式的IOC容器配置类 ， 然后将这些都汇总成为一个实例并加载到IOC容器中。</p>
<p><strong>结论：</strong></p>
<ol>
<li>SpringBoot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值</li>
<li>将这些值作为自动配置类导入容器 ， 自动配置类就生效 ， 帮我们进行自动配置工作；</li>
<li>整个J2EE的整体解决方案和自动配置都在springboot-autoconfigure的jar包中；</li>
<li>它会给容器中导入非常多的自动配置类 （xxxAutoConfiguration）, 就是给容器中导入这个场景需要的所有组件 ， 并配置好这些组件 ；</li>
<li>有了自动配置类 ， 免去了我们手动编写配置注入功能组件等的工作；</li>
</ol>
<h2 id="SpringApplication"><a href="#SpringApplication" class="headerlink" title="SpringApplication"></a><strong>SpringApplication</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class SpringbootApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(SpringbootApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>SpringApplication.run分析</strong></p>
<p>分析该方法主要分两部分，一部分是SpringApplication的实例化，二是run方法的执行；</p>
<p>SpringApplication这个类主要做了以下四件事情：</p>
<p>1、推断应用的类型是普通的项目还是Web项目</p>
<p>2、查找并加载所有可用初始化器 ， 设置到initializers属性中</p>
<p>3、找出所有的应用程序监听器，设置到listeners属性中</p>
<p>4、推断并设置main方法的定义类，找到运行的主类</p>
<p>查看构造器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public SpringApplication(ResourceLoader resourceLoader, Class... primarySources) &#123;</span><br><span class="line">    // ......</span><br><span class="line">    this.webApplicationType = WebApplicationType.deduceFromClasspath();</span><br><span class="line">    this.setInitializers(this.getSpringFactoriesInstances();</span><br><span class="line">    this.setListeners(this.getSpringFactoriesInstances(ApplicationListener.class));</span><br><span class="line">    this.mainApplicationClass = this.deduceMainApplicationClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>-SpringBoot</tag>
      </tags>
  </entry>
</search>
