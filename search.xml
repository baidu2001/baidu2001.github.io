<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Linux命令学习和软件安装等</title>
    <url>/2022/09/22/Linux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E7%AD%89/</url>
    <content><![CDATA[<p>自主学习了一天很懒的打字了，大部分就用图片替代吧</p>
<h3 id="VMware安装"><a href="#VMware安装" class="headerlink" title="VMware安装"></a>VMware安装</h3><span id="more"></span>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/3bv.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/vq9g.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/4j8q.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/vq8s.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/3bv_1.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/nd1.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/ncf.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/4je9.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/nc7.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/4je7.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/nc2.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/vtp7.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/nd8.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/4jqh.png"></p>
<h3 id="Linux学习"><a href="#Linux学习" class="headerlink" title="Linux学习"></a>Linux学习</h3><h4 id="Linux目录介绍"><a href="#Linux目录介绍" class="headerlink" title="Linux目录介绍"></a>Linux目录介绍</h4><ul>
<li><code>bin 存放二进制可执行文件</code></li>
<li><code>boot存放系统引导时使用的各种文件</code></li>
<li>`dev存放设备文件</li>
<li><code>etc存放系统配置文件</code></li>
<li>`home存放系统用户的文件</li>
<li><code>lib存放程序运行所需的共享库和内核模块</code></li>
<li><code>opt额外安装的可选应用程序包所放置的位置</code></li>
<li>`root超级用户目录</li>
<li><code>sbin存放二进制可执行文件，只有root用户才能访问tmp存放临时文件</code></li>
<li><code>usr存放系统应用程序</code></li>
<li><code>var存放运行时需要改变数据的文件，例如日志文件</code></li>
</ul>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/4jro.png"></p>
<h4 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h4><p><img src="https://i.p04e.com/baid/i/2022/09/22/4jnd.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/54n6.png"></p>
<mg src="https://i.p04e.com/baid/i/2022/09/22/1cv9d5.png">

<p><img src="https://i.p04e.com/baid/i/2022/09/22/9i2le1.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/1cv9a2.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/1cv9ph.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/6zbte.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/54nf.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/9i2yg5.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/zwjj.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/zwjr.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/6zc0e.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/1cvct3.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/6zbyc.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/zwlb.png"><br><img src="https://i.p04e.com/baid/i/2022/09/22/6zc0z.png"><br><img src="https://i.p04e.com/baid/i/2022/09/22/1cvcwh.png"><br><img src="https://i.p04e.com/baid/i/2022/09/22/zwhl.png"><br><img src="https://i.p04e.com/baid/i/2022/09/22/54nj.png"></p>
<h3 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h3><p><img src="https://i.p04e.com/baid/i/2022/09/22/zwf7.png"><br><img src="https://i.p04e.com/baid/i/2022/09/22/54mm.png"></p>
<h3 id="安装Tomcat"><a href="#安装Tomcat" class="headerlink" title="安装Tomcat"></a>安装Tomcat</h3><p><img src="https://i.p04e.com/baid/i/2022/09/22/4ju0.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">防火墙操作:</span><br><span class="line">查看防火墙状态(systemctl status firewalld、 firewall-cmd --state)</span><br><span class="line"></span><br><span class="line">暂时关闭防火墙(systemctl stop firewalld)</span><br><span class="line"></span><br><span class="line">永久关闭防火墙(systemctl disable firewalld)</span><br><span class="line"></span><br><span class="line">开启防火墙(systemctl start firewalld)</span><br><span class="line"></span><br><span class="line">开放指定端口(firewall-cmd --zone=public --add-port=8080/tcp --permanent)</span><br><span class="line"></span><br><span class="line">关闭指定端口(firewall-cmd --zone=public --remove-port=8080/tcp --permanent)</span><br><span class="line"></span><br><span class="line">立即生效(firewall-cmd --reload)</span><br><span class="line"></span><br><span class="line">查看开放的端口(firewall-cmd --zone=public --list-ports)</span><br><span class="line"></span><br><span class="line">注意:</span><br><span class="line">1、 systemctl是管理Linux中服务的命令，可以对服务进行启动、停止、重启、查看状态等操作</span><br><span class="line"></span><br><span class="line">2、firewall-cmd是Linux中专门用于控制防火墙的命令</span><br><span class="line"></span><br><span class="line">3、为了保证系统安全，服务器的防火墙不建议关闭</span><br></pre></td></tr></table></figure>
<h3 id="安装Mysql"><a href="#安装Mysql" class="headerlink" title="安装Mysql"></a>安装Mysql</h3><p><img src="https://i.p04e.com/baid/i/2022/09/22/nez.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/nfg.png"><br><img src="https://i.p04e.com/baid/i/2022/09/22/vv1m.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/6zmgo.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/zy5i.png"></p>
<h3 id="安装lrzsz"><a href="#安装lrzsz" class="headerlink" title="安装lrzsz"></a>安装lrzsz</h3><p><img src="https://i.p04e.com/baid/i/2022/09/22/vxab.png"></p>
<h3 id="手动部署项目"><a href="#手动部署项目" class="headerlink" title="手动部署项目"></a>手动部署项目</h3><p><img src="https://i.p04e.com/baid/i/2022/09/22/ngn.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/4k8s.png"><br><img src="https://i.p04e.com/baid/i/2022/09/22/4kcp.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/4k7c.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/1d3qa3.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/w00d.png"></p>
<h3 id="通过shell脚本自动部署项目"><a href="#通过shell脚本自动部署项目" class="headerlink" title="通过shell脚本自动部署项目"></a>通过shell脚本自动部署项目</h3><p><img src="https://i.p04e.com/baid/i/2022/09/22/vyu0.png"><br><img src="https://i.p04e.com/baid/i/2022/09/22/nhj.png"><br><img src="https://i.p04e.com/baid/i/2022/09/22/nho.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/10453.png"><br><img src="https://i.p04e.com/baid/i/2022/09/22/70t09.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">echo =================================</span><br><span class="line">echo  自动化部署脚本启动</span><br><span class="line">echo =================================</span><br><span class="line"></span><br><span class="line">echo 停止原来运行中的工程</span><br><span class="line">APP_NAME=helloworld</span><br><span class="line"></span><br><span class="line">tpid=`ps -ef|grep $APP_NAME|grep -v grep|grep -v kill|awk &#x27;&#123;print $2&#125;&#x27;`</span><br><span class="line">if [ $&#123;tpid&#125; ]; then</span><br><span class="line">    echo &#x27;Stop Process...&#x27;</span><br><span class="line">    kill -15 $tpid</span><br><span class="line">fi</span><br><span class="line">sleep 2</span><br><span class="line">tpid=`ps -ef|grep $APP_NAME|grep -v grep|grep -v kill|awk &#x27;&#123;print $2&#125;&#x27;`</span><br><span class="line">if [ $&#123;tpid&#125; ]; then</span><br><span class="line">    echo &#x27;Kill Process!&#x27;</span><br><span class="line">    kill -9 $tpid</span><br><span class="line">else</span><br><span class="line">    echo &#x27;Stop Success!&#x27;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">echo 准备从Git仓库拉取最新代码</span><br><span class="line">cd /usr/local/helloworld</span><br><span class="line"></span><br><span class="line">echo 开始从Git仓库拉取最新代码</span><br><span class="line">git pull</span><br><span class="line">echo 代码拉取完成</span><br><span class="line"></span><br><span class="line">echo 开始打包</span><br><span class="line">output=`mvn clean package -Dmaven.test.skip=true`</span><br><span class="line"></span><br><span class="line">cd target</span><br><span class="line"></span><br><span class="line">echo 启动项目</span><br><span class="line">nohup java -jar helloworld-1.0-SNAPSHOT.jar &amp;&gt; helloworld.log &amp;</span><br><span class="line">echo 项目启动完成</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/vyxp.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/njj.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/njj_1.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/nj1.png"></p>
</mg>]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>防火墙命令</tag>
        <tag>Tomcat</tag>
        <tag>Mysql</tag>
        <tag>lrzsz</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux查看ip地址出错，ens33不显示inet解决</title>
    <url>/2022/09/20/Linux%E6%9F%A5%E7%9C%8Bip%E5%9C%B0%E5%9D%80%E5%87%BA%E9%94%99%EF%BC%8Cens33%E4%B8%8D%E6%98%BE%E7%A4%BAinet%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<p>问题：在 CentOS7中输入 ip addr 时，没有显示出局域网 IP</p>
<span id="more"></span>
<p>一下午尝试了网上各种的修改方法，还是不可以，这里就不一一赘述了。</p>
<h5 id="有两种解决办法"><a href="#有两种解决办法" class="headerlink" title="有两种解决办法"></a>有两种解决办法</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.暂时解决，重新启动虚拟机后ip地址还是会消失</span><br><span class="line"></span><br><span class="line">dhclient ens33  //ens33有时也是32，这里看自己具体的内容</span><br><span class="line"></span><br><span class="line">cd /etc/sysconfig/network-scripts/   </span><br><span class="line">ls</span><br><span class="line">进这个目录下可查看</span><br></pre></td></tr></table></figure>
<p>之后重启后发现ip地址继续隐藏</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi/etc/sysconfig/network-scripts/ifcfg-ens33</span><br><span class="line"></span><br><span class="line">改BOOTPROTO=static</span><br><span class="line">  ONBOOT=yes</span><br><span class="line">  </span><br><span class="line">  之后添加自己的网关掩码等等</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://i.p04e.com/baid/i/2022/09/20/7khnp.png"></p>
<h5 id="那怎么找到自己的DNS等等呢"><a href="#那怎么找到自己的DNS等等呢" class="headerlink" title="那怎么找到自己的DNS等等呢"></a>那怎么找到自己的DNS等等呢</h5><p><img src="https://i.p04e.com/baid/i/2022/09/20/5lp3.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/20/137wp.png"></p>
<p>以上为ip 掩码 网关</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查看文件</span><br><span class="line">/var/lib/dhclient/dhclient.leases</span><br></pre></td></tr></table></figure>
<p><img src="https://i.p04e.com/baid/i/2022/09/20/sqk.png"></p>
<p>即为DNS</p>
<p>此时填回ifcfg-ens33，再次 ip addr</p>
<p><img src="https://i.p04e.com/baid/i/2022/09/20/7nc56.png"></p>
<p>出现inet!</p>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>inet</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL主从同步故障：Slave_SQL_Running:NO</title>
    <url>/2022/10/03/MySQL%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E6%95%85%E9%9A%9C%EF%BC%9ASlave-SQL-Running-NO/</url>
    <content><![CDATA[<p><img src="https://i.p04e.com/baid/i/2022/10/03/3jdmr.png"></p>
<p>Slave_SQL_Running: No</p>
<span id="more"></span>
<p>1.程序可能在slave上进行了写操作</p>
<p>2.也可能是slave机器重起后，事务回滚造成的.</p>
<p>一般是事务回滚造成的：</p>
<p>解决办法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; stop slave ;</span><br><span class="line">mysql&gt; set GLOBAL SQL_SLAVE_SKIP_COUNTER=1;</span><br><span class="line">mysql&gt; start slave ;</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">change master to master_host=&#x27;------&#x27;,master_user=&#x27;xiaoming&#x27;,master_password=&#x27;Root@123456&#x27;,master_log_file=&#x27;mysql-bin.----&#x27;,master_log_pos=---;</span><br></pre></td></tr></table></figure>
<p>——都是自己的</p>
<p><img src="https://i.p04e.com/baid/i/2022/10/03/ifdz.png"></p>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>Mysql</tag>
        <tag>主从复制</tag>
        <tag>错误</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo+github做出一个属于自己的博客!</title>
    <url>/2022/08/26/hexo-github%E5%81%9A%E5%87%BA%E4%B8%80%E4%B8%AA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    博客是按照我自己的方式通过hexo+github搭建出来的，最后的域名是从华为云购买。我会一步步的从初学者的角度向大家讲解，也会解决一些我碰到的问题 ，如果有些问题是在解决不了可以通过我的邮箱联系。</p>
<p><code>这一篇为整体的搭建，问题的解决会在最后</code></p>
<span id="more"></span>
<h3 id="准备工具"><a href="#准备工具" class="headerlink" title="准备工具"></a>准备工具</h3><ul>
<li><p>下载<a href="http://nodejs.cn/download/">node.js</a>，node.js是使用和安装hexo。</p>
</li>
<li><p>下载<a href="https://npm.taobao.org/mirrors/git-for-windows/v2.22.0.windows.1/Git-2.22.0-64-bit.exe">Git</a>,此脚本所有测试都在都在git bash上运行。</p>
</li>
<li><p>并且需要一个github账号</p>
<p>下载的步骤和环境的搭建自行百度就可以，非常简单。</p>
</li>
</ul>
<h4 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h4><ol>
<li>装完之后打开终端 win+r，然后cmd。</li>
</ol>
<p>2.输入指令回车查看版本号(新版的Node.js已自带npm，安装Node.js时会一起安装)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br><span class="line">git --version</span><br></pre></td></tr></table></figure>
<p><img src="/images/01.png"></p>
<p>出现版本号，说明你的电脑上已经有nodejs，npm安装成功</p>
<h4 id="准备hexo"><a href="#准备hexo" class="headerlink" title="准备hexo"></a>准备hexo</h4><p>在命令框里输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line"></span><br><span class="line">////////////////</span><br><span class="line"></span><br><span class="line">hexo -v</span><br></pre></td></tr></table></figure>
<p><img src="/images/02.png"></p>
<p>出现版本号即为安装成功！</p>
<h3 id="登录github"><a href="#登录github" class="headerlink" title="登录github"></a>登录github</h3><p><code>我们要做的就是利用Github的仓库作为我们hexo的一个服务器，将hexo的内容都装进这个仓库里面,让所有的人都可以访问。</code></p>
<h4 id="建仓"><a href="#建仓" class="headerlink" title="建仓"></a>建仓</h4><p>打开github，点击new新建仓库</p>
<p><img src="/images/03.png"></p>
<p><img src="/images/04.png"></p>
<p><code>注意：仓库的名字是有规定的，为自己的名字+.github.io,从上图也可看出。</code></p>
<p><img src="/images/05.png"></p>
<p> <code>跟着我的点，最后创建</code></p>
<p><img src="/images/06.png"></p>
<p>此时就已经建成功了。</p>
<h3 id="将github与本地进行绑定"><a href="#将github与本地进行绑定" class="headerlink" title="将github与本地进行绑定"></a>将github与本地进行绑定</h3><h4 id="设置密钥"><a href="#设置密钥" class="headerlink" title="设置密钥"></a>设置密钥</h4><p>​    随意进入一个文件中，在空白区域右键，点出Git bash here,输入如下指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;邮件地址&quot;  //注意在git里面想要粘贴时，右键Paste,此时输入的邮件地址为绑定的github账号的邮件地址</span><br></pre></td></tr></table></figure>
<p><img src="/images/07.png"></p>
<p><code>此时输入命令后四次回车如图即可，如果出现overwrite时输入 y</code></p>
<p><img src="/images/08.png"></p>
<p>在电脑的这个位置找见.ssh里面以.pub为结尾的文件，以笔记本打开。打开后ctrl  + a  /c</p>
<p>打开github</p>
<p><img src="/images/09.png"></p>
<p>打开Setting</p>
<p><img src="/images/10.png"></p>
<p>打开SSH and GPG keys ，在点绿色的New SSH key</p>
<p><img src="/images/11.png"></p>
<p>可以随便起一个名字，然后将复制的钥匙粘贴进下面的大框。</p>
<p>最后在原来的git命令行输入一下代码，确定是否绑定成功。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>
<p> <img src="/images/12.png"></p>
<p>过程中有一次问答输入 yes ，最后出现 successfully即可。</p>
<h2 id="建立blog并且发布到Github"><a href="#建立blog并且发布到Github" class="headerlink" title="建立blog并且发布到Github"></a>建立blog并且发布到Github</h2><p>git在国外不稳定所以命令有时候还会有网络问题，多试两次或者选择换国内镜像源也可以。</p>
<p>创建一个自己的blog的空文件夹，进入后右键出git bush here；</p>
<p>输入一下命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo init       //初始化hexo  如果成功会发现自己的blog下面会多出很多的内容</span><br><span class="line"></span><br><span class="line">hexo s         //静态生成hexo本地的博客页面</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/images/13.png"></p>
<p>ctrl加点击<a href="http://localhost:4000">http://localhost:4000</a> 即可进入本地的hexo服务器</p>
<p>ctrl + c 即可停止服务器</p>
<p>进入你的blog文件找见下面的 _config.yml文件。打开后进入代码的最下面，将代码改为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: &#x27;git&#x27;</span><br><span class="line">  repository: </span><br><span class="line">  branch: main</span><br><span class="line">//注意冒号后面还有空格</span><br></pre></td></tr></table></figure>
<p><img src="/images/14.png"></p>
<p><img src="/images/15.png"></p>
<p>进入githun中的这个code，点击复制，然后粘贴在上面的 repository后 。</p>
<p>在你的博客文件夹下面点开git命令，输入以下命令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save  </span><br><span class="line"></span><br><span class="line">hexo g   //生成页面</span><br><span class="line"></span><br><span class="line">hexo d    //上传文件至仓库，需要输入账号密码，在此处可能会出现网络不稳定问题，多试几次</span><br></pre></td></tr></table></figure>
<p><img src="/images/16.png"></p>
<p>这个为github的用户名，输入之后会在让输密码。。。。。。。注意此时不能在输密码，进入上面提到过的github里的setting ,找到左侧的Developer settings,点击开发者设置。</p>
<p><img src="/images/17.png"></p>
<p>点击 Generate new token 创建一个新的令牌。</p>
<p><img src="/images/18.png"></p>
<p>随意取一个名字，并将所有选项选上，点击生成令牌。<img src="/images/19.png"></p>
<p>复制此处的序列号令牌到弹出的提示输入密码框内。</p>
<p><img src="/images/20.png"></p>
<p>即为上传成功！<img src="/images/20.png"></p>
<p>此时仓库的内容就发生了变化。此时通过 <a href="https://你的git名字.github.io/">https://你的git名字.github.io/</a>      即可从网址访问。</p>
<p><img src="/images/21.png"></p>
<p>此时博客的搭建已经差不多了，剩下的时博客的页面主题的更换和域名的绑定</p>
]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo主题的更换与优化和域名的配置</title>
    <url>/2022/08/28/hexo%E4%B8%BB%E9%A2%98%E7%9A%84%E6%9B%B4%E6%8D%A2%E4%B8%8E%E4%BC%98%E5%8C%96%E5%92%8C%E5%9F%9F%E5%90%8D%E7%9A%84%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="一、选择主题"><a href="#一、选择主题" class="headerlink" title="一、选择主题"></a>一、选择主题</h2><p>目前 Hexo 里面应用最多的主题基本就是 Next 主题了，我用的就是Next，另外它支持的插件和功能也极为丰富。</p>
<span id="more"></span>
<h2 id="二、下载主题"><a href="#二、下载主题" class="headerlink" title="二、下载主题"></a>二、下载主题</h2><p>我们可以直接到 Next 主题的 <a href="https://so.csdn.net/so/search?q=GitHub&amp;spm=1001.2101.3001.7020">GitHub</a> Repository 上把这个主题下载下来。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://github.com/theme-next/hexo-theme-next</span><br></pre></td></tr></table></figure>
<p>命令行进入到blog项目的根目录，执行如下命令即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>
<p>执行完毕之后 Next 主题的源码就会出现在项目的 themes/next 文件夹下。<br>然后需要修改下博客所用的主题名称，修改项目根目录下的 _config.yml 文件，找到 theme 字段，修改为 next 即可，修改如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure>
<p>然后本地重新开启服务，访问刷新下页面，就可以看到 next 主题就切换成功了</p>
<p>Next 主题内部也提供了一个配置文件，Next 主题里面所有的功能都可以通过这个配置文件来控制，下文所述的内容都是修改的 themes/next/_config.yml 文件。</p>
<h3 id="3-1-样式"><a href="#3-1-样式" class="headerlink" title="3.1 样式"></a>3.1 样式</h3><p>Next 主题还提供了多种样式，风格都是类似黑白的搭配，但整个布局位置不太一样，通过修改配置文件的 scheme 字段即可，我选了 Pisces 样式，修改 _config.yml （注意是 themes/next/_config.yml 文件）如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scheme: Pisces</span><br></pre></td></tr></table></figure>
<h3 id="3-2-favicon"><a href="#3-2-favicon" class="headerlink" title="3.2 favicon"></a>3.2 favicon</h3><p><code>https://realfavicongenerator.net/</code></p>
<p>avicon 就是站点标签栏的小图标，默认是用的 Hexo 的小图标，如果我们有站点 Logo 的图片的话，我们可以自己定制小图标。到这里上传一张图，便可以直接打包下载各种尺寸和适配不同设备的小图标。</p>
<p>图标下载下来之后把它放在 themes/next/source/images 目录下面。<br>然后在配置文件里面找到 favicon 配置项，把一些相关路径配置进去即可，示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">favicon:</span><br><span class="line">  small: /images/favicon-16x16.png</span><br><span class="line">  medium: /images/favicon-32x32.png</span><br><span class="line">  apple_touch_icon: /images/apple-touch-icon.png</span><br><span class="line">  safari_pinned_tab: /images/safari-pinned-tab.svg</span><br></pre></td></tr></table></figure>
<p>也可以将图标上传至网上通过链接获得</p>
<h4 id="3-2-1-将图片上传至网络"><a href="#3-2-1-将图片上传至网络" class="headerlink" title="3.2.1  将图片上传至网络"></a>3.2.1  将图片上传至网络</h4><p><code>[薄荷图床 首页 -图床外链生成器-亚马逊图片上传-无限流量-全球加速-无限数量-图片转链接-跨境电商图片空间-图片托管 (riyugo.com)](https://riyugo.com/)</code></p>
<p>上传后将路径改为地址即可</p>
<h3 id="3-3-avatar"><a href="#3-3-avatar" class="headerlink" title="3.3 avatar"></a>3.3 avatar</h3><p>将1.png 图片放置到 themes/next/source/images/1.png 路径，然后在主题 _config.yml 文件下编辑 avatar 的配置，修改为正确的路径即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Sidebar Avatar</span><br><span class="line">avatar:</span><br><span class="line">  # In theme directory (source/images): /images/avatar.gif</span><br><span class="line">  # In site directory (source/uploads): /uploads/avatar.gif</span><br><span class="line">  # You can also use other linking images.</span><br><span class="line">  url: /images/avatar.png</span><br><span class="line">  # If true, the avatar would be dispalyed in circle.</span><br><span class="line">  rounded: true</span><br><span class="line">  # If true, the avatar would be rotated with the cursor.</span><br><span class="line">  rotated: true</span><br></pre></td></tr></table></figure>
<h3 id="3-4-top"><a href="#3-4-top" class="headerlink" title="3.4 top"></a>3.4 top</h3><p>在浏览网页的时候，想快速返回到网站的上端，一般都是有一个按钮来辅助的，这里也支持它的配置，修改 _config.yml 的 back2top 字段即可，我的设置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">back2top:	</span><br><span class="line">  enable: true	</span><br><span class="line">  # Back to top in sidebar.	</span><br><span class="line">  sidebar: false	</span><br><span class="line">  # Scroll percent label in b2t button.	</span><br><span class="line">  scrollpercent: true</span><br></pre></td></tr></table></figure>
<h3 id="3-5-reading-process"><a href="#3-5-reading-process" class="headerlink" title="3.5 reading_process"></a>3.5 reading_process</h3><p>reading_process，阅读进度。大家可能注意到有些站点的最上侧会出现一个细细的进度条，代表页面加载进度和阅读进度 ，修改_config.yml 如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reading_progress:	</span><br><span class="line">  enable: true	</span><br><span class="line">  # Available values: top | bottom	</span><br><span class="line">  position: top	</span><br><span class="line">  color: &quot;#222&quot;	</span><br><span class="line">  height: 2px</span><br></pre></td></tr></table></figure>
<h3 id="3-6-pangu"><a href="#3-6-pangu" class="headerlink" title="3.6 pangu"></a>3.6 pangu</h3><p>希望写中文和英文的时候中间必须要留有间距，一个简单直接的方法就是中间加个空格。</p>
<p>pangu 就是来解决这个问题的，我们只需要在主题里面开启这个选项，在编译生成页面的时候，中英文之间就会自动添加空格，看起来更加美观。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pangu: true</span><br></pre></td></tr></table></figure>
<h3 id="3-7-pjax"><a href="#3-7-pjax" class="headerlink" title="3.7 pjax"></a>3.7 pjax</h3><p>pjax 这个技术实际上就是，利用 Ajax 技术实现了局部页面刷新，既可以实现 URL 的更换，有可以做到无刷新加载。</p>
<p>要开启这个功能需要先将 pjax 功能开启，然后安装对应的 pjax 依赖库，首先修改 _config.yml 修改如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pjax: true</span><br></pre></td></tr></table></figure>
<p>然后安装依赖库，切换到 next 主题下，然后安装依赖库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/theme-next/theme-next-pjax source/lib/pjax</span><br></pre></td></tr></table></figure>
<h2 id="四、发布文章"><a href="#四、发布文章" class="headerlink" title="四、发布文章"></a>四、发布文章</h2><h3 id="4-1、增加文章"><a href="#4-1、增加文章" class="headerlink" title="4.1、增加文章"></a>4.1、增加文章</h3><p>需要调用 Hexo 提供的命令即可，比如我们要新建一篇「HelloWorld」的文章，命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new hello-world</span><br></pre></td></tr></table></figure>
<h3 id="4-2、个性化设置"><a href="#4-2、个性化设置" class="headerlink" title="4.2、个性化设置"></a>4.2、个性化设置</h3><h4 id="4-2-1-标签页"><a href="#4-2-1-标签页" class="headerlink" title="4.2.1 标签页"></a>4.2.1 标签页</h4><p>按上路径创建 <strong>index.md</strong> </p>
<p><img src="https://s1.plumeta.com/i/2022/08/29/p5vqdl.jpg" alt></p>
<p>里面输入内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title: tags</span><br><span class="line">type: &quot;tags&quot;</span><br></pre></td></tr></table></figure>
<p>然后再在主题的 _config.yml 文件将这个页面的链接添加到主菜单里面，修改 menu 字段如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">menu:	</span><br><span class="line">  home: / || home	</span><br><span class="line">  #about: /about/ || user	</span><br><span class="line">  tags: /tags/ || tags	</span><br><span class="line">  #categories: /categories/ || th	</span><br><span class="line">  archives: /archives/ || archive	</span><br><span class="line">  #schedule: /schedule/ || calendar	</span><br><span class="line">  #sitemap: /sitemap.xml || sitemap	</span><br><span class="line">  #commonweal: /404/ || heartbeat</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>分类页和标签页是一样的。</p>
<h4 id="4-2-2-搜索页"><a href="#4-2-2-搜索页" class="headerlink" title="4.2.2 搜索页"></a>4.2.2 搜索页</h4><p>我们需要搜索全站的内容，所以一个搜索功能的支持也是很有必要的。</p>
<p>如果要添加搜索的支持，需要先安装一个插件，叫做 hexo-generator-searchdb，命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>
<p>然后在项目的 _config.yml 里面添加搜索设置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">search:	</span><br><span class="line">  path: search.xml	</span><br><span class="line">  field: post	</span><br><span class="line">  format: html	</span><br><span class="line">  limit: 10000</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在主题的 _config.yml 里面修改如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Local search	</span><br><span class="line"># Dependencies: https://github.com/wzpan/hexo-generator-search	</span><br><span class="line">local_search:	</span><br><span class="line">  enable: true	</span><br><span class="line">  # If auto, trigger search by changing input.	</span><br><span class="line">  # If manual, trigger search by pressing enter key or search button.	</span><br><span class="line">  trigger: auto	</span><br><span class="line">  # Show top n results per article, show all results by setting to -1	</span><br><span class="line">  top_n_per_article: 5	</span><br><span class="line">  # Unescape html strings to the readable one.	</span><br><span class="line">  unescape: false	</span><br><span class="line">  # Preload the search data when the page loads.	</span><br><span class="line">  preload: false</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="4-2-3-404页面"><a href="#4-2-3-404页面" class="headerlink" title="4.2.3 404页面"></a>4.2.3 404页面</h4><p>另外还需要添加一个 404 页面，直接在根目录 source 文件夹新建一个 404.md 文件即可，内容可以仿照如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---	</span><br><span class="line">title: 404 Not Found	</span><br><span class="line">date: 2019-09-22 10:41:27	</span><br><span class="line">---	</span><br><span class="line"> </span><br><span class="line">	</span><br><span class="line">&lt;center&gt;	</span><br><span class="line">对不起，您所访问的页面不存在或者已删除。	</span><br><span class="line">您可以&lt;a href=&quot;   &quot;&gt;点击此处&lt;/a&gt;返回首页。	</span><br><span class="line">&lt;/center&gt;	</span><br><span class="line"> </span><br><span class="line">	</span><br><span class="line">&lt;blockquote class=&quot;blockquote-center&quot;&gt;	</span><br><span class="line">    NightTeam	</span><br><span class="line">&lt;/blockquote&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里面的一些相关信息和链接可以替换成自己的。</p>
<h2 id="五、更新部署-amp-域名配置"><a href="#五、更新部署-amp-域名配置" class="headerlink" title="五、更新部署&amp;域名配置"></a>五、更新部署&amp;域名配置</h2><h3 id="5-1-Hexo更新"><a href="#5-1-Hexo更新" class="headerlink" title="5.1 Hexo更新"></a>5.1 Hexo更新</h3><p>通过博客上面的地址输入框进入  cmd</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean	</span><br><span class="line">hexo generate	</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>
<h3 id="5-2-自定义域名"><a href="#5-2-自定义域名" class="headerlink" title="5.2 自定义域名"></a>5.2 自定义域名</h3><p>我本人是在<a href="https://auth.huaweicloud.com/authui/login.html?service=https%3A%2F%2Fconsole.huaweicloud.com%2Fdns%2F%3FagencyId%3D1fb2d46c8a3e48dbbc4d41fb5b2cf34c%26region%3Dcn-east-3%26locale%3Dzh-cn%26cloud_route_state%3D%2Fdns%2Frecordset%2Fpublic%2Flist%3Fzoneid%3D8aace3b98282c2260182d8bd74236172%26zonename%3Dbaidu2001.top.%26zoneStatus%3DACTIVE#/login">华为云</a>下面买的域名</p>
<p>在 GitHub 的 Repository 里面设置域名，找到 Settings，拉到下面，可以看到有个 GitHub Pages 的配置项，如图所示</p>
<p><img src="https://i.p04e.com/baid/i/2022/09/02/74zzg.png"></p>
<p>下面有个 custom domain 的选项，输入想自定义的域名地址，然后添加 CNAME 解析就好了。</p>
<p>另外下面还有一个 Enforce HTTPS 的选项，GitHub Pages 会在我们配置自定义域名之后自动帮我们配置 HTTPS 服务。刚配置完自定义域名的时候可能这个选项是不可用的，一段时间后等到其可以勾选了，直接勾选即可，这样整个博客就会变成 HTTPS 的协议的了。</p>
<p>另外有一个值得注意的地方，如果配置了自定义域名，在目前的情况下，每次部署的时候这个自定义域名的设置是会被自动清除的。所以为了避免这个情况，我们需要在项目目录下面新建一个 CNAME 文件，路径为 source/CNAME，内容就是自定义域名。<br>我就在 source 目录下新建了一个 CNAME 文件，内容为自己的域名</p>
<p><img src="https://i.p04e.com/baid/i/2022/09/02/10q7p.png"></p>
<p>可以避免了每次部署的时候自定义域名被清除的情况了。</p>
]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>域名</tag>
        <tag>图片的免费上传</tag>
      </tags>
  </entry>
  <entry>
    <title>java.sql.SQLSyntaxErrorException: Unknown column &#39;is_deleted&#39; in &#39;field list&#39;</title>
    <url>/2022/09/02/java-sql-SQLSyntaxErrorException-Unknown-column-is-deleted-in-field-list/</url>
    <content><![CDATA[<p><img src="https://i.p04e.com/baid/i/2022/09/02/58a7.png"></p>
<p>今天做的是一个分页查询，结果无法显示，回到idea下面查找问题</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">: Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exceptison is org.springframework.jdbc.BadSqlGrammarException: </span><br><span class="line"></span><br><span class="line">### Error querying database.  Cause: java.sql.SQLSyntaxErrorException: Unknown column &#x27;is_deleted&#x27; in &#x27;field list&#x27;</span><br><span class="line">其实最重要的是后面这句，很明显是sql的问题 ，大概意思就是不知道 is_deleted 在表格中的什么什么</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">然后我在实体类中找到了这句</span><br><span class="line">    //是否删除</span><br><span class="line">    private Integer isDeleted;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我刚开始以为是驼峰命名法不对，结果改了后还是不对。</p>
<p>之后再数据库中发现这个表中并没有 is_deleted这个字段，是另一个表内的，由于实体类是找的网上资源自己懒的写就弄了一个大乌龙，删除掉以后就好了。</p>
]]></content>
      <tags>
        <tag>Mysql</tag>
        <tag>错误</tag>
      </tags>
  </entry>
  <entry>
    <title>redis软件安装和指令学习</title>
    <url>/2022/09/28/redis%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%92%8C%E6%8C%87%E4%BB%A4%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h3 id="Redis入门"><a href="#Redis入门" class="headerlink" title="Redis入门"></a>Redis入门</h3><h4 id="什么是-Redis"><a href="#什么是-Redis" class="headerlink" title="什么是 Redis ?"></a>什么是 Redis ?</h4><p>Redis是一个基于内存的key-value结构数据库。</p>
<p>基于内存存储，读写性能高</p>
<p>适合存储热点数据（热点商品、资讯、新闻)企业应用广泛</p>
<span id="more"></span>
<h4 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h4><p>Redis is an open source (BSD licensed), in-memory data structure store, used as a database, cache, andmessage broker，翻译为:Redis是一个开源的内存中的数据结构存储系统，它可以用作:数据库、缓存和消息中间件。官网: <a href="https://redis.io">https://redis.io</a><br>Redis是用C语言开发的一个开源的高性能键值对(key-value)数据库，官方提供的数据是可以达到100000+的QPS（(每秒内查询次数）。它存储的value类型比较丰富，也被称为结构化的NoSql数据库。<br>NoSql ( Not only sQL)，不仅仅是SQL，泛指非关系型数据库。NoSql数据库并不是要取代关系型数据库，而是关系型数据库的补充。</p>
<p>关系型数据库(RDBMS)</p>
<ul>
<li>Mysql</li>
<li>oracleDB2</li>
<li>sQLServer</li>
</ul>
<p>非关系型数据库(NoSql)</p>
<ul>
<li>Redis</li>
<li>Mongo </li>
<li>dbMemCached</li>
</ul>
<p>Redis应用场景</p>
<ul>
<li>缓存</li>
<li>任务队列</li>
<li>消息队列</li>
<li>分布式锁</li>
</ul>
<h4 id="Redis下载与安装"><a href="#Redis下载与安装" class="headerlink" title="Redis下载与安装"></a>Redis下载与安装</h4><p>Redis安装包分为windows版和Linux版:</p>
<p>Windows版下载地址:https:l/github.com/microsoftarchive/redis/releases</p>
<p>Linux版下载地址: <a href="https://download.redis.io/releasesl">https://download.redis.io/releasesl</a></p>
<p>在Linux系统安装Redis步骤:</p>
<p>1.将Redis安装包上传到Linux</p>
<p>⒉.解压安装包，命令: tar -zxvf redis-4.0.0.tar.gz-C /usr/local</p>
<p>3.安装Redis的依赖环境gcc，命令: yum install gcc-C++</p>
<p>4.进入/usr/local/redis-4.0.0，进行编译，命令: make</p>
<p>5.进入redis的src目录，进行安装，命令: make install</p>
<h4 id="Redis服务启动与停止"><a href="#Redis服务启动与停止" class="headerlink" title="Redis服务启动与停止"></a>Redis服务启动与停止</h4><p>Linux中redis服务启动，可以使用redis-server，默认端口号为6379</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">src/redis-server ./redis.conf</span><br><span class="line"></span><br><span class="line">src/redis-cli -p 6379 -a 123456</span><br><span class="line"></span><br><span class="line">//用本地服务器连接</span><br><span class="line">.\redis-cli.exe -h 192.168.81.128 -p 6379 -a 123456</span><br></pre></td></tr></table></figure>
<p>Ctrl+C停止Redis服务</p>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>介绍</p>
<p>Redis存储的是key-value结构的数据，其中key是字符串类型，value有5种常用的数据类型:</p>
<p>字符串string</p>
<p>哈希hash</p>
<p>列表list</p>
<p>集合set</p>
<p>有序集合sorted set</p>
<p><img src="https://i.p04e.com/baid/i/2022/09/28/12m8f.png"></p>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><h4 id="字符串string操作命令"><a href="#字符串string操作命令" class="headerlink" title="字符串string操作命令"></a>字符串string操作命令</h4><ul>
<li>SET key value    设置指定key的值</li>
<li>GET key    获取指定key的值</li>
<li>SETEX key seconds value    设置指定key的值，并将key 的过期时间设为seconds</li>
<li>SETNX key value    只有在key 不存在时设置key 的值</li>
</ul>
<h4 id="哈希hash操作命令"><a href="#哈希hash操作命令" class="headerlink" title="哈希hash操作命令"></a>哈希hash操作命令</h4><p>Redis hash 是一个string类型的field和value 的映射表，hash特别适合用于存储对象，常用命令:</p>
<ul>
<li>HSET key field value    将哈希表key 中的字段field的值设为value</li>
<li>HGET key field    获取存储在哈希表中指定字段的值</li>
<li>HDEL key field    删除存储在哈希表中的指定字段</li>
<li>HKEYS key    获取哈希表中所有字段</li>
<li>HVALS key    获取哈希表中所有值</li>
<li>HGETALL key    获取在哈希表中指定key的所有字段和值</li>
</ul>
<h4 id="列表list操作命令"><a href="#列表list操作命令" class="headerlink" title="列表list操作命令"></a>列表list操作命令</h4><ul>
<li><p>Redis列表是简单的字符串列表，按照插入顺序排序，常用命令:</p>
</li>
<li><p>LPUSH key value1 [value2]    将一个或多个值插入到列表头部</p>
</li>
<li><p>LRANGE key start stop    获取列表指定范围内的元素</p>
</li>
<li><p>RPOP key    移除并获取列表最后一个元素</p>
</li>
<li><p>LLEN key    获取列表长度</p>
</li>
<li><p>BRPOP key1 [key2 ] timeout    移出并获取列表的最后一个元素，如果列表没有元素会阻塞列表直到等待超</p>
<p>​                                   时或发现可弹出元素为止</p>
<p><img src="https://i.p04e.com/baid/i/2022/09/28/sl9.png"></p>
</li>
</ul>
<h4 id="集合set操作命令"><a href="#集合set操作命令" class="headerlink" title="集合set操作命令"></a>集合set操作命令</h4><p>Redis set 是string类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据，常用命令:</p>
<ul>
<li>SADD key member1 [member2]    向集合添加一个或多个成员</li>
<li>SMEMBERS key    返回集合中的所有成员</li>
<li>SCARD key    获取集合的成员数</li>
<li>SINTER key1 [key2]    返回给定所有集合的交集</li>
<li>SUNION key1 [key2]    返回所有给定集合的并集</li>
<li>SDIFF key1 [key2]    返回给定所有集合的差集</li>
<li>SREM key member1[member2]    移除集合中一个或多个成员</li>
</ul>
<p><img src="https://i.p04e.com/baid/i/2022/09/28/1h4x2d.png"></p>
<h4 id="有序集合sorted-set操作命令"><a href="#有序集合sorted-set操作命令" class="headerlink" title="有序集合sorted set操作命令"></a>有序集合sorted set操作命令</h4><p>Redis sorted set有序集合是string类型元素的集合，且不允许重复的成员。每个元素都会关联一个double类</p>
<p>型的分数(score)。redis正是通过分数来为集合中的成员进行从小到大排序。有序集合的成员是唯一的，但分</p>
<p>数却可以重复。常用命令:</p>
<ul>
<li>ZADD key score1 member1[score2 member2]    向有序集合添加一个或多个成员，或者更新已存在成员的分</li>
<li>数</li>
<li>ZRANGE key start stop [WITHSCORES]    通过索引区间返回有序集合中指定区间内的成员</li>
<li>zINCRBY key increment member    有序集合中对指定成员的分数加上增量increment</li>
<li>ZREM key member [member …]    移除有序集合中的一个或多个成员</li>
</ul>
<p><img src="https://i.p04e.com/baid/i/2022/09/28/7mbae.png"></p>
<h4 id="通用命令"><a href="#通用命令" class="headerlink" title="通用命令"></a>通用命令</h4><ul>
<li>KEYs pattern    查找所有符合给定模式( pattern)的 key</li>
<li>EXISTs key    检查给定key是否存在</li>
<li>TYPE key    返回key所储存的值的类型</li>
<li>TTL key    返回给定key的剩余生存时间(TTL, time to live)，以秒为单位</li>
<li>DEL key    该命令用于在key存在是删除key</li>
</ul>
<h3 id="在Java中操作Redis"><a href="#在Java中操作Redis" class="headerlink" title="在Java中操作Redis"></a>在Java中操作Redis</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>Redis 的Java客户端很多，官方推荐的有三种:</p>
<ul>
<li>Jedis</li>
<li>Lettuce</li>
<li>Redisson</li>
</ul>
<p>Spring对Redis客户端进行了整合，提供了Spring Data Redis，在Spring Boot项目中还提供了对应的</p>
<p>Starter，即spring-boot-starter-data-redis</p>
<h4 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h4><p>Jedis的maven坐标:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;groupld&gt;redis.clients&lt;/groupld&gt;</span><br><span class="line"></span><br><span class="line">&lt;artifactld&gt;jedis&lt;lartifactld&gt;</span><br><span class="line"></span><br><span class="line">&lt;version&gt;2.8.O&lt;/version&gt;</span><br><span class="line"></span><br><span class="line">&lt;/ dependency&gt;</span><br></pre></td></tr></table></figure>
<p>使用Jedis操作Redis的步骤:</p>
<ul>
<li>获取连接</li>
<li>执行操作</li>
<li>关闭连接</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.test;</span><br><span class="line"></span><br><span class="line">import org.junit.Test;</span><br><span class="line">import redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 使用Jedis操作Redis</span><br><span class="line"> */</span><br><span class="line">public class JedisTest &#123;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testRedis()&#123;</span><br><span class="line">        //1 获取连接</span><br><span class="line">        Jedis jedis = new Jedis(&quot;localhost&quot;,6379);</span><br><span class="line">        </span><br><span class="line">        //2 执行具体的操作</span><br><span class="line">        jedis.set(&quot;username&quot;,&quot;xiaoming&quot;);</span><br><span class="line"></span><br><span class="line">        String value = jedis.get(&quot;username&quot;);</span><br><span class="line">        System.out.println(value);</span><br><span class="line"></span><br><span class="line">        //jedis.del(&quot;username&quot;);</span><br><span class="line"></span><br><span class="line">        jedis.hset(&quot;myhash&quot;,&quot;addr&quot;,&quot;bj&quot;);</span><br><span class="line">        String hValue = jedis.hget(&quot;myhash&quot;, &quot;addr&quot;);</span><br><span class="line">        System.out.println(hValue);</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; keys = jedis.keys(&quot;*&quot;);</span><br><span class="line">        for (String key : keys) &#123;</span><br><span class="line">            System.out.println(key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //3 关闭连接</span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="Spring-Data-Redis"><a href="#Spring-Data-Redis" class="headerlink" title="Spring Data Redis"></a>Spring Data Redis</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在Spring Boot项目中，可以使用Spring Data Redis来简化Redis操作，maven坐标:</span><br><span class="line">	&lt;dependency&gt;</span><br><span class="line">&lt;groupld&gt;org.springframework.boot&lt;/groupld&gt;</span><br><span class="line">&lt;artifactld&gt;spring-boot-starter-data-redis&lt;/artifactld&gt;</span><br><span class="line">	&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>Spring Data Redis中提供了一个高度封装的类: RedisTemplate，针对jedis客户端中大量ap进行了归类封装,</p>
<p>将同一类型操作封装为operation接口，具体分类如下:</p>
<ul>
<li>valueOperations:简单K-V操作</li>
<li>SetOperations: set类型数据操作</li>
<li>ZSetOperations: zset类型数据操作</li>
<li>HashOperations:针对map类型的数据操作</li>
<li>Listoperations:针对list类型的数据操作</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: springdataredis_demo</span><br><span class="line">  #Redis相关配置</span><br><span class="line">  redis:</span><br><span class="line">    host: localhost</span><br><span class="line">    port: 6379</span><br><span class="line">    #password: 123456</span><br><span class="line">    database: 0 #操作的是0号数据库</span><br><span class="line">    jedis:</span><br><span class="line">      #Redis连接池配置</span><br><span class="line">      pool:</span><br><span class="line">        max-active: 8 #最大连接数</span><br><span class="line">        max-wait: 1ms #连接池最大阻塞等待时间</span><br><span class="line">        max-idle: 4 #连接池中的最大空闲连接</span><br><span class="line">        min-idle: 0 #连接池中的最小空闲连接</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.test;</span><br><span class="line"></span><br><span class="line">import org.junit.Test;</span><br><span class="line">import org.junit.runner.RunWith;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line">import org.springframework.data.redis.connection.DataType;</span><br><span class="line">import org.springframework.data.redis.core.*;</span><br><span class="line">import org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Set;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">@SpringBootTest</span><br><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">public class SpringDataRedisTest &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 操作String类型数据</span><br><span class="line">     */</span><br><span class="line">    @Test</span><br><span class="line">    public void testString()&#123;</span><br><span class="line">        redisTemplate.opsForValue().set(&quot;city123&quot;,&quot;beijing&quot;);</span><br><span class="line"></span><br><span class="line">        String value = (String) redisTemplate.opsForValue().get(&quot;city123&quot;);</span><br><span class="line">        System.out.println(value);</span><br><span class="line"></span><br><span class="line">        redisTemplate.opsForValue().set(&quot;key1&quot;,&quot;value1&quot;,10l, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        Boolean aBoolean = redisTemplate.opsForValue().setIfAbsent(&quot;city1234&quot;, &quot;nanjing&quot;);</span><br><span class="line">        System.out.println(aBoolean);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 操作Hash类型数据</span><br><span class="line">     */</span><br><span class="line">    @Test</span><br><span class="line">    public void testHash()&#123;</span><br><span class="line">        HashOperations hashOperations = redisTemplate.opsForHash();</span><br><span class="line"></span><br><span class="line">        //存值</span><br><span class="line">        hashOperations.put(&quot;002&quot;,&quot;name&quot;,&quot;xiaoming&quot;);</span><br><span class="line">        hashOperations.put(&quot;002&quot;,&quot;age&quot;,&quot;20&quot;);</span><br><span class="line">        hashOperations.put(&quot;002&quot;,&quot;address&quot;,&quot;bj&quot;);</span><br><span class="line"></span><br><span class="line">        //取值</span><br><span class="line">        String age = (String) hashOperations.get(&quot;002&quot;, &quot;age&quot;);</span><br><span class="line">        System.out.println(age);</span><br><span class="line"></span><br><span class="line">        //获得hash结构中的所有字段</span><br><span class="line">        Set keys = hashOperations.keys(&quot;002&quot;);</span><br><span class="line">        for (Object key : keys) &#123;</span><br><span class="line">            System.out.println(key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //获得hash结构中的所有值</span><br><span class="line">        List values = hashOperations.values(&quot;002&quot;);</span><br><span class="line">        for (Object value : values) &#123;</span><br><span class="line">            System.out.println(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 操作List类型的数据</span><br><span class="line">     */</span><br><span class="line">    @Test</span><br><span class="line">    public void testList()&#123;</span><br><span class="line">        ListOperations listOperations = redisTemplate.opsForList();</span><br><span class="line"></span><br><span class="line">        //存值</span><br><span class="line">        listOperations.leftPush(&quot;mylist&quot;,&quot;a&quot;);</span><br><span class="line">        listOperations.leftPushAll(&quot;mylist&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;);</span><br><span class="line"></span><br><span class="line">        //取值</span><br><span class="line">        List&lt;String&gt; mylist = listOperations.range(&quot;mylist&quot;, 0, -1);</span><br><span class="line">        for (String value : mylist) &#123;</span><br><span class="line">            System.out.println(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //获得列表长度 llen</span><br><span class="line">        Long size = listOperations.size(&quot;mylist&quot;);</span><br><span class="line">        int lSize = size.intValue();</span><br><span class="line">        for (int i = 0; i &lt; lSize; i++) &#123;</span><br><span class="line">            //出队列</span><br><span class="line">            String element = (String) listOperations.rightPop(&quot;mylist&quot;);</span><br><span class="line">            System.out.println(element);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 操作Set类型的数据</span><br><span class="line">     */</span><br><span class="line">    @Test</span><br><span class="line">    public void testSet()&#123;</span><br><span class="line">        SetOperations setOperations = redisTemplate.opsForSet();</span><br><span class="line"></span><br><span class="line">        //存值</span><br><span class="line">        setOperations.add(&quot;myset&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;a&quot;);</span><br><span class="line"></span><br><span class="line">        //取值</span><br><span class="line">        Set&lt;String&gt; myset = setOperations.members(&quot;myset&quot;);</span><br><span class="line">        for (String o : myset) &#123;</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //删除成员</span><br><span class="line">        setOperations.remove(&quot;myset&quot;,&quot;a&quot;,&quot;b&quot;);</span><br><span class="line"></span><br><span class="line">        //取值</span><br><span class="line">        myset = setOperations.members(&quot;myset&quot;);</span><br><span class="line">        for (String o : myset) &#123;</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 操作ZSet类型的数据</span><br><span class="line">     */</span><br><span class="line">    @Test</span><br><span class="line">    public void testZset()&#123;</span><br><span class="line">        ZSetOperations zSetOperations = redisTemplate.opsForZSet();</span><br><span class="line"></span><br><span class="line">        //存值</span><br><span class="line">        zSetOperations.add(&quot;myZset&quot;,&quot;a&quot;,10.0);</span><br><span class="line">        zSetOperations.add(&quot;myZset&quot;,&quot;b&quot;,11.0);</span><br><span class="line">        zSetOperations.add(&quot;myZset&quot;,&quot;c&quot;,12.0);</span><br><span class="line">        zSetOperations.add(&quot;myZset&quot;,&quot;a&quot;,13.0);</span><br><span class="line"></span><br><span class="line">        //取值</span><br><span class="line">        Set&lt;String&gt; myZset = zSetOperations.range(&quot;myZset&quot;, 0, -1);</span><br><span class="line">        for (String s : myZset) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //修改分数</span><br><span class="line">        zSetOperations.incrementScore(&quot;myZset&quot;,&quot;b&quot;,20.0);</span><br><span class="line"></span><br><span class="line">        //取值</span><br><span class="line">        myZset = zSetOperations.range(&quot;myZset&quot;, 0, -1);</span><br><span class="line">        for (String s : myZset) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //删除成员</span><br><span class="line">        zSetOperations.remove(&quot;myZset&quot;,&quot;a&quot;,&quot;b&quot;);</span><br><span class="line"></span><br><span class="line">        //取值</span><br><span class="line">        myZset = zSetOperations.range(&quot;myZset&quot;, 0, -1);</span><br><span class="line">        for (String s : myZset) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 通用操作，针对不同的数据类型都可以操作</span><br><span class="line">     */</span><br><span class="line">    @Test</span><br><span class="line">    public void testCommon()&#123;</span><br><span class="line">        //获取Redis中所有的key</span><br><span class="line">        Set&lt;String&gt; keys = redisTemplate.keys(&quot;*&quot;);</span><br><span class="line">        for (String key : keys) &#123;</span><br><span class="line">            System.out.println(key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //判断某个key是否存在</span><br><span class="line">        Boolean itcast = redisTemplate.hasKey(&quot;itcast&quot;);</span><br><span class="line">        System.out.println(itcast);</span><br><span class="line"></span><br><span class="line">        //删除指定key</span><br><span class="line">        redisTemplate.delete(&quot;myZset&quot;);</span><br><span class="line"></span><br><span class="line">        //获取指定key对应的value的数据类型</span><br><span class="line">        DataType dataType = redisTemplate.type(&quot;myset&quot;);</span><br><span class="line">        System.out.println(dataType.name());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>Reids</tag>
      </tags>
  </entry>
  <entry>
    <title>白都的一封信</title>
    <url>/2022/08/26/%E4%BF%A1/</url>
    <content><![CDATA[<p>已至凌晨却无论如何都睡不着了，心里藏着很多事情。</p>
<span id="more"></span>
<hr>
<p>​    可对于已经发生过的事情，我们无能为力，能做好的只有接下来的事情。</p>
<p>​    <code>小时候经常仰望着星空，渴望着自己成为逆转时空的飞人</code></p>
<p>​    </p>
<hr>
<p>​    <code>黑还是白并不重要</code></p>
<hr>
<p>​    在痛苦开心的过程中会慢慢的触摸到心中真正的所想所愿。那是一种奇妙的感觉，很像是悟道一样的感觉。</p>
<p>​    <code>每天每天每月每月，实现那个梦</code></p>
<hr>
<p>​    生命的所有，都来自于想象力。</p>
<p>所有的可能，所有的道都来自于想象力。</p>
]]></content>
      <tags>
        <tag>念想</tag>
      </tags>
  </entry>
  <entry>
    <title>个人博客网站问题解决</title>
    <url>/2022/08/29/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<h2 id="一、Hexo-Next-实现全局播放背景音乐"><a href="#一、Hexo-Next-实现全局播放背景音乐" class="headerlink" title="一、Hexo + Next 实现全局播放背景音乐"></a>一、Hexo + Next 实现全局播放背景音乐</h2><p>进入网页版的网易云，进入你想选的歌单，按F12键进入开发人员工具，在元素里面 按ctrl + F 进行搜索生成外链，</p>
<span id="more"></span>
<p>记住前面的那一行数字，新开一个网页输入</p>
<p><code>https://music.163.com/#/outchain/0/</code>733122887         并将那行数字加载在 / 的后面。</p>
<p>打开我们主题文件：<code>themes\next\layout\_macro\sidebar.swig</code>找到<code>sidebar-inner</code>，复制下面代码粘贴到此<code>&lt;div&gt;</code>标签后即可。</p>
<ul>
<li>打开<code>themes\next\layout</code>文件夹找到<code>_layout.swig</code></li>
<li>在<code>&lt;\head&gt;</code>标签前添加下面代码，并保存。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;head&gt;   //粘贴到这里</span><br><span class="line">    </span><br><span class="line">  &lt;!--pjax：防止跳转页面音乐暂停--&gt;</span><br><span class="line">  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.js&quot;&gt;&lt;/script&gt; </span><br><span class="line">&lt;/head&gt; </span><br></pre></td></tr></table></figure>
<ul>
<li>在主题的配置文件中找到<code>pajx</code>，将它设置为<code>true</code>，并保存。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Easily enable fast Ajax navigation on your website.</span><br><span class="line"># Dependencies: https://github.com/theme-next/theme-next-pjax</span><br><span class="line">pjax: true</span><br></pre></td></tr></table></figure>
<h2 id="二、部署hexo时遇到报错ERROR-Deployer-not-found-git"><a href="#二、部署hexo时遇到报错ERROR-Deployer-not-found-git" class="headerlink" title="二、部署hexo时遇到报错ERROR Deployer not found: git"></a>二、部署hexo时遇到报错ERROR Deployer not found: git</h2><p>这是因为没有安装<code>hexo-deployer-git</code>插件,在<strong>站点目录</strong>下输入下面的命令安装插件就好了。执行下面这行命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<h2 id="三、使用命令npm-install-g-hexo-cli-安装Hexo报错bash-hexo-command-not-found问题解决"><a href="#三、使用命令npm-install-g-hexo-cli-安装Hexo报错bash-hexo-command-not-found问题解决" class="headerlink" title="三、使用命令npm install -g hexo-cli 安装Hexo报错bash: hexo: command not found问题解决"></a>三、使用命令npm install -g hexo-cli 安装Hexo报错bash: hexo: command not found问题解决</h2><p>选择一个磁盘，简历一个文件夹，取名为blog</p>
<p>然后按照下面的指令一步步输入</p>
<p><strong>在命令的前面加上npx。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npx hexo init blog</span><br><span class="line">cd blog</span><br><span class="line">npm install</span><br><span class="line">npx hexo server</span><br></pre></td></tr></table></figure>
<p>最后解释一下，为啥要在前面加上npx。</p>
<p>在大牛<a href="http://www.ruanyifeng.com/blog/2019/02/npx.html">阮一峰的网络日志</a>中，他是这么描述的：“<strong>npx 想要解决的主要问题，就是调用项目内部安装的模块</strong>”，所以可以理解为在命令行下调用，可以让项目内部安装的模块用起来更方便，npx运行的时候，会到<code>node_modules/.bin</code>路径和环境变量<code>$PATH</code>里面，检查命令是否存在。</p>
<p>如果还是不可以就手动加载路径</p>
<p>注意你的博客目录下应该有两个 <code>node_modules</code> 文件夹，要添加到 Path 里面的是与 _config.yml 在同一个目录的 node_modules 文件夹！</p>
<p>环境变量添加好了之后重新打开 git 即可运行 hexo 命令，如果此时仍然无法执行 hexo 命令，那就只能拿出终极绝招了，运行命令 <code>npm install hexo-cli -g</code> 重新安装 hexo 即可！</p>
]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>外卖管理平台删除套餐</title>
    <url>/2022/09/14/%E5%A4%96%E5%8D%96%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0%E5%88%A0%E9%99%A4%E5%A5%97%E9%A4%90/</url>
    <content><![CDATA[<h3 id="一、需求分析"><a href="#一、需求分析" class="headerlink" title="一、需求分析"></a>一、需求分析</h3><p>在套餐管理列表页面点击删除按钮，可以删除对应的套餐信息。也可以通过复选框选择多个套餐，点击批量删除按钮一次删除多个套餐。注意，对于状态为售卖中的套餐不能删除，需要先停售，然后才能删除。</p>
<span id="more"></span>
<h3 id="二、代码开发-梳理交互过程"><a href="#二、代码开发-梳理交互过程" class="headerlink" title="二、代码开发-梳理交互过程"></a>二、代码开发-梳理交互过程</h3><p>在开发代码之前，需要梳理一下删除套餐时前端页面和服务端的交互过程:</p>
<p>1、删除单个套餐时，页面发送ajax请求，根据套餐id删除对应套餐</p>
<p><img src="https://i.p04e.com/baid/i/2022/09/15/2lii.png"></p>
<p>2、删除多个套餐时，页面发送ajax请求，根据提交的多个套餐id删除对应套餐</p>
<p><img src="https://i.p04e.com/baid/i/2022/09/15/i6q6.png"></p>
<p>开发删除套餐功能，其实就是在服务端编写代码去处理前端页面发送的这2次请求即可。</p>
<p>观察删除单个套餐和批量删除套餐的请求信息可以发现，两种请求的地址和请求方式都是相同的，不同的则是传递的id个数，所以在服务端可以提供一个方法来统一处理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.service;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.extension.service.IService;</span><br><span class="line">import com.itheima.reggie.dto.SetmealDto;</span><br><span class="line">import com.itheima.reggie.entity.Setmeal;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public interface SetmealService extends IService&lt;Setmeal&gt; &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 新增套餐，同时需要保存套餐和菜品的关系</span><br><span class="line">     * @param setmealDto</span><br><span class="line">     */</span><br><span class="line">    public void saveWithDish(SetmealDto setmealDto);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 删除套餐，同时需要删除套餐和菜品的关联数据</span><br><span class="line">     * @param ids</span><br><span class="line">     */</span><br><span class="line">    public void removeWithDish(List&lt;Long&gt; ids);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 删除套餐，同时需要删除套餐和菜品的关联数据</span><br><span class="line"> * @param ids</span><br><span class="line"> */</span><br><span class="line">@Transactional</span><br><span class="line">public void removeWithDish(List&lt;Long&gt; ids) &#123;</span><br><span class="line">    //select count(*) from setmeal where id in (1,2,3) and status = 1</span><br><span class="line">    //查询套餐状态，确定是否可用删除</span><br><span class="line">    LambdaQueryWrapper&lt;Setmeal&gt; queryWrapper = new LambdaQueryWrapper();</span><br><span class="line">    queryWrapper.in(Setmeal::getId,ids);</span><br><span class="line">    queryWrapper.eq(Setmeal::getStatus,1);</span><br><span class="line"></span><br><span class="line">    int count = this.count(queryWrapper);</span><br><span class="line">    if(count &gt; 0)&#123;</span><br><span class="line">        //如果不能删除，抛出一个业务异常</span><br><span class="line">        throw new CustomException(&quot;套餐正在售卖中，不能删除&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //如果可以删除，先删除套餐表中的数据---setmeal</span><br><span class="line">    this.removeByIds(ids);</span><br><span class="line"></span><br><span class="line">    //delete from setmeal_dish where setmeal_id in (1,2,3)</span><br><span class="line">    LambdaQueryWrapper&lt;SetmealDish&gt; lambdaQueryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">    lambdaQueryWrapper.in(SetmealDish::getSetmealId,ids);</span><br><span class="line">    //删除关系表中的数据----setmeal_dish</span><br><span class="line">    setmealDishService.remove(lambdaQueryWrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 删除套餐</span><br><span class="line"> * @param ids</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">@DeleteMapping</span><br><span class="line">public R&lt;String&gt; delete(@RequestParam List&lt;Long&gt; ids)&#123;</span><br><span class="line">    log.info(&quot;ids:&#123;&#125;&quot;,ids);</span><br><span class="line"></span><br><span class="line">    setmealService.removeWithDish(ids);</span><br><span class="line"></span><br><span class="line">    return R.success(&quot;套餐数据删除成功&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>springboot - 外卖平台</tag>
        <tag>项目开发</tag>
        <tag>删除套餐</tag>
        <tag>mybatis plus</tag>
      </tags>
  </entry>
  <entry>
    <title>外卖管理平台修改菜品</title>
    <url>/2022/09/12/%E5%A4%96%E5%8D%96%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0%E4%BF%AE%E6%94%B9%E8%8F%9C%E5%93%81/</url>
    <content><![CDATA[<h3 id="一、需求分析"><a href="#一、需求分析" class="headerlink" title="一、需求分析"></a>一、需求分析</h3><p>在菜品管理列表页面点击修改按钮，跳转到修改菜品页面，在修改页面回显菜品相关信息并进行修改，最后点击确定按钮完成修改操作</p>
<span id="more"></span>
<h3 id="二、修改菜品"><a href="#二、修改菜品" class="headerlink" title="二、修改菜品"></a>二、修改菜品</h3><h4 id="代码开发-梳理交互过程"><a href="#代码开发-梳理交互过程" class="headerlink" title="代码开发-梳理交互过程"></a>代码开发-梳理交互过程</h4><p>在开发代码之前，需要梳理一下修改菜品时前端页面( add.html)和服务端的交互过程:</p>
<p>1、页面发送ajax请求，请求服务端获取分类数据，用于菜品分类下拉框中数据展示</p>
<p>2、页面发送ajax请求，请求服务端，根据id查询当前菜品信息，用于菜品信息回显</p>
<p>3、页面发送请求，请求服务端进行图片下载，用于页图片回显</p>
<p>4、点击保存按钮，页面发送ajax请求，将修改后的菜品相关数据以json形式提交到服务端</p>
<p><code>开发修改菜品功能，其实就是在服务端编写代码去处理前端页面发送的这4次请求即可。</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.service;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.extension.service.IService;</span><br><span class="line">import com.itheima.reggie.dto.DishDto;</span><br><span class="line">import com.itheima.reggie.entity.Dish;</span><br><span class="line"></span><br><span class="line">public interface DishService extends IService&lt;Dish&gt; &#123;</span><br><span class="line"></span><br><span class="line">    //新增菜品，同时插入菜品对应的口味数据，需要同时操作两张表： dish,dish_flavor</span><br><span class="line">    public void saveWithFlavor(DishDto dishDto);</span><br><span class="line"></span><br><span class="line">    //根据id来查询菜品信息和对应的口味信息</span><br><span class="line">    public DishDto getByIdwithFlavor(Long id);</span><br><span class="line"></span><br><span class="line">    //更新菜品信息，同时更新对应的口味信息</span><br><span class="line">    public void updateWithFlaovr(DishDto dishDto);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.service.impl;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;</span><br><span class="line">import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;</span><br><span class="line">import com.itheima.reggie.dto.DishDto;</span><br><span class="line">import com.itheima.reggie.entity.Dish;</span><br><span class="line">import com.itheima.reggie.entity.DishFlavor;</span><br><span class="line">import com.itheima.reggie.mapper.DishMapper;</span><br><span class="line">import com.itheima.reggie.service.DishFlavorService;</span><br><span class="line">import com.itheima.reggie.service.DishService;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.beans.BeanUtils;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line">import org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line">import java.util.Collections;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">@Slf4j</span><br><span class="line">public class DishServiceImpl extends ServiceImpl&lt;DishMapper,Dish&gt; implements DishService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private DishFlavorService dishFlavorService;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 新增菜品，同时保存对应的口味数据</span><br><span class="line">     * @param dishDto</span><br><span class="line">     */</span><br><span class="line">    @Transactional</span><br><span class="line">    public void saveWithFlavor(DishDto dishDto) &#123;</span><br><span class="line">        //保存菜品的基本信息到菜品表dish</span><br><span class="line">        this.save(dishDto);</span><br><span class="line"></span><br><span class="line">        Long dishId = dishDto.getId();//菜品id</span><br><span class="line"></span><br><span class="line">        //菜品口味</span><br><span class="line">        List&lt;DishFlavor&gt; flavors = dishDto.getFlavors();</span><br><span class="line">        flavors = flavors.stream().map((item) -&gt; &#123;</span><br><span class="line">            item.setDishId(dishId);</span><br><span class="line">            return item;</span><br><span class="line">        &#125;).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        //保存菜品口味数据到菜品口味表dish_flavor</span><br><span class="line">        dishFlavorService.saveBatch(flavors);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据id查询菜品信息和对应的口味信息</span><br><span class="line">     * @param id</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    public DishDto getByIdwithFlavor(Long id) &#123;</span><br><span class="line">        //查询菜品基本信息，从dish表查询</span><br><span class="line">        Dish dish = this.getById(id);</span><br><span class="line"></span><br><span class="line">        DishDto dishDto = new DishDto();</span><br><span class="line">        BeanUtils.copyProperties(dish,dishDto);</span><br><span class="line"></span><br><span class="line">        //查询当前菜品对应的口味信息，从dish_flavor表查询</span><br><span class="line">        LambdaQueryWrapper&lt;DishFlavor&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">        queryWrapper.eq(DishFlavor::getDishId,dish.getId());</span><br><span class="line">        List&lt;DishFlavor&gt; flavors = dishFlavorService.list(queryWrapper);</span><br><span class="line">        dishDto.setFlavors(flavors);</span><br><span class="line"></span><br><span class="line">        return dishDto;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    @Transactional</span><br><span class="line">    public void updateWithFlaovr(DishDto dishDto) &#123;</span><br><span class="line">        //更新dish表基本信息</span><br><span class="line">        this.updateById(dishDto);</span><br><span class="line"></span><br><span class="line">        //清理当前菜品对应口味数据---dish_flavor表的delete操作</span><br><span class="line">        LambdaQueryWrapper&lt;DishFlavor&gt; queryWrapper = new LambdaQueryWrapper();</span><br><span class="line">        queryWrapper.eq(DishFlavor::getDishId,dishDto.getId());</span><br><span class="line"></span><br><span class="line">        dishFlavorService.remove(queryWrapper);</span><br><span class="line"></span><br><span class="line">        //添加当前提交过来的口味数据---dish_flavor表的insert操作</span><br><span class="line">        List&lt;DishFlavor&gt; flavors = dishDto.getFlavors();</span><br><span class="line"></span><br><span class="line">        flavors = flavors.stream().map((item) -&gt; &#123;</span><br><span class="line">            item.setDishId(dishDto.getId());</span><br><span class="line">            return item;</span><br><span class="line">        &#125;).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        dishFlavorService.saveBatch(flavors);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.controller;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;</span><br><span class="line">import com.baomidou.mybatisplus.extension.plugins.pagination.Page;</span><br><span class="line">import com.itheima.reggie.common.R;</span><br><span class="line">import com.itheima.reggie.dto.DishDto;</span><br><span class="line">import com.itheima.reggie.entity.Category;</span><br><span class="line">import com.itheima.reggie.entity.Dish;</span><br><span class="line">import com.itheima.reggie.service.CategoryService;</span><br><span class="line">import com.itheima.reggie.service.DishFlavorService;</span><br><span class="line">import com.itheima.reggie.service.DishService;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.beans.BeanUtils;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/dish&quot;)</span><br><span class="line">@Slf4j</span><br><span class="line">public class DishController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private DishService dishService;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private DishFlavorService dishFlavorService;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private CategoryService categoryService;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 新增菜品</span><br><span class="line">     * @param dishDto</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @PostMapping</span><br><span class="line">    public R&lt;String&gt; save(@RequestBody DishDto dishDto) &#123;</span><br><span class="line"></span><br><span class="line">        log.info(dishDto.toString());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        dishService.saveWithFlavor(dishDto);</span><br><span class="line">        return R.success(&quot;新增菜品成功&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 菜品信息分页</span><br><span class="line">     * @param page</span><br><span class="line">     * @param pageSize</span><br><span class="line">     * @param name</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @GetMapping(&quot;/page&quot;)</span><br><span class="line">    public R&lt;Page&gt; page(int page, int pageSize, String name) &#123;</span><br><span class="line"></span><br><span class="line">        //构造分页构造器</span><br><span class="line">        Page&lt;Dish&gt; pageInfo = new Page&lt;&gt;(page,pageSize);</span><br><span class="line">        Page&lt;DishDto&gt; dishDtoPage = new Page&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        //条件构造器</span><br><span class="line">        LambdaQueryWrapper&lt;Dish&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        //添加过滤条件</span><br><span class="line">        queryWrapper.like(name != null,Dish::getName, name);</span><br><span class="line"></span><br><span class="line">        //添加排序条件</span><br><span class="line">        queryWrapper.orderByDesc(Dish::getUpdateTime);</span><br><span class="line"></span><br><span class="line">        //执行分页查询</span><br><span class="line">        dishService.page(pageInfo, queryWrapper);</span><br><span class="line"></span><br><span class="line">        //对象拷贝</span><br><span class="line">        BeanUtils.copyProperties(pageInfo,dishDtoPage,&quot;records&quot;);</span><br><span class="line"></span><br><span class="line">        List&lt;Dish&gt; records = pageInfo.getRecords();</span><br><span class="line">        List&lt;DishDto&gt; list = records.stream().map((item) -&gt;  &#123;</span><br><span class="line">            DishDto dishDto = new DishDto();</span><br><span class="line"></span><br><span class="line">            BeanUtils.copyProperties(item, dishDto);</span><br><span class="line"></span><br><span class="line">            Long categoryId = item.getCategoryId();</span><br><span class="line"></span><br><span class="line">            //根据id查询分类对象</span><br><span class="line">            Category category = categoryService.getById(categoryId);</span><br><span class="line"></span><br><span class="line">            if (category != null) &#123;</span><br><span class="line">                String categoryName = category.getName();</span><br><span class="line">                dishDto.setCategoryName(categoryName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            return dishDto;</span><br><span class="line">        &#125;).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        dishDtoPage.setRecords(list);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        return R.success(dishDtoPage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">    public R&lt;DishDto&gt; get(@PathVariable Long id) &#123;</span><br><span class="line"></span><br><span class="line">        DishDto dishDto = dishService.getByIdwithFlavor(id);</span><br><span class="line"></span><br><span class="line">        return R.success(dishDto);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 修改菜品</span><br><span class="line">     * @param dishDto</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @PutMapping</span><br><span class="line">    public R&lt;String&gt; update(@RequestBody DishDto dishDto) &#123;</span><br><span class="line"></span><br><span class="line">        log.info(dishDto.toString());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        dishService.updateWithFlaovr(dishDto);</span><br><span class="line"></span><br><span class="line">        return R.success(&quot;修改菜品成功&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据条件查询对应的菜品数据</span><br><span class="line">     * @param dish</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @GetMapping(&quot;/list&quot;)</span><br><span class="line">    public R&lt;List&lt;Dish&gt;&gt; list(Dish dish) &#123;</span><br><span class="line"></span><br><span class="line">        //构造查询条件</span><br><span class="line">        LambdaQueryWrapper&lt;Dish&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">        queryWrapper.eq(dish.getCategoryId() != null , Dish::getCategoryId, dish.getCategoryId());</span><br><span class="line">        //查询状态为1</span><br><span class="line">        queryWrapper.eq(Dish::getStatus,1);</span><br><span class="line">        //添加一个排序条件</span><br><span class="line">        queryWrapper.orderByAsc(Dish::getSort).orderByDesc(Dish::getUpdateTime);</span><br><span class="line"></span><br><span class="line">        List&lt;Dish&gt; list = dishService.list(queryWrapper);</span><br><span class="line">        return R.success(list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>springboot - 外卖平台</tag>
        <tag>项目开发</tag>
        <tag>mybatis plus</tag>
        <tag>修改菜品</tag>
      </tags>
  </entry>
  <entry>
    <title>外卖管理平台套餐信息分页查询</title>
    <url>/2022/09/14/%E5%A4%96%E5%8D%96%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0%E5%A5%97%E9%A4%90%E4%BF%A1%E6%81%AF%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<h3 id="一、需求分析"><a href="#一、需求分析" class="headerlink" title="一、需求分析"></a>一、需求分析</h3><p>系统中的套餐数据很多的时候，如果在一个页面中全部展示出来会显得比较乱，不便于查看，所以一般的系统中都会以分页的方式来展示列表数据。</p>
<span id="more"></span>
<h3 id="二、代码开发-梳理交互过程"><a href="#二、代码开发-梳理交互过程" class="headerlink" title="二、代码开发-梳理交互过程"></a>二、代码开发-梳理交互过程</h3><p>在开发代码之前，需要梳理一下套餐分页查询时前端页面和服务端的交互过程:</p>
<p>1、页面(backend/page/combo/list.html)发送ajax请求，将分页查询参数(page. pageSize、</p>
<p>name)提交到服务端，获取分页数据</p>
<p>2、页面发送请求，请求服务端进行图片下载，用于页面图片展示</p>
<p>开发套餐信息分页查询功能，其实就是在服务端编写代码去处理前端页面发送的这2次请求即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.controller;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *套餐分页查询</span><br><span class="line">     * @param page</span><br><span class="line">     * @param pageSize</span><br><span class="line">     * @param name</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @GetMapping(&quot;/page&quot;)</span><br><span class="line">    public R&lt;Page&gt; page(int page, int pageSize, String name) &#123;</span><br><span class="line">        //分页构造器对象</span><br><span class="line">        Page&lt;Setmeal&gt; pageInfo = new Page&lt;&gt;(page, pageSize);</span><br><span class="line">        Page&lt;SetmealDto&gt; dtoPage = new Page&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        LambdaQueryWrapper&lt;Setmeal&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">        //添加查询条件，根据name进行like模糊查询</span><br><span class="line">        queryWrapper.like(name != null, Setmeal::getName, name);</span><br><span class="line">        //添加排序条件，根据更新时间降序排列</span><br><span class="line">        queryWrapper.orderByDesc(Setmeal::getUpdateTime);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        setmealService.page(pageInfo,queryWrapper);</span><br><span class="line"></span><br><span class="line">        //对象拷贝</span><br><span class="line">        BeanUtils.copyProperties(pageInfo, dtoPage,&quot;records&quot;);</span><br><span class="line">        List&lt;Setmeal&gt; records = pageInfo.getRecords();</span><br><span class="line"></span><br><span class="line">        List&lt;SetmealDto&gt; list = records.stream().map((item) -&gt; &#123;</span><br><span class="line">            SetmealDto setmealDto = new SetmealDto();</span><br><span class="line">            //对象拷贝</span><br><span class="line">            BeanUtils.copyProperties(item,setmealDto);</span><br><span class="line">            //分类id</span><br><span class="line">            Long categoryId = item.getCategoryId();</span><br><span class="line">            //根据分类id查询分类对象</span><br><span class="line">            Category category = categoryService.getById(categoryId);</span><br><span class="line">            if (category != null) &#123;</span><br><span class="line">                //分类名称</span><br><span class="line">                String categoryName = category.getName();</span><br><span class="line">                setmealDto.setCategoryName(categoryName);</span><br><span class="line">            &#125;</span><br><span class="line">            return setmealDto;</span><br><span class="line">        &#125;).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        dtoPage.setRecords(list);</span><br><span class="line">        return R.success(dtoPage);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>springboot - 外卖平台</tag>
        <tag>项目开发</tag>
        <tag>mybatis plus</tag>
        <tag>套餐信息分页查询</tag>
      </tags>
  </entry>
  <entry>
    <title>外卖管理平台文件上传下载</title>
    <url>/2022/09/09/%E5%A4%96%E5%8D%96%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD/</url>
    <content><![CDATA[<h3 id="一、文件上传介绍"><a href="#一、文件上传介绍" class="headerlink" title="一、文件上传介绍"></a>一、文件上传介绍</h3><p>文件上传，也称为upload，是指将本地图片、视频、音频等文件上传到服务器上，可以供其他用户浏览或下载的过程。文件上传在项目中应用非常广泛，我们经常发微博、发微信朋友圈都用到了文件上传功能。</p>
<span id="more"></span>
<p>文件上传时，对页面的form表单有如下要求:</p>
<ul>
<li><p>method=”post”              采用post方式提交数据</p>
</li>
<li><p>enctype=”multipart/form-data”            采用multipart格式上传文件</p>
</li>
<li><p>type=”file”        使用input的file控件上传</p>
</li>
</ul>
<p>  举例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;form method=&quot;post&quot;action=&quot; /common/upload&quot; enctype=&quot;multipart/form-data&quot;&gt;&lt;input name=&quot;myFile&quot; type=&quot;file&quot;/&gt;</span><br><span class="line">&lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;&lt;/form&gt;</span><br></pre></td></tr></table></figure>
<p>目前一些前端组件库也提供了相应的上传组件，但是底层原理还是基于form表单的文件上传。例如ElementUI中提供的upload上传组件:</p>
<p><img src="https://i.p04e.com/baid/i/2022/09/09/13n.png"></p>
<p>服务端要接收客户端页面上传的文件，通常都会使用Apache的两个组件:</p>
<ul>
<li>commons-fileupload</li>
<li>commons-io</li>
</ul>
<p>Spring框架在spring-web包中对文件上传进行了封装，大大简化了服务端代码，我们只需要在Controller的方法中声明一个MultipartFile类型的参数即可接收上传的文件，例如:</p>
<p><img src="https://i.p04e.com/baid/i/2022/09/09/1oku.png"></p>
<p>文件下载，也称为download，是指将文件从服务器传输到本地计算机的过程。</p>
<p>通过浏览器进行文件下载，通常有两种表现形式:</p>
<p>以附件形式下载，弹出保存对话框，将文件保存到指定磁盘目录直接在浏览器中打开</p>
<p>通过浏览器进行文件下载，本质上就是服务端将文件以流的形式写回浏览器的过程。</p>
<p>文件上传，页面端可以使用ElementUI提供的上传组件。</p>
<p>可以直接使用资料中提供的上传页面，位置:资料/文件上传下载页面/upload.html</p>
<p><img src="https://i.p04e.com/baid/i/2022/09/09/3h39j.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.controller;</span><br><span class="line"></span><br><span class="line">import com.itheima.reggie.common.R;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.beans.factory.annotation.Value;</span><br><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line">import org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line">import org.springframework.web.multipart.MultipartFile;</span><br><span class="line"></span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.UUID;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 文件上传和下载</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/common&quot;)</span><br><span class="line">@Slf4j</span><br><span class="line">public class CommonController &#123;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;reggie.path&#125;&quot;)</span><br><span class="line">    private String basePath;</span><br><span class="line">    /**</span><br><span class="line">     * 文件上传</span><br><span class="line">     * @param file</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @PostMapping(&quot;/upload&quot;)</span><br><span class="line">    public R&lt;String&gt; upload (MultipartFile file) &#123;</span><br><span class="line">        //file是一个临时文件，需要转存到指定位置，否则本次请求完成后临时文件将被删除</span><br><span class="line">        log.info(file.toString());</span><br><span class="line"></span><br><span class="line">        //获得原始文件名</span><br><span class="line">        String originalFilename = file.getOriginalFilename();</span><br><span class="line">        String suffix = originalFilename.substring((originalFilename.lastIndexOf(&quot;.&quot;)));</span><br><span class="line"></span><br><span class="line">        //使用UUID重新生成文件名，防止文件名称重复造成文件覆盖</span><br><span class="line">        String fileName = UUID.randomUUID().toString() + suffix;</span><br><span class="line"></span><br><span class="line">        //创建一个目录对象</span><br><span class="line">        File dir = new File(basePath);</span><br><span class="line">        //判断目录是否存在</span><br><span class="line">        if (!dir.exists()) &#123;</span><br><span class="line">            //目录不存在需要创建</span><br><span class="line">            dir.mkdir();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            file.transferTo(new File(basePath + fileName));</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return R.success(fileName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="二、文件上传下载"><a href="#二、文件上传下载" class="headerlink" title="二、文件上传下载"></a>二、文件上传下载</h3><p><code>文件下载代码实现</code></p>
<p>文件下载，页面端可以使用<img>标签展示下载的图片</p>
<p><img v-if="imageUrl" :src="imageUr1" class="avatar"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">handleAvatarSuccess (response，file，fileList) &#123;</span><br><span class="line">this. imageUrl =`/common/download?name=$ &#123;response.data&#125;`</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 文件下载</span><br><span class="line"> * @param name</span><br><span class="line"> * @param response</span><br><span class="line"> */</span><br><span class="line">@GetMapping(&quot;/download&quot;)</span><br><span class="line">public void downLoad(String name, HttpServletResponse response) &#123;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        //输入流，通过输入流读取文件内容</span><br><span class="line"></span><br><span class="line">        FileInputStream fileInputStream = new FileInputStream(new File(basePath + name));</span><br><span class="line"></span><br><span class="line">        //通过输出流将文件写回浏览器，在浏览器展示图片</span><br><span class="line"></span><br><span class="line">        ServletOutputStream outputStream = response.getOutputStream();</span><br><span class="line"></span><br><span class="line">        response.setContentType(&quot;image/jpeg&quot;);</span><br><span class="line"></span><br><span class="line">        int len = 0;</span><br><span class="line">        byte[] bytes = new byte[1024];</span><br><span class="line">        while ( (len = fileInputStream.read(bytes)) != -1) &#123;</span><br><span class="line">            outputStream.write(bytes,0,len);</span><br><span class="line">            outputStream.flush();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //关闭资源</span><br><span class="line">        outputStream.close();</span><br><span class="line">        fileInputStream.close();</span><br><span class="line"></span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>springboot - 外卖平台</tag>
        <tag>项目开发</tag>
        <tag>mybatis plus</tag>
        <tag>文件上传下载</tag>
      </tags>
  </entry>
  <entry>
    <title>外卖管理平台新增套餐</title>
    <url>/2022/09/13/%E5%A4%96%E5%8D%96%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0%E6%96%B0%E5%A2%9E%E5%A5%97%E9%A4%90/</url>
    <content><![CDATA[<h3 id="一、需求分析"><a href="#一、需求分析" class="headerlink" title="一、需求分析"></a>一、需求分析</h3><p>套餐就是菜品的集合。</p>
<p>后台系统中可以管理套餐信息，通过新增套餐功能来添加一个新的套餐，在添加套餐时需要选择当前套餐所属的套餐分类和包含的菜品，并且需要上传套餐对应的图片，在移动端会按照套餐分类来展示对应的套餐。</p>
<span id="more"></span>
<h4 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h4><p>新增套餐，其实就是将新增页面录入的套餐信息插入到setmeal表，还需要向setmeal_dish表插入套餐和菜品关联数据。</p>
<p>所以在新增套餐时，涉及到两个表:</p>
<p>setmeal    套餐表</p>
<p>setmeal_dish套餐菜品关系表</p>
<h3 id="二、代码开发-准备工作"><a href="#二、代码开发-准备工作" class="headerlink" title="二、代码开发 - 准备工作"></a>二、代码开发 - 准备工作</h3><p>在开发业务功能前,先将需要用到的类和接口基本结构创建好:</p>
<ul>
<li>实体类SetmealDish</li>
<li>DTO SetmealDto</li>
<li>Mapper接口SetmealDishMapper</li>
<li>业务层接口SetmealDishService</li>
<li>业务层实现类SetmealDishServicelmpl</li>
<li>控制层SetmealController</li>
</ul>
<h4 id="梳理交互过程"><a href="#梳理交互过程" class="headerlink" title="梳理交互过程"></a>梳理交互过程</h4><p>在开发代码之前，需要梳理一下新增套餐时前端页面和服务端的交互过程:</p>
<p>1、页面(backend/page/comboladd.html)发送ajax请求，请求服务端获取套餐分类数据并展示到下拉框中2、页面发送ajax请求，请求服务端获取菜品分类数据并展示到添加菜品窗口中</p>
<p>3、页面发送ajax请求，请求服务端，根据菜品分类查询对应的菜品数据并展示到添加菜品窗口中</p>
<p>4、页面发送请求进行图片上传，请求服务端将图片保存到服务器</p>
<p>5、页面发送请求进行图片下载，将上传的图片进行回显</p>
<p>6、点击保存按钮，发送ajax请求，将套餐相关数据以json形式提交到服务端</p>
<p>开发新增套餐功能，其实就是在服务端编写代码去处理前端页面发送的这6次请求即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 根据条件查询对应的菜品数据</span><br><span class="line"> * @param dish</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">@GetMapping(&quot;/list&quot;)</span><br><span class="line">public R&lt;List&lt;Dish&gt;&gt; list(Dish dish) &#123;</span><br><span class="line"></span><br><span class="line">    //构造查询条件</span><br><span class="line">    LambdaQueryWrapper&lt;Dish&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">    queryWrapper.eq(dish.getCategoryId() != null , Dish::getCategoryId, dish.getCategoryId());</span><br><span class="line">    //查询状态为1</span><br><span class="line">    queryWrapper.eq(Dish::getStatus,1);</span><br><span class="line">    //添加一个排序条件</span><br><span class="line">    queryWrapper.orderByAsc(Dish::getSort).orderByDesc(Dish::getUpdateTime);</span><br><span class="line"></span><br><span class="line">    List&lt;Dish&gt; list = dishService.list(queryWrapper);</span><br><span class="line">    return R.success(list);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.controller;</span><br><span class="line"></span><br><span class="line">import com.itheima.reggie.common.R;</span><br><span class="line">import com.itheima.reggie.dto.SetmealDto;</span><br><span class="line">import com.itheima.reggie.service.CategoryService;</span><br><span class="line">import com.itheima.reggie.service.SetmealDishService;</span><br><span class="line">import com.itheima.reggie.service.SetmealService;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestBody;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 套餐管理</span><br><span class="line"> */</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/setmeal&quot;)</span><br><span class="line">@Slf4j</span><br><span class="line">public class SetmealController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private SetmealService setmealService;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private CategoryService categoryService;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private SetmealDishService setmealDishService;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 新增套餐</span><br><span class="line">     * @param setmealDto</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @PostMapping</span><br><span class="line">    public R&lt;String&gt; save(@RequestBody SetmealDto setmealDto)&#123;</span><br><span class="line">        log.info(&quot;套餐信息：&#123;&#125;&quot;,setmealDto);</span><br><span class="line"></span><br><span class="line">        setmealService.saveWithDish(setmealDto);</span><br><span class="line"></span><br><span class="line">        return R.success(&quot;新增套餐成功&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.service;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.extension.service.IService;</span><br><span class="line">import com.itheima.reggie.dto.SetmealDto;</span><br><span class="line">import com.itheima.reggie.entity.Setmeal;</span><br><span class="line"></span><br><span class="line">public interface SetmealService extends IService&lt;Setmeal&gt; &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 新增套餐，同时需要保存套餐和菜品的关系</span><br><span class="line">     * @param setmealDto</span><br><span class="line">     */</span><br><span class="line">    public void saveWithDish(SetmealDto setmealDto);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.service.impl;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;</span><br><span class="line">import com.itheima.reggie.dto.SetmealDto;</span><br><span class="line">import com.itheima.reggie.entity.Setmeal;</span><br><span class="line">import com.itheima.reggie.entity.SetmealDish;</span><br><span class="line">import com.itheima.reggie.mapper.SetmealMapper;</span><br><span class="line">import com.itheima.reggie.service.SetmealDishService;</span><br><span class="line">import com.itheima.reggie.service.SetmealService;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line">import org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">@Slf4j</span><br><span class="line">public class SetmealServiceImpl extends ServiceImpl&lt;SetmealMapper, Setmeal&gt; implements SetmealService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private SetmealDishService setmealDishService;</span><br><span class="line">    /**</span><br><span class="line">     * 新增套餐，同时需要保存套餐和菜品的关系</span><br><span class="line">     * @param setmealDto</span><br><span class="line">     */</span><br><span class="line">    @Transactional</span><br><span class="line">    public void saveWithDish(SetmealDto setmealDto) &#123;</span><br><span class="line">        //保存套餐的基本信息，执行insert操作</span><br><span class="line">        this.save(setmealDto);</span><br><span class="line">        List&lt;SetmealDish&gt; setmealDishes = setmealDto.getSetmealDishes();</span><br><span class="line">        setmealDishes.stream().map((item) -&gt; &#123;</span><br><span class="line">            item.setSetmealId(setmealDto.getId());</span><br><span class="line">            return item;</span><br><span class="line">        &#125;).collect(Collectors.toList());</span><br><span class="line">        //保存套餐和菜品的关联信息，操作setmeal_dish,执行insert操作</span><br><span class="line">        setmealDishService.saveBatch(setmealDishes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>springboot - 外卖平台</tag>
        <tag>项目开发</tag>
        <tag>mybatis plus</tag>
        <tag>新增套餐</tag>
      </tags>
  </entry>
  <entry>
    <title>外卖管理平台新增菜品</title>
    <url>/2022/09/10/%E5%A4%96%E5%8D%96%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0%E6%96%B0%E5%A2%9E%E8%8F%9C%E5%93%81/</url>
    <content><![CDATA[<h3 id="一、需求分析"><a href="#一、需求分析" class="headerlink" title="一、需求分析"></a>一、需求分析</h3><p>后台系统中可以管理菜品信息，通过新增功能来添加一个新的菜品，在添加菜品时需要选择当前菜品所属的菜品分类，并且需要上传菜品图片，在移动端会按照菜品分类来展示对应的菜品信息。</p>
<span id="more"></span>
<h4 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h4><p>新增菜品，其实就是将新增页面录入的菜品信息插入到dish表，如果添加了口味做法，还需要向dish_flavor表插入数据.所以在新增菜品时，涉及到两个表:</p>
<ul>
<li>dish    菜品表</li>
<li>dish_flavor菜品口味表</li>
</ul>
<h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><p>在开发业务功能前，先将需要用到的类和接口基本结构创建好︰</p>
<ul>
<li>实体类DishFlavor</li>
<li>Mapper接口DishFlavorMapper</li>
<li>业务层接口DishFlavorService</li>
<li>业务层实现类DishFlavorServicelmpl控制层DishController</li>
</ul>
<h3 id="二、代码开发-梳理交互过程"><a href="#二、代码开发-梳理交互过程" class="headerlink" title="二、代码开发-梳理交互过程"></a>二、代码开发-梳理交互过程</h3><p>在开发代码之前，需要梳理一下新增菜品时前端页面和服务端的交互过程:</p>
<p>代码开发-梳理交互过程<br>在开发代码之前，需要梳理一下新增菜品时前端页面和服务端的交互过程:</p>
<p> 1、页面(backend/page/food/add.html)发送ajax请求，请求服务端获取菜品分类数据并展示到下拉框中</p>
<p>2、页面发送请求进行图片上传，请求服务端将图片保存到服务器<br>3、页面发送请求进行图片下载，将上传的图片进行回显<br>4、点击保存按钮，发送ajax请求，将菜品相关数据以json形式提交到服务端</p>
<p><code>开发新增菜品功能，其实就是在服务端编写代码去处理前端页面发送的这4次请求即可。</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据条件查询分类数据</span><br><span class="line">     * @param category</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @GetMapping(&quot;/list&quot;)</span><br><span class="line">    public R&lt;List&lt;Category&gt;&gt; list(Category category) &#123;</span><br><span class="line">        //条件构造器</span><br><span class="line">LambdaQueryWrapper&lt;Category&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">        //添加条件</span><br><span class="line">queryWrapper.eq(category.getType() != null, Category::getType, category.getType());</span><br><span class="line">        //添加排序条件</span><br><span class="line">        queryWrapper.orderByAsc(Category::getSort).orderByDesc(Category::getUpdateTime);</span><br><span class="line"></span><br><span class="line">        List&lt;Category&gt; list = categoryService.list(queryWrapper);</span><br><span class="line">        return R.success(list);</span><br></pre></td></tr></table></figure>
<h4 id="导入DTO"><a href="#导入DTO" class="headerlink" title="导入DTO"></a>导入DTO</h4><p>导入DishDto，用于封装页面提交的数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class DishDto extends Dish &#123;</span><br><span class="line">private List&lt;DishFlavor&gt; flavors = new ArrayList&lt;&gt; () ;</span><br><span class="line">private String categoryName;</span><br><span class="line">private Integer copies;</span><br></pre></td></tr></table></figure>
<p><code>注意事项</code><br><code>DTO，全称为Data Transfer Object，即数据传输对象，一般用于展示层与服务层之同的数据传输。</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.dto;</span><br><span class="line"></span><br><span class="line">import com.itheima.reggie.entity.Dish;</span><br><span class="line">import com.itheima.reggie.entity.DishFlavor;</span><br><span class="line">import lombok.Data;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">@Data</span><br><span class="line">public class DishDto extends Dish &#123;</span><br><span class="line"></span><br><span class="line">    private List&lt;DishFlavor&gt; flavors = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    private String categoryName;</span><br><span class="line"></span><br><span class="line">    private Integer copies;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.controller;</span><br><span class="line"></span><br><span class="line">import com.itheima.reggie.common.R;</span><br><span class="line">import com.itheima.reggie.dto.DishDto;</span><br><span class="line">import com.itheima.reggie.service.DishFlavorService;</span><br><span class="line">import com.itheima.reggie.service.DishService;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestBody;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/dish&quot;)</span><br><span class="line">@Slf4j</span><br><span class="line">public class DishController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private DishService dishService;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private DishFlavorService dishFlavorService;</span><br><span class="line"></span><br><span class="line">    @PostMapping</span><br><span class="line">    public R&lt;String&gt; save(@RequestBody DishDto dishDto) &#123;</span><br><span class="line"></span><br><span class="line">        log.info(dishDto.toString());</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.service.impl;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;</span><br><span class="line">import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;</span><br><span class="line">import com.itheima.reggie.dto.DishDto;</span><br><span class="line">import com.itheima.reggie.entity.Dish;</span><br><span class="line">import com.itheima.reggie.entity.DishFlavor;</span><br><span class="line">import com.itheima.reggie.mapper.DishMapper;</span><br><span class="line">import com.itheima.reggie.service.DishFlavorService;</span><br><span class="line">import com.itheima.reggie.service.DishService;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.beans.BeanUtils;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line">import org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line">import java.util.Collections;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">@Slf4j</span><br><span class="line">public class DishServiceImpl extends ServiceImpl&lt;DishMapper,Dish&gt; implements DishService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private DishFlavorService dishFlavorService;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 新增菜品，同时保存对应的口味数据</span><br><span class="line">     * @param dishDto</span><br><span class="line">     */</span><br><span class="line">    @Transactional</span><br><span class="line">    public void saveWithFlavor(DishDto dishDto) &#123;</span><br><span class="line">        //保存菜品的基本信息到菜品表dish</span><br><span class="line">        this.save(dishDto);</span><br><span class="line"></span><br><span class="line">        Long dishId = dishDto.getId();//菜品id</span><br><span class="line"></span><br><span class="line">        //菜品口味</span><br><span class="line">        List&lt;DishFlavor&gt; flavors = dishDto.getFlavors();</span><br><span class="line">        flavors = flavors.stream().map((item) -&gt; &#123;</span><br><span class="line">            item.setDishId(dishId);</span><br><span class="line">            return item;</span><br><span class="line">        &#125;).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        //保存菜品口味数据到菜品口味表dish_flavor</span><br><span class="line">        dishFlavorService.saveBatch(flavors);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据id查询菜品信息和对应的口味信息</span><br><span class="line">     * @param id</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public DishDto getByIdWithFlavor(Long id) &#123;</span><br><span class="line">        //查询菜品基本信息，从dish表查询</span><br><span class="line">        Dish dish = this.getById(id);</span><br><span class="line"></span><br><span class="line">        DishDto dishDto = new DishDto();</span><br><span class="line">        BeanUtils.copyProperties(dish,dishDto);</span><br><span class="line"></span><br><span class="line">        //查询当前菜品对应的口味信息，从dish_flavor表查询</span><br><span class="line">        LambdaQueryWrapper&lt;DishFlavor&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">        queryWrapper.eq(DishFlavor::getDishId,dish.getId());</span><br><span class="line">        List&lt;DishFlavor&gt; flavors = dishFlavorService.list(queryWrapper);</span><br><span class="line">        dishDto.setFlavors(flavors);</span><br><span class="line"></span><br><span class="line">        return dishDto;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Transactional</span><br><span class="line">    public void updateWithFlavor(DishDto dishDto) &#123;</span><br><span class="line">        //更新dish表基本信息</span><br><span class="line">        this.updateById(dishDto);</span><br><span class="line"></span><br><span class="line">        //清理当前菜品对应口味数据---dish_flavor表的delete操作</span><br><span class="line">        LambdaQueryWrapper&lt;DishFlavor&gt; queryWrapper = new LambdaQueryWrapper();</span><br><span class="line">        queryWrapper.eq(DishFlavor::getDishId,dishDto.getId());</span><br><span class="line"></span><br><span class="line">        dishFlavorService.remove(queryWrapper);</span><br><span class="line"></span><br><span class="line">        //添加当前提交过来的口味数据---dish_flavor表的insert操作</span><br><span class="line">        List&lt;DishFlavor&gt; flavors = dishDto.getFlavors();</span><br><span class="line"></span><br><span class="line">        flavors = flavors.stream().map((item) -&gt; &#123;</span><br><span class="line">            item.setDishId(dishDto.getId());</span><br><span class="line">            return item;</span><br><span class="line">        &#125;).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        dishFlavorService.saveBatch(flavors);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.controller;</span><br><span class="line"></span><br><span class="line">import com.itheima.reggie.common.R;</span><br><span class="line">import com.itheima.reggie.dto.DishDto;</span><br><span class="line">import com.itheima.reggie.service.DishFlavorService;</span><br><span class="line">import com.itheima.reggie.service.DishService;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestBody;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/dish&quot;)</span><br><span class="line">@Slf4j</span><br><span class="line">public class DishController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private DishService dishService;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private DishFlavorService dishFlavorService;</span><br><span class="line"></span><br><span class="line">    @PostMapping</span><br><span class="line">    public R&lt;String&gt; save(@RequestBody DishDto dishDto) &#123;</span><br><span class="line"></span><br><span class="line">        log.info(dishDto.toString());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        dishService.saveWithFlavor(dishDto);</span><br><span class="line">        return R.success(&quot;新增菜品成功&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line">import org.springframework.boot.web.servlet.ServletComponentScan;</span><br><span class="line">import org.springframework.transaction.annotation.EnableTransactionManagement;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Slf4j</span><br><span class="line">@SpringBootApplication</span><br><span class="line">@ServletComponentScan</span><br><span class="line">@EnableTransactionManagement</span><br><span class="line">public class ReggieApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(ReggieApplication.class,args);</span><br><span class="line">        log.info(&quot;项目启动成功...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>springboot - 外卖平台</tag>
        <tag>项目开发</tag>
        <tag>mybatis plus</tag>
        <tag>新增菜品</tag>
      </tags>
  </entry>
  <entry>
    <title>外卖管理平台短信发送</title>
    <url>/2022/09/14/%E5%A4%96%E5%8D%96%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0%E7%9F%AD%E4%BF%A1%E5%8F%91%E9%80%81/</url>
    <content><![CDATA[<h3 id="一、短信服务介绍"><a href="#一、短信服务介绍" class="headerlink" title="一、短信服务介绍"></a>一、短信服务介绍</h3><p>目前市面上有很多第三方提供的短信服务，这些第三方短信服务会和各个运营商（移动、联通、电信）对接，我们只需要注册成为会员并且按照提供的开发文档进行调用就可以发送短信。需要说明的是，这些短信服务一般都是收费服务。</p>
<span id="more"></span>
<p>常用短信服务:</p>
<ul>
<li>阿里云</li>
<li>华为云</li>
<li>腾讯云</li>
<li>京东</li>
<li>梦网</li>
<li>乐信</li>
</ul>
<h4 id="阿里云短信服务-介绍"><a href="#阿里云短信服务-介绍" class="headerlink" title="阿里云短信服务-介绍"></a>阿里云短信服务-介绍</h4><p>阿里云短信服务（Short Message Service)是广大企业客户快速触达手机用户所优选使用的通信能力。调用API或用群发助手，即可发送验证码、通知类和营销类短信;国内验证短信秒级触达，到达率最高可达99%;国际/港澳台短信覆盖200多个国家和地区，安全稳定，广受出海企业选用。</p>
<p>应用场景:</p>
<ul>
<li>验证码</li>
<li>短信通知</li>
<li>推广短信</li>
</ul>
<h4 id="阿里云短信服务-注册账号"><a href="#阿里云短信服务-注册账号" class="headerlink" title="阿里云短信服务-注册账号"></a>阿里云短信服务-注册账号</h4><p>阿里云官网: https:// www.aliyun.com/</p>
<p>点击官网首页注册按钮，跳转到如下注册页面:</p>
<p><img src="https://i.p04e.com/baid/i/2022/09/18/uub.png"></p>
<h4 id="阿里云短信服务-设置短信签名"><a href="#阿里云短信服务-设置短信签名" class="headerlink" title="阿里云短信服务-设置短信签名"></a>阿里云短信服务-设置短信签名</h4><p>注册成功后，点击登录按钮进行登录。登录后进入短信服务管理页面，选择国内消息菜单:</p>
<p><img src="https://i.p04e.com/baid/i/2022/09/18/n3tp.png"></p>
<p>短信签名是短信发送者的署名，表示发送方的身份。</p>
<h4 id="阿里云短信服务-设置短信模板"><a href="#阿里云短信服务-设置短信模板" class="headerlink" title="阿里云短信服务-设置短信模板"></a>阿里云短信服务-设置短信模板</h4><p>切换到【模板管理】标签页:</p>
<p><img src="https://i.p04e.com/baid/i/2022/09/18/y3t7.png"></p>
<h4 id="阿里云短信服务-设置AccessKey"><a href="#阿里云短信服务-设置AccessKey" class="headerlink" title="阿里云短信服务-设置AccessKey"></a>阿里云短信服务-设置AccessKey</h4><p>光标移动到用户头像上，在弹出的窗口中点击【AccessKey管理】∶</p>
<p><img src="https://i.p04e.com/baid/i/2022/09/18/2r.png"></p>
<p>选择子用户。</p>
<p>使用阿里云短信服务发送短信，可以参照官方提供的<a href="https://help.aliyun.com/product/44282.html?spm=5176.25163407.help.dexternal.51a7bb6e9O0uQU">文档</a>即可。</p>
<p>具体开发步骤:</p>
<p>1、导入maven坐标</p>
<p>2、调用API</p>
<p><img src="https://i.p04e.com/baid/i/2022/09/18/9m94.png"></p>
<h3 id="二、需求分析"><a href="#二、需求分析" class="headerlink" title="二、需求分析"></a>二、需求分析</h3><p>为了方便用户登录，移动端通常都会提供通过手机验证码登录的功能。<br>心</p>
<p>手机验证码登录的优点:</p>
<ul>
<li>方便快捷，无需注册，直接登录</li>
<li>使用短信验证码作为登录凭证，无需记忆密码</li>
<li>安全<br>登录流程:<br>输入手机号&gt;获取验证码&gt;输入验证码&gt;点击登录&gt;登录成功<br><code>注意:通过手机验证码登录，手机号是区分不同用户的标识。</code></li>
</ul>
<h4 id="三、代码开发-梳理交互过程"><a href="#三、代码开发-梳理交互过程" class="headerlink" title="三、代码开发-梳理交互过程"></a>三、代码开发-梳理交互过程</h4><p>在开发代码之前，需要梳理一下登录时前端页面和服务端的交互过程:</p>
<p>1、在登录页面(front/page/login.html)输入手机号，点击【获取验证码】按钮，页面发送ajax请求，在服务端调用短信服务API给指定手机号发送验证码短信</p>
<p>2、在登录页面输入验证码，点击【登录】按钮，发送ajax请求，在服务端处理登录请求</p>
<p>开发手机验证码登录功能，其实就是在服务端编写代码去处理前端页面发送的这2次请求即可。</p>
<h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><p>在开发业务功能前，先将需要用到的类和接口基本结构创建好:实体类User（</p>
<p>Mapper接口UserMapper</p>
<p>业务层接口UserService</p>
<p>业务层实现类UserServicelmpl控制层Usercontroller</p>
<p>工具类SMSutils、ValidateCodeutils</p>
<h4 id="代码开发-修改LoginCheckFilter"><a href="#代码开发-修改LoginCheckFilter" class="headerlink" title="代码开发-修改LoginCheckFilter"></a>代码开发-修改LoginCheckFilter</h4><p>前面我们已经完成了LoginCheckFilter过滤器的开发，此过滤器用于检查用户的登录状态。我们在进行手机验证码登录时，发送的请求需要在此过滤器处理时直接放行。</p>
<p><img src="https://i.p04e.com/baid/i/2022/09/18/d0i.png"></p>
<p>在LoginCheckFilter过滤器中扩展逻辑，判断移动端用户登录状态:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//4-1、判断登录状态，如果已登录，则直接放行</span><br><span class="line">        if(request.getSession().getAttribute(&quot;employee&quot;) != null)&#123;</span><br><span class="line">            log.info(&quot;用户已登录，用户id为：&#123;&#125;&quot;,request.getSession().getAttribute(&quot;employee&quot;));</span><br><span class="line"></span><br><span class="line">            Long empId = (Long) request.getSession().getAttribute(&quot;employee&quot;);</span><br><span class="line">            BaseContext.setCurrentId(empId);</span><br><span class="line"></span><br><span class="line">            filterChain.doFilter(request,response);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //4-2、判断登录状态，如果已登录，则直接放行</span><br><span class="line">        if(request.getSession().getAttribute(&quot;user&quot;) != null)&#123;</span><br><span class="line">            log.info(&quot;用户已登录，用户id为：&#123;&#125;&quot;,request.getSession().getAttribute(&quot;user&quot;));</span><br><span class="line"></span><br><span class="line">            Long userId = (Long) request.getSession().getAttribute(&quot;user&quot;);</span><br><span class="line">            BaseContext.setCurrentId(userId);</span><br><span class="line"></span><br><span class="line">            filterChain.doFilter(request,response);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        log.info(&quot;用户未登录&quot;);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.controller;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;</span><br><span class="line">import com.itheima.reggie.common.R;</span><br><span class="line">import com.itheima.reggie.entity.User;</span><br><span class="line">import com.itheima.reggie.service.UserService;</span><br><span class="line">import com.itheima.reggie.utils.ValidateCodeUtils;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.apache.commons.lang.StringUtils;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestBody;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">import javax.servlet.http.HttpSession;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/user&quot;)</span><br><span class="line">@Slf4j</span><br><span class="line">public class UserController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private UserService userService;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 发送手机短信验证码</span><br><span class="line">     * @param user</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @PostMapping(&quot;/sendMsg&quot;)</span><br><span class="line">    public R&lt;String&gt; sendMsg(@RequestBody User user, HttpSession session)&#123;</span><br><span class="line">        //获取手机号</span><br><span class="line">        String phone = user.getPhone();</span><br><span class="line"></span><br><span class="line">        if(StringUtils.isNotEmpty(phone))&#123;</span><br><span class="line">            //生成随机的4位验证码</span><br><span class="line">            String code = ValidateCodeUtils.generateValidateCode(4).toString();</span><br><span class="line">            log.info(&quot;code=&#123;&#125;&quot;,code);</span><br><span class="line"></span><br><span class="line">            //调用阿里云提供的短信服务API完成发送短信</span><br><span class="line">            //SMSUtils.sendMessage(&quot;瑞吉外卖&quot;,&quot;&quot;,phone,code);</span><br><span class="line"></span><br><span class="line">            //需要将生成的验证码保存到Session</span><br><span class="line">            session.setAttribute(phone,code);</span><br><span class="line"></span><br><span class="line">            return R.success(&quot;手机验证码短信发送成功&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return R.error(&quot;短信发送失败&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 移动端用户登录</span><br><span class="line">     * @param map</span><br><span class="line">     * @param session</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @PostMapping(&quot;/login&quot;)</span><br><span class="line">    public R&lt;User&gt; login(@RequestBody Map map, HttpSession session)&#123;</span><br><span class="line">        log.info(map.toString());</span><br><span class="line"></span><br><span class="line">        //获取手机号</span><br><span class="line">        String phone = map.get(&quot;phone&quot;).toString();</span><br><span class="line"></span><br><span class="line">        //获取验证码</span><br><span class="line">        String code = map.get(&quot;code&quot;).toString();</span><br><span class="line"></span><br><span class="line">        //从Session中获取保存的验证码</span><br><span class="line">        Object codeInSession = session.getAttribute(phone);</span><br><span class="line"></span><br><span class="line">        //进行验证码的比对（页面提交的验证码和Session中保存的验证码比对）</span><br><span class="line">        if(codeInSession != null &amp;&amp; codeInSession.equals(code))&#123;</span><br><span class="line">            //如果能够比对成功，说明登录成功</span><br><span class="line"></span><br><span class="line">            LambdaQueryWrapper&lt;User&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">            queryWrapper.eq(User::getPhone,phone);</span><br><span class="line"></span><br><span class="line">            User user = userService.getOne(queryWrapper);</span><br><span class="line">            if(user == null)&#123;</span><br><span class="line">                //判断当前手机号对应的用户是否为新用户，如果是新用户就自动完成注册</span><br><span class="line">                user = new User();</span><br><span class="line">                user.setPhone(phone);</span><br><span class="line">                user.setStatus(1);</span><br><span class="line">                userService.save(user);</span><br><span class="line">            &#125;</span><br><span class="line">            session.setAttribute(&quot;user&quot;,user.getId());</span><br><span class="line">            return R.success(user);</span><br><span class="line">        &#125;</span><br><span class="line">        return R.error(&quot;登录失败&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>springboot - 外卖平台</tag>
        <tag>项目开发</tag>
        <tag>mybatis plus</tag>
        <tag>短信发送</tag>
      </tags>
  </entry>
  <entry>
    <title>外卖管理平台用户下单</title>
    <url>/2022/09/19/%E5%A4%96%E5%8D%96%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0%E7%94%A8%E6%88%B7%E4%B8%8B%E5%8D%95/</url>
    <content><![CDATA[<h3 id="一、需求分析"><a href="#一、需求分析" class="headerlink" title="一、需求分析"></a>一、需求分析</h3><p>移动端用户将菜品或者套餐加入购物车后，可以点击购物车中的去结算按钮，页面跳转到订单确认页面，点<br>击去支付按钮则完成下单操作。</p>
<span id="more"></span>
<h4 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h4><p>用户下单业务对应的数据表为orders表和order_detail表:</p>
<ul>
<li>orders:订单表</li>
<li>order_detail:订单明细表</li>
</ul>
<h3 id="二、代码开发-梳理交互过程"><a href="#二、代码开发-梳理交互过程" class="headerlink" title="二、代码开发-梳理交互过程"></a>二、代码开发-梳理交互过程</h3><p>在开发代码之前，需要梳理一下用户下单操作时前端页面和服务端的交互过程:</p>
<p>1、在购物车中点击按钮，页面跳转到订单确认页面</p>
<p>2、在订单确认页面，发送ajax请求，请求服务端获取当前登录用户的默认地址</p>
<p>3、在订单确认页面，发送ajax请求，请求服务端获取当前登录用户的购物车数据</p>
<p>4、在订单确认页面点击去支付按钮，发送ajax请求，请求服务端完成下单操作</p>
<p>开发用户下单功能，其实就是在服务端编写代码去处理前端页面发送的请求即可。</p>
<h4 id="代码开发-准备工作"><a href="#代码开发-准备工作" class="headerlink" title="代码开发-准备工作"></a>代码开发-准备工作</h4><p>在开发业务功能前，先将需要用到的类和接口基本结构创建好:</p>
<ul>
<li>实体类Orders、OrderDetail </li>
<li>Mapper接口OrderMapper、OrderDetailMapper</li>
<li>业务层接口OrderService.OrderDetailService</li>
<li>业务层实现类QrderServicelmpl、OrderDetailServicelmpl</li>
<li>控制层OrderController、OrderDetailController</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.controller;</span><br><span class="line"></span><br><span class="line">import com.itheima.reggie.common.R;</span><br><span class="line">import com.itheima.reggie.entity.Orders;</span><br><span class="line">import com.itheima.reggie.service.OrderService;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestBody;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 订单</span><br><span class="line"> */</span><br><span class="line">@Slf4j</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/order&quot;)</span><br><span class="line">public class OrderController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private OrderService orderService;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 用户下单</span><br><span class="line">     * @param orders</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @PostMapping(&quot;/submit&quot;)</span><br><span class="line">    public R&lt;String&gt; submit(@RequestBody Orders orders)&#123;</span><br><span class="line">        log.info(&quot;订单数据：&#123;&#125;&quot;,orders);</span><br><span class="line">        orderService.submit(orders);</span><br><span class="line">        return R.success(&quot;下单成功&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.service;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.extension.service.IService;</span><br><span class="line">import com.itheima.reggie.entity.Orders;</span><br><span class="line"></span><br><span class="line">public interface OrderService extends IService&lt;Orders&gt; &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 用户下单</span><br><span class="line">     * @param orders</span><br><span class="line">     */</span><br><span class="line">    public void submit(Orders orders);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.service.impl;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;</span><br><span class="line">import com.baomidou.mybatisplus.core.toolkit.IdWorker;</span><br><span class="line">import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;</span><br><span class="line">import com.itheima.reggie.common.BaseContext;</span><br><span class="line">import com.itheima.reggie.common.CustomException;</span><br><span class="line">import com.itheima.reggie.entity.*;</span><br><span class="line">import com.itheima.reggie.mapper.OrderMapper;</span><br><span class="line">import com.itheima.reggie.service.*;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line">import org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line">import java.math.BigDecimal;</span><br><span class="line">import java.time.LocalDateTime;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line">import java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">@Slf4j</span><br><span class="line">public class OrderServiceImpl extends ServiceImpl&lt;OrderMapper, Orders&gt; implements OrderService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private ShoppingCartService shoppingCartService;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private UserService userService;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private AddressBookService addressBookService;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private OrderDetailService orderDetailService;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 用户下单</span><br><span class="line">     * @param orders</span><br><span class="line">     */</span><br><span class="line">    @Transactional</span><br><span class="line">    public void submit(Orders orders) &#123;</span><br><span class="line">        //获得当前用户id</span><br><span class="line">        Long userId = BaseContext.getCurrentId();</span><br><span class="line"></span><br><span class="line">        //查询当前用户的购物车数据</span><br><span class="line">        LambdaQueryWrapper&lt;ShoppingCart&gt; wrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">        wrapper.eq(ShoppingCart::getUserId,userId);</span><br><span class="line">        List&lt;ShoppingCart&gt; shoppingCarts = shoppingCartService.list(wrapper);</span><br><span class="line"></span><br><span class="line">        if(shoppingCarts == null || shoppingCarts.size() == 0)&#123;</span><br><span class="line">            throw new CustomException(&quot;购物车为空，不能下单&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //查询用户数据</span><br><span class="line">        User user = userService.getById(userId);</span><br><span class="line"></span><br><span class="line">        //查询地址数据</span><br><span class="line">        Long addressBookId = orders.getAddressBookId();</span><br><span class="line">        AddressBook addressBook = addressBookService.getById(addressBookId);</span><br><span class="line">        if(addressBook == null)&#123;</span><br><span class="line">            throw new CustomException(&quot;用户地址信息有误，不能下单&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        long orderId = IdWorker.getId();//订单号</span><br><span class="line"></span><br><span class="line">        AtomicInteger amount = new AtomicInteger(0);</span><br><span class="line"></span><br><span class="line">        List&lt;OrderDetail&gt; orderDetails = shoppingCarts.stream().map((item) -&gt; &#123;</span><br><span class="line">            OrderDetail orderDetail = new OrderDetail();</span><br><span class="line">            orderDetail.setOrderId(orderId);</span><br><span class="line">            orderDetail.setNumber(item.getNumber());</span><br><span class="line">            orderDetail.setDishFlavor(item.getDishFlavor());</span><br><span class="line">            orderDetail.setDishId(item.getDishId());</span><br><span class="line">            orderDetail.setSetmealId(item.getSetmealId());</span><br><span class="line">            orderDetail.setName(item.getName());</span><br><span class="line">            orderDetail.setImage(item.getImage());</span><br><span class="line">            orderDetail.setAmount(item.getAmount());</span><br><span class="line">            amount.addAndGet(item.getAmount().multiply(new BigDecimal(item.getNumber())).intValue());</span><br><span class="line">            return orderDetail;</span><br><span class="line">        &#125;).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        orders.setId(orderId);</span><br><span class="line">        orders.setOrderTime(LocalDateTime.now());</span><br><span class="line">        orders.setCheckoutTime(LocalDateTime.now());</span><br><span class="line">        orders.setStatus(2);</span><br><span class="line">        orders.setAmount(new BigDecimal(amount.get()));//总金额</span><br><span class="line">        orders.setUserId(userId);</span><br><span class="line">        orders.setNumber(String.valueOf(orderId));</span><br><span class="line">        orders.setUserName(user.getName());</span><br><span class="line">        orders.setConsignee(addressBook.getConsignee());</span><br><span class="line">        orders.setPhone(addressBook.getPhone());</span><br><span class="line">        orders.setAddress((addressBook.getProvinceName() == null ? &quot;&quot; : addressBook.getProvinceName())</span><br><span class="line">                + (addressBook.getCityName() == null ? &quot;&quot; : addressBook.getCityName())</span><br><span class="line">                + (addressBook.getDistrictName() == null ? &quot;&quot; : addressBook.getDistrictName())</span><br><span class="line">                + (addressBook.getDetail() == null ? &quot;&quot; : addressBook.getDetail()));</span><br><span class="line">        //向订单表插入数据，一条数据</span><br><span class="line">        this.save(orders);</span><br><span class="line"></span><br><span class="line">        //向订单明细表插入数据，多条数据</span><br><span class="line">        orderDetailService.saveBatch(orderDetails);</span><br><span class="line"></span><br><span class="line">        //清空购物车数据</span><br><span class="line">        shoppingCartService.remove(wrapper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>springboot - 外卖平台</tag>
        <tag>项目开发</tag>
        <tag>mybatis plus</tag>
        <tag>用户下单</tag>
      </tags>
  </entry>
  <entry>
    <title>外卖管理平台菜品信息分页查询</title>
    <url>/2022/09/11/%E5%A4%96%E5%8D%96%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0%E8%8F%9C%E5%93%81%E4%BF%A1%E6%81%AF%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><h3 id="一、需求分析"><a href="#一、需求分析" class="headerlink" title="一、需求分析"></a>一、需求分析</h3><p>系统中的菜品数据很多的时候，如果在一个页面中全部展示出来会显得比较乱，不便于查看，所以一般的系统中都会以分页的方式来展示列表数据。</p>
<span id="more"></span>
<h3 id="二、代码开发"><a href="#二、代码开发" class="headerlink" title="二、代码开发"></a>二、代码开发</h3><h4 id="梳理交互过程"><a href="#梳理交互过程" class="headerlink" title="梳理交互过程"></a>梳理交互过程</h4><p>在开发代码之前，需要梳理一下菜品分页查询时前端页面和服务端的交互过程:</p>
<p>1、页面(backend/page/food/list.html)发送ajax请求，将分页查询参数(page、pageSize、name)提交到服务端，获取分页数据</p>
<p>2、页面发送请求，请求服务端进行图片下载，用于页面图片展示</p>
<p>开发菜品信息分页查询功能，其实就是在服务端编写代码去处理前端页面发送的这2次请求即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.controller;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;</span><br><span class="line">import com.baomidou.mybatisplus.extension.plugins.pagination.Page;</span><br><span class="line">import com.itheima.reggie.common.R;</span><br><span class="line">import com.itheima.reggie.dto.DishDto;</span><br><span class="line">import com.itheima.reggie.entity.Category;</span><br><span class="line">import com.itheima.reggie.entity.Dish;</span><br><span class="line">import com.itheima.reggie.service.CategoryService;</span><br><span class="line">import com.itheima.reggie.service.DishFlavorService;</span><br><span class="line">import com.itheima.reggie.service.DishService;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.beans.BeanUtils;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/dish&quot;)</span><br><span class="line">@Slf4j</span><br><span class="line">public class DishController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private DishService dishService;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private DishFlavorService dishFlavorService;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private CategoryService categoryService;</span><br><span class="line"></span><br><span class="line">    @PostMapping</span><br><span class="line">    public R&lt;String&gt; save(@RequestBody DishDto dishDto) &#123;</span><br><span class="line"></span><br><span class="line">        log.info(dishDto.toString());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        dishService.saveWithFlavor(dishDto);</span><br><span class="line">        return R.success(&quot;新增菜品成功&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 菜品信息分页</span><br><span class="line">     * @param page</span><br><span class="line">     * @param pageSize</span><br><span class="line">     * @param name</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @GetMapping(&quot;/page&quot;)</span><br><span class="line">    public R&lt;Page&gt; page(int page, int pageSize, String name) &#123;</span><br><span class="line"></span><br><span class="line">        //构造分页构造器</span><br><span class="line">        Page&lt;Dish&gt; pageInfo = new Page&lt;&gt;(page,pageSize);</span><br><span class="line">        Page&lt;DishDto&gt; dishDtoPage = new Page&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        //条件构造器</span><br><span class="line">        LambdaQueryWrapper&lt;Dish&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        //添加过滤条件</span><br><span class="line">        queryWrapper.like(name != null,Dish::getName, name);</span><br><span class="line"></span><br><span class="line">        //添加排序条件</span><br><span class="line">        queryWrapper.orderByDesc(Dish::getUpdateTime);</span><br><span class="line"></span><br><span class="line">        //执行分页查询</span><br><span class="line">        dishService.page(pageInfo, queryWrapper);</span><br><span class="line"></span><br><span class="line">        //对象拷贝</span><br><span class="line">        BeanUtils.copyProperties(pageInfo,dishDtoPage,&quot;records&quot;);</span><br><span class="line"></span><br><span class="line">        List&lt;Dish&gt; records = pageInfo.getRecords();</span><br><span class="line">        List&lt;DishDto&gt; list = records.stream().map((item) -&gt;  &#123;</span><br><span class="line">            DishDto dishDto = new DishDto();</span><br><span class="line"></span><br><span class="line">            BeanUtils.copyProperties(item, dishDto);</span><br><span class="line"></span><br><span class="line">            Long categoryId = item.getCategoryId();</span><br><span class="line"></span><br><span class="line">            //根据id查询分类对象</span><br><span class="line">            Category category = categoryService.getById(categoryId);</span><br><span class="line"></span><br><span class="line">            if (category != null) &#123;</span><br><span class="line">                String categoryName = category.getName();</span><br><span class="line">                dishDto.setCategoryName(categoryName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            return dishDto;</span><br><span class="line">        &#125;).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        dishDtoPage.setRecords(list);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        return R.success(dishDtoPage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>springboot - 外卖平台</tag>
        <tag>项目开发</tag>
        <tag>mybatis plus</tag>
        <tag>菜品信息分页查询</tag>
      </tags>
  </entry>
  <entry>
    <title>外卖管理平台菜品展示</title>
    <url>/2022/09/19/%E5%A4%96%E5%8D%96%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0%E8%8F%9C%E5%93%81%E5%B1%95%E7%A4%BA/</url>
    <content><![CDATA[<h3 id="一、菜品展示"><a href="#一、菜品展示" class="headerlink" title="一、菜品展示"></a>一、菜品展示</h3><p>用户登录成功后跳转到系统首页，在首页需要根据分类来展示菜品和套餐。如果菜品设置了口味信息，需要展示<code>选择规格</code>按钮，否则显示<code>+</code>按钮。</p>
<span id="more"></span>
<h3 id="二、代码开发-梳理交互过程"><a href="#二、代码开发-梳理交互过程" class="headerlink" title="二、代码开发-梳理交互过程"></a>二、代码开发-梳理交互过程</h3><p>在开发代码之前，需要梳理一下前端页面和服务端的交互过程:</p>
<p>在开发代码之前，需要梳理一下前端页面和服务端的交互过程:<br>1、页面(front/index.html)发送ajax请求，获取分类数据（菜品分类和套餐分类)</p>
<p>2、页面发送ajax请求，获取第一个分类下的菜品或者套餐</p>
<p>开发菜品展示功能，其实就是在服务端编写代码去处理前端页面发送的这2次请求即可。</p>
<p>注意:首页加载完成后，还发送了一次ajax请求用于加载购物车数据，此处可以将这次请求的地址暂时修改一下，从静态json文件获取数据，等后续开发购物车功能时再修改回来，如下:</p>
<p><img src="https://i.p04e.com/baid/i/2022/09/19/3puk7.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 根据条件查询对应的菜品数据</span><br><span class="line">     * @param dish</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    /*@GetMapping(&quot;/list&quot;)</span><br><span class="line">    public R&lt;List&lt;Dish&gt;&gt; list(Dish dish)&#123;</span><br><span class="line">        //构造查询条件</span><br><span class="line">        LambdaQueryWrapper&lt;Dish&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">        queryWrapper.eq(dish.getCategoryId() != null ,Dish::getCategoryId,dish.getCategoryId());</span><br><span class="line">        //添加条件，查询状态为1（起售状态）的菜品</span><br><span class="line">        queryWrapper.eq(Dish::getStatus,1);</span><br><span class="line"></span><br><span class="line">        //添加排序条件</span><br><span class="line">        queryWrapper.orderByAsc(Dish::getSort).orderByDesc(Dish::getUpdateTime);</span><br><span class="line"></span><br><span class="line">        List&lt;Dish&gt; list = dishService.list(queryWrapper);</span><br><span class="line"></span><br><span class="line">        return R.success(list);</span><br><span class="line">    &#125;*/</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/list&quot;)</span><br><span class="line">    public R&lt;List&lt;DishDto&gt;&gt; list(Dish dish)&#123;</span><br><span class="line">        //构造查询条件</span><br><span class="line">        LambdaQueryWrapper&lt;Dish&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">        queryWrapper.eq(dish.getCategoryId() != null ,Dish::getCategoryId,dish.getCategoryId());</span><br><span class="line">        //添加条件，查询状态为1（起售状态）的菜品</span><br><span class="line">        queryWrapper.eq(Dish::getStatus,1);</span><br><span class="line"></span><br><span class="line">        //添加排序条件</span><br><span class="line">        queryWrapper.orderByAsc(Dish::getSort).orderByDesc(Dish::getUpdateTime);</span><br><span class="line"></span><br><span class="line">        List&lt;Dish&gt; list = dishService.list(queryWrapper);</span><br><span class="line"></span><br><span class="line">        List&lt;DishDto&gt; dishDtoList = list.stream().map((item) -&gt; &#123;</span><br><span class="line">            DishDto dishDto = new DishDto();</span><br><span class="line"></span><br><span class="line">            BeanUtils.copyProperties(item,dishDto);</span><br><span class="line"></span><br><span class="line">            Long categoryId = item.getCategoryId();//分类id</span><br><span class="line">            //根据id查询分类对象</span><br><span class="line">            Category category = categoryService.getById(categoryId);</span><br><span class="line"></span><br><span class="line">            if(category != null)&#123;</span><br><span class="line">                String categoryName = category.getName();</span><br><span class="line">                dishDto.setCategoryName(categoryName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //当前菜品的id</span><br><span class="line">            Long dishId = item.getId();</span><br><span class="line">            LambdaQueryWrapper&lt;DishFlavor&gt; lambdaQueryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">            lambdaQueryWrapper.eq(DishFlavor::getDishId,dishId);</span><br><span class="line">            //SQL:select * from dish_flavor where dish_id = ?</span><br><span class="line">            List&lt;DishFlavor&gt; dishFlavorList = dishFlavorService.list(lambdaQueryWrapper);</span><br><span class="line">            dishDto.setFlavors(dishFlavorList);</span><br><span class="line">            return dishDto;</span><br><span class="line">        &#125;).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        return R.success(dishDtoList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 根据条件查询分类数据</span><br><span class="line"> * @param category</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">@GetMapping(&quot;/list&quot;)</span><br><span class="line">public R&lt;List&lt;Category&gt;&gt; list(Category category) &#123;</span><br><span class="line">    //条件构造器</span><br><span class="line">    LambdaQueryWrapper&lt;Category&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">    //添加条件</span><br><span class="line">    queryWrapper.eq(category.getType() != null, Category::getType, category.getType());</span><br><span class="line">    //添加排序条件</span><br><span class="line">    queryWrapper.orderByAsc(Category::getSort).orderByDesc(Category::getUpdateTime);</span><br><span class="line"></span><br><span class="line">    List&lt;Category&gt; list = categoryService.list(queryWrapper);</span><br><span class="line">    return R.success(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据条件查询套餐数据</span><br><span class="line">     * @param setmeal</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @GetMapping(&quot;/list&quot;)</span><br><span class="line">    public R&lt;List&lt;Setmeal&gt;&gt; list(Setmeal setmeal)&#123;</span><br><span class="line">        LambdaQueryWrapper&lt;Setmeal&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">        queryWrapper.eq(setmeal.getCategoryId() != null,Setmeal::getCategoryId,setmeal.getCategoryId());</span><br><span class="line">        queryWrapper.eq(setmeal.getStatus() != null,Setmeal::getStatus,setmeal.getStatus());</span><br><span class="line">        queryWrapper.orderByDesc(Setmeal::getUpdateTime);</span><br><span class="line"></span><br><span class="line">        List&lt;Setmeal&gt; list = setmealService.list(queryWrapper);</span><br><span class="line"></span><br><span class="line">        return R.success(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>springboot - 外卖平台</tag>
        <tag>项目开发</tag>
        <tag>mybatis plus</tag>
        <tag>菜品展示</tag>
      </tags>
  </entry>
  <entry>
    <title>外卖管理平台购物车</title>
    <url>/2022/09/19/%E5%A4%96%E5%8D%96%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0%E8%B4%AD%E7%89%A9%E8%BD%A6/</url>
    <content><![CDATA[<h3 id="一、需求分析"><a href="#一、需求分析" class="headerlink" title="一、需求分析"></a>一、需求分析</h3><p>移动端用户可以将菜品或者套餐添加到购物车。对于菜品来说，如果设置了口味信息，则需要选择规格后才能加入购物车;对于套餐来说，可以直接点击将当前套餐加入购物车。在购物车中可以修改菜品和套餐的数量，也可以清空购物车。</p>
<span id="more"></span>
<h3 id="二、代码开发-梳理交互过程"><a href="#二、代码开发-梳理交互过程" class="headerlink" title="二、代码开发-梳理交互过程"></a>二、代码开发-梳理交互过程</h3><p>在开发代码之前，需要梳理一下购物车操作时前端页面和服务端的交互过程:</p>
<p>1、点击加入购物或者按钮+，页面发送ajax请求，请求服务端，将菜品或者套餐添加到购物车</p>
<p>2、点击购物车图标，页面发送ajax请求，请求服务端查询购物车中的菜品和套餐</p>
<p>3、点击清空购物车按钮，页面发送ajax请求，请求服务端来执行清空购物车操作</p>
<p>开发购物车功能，其实就是在服务端编写代码去处理前端页面发送的这3次请求即可。</p>
<h4 id="代码开发-准备工作"><a href="#代码开发-准备工作" class="headerlink" title="代码开发-准备工作"></a>代码开发-准备工作</h4><p>在开发业务功能前，先将需要用到的类和接口基本结构创建好:</p>
<ul>
<li>实体类ShoppingCart(直接从课程资料中导入即可)</li>
<li>Mapper接口ShoppingCartMapper</li>
<li>业务层接口ShoppingCartservice</li>
<li>业务层实现类ShoppingCartServicelmpl控制层 ShoppingcartController</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.controller;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;</span><br><span class="line">import com.itheima.reggie.common.BaseContext;</span><br><span class="line">import com.itheima.reggie.common.R;</span><br><span class="line">import com.itheima.reggie.entity.ShoppingCart;</span><br><span class="line">import com.itheima.reggie.service.ShoppingCartService;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line">import java.time.LocalDateTime;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 购物车</span><br><span class="line"> */</span><br><span class="line">@Slf4j</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/shoppingCart&quot;)</span><br><span class="line">public class ShoppingCartController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private ShoppingCartService shoppingCartService;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 添加购物车</span><br><span class="line">     * @param shoppingCart</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @PostMapping(&quot;/add&quot;)</span><br><span class="line">    public R&lt;ShoppingCart&gt; add(@RequestBody ShoppingCart shoppingCart)&#123;</span><br><span class="line">        log.info(&quot;购物车数据:&#123;&#125;&quot;,shoppingCart);</span><br><span class="line"></span><br><span class="line">        //设置用户id，指定当前是哪个用户的购物车数据</span><br><span class="line">        Long currentId = BaseContext.getCurrentId();</span><br><span class="line">        shoppingCart.setUserId(currentId);</span><br><span class="line"></span><br><span class="line">        Long dishId = shoppingCart.getDishId();</span><br><span class="line"></span><br><span class="line">        LambdaQueryWrapper&lt;ShoppingCart&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">        queryWrapper.eq(ShoppingCart::getUserId,currentId);</span><br><span class="line"></span><br><span class="line">        if(dishId != null)&#123;</span><br><span class="line">            //添加到购物车的是菜品</span><br><span class="line">            queryWrapper.eq(ShoppingCart::getDishId,dishId);</span><br><span class="line"></span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            //添加到购物车的是套餐</span><br><span class="line">            queryWrapper.eq(ShoppingCart::getSetmealId,shoppingCart.getSetmealId());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //查询当前菜品或者套餐是否在购物车中</span><br><span class="line">        //SQL:select * from shopping_cart where user_id = ? and dish_id/setmeal_id = ?</span><br><span class="line">        ShoppingCart cartServiceOne = shoppingCartService.getOne(queryWrapper);</span><br><span class="line"></span><br><span class="line">        if(cartServiceOne != null)&#123;</span><br><span class="line">            //如果已经存在，就在原来数量基础上加一</span><br><span class="line">            Integer number = cartServiceOne.getNumber();</span><br><span class="line">            cartServiceOne.setNumber(number + 1);</span><br><span class="line">            shoppingCartService.updateById(cartServiceOne);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            //如果不存在，则添加到购物车，数量默认就是一</span><br><span class="line">            shoppingCart.setNumber(1);</span><br><span class="line">            shoppingCart.setCreateTime(LocalDateTime.now());</span><br><span class="line">            shoppingCartService.save(shoppingCart);</span><br><span class="line">            cartServiceOne = shoppingCart;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return R.success(cartServiceOne);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 查看购物车</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @GetMapping(&quot;/list&quot;)</span><br><span class="line">    public R&lt;List&lt;ShoppingCart&gt;&gt; list()&#123;</span><br><span class="line">        log.info(&quot;查看购物车...&quot;);</span><br><span class="line"></span><br><span class="line">        LambdaQueryWrapper&lt;ShoppingCart&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">        queryWrapper.eq(ShoppingCart::getUserId,BaseContext.getCurrentId());</span><br><span class="line">        queryWrapper.orderByAsc(ShoppingCart::getCreateTime);</span><br><span class="line"></span><br><span class="line">        List&lt;ShoppingCart&gt; list = shoppingCartService.list(queryWrapper);</span><br><span class="line"></span><br><span class="line">        return R.success(list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 清空购物车</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @DeleteMapping(&quot;/clean&quot;)</span><br><span class="line">    public R&lt;String&gt; clean()&#123;</span><br><span class="line">        //SQL:delete from shopping_cart where user_id = ?</span><br><span class="line"></span><br><span class="line">        LambdaQueryWrapper&lt;ShoppingCart&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">        queryWrapper.eq(ShoppingCart::getUserId,BaseContext.getCurrentId());</span><br><span class="line"></span><br><span class="line">        shoppingCartService.remove(queryWrapper);</span><br><span class="line"></span><br><span class="line">        return R.success(&quot;清空购物车成功&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>springboot - 外卖平台</tag>
        <tag>项目开发</tag>
        <tag>mybatis plus</tag>
        <tag>购物车</tag>
      </tags>
  </entry>
  <entry>
    <title>外卖项目优化之使用git管理代码</title>
    <url>/2022/09/20/%E5%A4%96%E5%8D%96%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96%E4%B9%8B%E4%BD%BF%E7%94%A8git%E7%AE%A1%E7%90%86%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<h3 id="一、配置ssh公钥"><a href="#一、配置ssh公钥" class="headerlink" title="一、配置ssh公钥"></a>一、配置ssh公钥</h3><p>在原来项目的基础上做出优化，先将代码移至gitee好管理代码。</p>
<span id="more"></span>
<h4 id="先配置好ssh公钥"><a href="#先配置好ssh公钥" class="headerlink" title="先配置好ssh公钥"></a>先配置好ssh公钥</h4><ul>
<li>在GitBash界面按照如下命令生成公匙</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;xxxxx@xxxxx.com&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><p>按照提示完成三次回车，即可生成 ssh key。</p>
</li>
<li><p>通过查看 ~/.ssh/id_rsa.pub文件内容，获取到你的 public key。</p>
</li>
<li><p>复制id_rsa.pub文件中中生成的sshkey</p>
</li>
<li><p>在 [个人用户] -&gt; [设置] -&gt; [安全设置] -&gt; [ssh公匙] 页面添加sshkey</p>
</li>
<li><p>将复制的sshkey添加到公匙输入框中，设置标题，确定即可添加公匙</p>
<h4 id="验证ssh公匙"><a href="#验证ssh公匙" class="headerlink" title="验证ssh公匙"></a>验证ssh公匙</h4><p>输入<code>ssh -T git@gitee.com</code></p>
<p>首次使用需要确认并添加主机到本机SSH可信列表。<br> 若返回 Hi XXX! You’ve successfully authenticated, but Gitee.com does not provide shell access. 内容，则证明添加成功。</p>
</li>
</ul>
<h3 id="二、使用gitee管理代码"><a href="#二、使用gitee管理代码" class="headerlink" title="二、使用gitee管理代码"></a>二、使用gitee管理代码</h3><p><img src="https://i.p04e.com/baid/i/2022/09/20/l2.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/20/5kl7.png"><br><img src="https://i.p04e.com/baid/i/2022/09/20/sxj.png"><br><img src="https://i.p04e.com/baid/i/2022/09/20/t41.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在根目录下添加.gitgnore文件，因为不是所有的文件都需要上传到gitee</span><br><span class="line">.git</span><br><span class="line">logs</span><br><span class="line">rebel.xml</span><br><span class="line">target/</span><br><span class="line">!.mvn/wrapper/maven-wrapper.jar</span><br><span class="line">log.path_IS_UNDEFINED</span><br><span class="line">.DS_Store</span><br><span class="line">offline_user.md</span><br><span class="line"></span><br><span class="line">### STS ###</span><br><span class="line">.apt_generated</span><br><span class="line">.classpath</span><br><span class="line">.factorypath</span><br><span class="line">.project</span><br><span class="line">.settings</span><br><span class="line">.springBeans</span><br><span class="line"></span><br><span class="line">### IntelliJ IDEA ###</span><br><span class="line">.idea</span><br><span class="line">*.iws</span><br><span class="line">*.iml</span><br><span class="line">*.ipr</span><br><span class="line"></span><br><span class="line">### NetBeans ###</span><br><span class="line">nbproject/private/</span><br><span class="line">build/</span><br><span class="line">nbbuild/</span><br><span class="line">dist/</span><br><span class="line">nbdist/</span><br><span class="line">.nb-gradle/</span><br><span class="line">generatorConfig.xml</span><br><span class="line"></span><br><span class="line">### nacos ###</span><br><span class="line">third-party/nacos/derby.log</span><br><span class="line">third-party/nacos/data/</span><br><span class="line">third-party/nacos/work/</span><br><span class="line"></span><br><span class="line">file/</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://i.p04e.com/baid/i/2022/09/20/aqjg.png"><br><img src="https://i.p04e.com/baid/i/2022/09/20/7w1.png"><br><img src="https://i.p04e.com/baid/i/2022/09/20/1j7t.png"><br><img src="https://i.p04e.com/baid/i/2022/09/20/23809.png"><br><img src="https://i.p04e.com/baid/i/2022/09/20/7w9.png"><br><img src="https://i.p04e.com/baid/i/2022/09/20/1j9d.png"><br><img src="https://i.p04e.com/baid/i/2022/09/20/7w3.png"><br><img src="https://i.p04e.com/baid/i/2022/09/20/237q6.png"><br><img src="https://i.p04e.com/baid/i/2022/09/20/ar6a.png"><br><img src="https://i.p04e.com/baid/i/2022/09/20/1jaq.png"><br><img src="https://i.p04e.com/baid/i/2022/09/20/ar1g.png"></p>
]]></content>
      <tags>
        <tag>springboot - 外卖平台</tag>
        <tag>项目开发</tag>
        <tag>mybatis plus</tag>
        <tag>使用git管理代码</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>外卖项目优化之环境搭建</title>
    <url>/2022/09/20/%E5%A4%96%E5%8D%96%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96%E4%B9%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>外卖管理平台新增分类代码开发</title>
    <url>/2022/09/02/%E5%A4%96%E5%8D%96%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0%E6%96%B0%E5%A2%9E%E5%88%86%E7%B1%BB%E4%BB%A3%E7%A0%81%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h3 id="一、新增分类"><a href="#一、新增分类" class="headerlink" title="一、新增分类"></a>一、新增分类</h3><p>在开发代码之前，需要梳理一下整个程序的执行过程:</p>
<span id="more"></span>
<p>1、页面(backend/page/category/list.html)发送ajax请求，将新增分类窗口输入的数据以json形式提交到服务端</p>
<p>2、服务端Controller接收页面提交的数据并调用Service将数据进行保存</p>
<p>3、Service调用Mapper操作数据库，保存数据</p>
<p>可以先将大概的框架写出，后面在完善</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.entity;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.annotation.FieldFill;</span><br><span class="line">import com.baomidou.mybatisplus.annotation.IdType;</span><br><span class="line">import com.baomidou.mybatisplus.annotation.TableField;</span><br><span class="line">import com.baomidou.mybatisplus.annotation.TableId;</span><br><span class="line">import lombok.Data;</span><br><span class="line">import lombok.Getter;</span><br><span class="line">import lombok.Setter;</span><br><span class="line">import java.io.Serializable;</span><br><span class="line">import java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 分类</span><br><span class="line"> */</span><br><span class="line">@Data</span><br><span class="line">public class Category implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID = 1L;</span><br><span class="line"></span><br><span class="line">    private Long id;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //类型 1 菜品分类 2 套餐分类</span><br><span class="line">    private Integer type;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //分类名称</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //顺序</span><br><span class="line">    private Integer sort;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //创建时间</span><br><span class="line">    @TableField(fill = FieldFill.INSERT)</span><br><span class="line">    private LocalDateTime createTime;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //更新时间</span><br><span class="line">    @TableField(fill = FieldFill.INSERT_UPDATE)</span><br><span class="line">    private LocalDateTime updateTime;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //创建人</span><br><span class="line">    @TableField(fill = FieldFill.INSERT)</span><br><span class="line">    private Long createUser;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //修改人</span><br><span class="line">    @TableField(fill = FieldFill.INSERT_UPDATE)</span><br><span class="line">    private Long updateUser;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.mapper;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.core.mapper.BaseMapper;</span><br><span class="line">import com.itheima.reggie.entity.Category;</span><br><span class="line">import org.apache.ibatis.annotations.Mapper;</span><br><span class="line"></span><br><span class="line">@Mapper</span><br><span class="line">public interface CategoryMapper extends BaseMapper&lt;Category&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.service;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.extension.service.IService;</span><br><span class="line">import com.itheima.reggie.entity.Category;</span><br><span class="line"></span><br><span class="line">public interface CategoryService extends IService&lt;Category&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.service.impl;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;</span><br><span class="line">import com.itheima.reggie.entity.Category;</span><br><span class="line">import com.itheima.reggie.mapper.CategoryMapper;</span><br><span class="line">import com.itheima.reggie.service.CategoryService;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class CategoryServiceImpl extends ServiceImpl&lt;CategoryMapper, Category&gt; implements CategoryService &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.controller;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import com.itheima.reggie.service.CategoryService;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/category&quot;)</span><br><span class="line">public class CategoryController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private CategoryService categoryService;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到新增菜品分类和新增套餐分类请求的服务端地址和提交的json数据结构相同，所以服务端只需要提供一个方法统一处理即可：</p>
<p><img src="https://i.p04e.com/baid/i/2022/09/02/5955.png"></p>
<h3 id="二、分类信息分页查询"><a href="#二、分类信息分页查询" class="headerlink" title="二、分类信息分页查询"></a>二、分类信息分页查询</h3><h4 id="1、需求分析"><a href="#1、需求分析" class="headerlink" title="1、需求分析"></a>1、需求分析</h4><p>系统中的分类很多的时候，如果在一个页面中全部展示出来会显得比较乱，不便于查看，所以一般的系统中都会以分页的方式来展示列表数据。</p>
<h4 id="2、代码开发"><a href="#2、代码开发" class="headerlink" title="2、代码开发"></a>2、代码开发</h4><p>在开发代码之前，需要梳理一下整个程序的执行过程:</p>
<p>1、页面发送ajax请求，将分页查询参数(page.pageSize)提交到服务端</p>
<p>2、服务端Controller接收页面提交的数据并调用Service查询数据</p>
<p>3、Service调用Mapper操作数据库，查询分页数据</p>
<p>4、Controller将查询到的分页数据响应给页面</p>
<p>5、页面接收到分页数据并通过Elementul的Table组件展示到页面上</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.controller;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;</span><br><span class="line">import com.baomidou.mybatisplus.extension.plugins.pagination.Page;</span><br><span class="line">import com.itheima.reggie.common.R;</span><br><span class="line">import com.itheima.reggie.entity.Category;</span><br><span class="line">import com.itheima.reggie.service.CategoryService;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 分类管理</span><br><span class="line"> */</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/category&quot;)</span><br><span class="line">@Slf4j</span><br><span class="line">public class CategoryController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private CategoryService categoryService;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 新增分类</span><br><span class="line">     * @param category</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @PostMapping</span><br><span class="line">    public R&lt;String&gt; save(@RequestBody Category category)&#123;</span><br><span class="line">        log.info(&quot;category:&#123;&#125;&quot;,category);</span><br><span class="line">        categoryService.save(category);</span><br><span class="line">        return R.success(&quot;新增分类成功&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 分页查询</span><br><span class="line">     * @param page</span><br><span class="line">     * @param pageSize</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @GetMapping(&quot;/page&quot;)</span><br><span class="line">    public R&lt;Page&gt; page(int page,int pageSize)&#123;</span><br><span class="line">        //分页构造器</span><br><span class="line">        Page&lt;Category&gt; pageInfo = new Page&lt;&gt;(page,pageSize);</span><br><span class="line">        //条件构造器</span><br><span class="line">        LambdaQueryWrapper&lt;Category&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">        //添加排序条件，根据sort进行排序</span><br><span class="line">        queryWrapper.orderByAsc(Category::getSort);</span><br><span class="line"></span><br><span class="line">        //分页查询</span><br><span class="line">        categoryService.page(pageInfo,queryWrapper);</span><br><span class="line">        return R.success(pageInfo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最后就可以显示出来了。</p>
<p><img src="https://i.p04e.com/baid/i/2022/09/02/5cgu.png"></p>
<h3 id="三、删除分类"><a href="#三、删除分类" class="headerlink" title="三、删除分类"></a>三、删除分类</h3><h4 id="1、需求分析-1"><a href="#1、需求分析-1" class="headerlink" title="1、需求分析"></a>1、需求分析</h4><p>在分类管理列表页面，可以对某个分类进行删除操作。需要注意的是当分类关联了菜品或者套餐时，此分类不允许删除。</p>
<h4 id="2、代码开发-1"><a href="#2、代码开发-1" class="headerlink" title="2、代码开发"></a>2、代码开发</h4><p>在开发代码之前，需要梳理一下整个程序的执行过程:</p>
<p>1、页面发送ajax请求，将参数(id)提交到服务端</p>
<p>2、服务端Controller接收页面提交的数据并调用Service删除数据</p>
<p>3、Service调用Mapper操作数据库</p>
<p><img src="https://i.p04e.com/baid/i/2022/09/03/ycuv.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 根据id删除分类</span><br><span class="line"> * @param id</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">@DeleteMapping</span><br><span class="line">public R&lt;String&gt; delete(Long id) &#123;</span><br><span class="line">    log.info(&quot;删除分类，id为：&#123;&#125;&quot;,id);</span><br><span class="line"></span><br><span class="line">    categoryService.removeById(id);</span><br><span class="line">    return R.success(&quot;分类信息删除成功&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3、功能完善"><a href="#3、功能完善" class="headerlink" title="3、功能完善"></a>3、功能完善</h4><p>前面我们已经实现了根据id删除分类的功能，但是并没有检查删除的分类是否关联了菜品或者套餐，所以我们需要进行功能完善。</p>
<p>要完善分类删除功能，需要先准备基础的类和接口:1、实体类Dish和Setmeal (从课程资料中复制即可)</p>
<p>2、Mapper接口DishMapper和SetmealMapper</p>
<p>3、Service接口DishService和SetmealService</p>
<p>4、Service实现类DishServicelmpl和SetmealServicelmpl</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.entity;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.annotation.FieldFill;</span><br><span class="line">import com.baomidou.mybatisplus.annotation.IdType;</span><br><span class="line">import com.baomidou.mybatisplus.annotation.TableField;</span><br><span class="line">import com.baomidou.mybatisplus.annotation.TableId;</span><br><span class="line">import lombok.Data;</span><br><span class="line">import java.io.Serializable;</span><br><span class="line">import java.math.BigDecimal;</span><br><span class="line">import java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> 菜品</span><br><span class="line"> */</span><br><span class="line">@Data</span><br><span class="line">public class Dish implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID = 1L;</span><br><span class="line"></span><br><span class="line">    private Long id;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //菜品名称</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //菜品分类id</span><br><span class="line">    private Long categoryId;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //菜品价格</span><br><span class="line">    private BigDecimal price;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //商品码</span><br><span class="line">    private String code;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //图片</span><br><span class="line">    private String image;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //描述信息</span><br><span class="line">    private String description;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //0 停售 1 起售</span><br><span class="line">    private Integer status;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //顺序</span><br><span class="line">    private Integer sort;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @TableField(fill = FieldFill.INSERT)</span><br><span class="line">    private LocalDateTime createTime;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @TableField(fill = FieldFill.INSERT_UPDATE)</span><br><span class="line">    private LocalDateTime updateTime;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @TableField(fill = FieldFill.INSERT)</span><br><span class="line">    private Long createUser;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @TableField(fill = FieldFill.INSERT_UPDATE)</span><br><span class="line">    private Long updateUser;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //是否删除</span><br><span class="line">    private Integer isDeleted;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.entity;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.annotation.FieldFill;</span><br><span class="line">import com.baomidou.mybatisplus.annotation.IdType;</span><br><span class="line">import com.baomidou.mybatisplus.annotation.TableField;</span><br><span class="line">import com.baomidou.mybatisplus.annotation.TableId;</span><br><span class="line">import lombok.Data;</span><br><span class="line">import java.io.Serializable;</span><br><span class="line">import java.math.BigDecimal;</span><br><span class="line">import java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 套餐</span><br><span class="line"> */</span><br><span class="line">@Data</span><br><span class="line">public class Setmeal implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID = 1L;</span><br><span class="line"></span><br><span class="line">    private Long id;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //分类id</span><br><span class="line">    private Long categoryId;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //套餐名称</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //套餐价格</span><br><span class="line">    private BigDecimal price;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //状态 0:停用 1:启用</span><br><span class="line">    private Integer status;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //编码</span><br><span class="line">    private String code;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //描述信息</span><br><span class="line">    private String description;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //图片</span><br><span class="line">    private String image;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @TableField(fill = FieldFill.INSERT)</span><br><span class="line">    private LocalDateTime createTime;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @TableField(fill = FieldFill.INSERT_UPDATE)</span><br><span class="line">    private LocalDateTime updateTime;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @TableField(fill = FieldFill.INSERT)</span><br><span class="line">    private Long createUser;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @TableField(fill = FieldFill.INSERT_UPDATE)</span><br><span class="line">    private Long updateUser;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //是否删除</span><br><span class="line">    private Integer isDeleted;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.mapper;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.core.mapper.BaseMapper;</span><br><span class="line">import com.itheima.reggie.entity.Dish;</span><br><span class="line">import org.apache.ibatis.annotations.Mapper;</span><br><span class="line"></span><br><span class="line">@Mapper</span><br><span class="line">public interface DishMapper extends BaseMapper&lt;Dish&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.mapper;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.core.mapper.BaseMapper;</span><br><span class="line">import com.itheima.reggie.entity.Setmeal;</span><br><span class="line">import org.apache.ibatis.annotations.Mapper;</span><br><span class="line"></span><br><span class="line">@Mapper</span><br><span class="line">public interface SetmealMapper extends BaseMapper&lt;Setmeal&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.service;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.extension.service.IService;</span><br><span class="line">import com.itheima.reggie.entity.Dish;</span><br><span class="line"></span><br><span class="line">public interface DishService extends IService&lt;Dish&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.service;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.extension.service.IService;</span><br><span class="line">import com.itheima.reggie.entity.Setmeal;</span><br><span class="line"></span><br><span class="line">public interface SetmealService extends IService&lt;Setmeal&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.service.impl;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;</span><br><span class="line">import com.itheima.reggie.entity.Dish;</span><br><span class="line">import com.itheima.reggie.mapper.DishMapper;</span><br><span class="line">import com.itheima.reggie.service.DishService;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">@Slf4j</span><br><span class="line">public class DishServiceImpl extends ServiceImpl&lt;DishMapper, Dish&gt; implements DishService &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.service.impl;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;</span><br><span class="line">import com.itheima.reggie.entity.Setmeal;</span><br><span class="line">import com.itheima.reggie.mapper.SetmealMapper;</span><br><span class="line">import com.itheima.reggie.service.SetmealService;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">@Slf4j</span><br><span class="line">public class SetmealServiceImpl extends ServiceImpl&lt;SetmealMapper, Setmeal&gt; implements SetmealService &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.controller;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;</span><br><span class="line">import com.baomidou.mybatisplus.extension.plugins.pagination.Page;</span><br><span class="line">import com.itheima.reggie.common.R;</span><br><span class="line">import com.itheima.reggie.entity.Category;</span><br><span class="line">import com.itheima.reggie.service.CategoryService;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 分类管理</span><br><span class="line"> */</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/category&quot;)</span><br><span class="line">@Slf4j</span><br><span class="line">public class CategoryController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private CategoryService categoryService;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 新增分类</span><br><span class="line">     * @param category</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @PostMapping</span><br><span class="line">    public R&lt;String&gt; save(@RequestBody Category category)&#123;</span><br><span class="line">        log.info(&quot;category:&#123;&#125;&quot;,category);</span><br><span class="line">        categoryService.save(category);</span><br><span class="line">        return R.success(&quot;新增分类成功&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 分页查询</span><br><span class="line">     * @param page</span><br><span class="line">     * @param pageSize</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @GetMapping(&quot;/page&quot;)</span><br><span class="line">    public R&lt;Page&gt; page(int page,int pageSize)&#123;</span><br><span class="line">        //分页构造器</span><br><span class="line">        Page&lt;Category&gt; pageInfo = new Page&lt;&gt;(page,pageSize);</span><br><span class="line">        //条件构造器</span><br><span class="line">        LambdaQueryWrapper&lt;Category&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">        //添加排序条件，根据sort进行排序</span><br><span class="line">        queryWrapper.orderByAsc(Category::getSort);</span><br><span class="line"></span><br><span class="line">        //分页查询</span><br><span class="line">        categoryService.page(pageInfo,queryWrapper);</span><br><span class="line">        return R.success(pageInfo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据id删除分类</span><br><span class="line">     * @param id</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @DeleteMapping</span><br><span class="line">    public R&lt;String&gt; delete(Long id) &#123;</span><br><span class="line">        log.info(&quot;删除分类，id为：&#123;&#125;&quot;,id);</span><br><span class="line"></span><br><span class="line">        //categoryService.removeById(id);</span><br><span class="line">        categoryService.remove(id);</span><br><span class="line">        return R.success(&quot;分类信息删除成功&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.service.impl;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;</span><br><span class="line">import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;</span><br><span class="line">import com.itheima.reggie.common.CustomException;</span><br><span class="line">import com.itheima.reggie.entity.Category;</span><br><span class="line">import com.itheima.reggie.entity.Dish;</span><br><span class="line">import com.itheima.reggie.entity.Setmeal;</span><br><span class="line">import com.itheima.reggie.mapper.CategoryMapper;</span><br><span class="line">import com.itheima.reggie.service.CategoryService;</span><br><span class="line">import com.itheima.reggie.service.DishService;</span><br><span class="line">import com.itheima.reggie.service.SetmealService;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class CategoryServiceImpl extends ServiceImpl&lt;CategoryMapper, Category&gt; implements CategoryService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private DishService dishService;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private SetmealService setmealService;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据id删除分类,删除之前需要进行判断</span><br><span class="line">     * @param id</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void remove(Long id) &#123;</span><br><span class="line">        LambdaQueryWrapper&lt;Dish&gt; dishLambdaQueryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">        //添加查询条件，根据分类id进行查询</span><br><span class="line">        dishLambdaQueryWrapper.eq(Dish::getCategoryId, id);</span><br><span class="line">        int count1 = dishService.count(dishLambdaQueryWrapper);</span><br><span class="line">        //查询当前分类是否关联了菜品，如果已经关联，抛出一个业务异常</span><br><span class="line">        if (count1 &gt; 0) &#123;</span><br><span class="line">            //已经关联菜品，抛出一个业务异常</span><br><span class="line">            throw new CustomException(&quot;当前分类下关联了分类菜品，不能删除&quot;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //查询当前分类是否关联了套餐，如果已经关联，抛出一个业务异常</span><br><span class="line">        LambdaQueryWrapper&lt;Setmeal&gt; setmealLambdaQueryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">        int count2 = setmealService.count(setmealLambdaQueryWrapper);</span><br><span class="line">        if (count2 &gt; 0) &#123;</span><br><span class="line">            //已经关联套餐，抛出一个业务异常</span><br><span class="line">            throw new CustomException(&quot;当前分类下关联了套餐，不能删除&quot;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //正常删除分类</span><br><span class="line">        super.removeById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.common;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 自定义业务异常</span><br><span class="line"> */</span><br><span class="line">public class CustomException extends RuntimeException&#123;</span><br><span class="line">    public CustomException(String message) &#123;</span><br><span class="line">        super(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.common;</span><br><span class="line"></span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line">import org.springframework.web.bind.annotation.ControllerAdvice;</span><br><span class="line">import org.springframework.web.bind.annotation.ExceptionHandler;</span><br><span class="line">import org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">import java.sql.SQLIntegrityConstraintViolationException;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 全局异常处理</span><br><span class="line"> */</span><br><span class="line">@ControllerAdvice(annotations = &#123;RestController.class, Controller.class&#125;)</span><br><span class="line">@ResponseBody</span><br><span class="line">@Slf4j</span><br><span class="line">public class GlobalExceptionHandler &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 异常处理方法</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @ExceptionHandler(SQLIntegrityConstraintViolationException.class)</span><br><span class="line">    public R&lt;String&gt; exceptionHandler(SQLIntegrityConstraintViolationException ex)&#123;</span><br><span class="line">        log.error(ex.getMessage());</span><br><span class="line"></span><br><span class="line">        if(ex.getMessage().contains(&quot;Duplicate entry&quot;))&#123;</span><br><span class="line">            String[] split = ex.getMessage().split(&quot; &quot;);</span><br><span class="line">            String msg = split[2] + &quot;已存在&quot;;</span><br><span class="line">            return R.error(msg);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return R.error(&quot;未知错误&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 异常处理方法</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @ExceptionHandler(CustomException.class)</span><br><span class="line">    public R&lt;String&gt; exceptionHandler(CustomException ex)&#123;</span><br><span class="line">        log.error(ex.getMessage());</span><br><span class="line"></span><br><span class="line">        return R.error(ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="四、修改分类"><a href="#四、修改分类" class="headerlink" title="四、修改分类"></a>四、修改分类</h3><h4 id="1、需求分析-2"><a href="#1、需求分析-2" class="headerlink" title="1、需求分析"></a>1、需求分析</h4><p>在分类管理列表页面点击修改按钮，弹出修改窗口，在修改窗口回显分类信息并进行修改，最后点击确定按钮完成修改操作</p>
<h4 id="2、代码开发-2"><a href="#2、代码开发-2" class="headerlink" title="2、代码开发"></a>2、代码开发</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 根据id修改分类信息</span><br><span class="line"> * @param category</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">@PutMapping</span><br><span class="line">public R&lt;String&gt; update(@RequestBody Category category)&#123;</span><br><span class="line">    log.info(&quot;修改分类信息：&#123;&#125;&quot;,category);</span><br><span class="line"></span><br><span class="line">    categoryService.updateById(category);</span><br><span class="line"></span><br><span class="line">    return R.success(&quot;修改分类信息成功&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>springboot - 外卖平台</tag>
        <tag>项目开发</tag>
        <tag>mybatis plus</tag>
        <tag>新增分类</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker实用篇</title>
    <url>/2022/11/22/Docker%E5%AE%9E%E7%94%A8%E7%AF%87/</url>
    <content><![CDATA[<h1 id="Docker实用篇"><a href="#Docker实用篇" class="headerlink" title="Docker实用篇"></a>Docker实用篇</h1><span id="more"></span>
<h1 id="0-学习目标"><a href="#0-学习目标" class="headerlink" title="0.学习目标"></a>0.学习目标</h1><h1 id="1-初识Docker"><a href="#1-初识Docker" class="headerlink" title="1.初识Docker"></a>1.初识Docker</h1><h2 id="1-1-什么是Docker"><a href="#1-1-什么是Docker" class="headerlink" title="1.1.什么是Docker"></a>1.1.什么是Docker</h2><p>微服务虽然具备各种各样的优势，但服务的拆分通用给部署带来了很大的麻烦。</p>
<ul>
<li>分布式系统中，依赖的组件非常多，不同组件之间部署时往往会产生一些冲突。</li>
<li>在数百上千台服务中重复部署，环境不一定一致，会遇到各种问题</li>
</ul>
<h3 id="1-1-1-应用部署的环境问题"><a href="#1-1-1-应用部署的环境问题" class="headerlink" title="1.1.1.应用部署的环境问题"></a>1.1.1.应用部署的环境问题</h3><p>大型项目组件较多，运行环境也较为复杂，部署时会碰到一些问题：</p>
<ul>
<li>依赖关系复杂，容易出现兼容性问题</li>
<li>开发、测试、生产环境有差异</li>
</ul>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/voq.png"></p>
<p>例如一个项目中，部署时需要依赖于node.js、Redis、RabbitMQ、MySQL等，这些服务部署时所需要的函数库、依赖项各不相同，甚至会有冲突。给部署带来了极大的困难。</p>
<h3 id="1-1-2-Docker解决依赖兼容问题"><a href="#1-1-2-Docker解决依赖兼容问题" class="headerlink" title="1.1.2.Docker解决依赖兼容问题"></a>1.1.2.Docker解决依赖兼容问题</h3><p>而Docker确巧妙的解决了这些问题，Docker是如何实现的呢？</p>
<p>Docker为了解决依赖的兼容问题的，采用了两个手段：</p>
<ul>
<li>将应用的Libs（函数库）、Deps（依赖）、配置与应用一起打包</li>
<li>将每个应用放到一个隔离<strong>容器</strong>去运行，避免互相干扰</li>
</ul>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/vjp.png"></p>
<p>这样打包好的应用包中，既包含应用本身，也保护应用所需要的Libs、Deps，无需再操作系统上安装这些，自然就不存在不同应用之间的兼容问题了。</p>
<p>虽然解决了不同应用的兼容问题，但是开发、测试等环境会存在差异，操作系统版本也会有差异，怎么解决这些问题呢？</p>
<h3 id="1-1-3-Docker解决操作系统环境差异"><a href="#1-1-3-Docker解决操作系统环境差异" class="headerlink" title="1.1.3.Docker解决操作系统环境差异"></a>1.1.3.Docker解决操作系统环境差异</h3><p>要解决不同操作系统环境差异问题，必须先了解操作系统结构。以一个Ubuntu操作系统为例，结构如下：</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/66x0.png"></p>
<p>结构包括：</p>
<ul>
<li>计算机硬件：例如CPU、内存、磁盘等</li>
<li>系统内核：所有Linux发行版的内核都是Linux，例如CentOS、Ubuntu、Fedora等。内核可以与计算机硬件交互，对外提供<strong>内核指令</strong>，用于操作计算机硬件。</li>
<li>系统应用：操作系统本身提供的应用、函数库。这些函数库是对内核指令的封装，使用更加方便。</li>
</ul>
<p>应用于计算机交互的流程如下：</p>
<p>1）应用调用操作系统应用（函数库），实现各种功能</p>
<p>2）系统函数库是对内核指令集的封装，会调用内核指令</p>
<p>3）内核指令操作计算机硬件</p>
<p>Ubuntu和CentOSpringBoot都是基于Linux内核，无非是系统应用不同，提供的函数库有差异：</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/67g7.png"></p>
<p>此时，如果将一个Ubuntu版本的MySQL应用安装到CentOS系统，MySQL在调用Ubuntu函数库时，会发现找不到或者不匹配，就会报错了：</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/w0g.png"></p>
<p>Docker如何解决不同系统环境的问题？</p>
<ul>
<li>Docker将用户程序与所需要调用的系统(比如Ubuntu)函数库一起打包</li>
<li>Docker运行到不同操作系统时，直接基于打包的函数库，借助于操作系统的Linux内核来运行</li>
</ul>
<p>如图：</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/67vy.png"></p>
<h3 id="1-1-4-小结"><a href="#1-1-4-小结" class="headerlink" title="1.1.4.小结"></a>1.1.4.小结</h3><p>Docker如何解决大型项目依赖关系复杂，不同组件依赖的兼容性问题？</p>
<ul>
<li>Docker允许开发中将应用、依赖、函数库、配置一起<strong>打包</strong>，形成可移植镜像</li>
<li>Docker应用运行在容器中，使用沙箱机制，相互<strong>隔离</strong></li>
</ul>
<p>Docker如何解决开发、测试、生产环境有差异的问题？</p>
<ul>
<li>Docker镜像中包含完整运行环境，包括系统函数库，仅依赖系统的Linux内核，因此可以在任意Linux操作系统上运行</li>
</ul>
<p>Docker是一个快速交付应用、运行应用的技术，具备下列优势：</p>
<ul>
<li>可以将程序及其依赖、运行环境一起打包为一个镜像，可以迁移到任意Linux操作系统</li>
<li>运行时利用沙箱机制形成隔离容器，各个应用互不干扰</li>
<li>启动、移除都可以通过一行命令完成，方便快捷</li>
</ul>
<h2 id="1-2-Docker和虚拟机的区别"><a href="#1-2-Docker和虚拟机的区别" class="headerlink" title="1.2.Docker和虚拟机的区别"></a>1.2.Docker和虚拟机的区别</h2><p>Docker可以让一个应用在任何操作系统中非常方便的运行。而以前我们接触的虚拟机，也能在一个操作系统中，运行另外一个操作系统，保护系统中的任何应用。</p>
<p>两者有什么差异呢？</p>
<p><strong>虚拟机</strong>（virtual machine）是在操作系统中<strong>模拟</strong>硬件设备，然后运行另一个操作系统，比如在 Windows 系统里面运行 Ubuntu 系统，这样就可以运行任意的Ubuntu应用了。</p>
<p><strong>Docker</strong>仅仅是封装函数库，并没有模拟完整的操作系统，如图：</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/672v.png"></p>
<p>对比来看：</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/vvg.png"></p>
<p>小结：</p>
<p>Docker和虚拟机的差异：</p>
<ul>
<li>docker是一个系统进程；虚拟机是在操作系统中的操作系统</li>
<li>docker体积小、启动速度快、性能好；虚拟机体积大、启动速度慢、性能一般</li>
</ul>
<h2 id="1-3-Docker架构"><a href="#1-3-Docker架构" class="headerlink" title="1.3.Docker架构"></a>1.3.Docker架构</h2><h3 id="1-3-1-镜像和容器"><a href="#1-3-1-镜像和容器" class="headerlink" title="1.3.1.镜像和容器"></a>1.3.1.镜像和容器</h3><p>Docker中有几个重要的概念：</p>
<p><strong>镜像（Image）</strong>：Docker将应用程序及其所需的依赖、函数库、环境、配置等文件打包在一起，称为镜像。</p>
<p><strong>容器（Container）</strong>：镜像中的应用程序运行后形成的进程就是<strong>容器</strong>，只是Docker会给容器进程做隔离，对外不可见。</p>
<p>一切应用最终都是代码组成，都是硬盘中的一个个的字节形成的<strong>文件</strong>。只有运行时，才会加载到内存，形成进程。</p>
<p>而<strong>镜像</strong>，就是把一个应用在硬盘上的文件、及其运行环境、部分系统函数库文件一起打包形成的文件包。这个文件包是只读的。</p>
<p><strong>容器</strong>呢，就是将这些文件中编写的程序、函数加载到内存中允许，形成进程，只不过要隔离起来。因此一个镜像可以启动多次，形成多个容器进程。</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/8prb.png"></p>
<p>例如你下载了一个QQ，如果我们将QQ在磁盘上的运行<strong>文件</strong>及其运行的操作系统依赖打包，形成QQ镜像。然后你可以启动多次，双开、甚至三开QQ，跟多个妹子聊天。</p>
<h3 id="1-3-2-DockerHub"><a href="#1-3-2-DockerHub" class="headerlink" title="1.3.2.DockerHub"></a>1.3.2.DockerHub</h3><p>开源应用程序非常多，打包这些应用往往是重复的劳动。为了避免这些重复劳动，人们就会将自己打包的应用镜像，例如Redis、MySQL镜像放到网络上，共享使用，就像GitHub的代码共享一样。</p>
<ul>
<li>DockerHub：DockerHub是一个官方的Docker镜像的托管平台。这样的平台称为Docker Registry。</li>
<li>国内也有类似于DockerHub 的公开服务，比如 <a href="https://c.163yun.com/hub">网易云镜像服务</a>、<a href="https://cr.console.aliyun.com/">阿里云镜像库</a>等。</li>
</ul>
<p>我们一方面可以将自己的镜像共享到DockerHub，另一方面也可以从DockerHub拉取镜像：</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/18vy.png"></p>
<h3 id="1-3-3-Docker架构"><a href="#1-3-3-Docker架构" class="headerlink" title="1.3.3.Docker架构"></a>1.3.3.Docker架构</h3><p>我们要使用Docker来操作镜像、容器，就必须要安装Docker。</p>
<p>Docker是一个CS架构的程序，由两部分组成：</p>
<ul>
<li>服务端(server)：Docker守护进程，负责处理Docker指令，管理镜像、容器等</li>
<li>客户端(client)：通过命令或RestAPI向Docker服务端发送指令。可以在本地或远程向服务端发送指令。</li>
</ul>
<p>如图：</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/1p8x0.png"></p>
<h3 id="1-3-4-小结"><a href="#1-3-4-小结" class="headerlink" title="1.3.4.小结"></a>1.3.4.小结</h3><p>镜像：</p>
<ul>
<li>将应用程序及其依赖、环境、配置打包在一起</li>
</ul>
<p>容器：</p>
<ul>
<li>镜像运行起来就是容器，一个镜像可以运行多个容器</li>
</ul>
<p>Docker结构：</p>
<ul>
<li>服务端：接收命令或远程请求，操作镜像或容器</li>
<li>客户端：发送命令或者请求到Docker服务端</li>
</ul>
<p>DockerHub：</p>
<ul>
<li>一个镜像托管的服务器，类似的还有阿里云镜像服务，统称为DockerRegistry</li>
</ul>
<h2 id="1-4-安装Docker"><a href="#1-4-安装Docker" class="headerlink" title="1.4.安装Docker"></a>1.4.安装Docker</h2><p>企业部署一般都是采用Linux操作系统，而其中又数CentOS发行版占比最多，因此我们在CentOS下安装Docker。</p>
<h1 id="2-Docker的基本操作"><a href="#2-Docker的基本操作" class="headerlink" title="2.Docker的基本操作"></a>2.Docker的基本操作</h1><h2 id="2-1-镜像操作"><a href="#2-1-镜像操作" class="headerlink" title="2.1.镜像操作"></a>2.1.镜像操作</h2><h3 id="2-1-1-镜像名称"><a href="#2-1-1-镜像名称" class="headerlink" title="2.1.1.镜像名称"></a>2.1.1.镜像名称</h3><p>首先来看下镜像的名称组成：</p>
<ul>
<li>镜名称一般分两部分组成：[repository]:[tag]。</li>
<li>在没有指定tag时，默认是latest，代表最新版本的镜像</li>
</ul>
<p>如图：</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/8r3w.png"></p>
<p>这里的mysql就是repository，5.7就是tag，合一起就是镜像名称，代表5.7版本的MySQL镜像。</p>
<h3 id="2-1-2-镜像命令"><a href="#2-1-2-镜像命令" class="headerlink" title="2.1.2.镜像命令"></a>2.1.2.镜像命令</h3><p>常见的镜像操作命令如图：</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/190c.png"></p>
<h3 id="2-1-3-案例1-拉取、查看镜像"><a href="#2-1-3-案例1-拉取、查看镜像" class="headerlink" title="2.1.3.案例1-拉取、查看镜像"></a>2.1.3.案例1-拉取、查看镜像</h3><p>需求：从DockerHub中拉取一个nginx镜像并查看</p>
<p>1）首先去镜像仓库搜索nginx镜像，比如<a href="https://hub.docker.com/">DockerHub</a>:</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/6fi.png"></p>
<p>2）根据查看到的镜像名称，拉取自己需要的镜像，通过命令：docker pull nginx</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/191y.png"></p>
<p>3）通过命令：docker images 查看拉取到的镜像</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/1v2hq.png"></p>
<h3 id="2-1-4-案例2-保存、导入镜像"><a href="#2-1-4-案例2-保存、导入镜像" class="headerlink" title="2.1.4.案例2-保存、导入镜像"></a>2.1.4.案例2-保存、导入镜像</h3><p>需求：利用docker save将nginx镜像导出磁盘，然后再通过load加载回来</p>
<p>1）利用docker xx —help命令查看docker save和docker load的语法</p>
<p>例如，查看save命令用法，可以输入命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker save --<span class="built_in">help</span></span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/9l3f.png"></p>
<p>命令格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker save -o [保存的目标文件名称] [镜像名称]</span><br></pre></td></tr></table></figure>
<p>2）使用docker save导出镜像到磁盘 </p>
<p>运行命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker save -o nginx.tar nginx:latest</span><br></pre></td></tr></table></figure>
<p>结果如图：</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/9l58.png"></p>
<p>3）使用docker load加载镜像</p>
<p>先删除本地的nginx镜像：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker rmi nginx:latest</span><br></pre></td></tr></table></figure>
<p>然后运行命令，加载本地文件：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker load -i nginx.tar</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/9lam.png"></p>
<h3 id="2-1-5-练习"><a href="#2-1-5-练习" class="headerlink" title="2.1.5.练习"></a>2.1.5.练习</h3><p>需求：去DockerHub搜索并拉取一个Redis镜像</p>
<p>目标：</p>
<p>1）去DockerHub搜索Redis镜像</p>
<p>2）查看Redis镜像的名称和版本</p>
<p>3）利用docker pull命令拉取镜像</p>
<p>4）利用docker save命令将 redis:latest打包为一个redis.tar包</p>
<p>5）利用docker rmi 删除本地的redis:latest</p>
<p>6）利用docker load 重新加载 redis.tar文件</p>
<h2 id="2-2-容器操作"><a href="#2-2-容器操作" class="headerlink" title="2.2.容器操作"></a>2.2.容器操作</h2><h3 id="2-2-1-容器相关命令"><a href="#2-2-1-容器相关命令" class="headerlink" title="2.2.1.容器相关命令"></a>2.2.1.容器相关命令</h3><p>容器操作的命令如图：</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/9lcs.png"></p>
<p>容器保护三个状态：</p>
<ul>
<li>运行：进程正常运行</li>
<li>暂停：进程暂停，CPU不再运行，并不释放内存</li>
<li>停止：进程终止，回收进程占用的内存、CPU等资源</li>
</ul>
<p>其中：</p>
<ul>
<li>docker run：创建并运行一个容器，处于运行状态</li>
<li>docker pause：让一个运行的容器暂停</li>
<li>docker unpause：让一个容器从暂停状态恢复运行</li>
<li>docker stop：停止一个运行的容器</li>
<li>docker start：让一个停止的容器再次运行</li>
<li>docker rm：删除一个容器</li>
</ul>
<h3 id="2-2-2-案例-创建并运行一个容器"><a href="#2-2-2-案例-创建并运行一个容器" class="headerlink" title="2.2.2.案例-创建并运行一个容器"></a>2.2.2.案例-创建并运行一个容器</h3><p>创建并运行nginx容器的命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run --name containerName -p 80:80 -d nginx</span><br></pre></td></tr></table></figure>
<p>命令解读：</p>
<ul>
<li>docker run ：创建并运行一个容器</li>
<li>—name : 给容器起一个名字，比如叫做mn</li>
<li>-p ：将宿主机端口与容器端口映射，冒号左侧是宿主机端口，右侧是容器端口</li>
<li>-d：后台运行容器</li>
<li>nginx：镜像名称，例如nginx</li>
</ul>
<p>这里的<code>-p</code>参数，是将容器端口映射到宿主机端口。</p>
<p>默认情况下，容器是隔离环境，我们直接访问宿主机的80端口，肯定访问不到容器中的nginx。</p>
<p>现在，将容器的80与宿主机的80关联起来，当我们访问宿主机的80端口时，就会被映射到容器的80，这样就能访问到nginx了：</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/d25l1.png"></p>
<h3 id="2-2-3-案例-进入容器，修改文件"><a href="#2-2-3-案例-进入容器，修改文件" class="headerlink" title="2.2.3.案例-进入容器，修改文件"></a>2.2.3.案例-进入容器，修改文件</h3><p><strong>需求</strong>：进入Nginx容器，修改HTML文件内容，添加“传智教育欢迎您”</p>
<p><strong>提示</strong>：进入容器要用到docker exec命令。</p>
<p><strong>步骤</strong>：</p>
<p>1）进入容器。进入我们刚刚创建的nginx容器的命令为：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it mn bash</span><br></pre></td></tr></table></figure>
<p>命令解读：</p>
<ul>
<li>docker exec ：进入容器内部，执行一个命令</li>
<li>-it : 给当前进入的容器创建一个标准输入、输出终端，允许我们与容器交互</li>
<li>mn ：要进入的容器的名称</li>
<li>bash：进入容器后执行的命令，bash是一个linux终端交互命令</li>
</ul>
<p>2）进入nginx的HTML所在目录 /usr/share/nginx/html</p>
<p>容器内部会模拟一个独立的Linux文件系统，看起来如同一个linux服务器一样：</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/1v6lg.png"></p>
<p>nginx的环境、配置、运行文件全部都在这个文件系统中，包括我们要修改的html文件。</p>
<p>查看DockerHub网站中的nginx页面，可以知道nginx的html目录位置在<code>/usr/share/nginx/html</code></p>
<p>我们执行命令，进入该目录：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/share/nginx/html</span><br></pre></td></tr></table></figure>
<p> 查看目录下文件：</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/9llt.png"></p>
<p>3）修改index.html的内容</p>
<p>容器内没有vi命令，无法直接修改，我们用下面的命令来修改：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sed -i -e <span class="string">&#x27;s#Welcome to nginx#传智教育欢迎您#g&#x27;</span> -e <span class="string">&#x27;s#&lt;head&gt;#&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;#g&#x27;</span> index.html</span><br></pre></td></tr></table></figure>
<p>在浏览器访问自己的虚拟机地址即可看到结果：</p>
<h3 id="2-2-4-小结"><a href="#2-2-4-小结" class="headerlink" title="2.2.4.小结"></a>2.2.4.小结</h3><p>docker run命令的常见参数有哪些？</p>
<ul>
<li>—name：指定容器名称</li>
<li>-p：指定端口映射</li>
<li>-d：让容器后台运行</li>
</ul>
<p>查看容器日志的命令：</p>
<ul>
<li>docker logs</li>
<li>添加 -f 参数可以持续查看日志</li>
</ul>
<p>查看容器状态：</p>
<ul>
<li>docker ps</li>
<li>docker ps -a 查看所有容器，包括已经停止的</li>
</ul>
<h2 id="2-3-数据卷（容器数据管理）"><a href="#2-3-数据卷（容器数据管理）" class="headerlink" title="2.3.数据卷（容器数据管理）"></a>2.3.数据卷（容器数据管理）</h2><p>在之前的nginx案例中，修改nginx的html页面时，需要进入nginx内部。并且因为没有编辑器，修改文件也很麻烦。</p>
<p>这就是因为容器与数据（容器内文件）耦合带来的后果。</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/19hv.png"></p>
<p>要解决这个问题，必须将数据与容器解耦，这就要用到数据卷了。</p>
<h3 id="2-3-1-什么是数据卷"><a href="#2-3-1-什么是数据卷" class="headerlink" title="2.3.1.什么是数据卷"></a>2.3.1.什么是数据卷</h3><p><strong>数据卷（volume）</strong>是一个虚拟目录，指向宿主机文件系统中的某个目录。</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/6gy.png"></p>
<p>一旦完成数据卷挂载，对容器的一切操作都会作用在数据卷对应的宿主机目录了。</p>
<p>这样，我们操作宿主机的/var/lib/docker/volumes/html目录，就等于操作容器内的/usr/share/nginx/html目录了</p>
<h3 id="2-3-2-数据集操作命令"><a href="#2-3-2-数据集操作命令" class="headerlink" title="2.3.2.数据集操作命令"></a>2.3.2.数据集操作命令</h3><p>数据卷操作的基本语法如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker volume [COMMAND]</span><br></pre></td></tr></table></figure>
<p>docker volume命令是数据卷操作，根据命令后跟随的command来确定下一步的操作：</p>
<ul>
<li>create 创建一个volume</li>
<li>inspect 显示一个或多个volume的信息</li>
<li>ls 列出所有的volume</li>
<li>prune 删除未使用的volume</li>
<li>rm 删除一个或多个指定的volume</li>
</ul>
<h3 id="2-3-3-创建和查看数据卷"><a href="#2-3-3-创建和查看数据卷" class="headerlink" title="2.3.3.创建和查看数据卷"></a>2.3.3.创建和查看数据卷</h3><p><strong>需求</strong>：创建一个数据卷，并查看数据卷在宿主机的目录位置</p>
<p>① 创建数据卷</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker volume create html</span><br></pre></td></tr></table></figure>
<p>② 查看所有数据</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker volume <span class="built_in">ls</span></span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/6hz.png"></p>
<p>③ 查看数据卷详细信息卷</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker volume inspect html</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/8t97.png"></p>
<p>可以看到，我们创建的html这个数据卷关联的宿主机目录为<code>/var/lib/docker/volumes/html/_data</code>目录。</p>
<p><strong>小结</strong>：</p>
<p>数据卷的作用：</p>
<ul>
<li>将容器与数据分离，解耦合，方便操作容器内数据，保证数据安全</li>
</ul>
<p>数据卷操作：</p>
<ul>
<li>docker volume create：创建数据卷</li>
<li>docker volume ls：查看所有数据卷</li>
<li>docker volume inspect：查看数据卷详细信息，包括关联的宿主机目录位置</li>
<li>docker volume rm：删除指定数据卷</li>
<li>docker volume prune：删除所有未使用的数据卷</li>
</ul>
<h3 id="2-3-4-挂载数据卷"><a href="#2-3-4-挂载数据卷" class="headerlink" title="2.3.4.挂载数据卷"></a>2.3.4.挂载数据卷</h3><p>我们在创建容器时，可以通过 -v 参数来挂载一个数据卷到某个容器内目录，命令格式如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run \</span><br><span class="line">  --name mn \</span><br><span class="line">  -v html:/root/html \</span><br><span class="line">  -p 8080:80</span><br><span class="line">  nginx \</span><br></pre></td></tr></table></figure>
<p>这里的-v就是挂载数据卷的命令：</p>
<ul>
<li><code>-v html:/root/htm</code> ：把html数据卷挂载到容器内的/root/html这个目录中</li>
</ul>
<h3 id="2-3-5-案例-给nginx挂载数据卷"><a href="#2-3-5-案例-给nginx挂载数据卷" class="headerlink" title="2.3.5.案例-给nginx挂载数据卷"></a>2.3.5.案例-给nginx挂载数据卷</h3><p><strong>需求</strong>：创建一个nginx容器，修改容器内的html目录内的index.html内容</p>
<p><strong>分析</strong>：上个案例中，我们进入nginx容器内部，已经知道nginx的html目录所在位置/usr/share/nginx/html ，我们需要把这个目录挂载到html这个数据卷上，方便操作其中的内容。</p>
<p><strong>提示</strong>：运行容器时使用 -v 参数挂载数据卷</p>
<p>步骤：</p>
<p>① 创建容器并挂载数据卷到容器内的HTML目录</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run --name mn -v html:/usr/share/nginx/html -p 80:80 -d nginx</span><br></pre></td></tr></table></figure>
<p>② 进入html数据卷所在位置，并修改HTML内容</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看html数据卷的位置</span></span><br><span class="line">docker volume inspect html</span><br><span class="line"><span class="comment"># 进入该目录</span></span><br><span class="line"><span class="built_in">cd</span> /var/lib/docker/volumes/html/_data</span><br><span class="line"><span class="comment"># 修改文件</span></span><br><span class="line">vi index.html</span><br></pre></td></tr></table></figure>
<h3 id="2-3-6-案例-给MySQL挂载本地目录"><a href="#2-3-6-案例-给MySQL挂载本地目录" class="headerlink" title="2.3.6.案例-给MySQL挂载本地目录"></a>2.3.6.案例-给MySQL挂载本地目录</h3><p>容器不仅仅可以挂载数据卷，也可以直接挂载到宿主机目录上。关联关系如下：</p>
<ul>
<li>带数据卷模式：宿主机目录 —&gt; 数据卷 —-&gt; 容器内目录</li>
<li>直接挂载模式：宿主机目录 —-&gt; 容器内目录</li>
</ul>
<p>如图：</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/8uwz.png"></p>
<p><strong>语法</strong>：</p>
<p>目录挂载与数据卷挂载的语法是类似的：</p>
<ul>
<li>-v [宿主机目录]:[容器内目录]</li>
<li>-v [宿主机文件]:[容器内文件]</li>
</ul>
<p><strong>需求</strong>：创建并运行一个MySQL容器，将宿主机目录直接挂载到容器</p>
<p>实现思路如下：</p>
<p>1）在将课前资料中的mysql.tar文件上传到虚拟机，通过load命令加载为镜像</p>
<p>2）创建目录/tmp/mysql/data</p>
<p>3）创建目录/tmp/mysql/conf，将课前资料提供的hmy.cnf文件上传到/tmp/mysql/conf</p>
<p>4）去DockerHub查阅资料，创建并运行MySQL容器，要求：</p>
<p>① 挂载/tmp/mysql/data到mysql容器内数据存储目录</p>
<p>② 挂载/tmp/mysql/conf/hmy.cnf到mysql容器的配置文件</p>
<p>③ 设置MySQL密码</p>
<h3 id="2-3-7-小结"><a href="#2-3-7-小结" class="headerlink" title="2.3.7.小结"></a>2.3.7.小结</h3><p>docker run的命令中通过 -v 参数挂载文件或目录到容器中：</p>
<ul>
<li>-v volume名称:容器内目录</li>
<li>-v 宿主机文件:容器内文</li>
<li>-v 宿主机目录:容器内目录</li>
</ul>
<p>数据卷挂载与目录直接挂载的</p>
<ul>
<li>数据卷挂载耦合度低，由docker来管理目录，但是目录较深，不好找</li>
<li>目录挂载耦合度高，需要我们自己管理目录，不过目录容易寻找查看</li>
</ul>
<h1 id="3-Dockerfile自定义镜像"><a href="#3-Dockerfile自定义镜像" class="headerlink" title="3.Dockerfile自定义镜像"></a>3.Dockerfile自定义镜像</h1><p>常见的镜像在DockerHub就能找到，但是我们自己写的项目就必须自己构建镜像了。</p>
<p>而要自定义镜像，就必须先了解镜像的结构才行。</p>
<h2 id="3-1-镜像结构"><a href="#3-1-镜像结构" class="headerlink" title="3.1.镜像结构"></a>3.1.镜像结构</h2><p>镜像是将应用程序及其需要的系统函数库、环境、配置、依赖打包而成。</p>
<p>我们以MySQL为例，来看看镜像的组成结构：</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/6ik.png"></p>
<p>简单来说，镜像就是在系统函数库、运行环境基础上，添加应用程序文件、配置文件、依赖文件等组合，然后编写好启动脚本打包在一起形成的文件。</p>
<p>我们要构建镜像，其实就是实现上述打包的过程。</p>
<h2 id="3-2-Dockerfile语法"><a href="#3-2-Dockerfile语法" class="headerlink" title="3.2.Dockerfile语法"></a>3.2.Dockerfile语法</h2><p>构建自定义的镜像时，并不需要一个个文件去拷贝，打包。</p>
<p>我们只需要告诉Docker，我们的镜像的组成，需要哪些BaseImage、需要拷贝什么文件、需要安装什么依赖、启动脚本是什么，将来Docker会帮助我们构建镜像。</p>
<p>而描述上述信息的文件就是Dockerfile文件。</p>
<p><strong>Dockerfile</strong>就是一个文本文件，其中包含一个个的<strong>指令(Instruction)</strong>，用指令来说明要执行什么操作来构建镜像。每一个指令都会形成一层Layer。</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/19ok.png"></p>
<p>更新详细语法说明，请参考官网文档： <a href="https://docs.docker.com/engine/reference/builder">https://docs.docker.com/engine/reference/builder</a></p>
<h2 id="3-3-构建Java项目"><a href="#3-3-构建Java项目" class="headerlink" title="3.3.构建Java项目"></a>3.3.构建Java项目</h2><h3 id="3-3-1-基于Ubuntu构建Java项目"><a href="#3-3-1-基于Ubuntu构建Java项目" class="headerlink" title="3.3.1.基于Ubuntu构建Java项目"></a>3.3.1.基于Ubuntu构建Java项目</h3><p>需求：基于Ubuntu镜像构建一个新镜像，运行一个java项目</p>
<ul>
<li><p>步骤1：新建一个空文件夹docker-demo</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/1mhj.png"></p>
</li>
<li><p>步骤2：拷贝课前资料中的docker-demo.jar文件到docker-demo这个目录</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/bcq9.png"></p>
</li>
<li><p>步骤3：拷贝课前资料中的jdk8.tar.gz文件到docker-demo这个目录</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/bdf2.png"></p>
</li>
<li><p>步骤4：拷贝课前资料提供的Dockerfile到docker-demo这个目录</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/bdf2.png"></p>
<p>其中的内容如下：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">16.04</span></span><br><span class="line"><span class="comment"># 配置环境变量，JDK的安装目录</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_DIR=/usr/local</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝jdk和java项目的包</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./jdk8.tar.gz <span class="variable">$JAVA_DIR</span>/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./docker-demo.jar /tmp/app.jar</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装JDK</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">cd</span> <span class="variable">$JAVA_DIR</span> \</span></span><br><span class="line"><span class="language-bash"> &amp;&amp; tar -xf ./jdk8.tar.gz \</span></span><br><span class="line"><span class="language-bash"> &amp;&amp; <span class="built_in">mv</span> ./jdk1.8.0_144 ./java8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_HOME=$JAVA_DIR/java8</span><br><span class="line"><span class="keyword">ENV</span> PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 暴露端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8090</span></span><br><span class="line"><span class="comment"># 入口，java项目的启动命令</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> java -jar /tmp/app.jar</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>步骤5：进入docker-demo</p>
<p>将准备好的docker-demo上传到虚拟机任意目录，然后进入docker-demo目录下</p>
</li>
<li><p>步骤6：运行命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker build -t javaweb:1.0 .</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>最后访问 <a href="http://192.168.150.101:8090/hello/count，其中的ip改成你的虚拟机ip">http://192.168.150.101:8090/hello/count，其中的ip改成你的虚拟机ip</a></p>
<h3 id="3-3-2-基于java8构建Java项目"><a href="#3-3-2-基于java8构建Java项目" class="headerlink" title="3.3.2.基于java8构建Java项目"></a>3.3.2.基于java8构建Java项目</h3><p>虽然我们可以基于Ubuntu基础镜像，添加任意自己需要的安装包，构建镜像，但是却比较麻烦。所以大多数情况下，我们都可以在一些安装了部分软件的基础镜像上做改造。</p>
<p>例如，构建java项目的镜像，可以在已经准备了JDK的基础镜像基础上构建。</p>
<p>需求：基于java:8-alpine镜像，将一个Java项目构建为镜像</p>
<p>实现思路如下：</p>
<ul>
<li><p>① 新建一个空的目录，然后在目录中新建一个文件，命名为Dockerfile</p>
</li>
<li><p>② 拷贝课前资料提供的docker-demo.jar到这个目录中</p>
</li>
<li><p>③ 编写Dockerfile文件：</p>
<ul>
<li><p>a ）基于java:8-alpine作为基础镜像</p>
</li>
<li><p>b ）将app.jar拷贝到镜像中</p>
</li>
<li><p>c ）暴露端口</p>
</li>
<li><p>d ）编写入口ENTRYPOINT</p>
<p>内容如下：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> java:<span class="number">8</span>-alpine</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./app.jar /tmp/app.jar</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8090</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> java -jar /tmp/app.jar</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>④ 使用docker build命令构建镜像</p>
</li>
<li><p>⑤ 使用docker run创建容器并运行</p>
</li>
</ul>
<h2 id="3-4-小结"><a href="#3-4-小结" class="headerlink" title="3.4.小结"></a>3.4.小结</h2><p>小结：</p>
<ol>
<li>Dockerfile的本质是一个文件，通过指令描述镜像的构建过程</li>
<li>Dockerfile的第一行必须是FROM，从一个基础镜像来构建</li>
<li>基础镜像可以是基本操作系统，如Ubuntu。也可以是其他人制作好的镜像，例如：java:8-alpine</li>
</ol>
<h1 id="4-Docker-Compose"><a href="#4-Docker-Compose" class="headerlink" title="4.Docker-Compose"></a>4.Docker-Compose</h1><p>Docker Compose可以基于Compose文件帮我们快速的部署分布式应用，而无需手动一个个创建和运行容器！</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/8bp.png"></p>
<h2 id="4-1-初识DockerCompose"><a href="#4-1-初识DockerCompose" class="headerlink" title="4.1.初识DockerCompose"></a>4.1.初识DockerCompose</h2><p>Compose文件是一个文本文件，通过指令定义集群中的每个容器如何运行。格式如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">version<span class="punctuation">:</span> <span class="string">&quot;3.8&quot;</span></span><br><span class="line"> services<span class="punctuation">:</span></span><br><span class="line">  mysql<span class="punctuation">:</span></span><br><span class="line">    image<span class="punctuation">:</span> mysql<span class="punctuation">:</span><span class="number">5.7</span><span class="number">.25</span></span><br><span class="line">    environment<span class="punctuation">:</span></span><br><span class="line">     MYSQL_ROOT_PASSWORD<span class="punctuation">:</span> <span class="number">123</span> </span><br><span class="line">    volumes<span class="punctuation">:</span></span><br><span class="line">     - <span class="string">&quot;/tmp/mysql/data:/var/lib/mysql&quot;</span></span><br><span class="line">     - <span class="string">&quot;/tmp/mysql/conf/hmy.cnf:/etc/mysql/conf.d/hmy.cnf&quot;</span></span><br><span class="line">  web<span class="punctuation">:</span></span><br><span class="line">    build<span class="punctuation">:</span> .</span><br><span class="line">    ports<span class="punctuation">:</span></span><br><span class="line">     - <span class="string">&quot;8090:8090&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面的Compose文件就描述一个项目，其中包含两个容器：</p>
<ul>
<li>mysql：一个基于<code>mysql:5.7.25</code>镜像构建的容器，并且挂载了两个目录</li>
<li>web：一个基于<code>docker build</code>临时构建的镜像容器，映射端口时8090</li>
</ul>
<p>DockerCompose的详细语法参考官网：<a href="https://docs.docker.com/compose/compose-file/">https://docs.docker.com/compose/compose-file/</a></p>
<p>其实DockerCompose文件可以看做是将多个docker run命令写到一个文件，只是语法稍有差异。</p>
<h2 id="4-2-安装DockerCompose"><a href="#4-2-安装DockerCompose" class="headerlink" title="4.2.安装DockerCompose"></a>4.2.安装DockerCompose</h2><p>参考课前资料</p>
<h2 id="4-3-部署微服务集群"><a href="#4-3-部署微服务集群" class="headerlink" title="4.3.部署微服务集群"></a>4.3.部署微服务集群</h2><p><strong>需求</strong>：将之前学习的cloud-demo微服务集群利用DockerCompose部署</p>
<p><strong>实现思路</strong>：</p>
<p>① 查看课前资料提供的cloud-demo文件夹，里面已经编写好了docker-compose文件</p>
<p>② 修改自己的cloud-demo项目，将数据库、nacos地址都命名为docker-compose中的服务名</p>
<p>③ 使用maven打包工具，将项目中的每个微服务都打包为app.jar</p>
<p>④ 将打包好的app.jar拷贝到cloud-demo中的每一个对应的子目录中</p>
<p>⑤ 将cloud-demo上传至虚拟机，利用 docker-compose up -d 来部署</p>
<h3 id="4-3-1-compose文件"><a href="#4-3-1-compose文件" class="headerlink" title="4.3.1.compose文件"></a>4.3.1.compose文件</h3><p>查看课前资料提供的cloud-demo文件夹，里面已经编写好了docker-compose文件，而且每个微服务都准备了一个独立的目录：</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/bbur.png"></p>
<p>内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">nacos:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nacos/nacos-server</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MODE:</span> <span class="string">standalone</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8848:8848&quot;</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:5.7.25</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="number">123</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;$PWD/mysql/data:/var/lib/mysql&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;$PWD/mysql/conf:/etc/mysql/conf.d/&quot;</span></span><br><span class="line">  <span class="attr">userservice:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">./user-service</span></span><br><span class="line">  <span class="attr">orderservice:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">./order-service</span></span><br><span class="line">  <span class="attr">gateway:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">./gateway</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;10010:10010&quot;</span></span><br></pre></td></tr></table></figure>
<p>可以看到，其中包含5个service服务：</p>
<ul>
<li><code>nacos</code>：作为注册中心和配置中心<ul>
<li><code>image: nacos/nacos-server</code>： 基于nacos/nacos-server镜像构建</li>
<li><code>environment</code>：环境变量<ul>
<li><code>MODE: standalone</code>：单点模式启动</li>
</ul>
</li>
<li><code>ports</code>：端口映射，这里暴露了8848端口</li>
</ul>
</li>
<li><code>mysql</code>：数据库<ul>
<li><code>image: mysql:5.7.25</code>：镜像版本是mysql:5.7.25</li>
<li><code>environment</code>：环境变量<ul>
<li><code>MYSQL_ROOT_PASSWORD: 123</code>：设置数据库root账户的密码为123</li>
</ul>
</li>
<li><code>volumes</code>：数据卷挂载，这里挂载了mysql的data、conf目录，其中有我提前准备好的数据</li>
</ul>
</li>
<li><code>userservice</code>、<code>orderservice</code>、<code>gateway</code>：都是基于Dockerfile临时构建的</li>
</ul>
<p>查看mysql目录，可以看到其中已经准备好了cloud_order、cloud_user表：</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/bd7c.png"></p>
<p>查看微服务目录，可以看到都包含Dockerfile文件：</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/bd3h.png"></p>
<p>内容如下：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> java:<span class="number">8</span>-alpine</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./app.jar /tmp/app.jar</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> java -jar /tmp/app.jar</span></span><br></pre></td></tr></table></figure>
<h3 id="4-3-2-修改微服务配置"><a href="#4-3-2-修改微服务配置" class="headerlink" title="4.3.2.修改微服务配置"></a>4.3.2.修改微服务配置</h3><p>因为微服务将来要部署为docker容器，而容器之间互联不是通过IP地址，而是通过容器名。这里我们将order-service、user-service、gateway服务的mysql、nacos地址都修改为基于容器名的访问。</p>
<p>如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://mysql:3306/cloud_order?useSSL=false</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">orderservice</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">nacos:8848</span> <span class="comment"># nacos服务地址</span></span><br></pre></td></tr></table></figure>
<h3 id="4-3-3-打包"><a href="#4-3-3-打包" class="headerlink" title="4.3.3.打包"></a>4.3.3.打包</h3><p>接下来需要将我们的每个微服务都打包。因为之前查看到Dockerfile中的jar包名称都是app.jar，因此我们的每个微服务都需要用这个名称。</p>
<p>可以通过修改pom.xml中的打包名称来实现，每个微服务都需要修改：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 服务打包的最终名称 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>app<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>打包后：</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/bcbv.png"></p>
<h3 id="4-3-4-拷贝jar包到部署目录"><a href="#4-3-4-拷贝jar包到部署目录" class="headerlink" title="4.3.4.拷贝jar包到部署目录"></a>4.3.4.拷贝jar包到部署目录</h3><p>编译打包好的app.jar文件，需要放到Dockerfile的同级目录中。注意：每个微服务的app.jar放到与服务名称对应的目录，别搞错了。</p>
<p>user-service：</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/8bw.png"></p>
<p>order-service：</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/1mg8.png"></p>
<p>gateway：</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/bcuz.png"></p>
<h3 id="4-3-5-部署"><a href="#4-3-5-部署" class="headerlink" title="4.3.5.部署"></a>4.3.5.部署</h3><p>最后，我们需要将文件整个cloud-demo文件夹上传到虚拟机中，理由DockerCompose部署。</p>
<p>上传到任意目录：</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/bdac.png"></p>
<p>部署：</p>
<p>进入cloud-demo目录，然后运行下面的命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>
<h1 id="5-Docker镜像仓库"><a href="#5-Docker镜像仓库" class="headerlink" title="5.Docker镜像仓库"></a>5.Docker镜像仓库</h1><h2 id="5-1-搭建私有镜像仓库"><a href="#5-1-搭建私有镜像仓库" class="headerlink" title="5.1.搭建私有镜像仓库"></a>5.1.搭建私有镜像仓库</h2><p>参考课前资料《CentOS7安装Docker.md》</p>
<h2 id="5-2-推送、拉取镜像"><a href="#5-2-推送、拉取镜像" class="headerlink" title="5.2.推送、拉取镜像"></a>5.2.推送、拉取镜像</h2><p>推送镜像到私有镜像服务必须先tag，步骤如下：</p>
<p>① 重新tag本地镜像，名称前缀为私有仓库的地址：192.168.150.101:8080/</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker tag nginx:latest 192.168.150.101:8080/nginx:1.0 </span><br></pre></td></tr></table></figure>
<p>② 推送镜像</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker push 192.168.150.101:8080/nginx:1.0 </span><br></pre></td></tr></table></figure>
<p>③ 拉取镜像</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker pull 192.168.150.101:8080/nginx:1.0 </span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Docker</tag>
        <tag>镜像仓库</tag>
        <tag>数据卷</tag>
      </tags>
  </entry>
  <entry>
    <title>Nacos-服务发现与配置管理v1.0</title>
    <url>/2023/01/06/Nacos-%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E4%B8%8E%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86v1-0/</url>
    <content><![CDATA[<h1 id="Nacos-服务发现和配置管理"><a href="#Nacos-服务发现和配置管理" class="headerlink" title="Nacos - 服务发现和配置管理"></a>Nacos - 服务发现和配置管理</h1><h2 id="1-理解服务发现"><a href="#1-理解服务发现" class="headerlink" title="1 理解服务发现"></a>1 <strong>理解服务发现</strong></h2><h3 id="1-1-微服务架构"><a href="#1-1-微服务架构" class="headerlink" title="1.1 微服务架构"></a>1.1 <strong>微服务架构</strong></h3><p>为适应企业的业务发展，提高软件研发的生产力，降低软件研发的成本，软件架构也作了升级和优化，将一个独立 的系统拆分成若干小的服务，每个小服务运行在不同的进程中，服务与服务之间采用RESTful、RPC等协议传输数    据，每个服务所拥有的功能具有独立性强的特点，这样的设计就实现了单个服务的高内聚，服务与服务之间的低耦 合效果，这些小服务就是微服务，基于这种方法设计的系统架构即微服务架构。</p>
<span id="more"></span>
<p>下图是基于微服务架构的电商系统：</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/06/5het.png"></p>
<p>特点：</p>
<p>1、服务层按业务拆分为一个一个的微服务。</p>
<p>2、微服务的职责单一。</p>
<p>3、微服务之间采用RESTful、RPC等轻量级协议传输。</p>
<p>4、有利于采用前后端分离架构。</p>
<h3 id="1-2理解服务发现"><a href="#1-2理解服务发现" class="headerlink" title="1.2理解服务发现"></a>1.2<strong>理解服务发现</strong></h3><h4 id="1-2-1-测试环境"><a href="#1-2-1-测试环境" class="headerlink" title="1.2.1 测试环境"></a>1.2.1 <strong>测试环境</strong></h4><p>在微服务架构中，整个系统会按职责能力划分为多个服务，通过服务之间协作来实现业务目标。这样在我们的代码 中免不了要进行服务间的远程调用，服务的消费方要调用服务的生产方，为了完成一次请求，消费方需要知道服务 生产方的网络位置(IP地址和端口号)。</p>
<p>我们的代码可以通过读取配置文件的方式读取服务生产方网络位置，如下：</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/06/62i4.png"></p>
<p>我们通过Spring boot技术很容易实现： </p>
<p><strong>1</strong>、创建nacos-discovery父工程</p>
<p>pom.xml如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF‐8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema‐instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0</span><br><span class="line">http://maven.apache.org/xsd/maven‐4.0.0.xsd&quot;&gt;</span><br><span class="line">&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">&lt;groupId&gt;com.itheima.nacos&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;nacos‐discovery&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.0‐SNAPSHOT&lt;/version&gt;</span><br><span class="line">&lt;packaging&gt;pom&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring‐boot‐dependencies&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;2.1.3.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">&lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line">&lt;/dependencyManagement&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>
<p>2、Service B（服务生产者）</p>
<p>创建服务提供者 nacos-restful-provider。</p>
<p>pom.xml如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF‐8&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema‐instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0</span><br><span class="line">http://maven.apache.org/xsd/maven‐4.0.0.xsd&quot;&gt;</span><br><span class="line">&lt;parent&gt;</span><br><span class="line">&lt;artifactId&gt;nacos‐discovery&lt;/artifactId&gt;</span><br><span class="line">&lt;groupId&gt;com.itheima.nacos&lt;/groupId&gt;</span><br><span class="line">&lt;version&gt;1.0‐SNAPSHOT&lt;/version&gt;</span><br><span class="line">&lt;/parent&gt;</span><br><span class="line">&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">&lt;artifactId&gt;nacos‐restful‐provider&lt;/artifactId&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring‐boot‐starter‐web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>
<p>1、创建Controller</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.nacos.provider.controller;</span><br><span class="line"></span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">public class RestProviderController &#123; @GetMapping(value = &quot;/service&quot;) //暴露服务public String service()&#123;</span><br><span class="line">System.out.println(&quot;provider invoke&quot;); return &quot;provider invoke&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、创建启动类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class SpringRestProviderBootstrap &#123; public static void main(String[] args) &#123;</span><br><span class="line">SpringApplication.run(SpringRestProviderBootstrap.class, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置文件：</p>
<p>创建application.yml，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server：</span><br><span class="line">port：56010</span><br></pre></td></tr></table></figure>
<p><strong>3</strong>、<strong>Service</strong> <strong>A</strong>（服务消费者）</p>
<p>创建nacos-restful-consumer 服务消费工程。</p>
<p>pom.xml如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF‐8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema‐instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0</span><br><span class="line">http://maven.apache.org/xsd/maven‐4.0.0.xsd&quot;&gt;</span><br><span class="line">&lt;parent&gt;</span><br><span class="line">&lt;artifactId&gt;nacos‐discovery&lt;/artifactId&gt;</span><br><span class="line">&lt;groupId&gt;com.itheima.nacos&lt;/groupId&gt;</span><br><span class="line">&lt;version&gt;1.0‐SNAPSHOT&lt;/version&gt;</span><br><span class="line">&lt;/parent&gt;</span><br><span class="line">&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">&lt;artifactId&gt;nacos‐restful‐consumer&lt;/artifactId&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring‐boot‐starter‐web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>
<p>实现代码：</p>
<p>1、创建controller</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.nacos.consumer.controller;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.annotation.Value; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; import org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">public class RestConsumerController &#123; @Value(&quot;$&#123;provider.address&#125;&quot;) private String providerAddress;</span><br><span class="line">@GetMapping(value = &quot;/service&quot;)</span><br><span class="line">public String service()&#123;</span><br><span class="line">RestTemplate restTemplate = new RestTemplate();</span><br><span class="line">//调用服务</span><br><span class="line">String providerResult = restTemplate.getForObject(&quot;http://&quot; + providerAddress + &quot;/service&quot;,String.class);</span><br><span class="line">return &quot;consumer invoke | &quot; + providerResult;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、创建启动类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class SpringRestConsumerBootstrap &#123; public static void main(String[] args) &#123;</span><br><span class="line">SpringApplication.run(SpringRestConsumerBootstrap.class, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置文件：</p>
<p>创建application.yml，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server.port = 56020 # 服务生产方地址</span><br><span class="line">provider.address = 127.0.0.1:56010</span><br></pre></td></tr></table></figure>
<p>访问<a href="http://127.0.0.1:56020/service，输出以下内容：">http://127.0.0.1:56020/service，输出以下内容：</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">consumer invoke | provider invoke</span><br></pre></td></tr></table></figure>
<h4 id="1-2-2-服务发现流程"><a href="#1-2-2-服务发现流程" class="headerlink" title="1.2.2 服务发现流程"></a>1.2.2 <strong>服务发现流程</strong></h4><p>上边的例子看上去很完美，但是，仔细考虑以下，此方案对于微服务应用而言行不通。首先，微服务可能是部署在 云环境的，服务实例的网络位置或许是动态分配的。另外，每一个服务一般会有多个实例来做负载均衡，由于宕机 或升级，服务实例网络地址会经常动态改变。再者，每一个服务也可能应对临时访问压力增加新的服务节点。正如 下图所示：</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/06/tib.png"></p>
<p>基于以上的问题，服务之间如何相互发现？服务如何管理？这就是服务发现的问题了。</p>
<p>服务发现就是服务消费方通过服务发现中心智能发现服务提供方，从而进行远程调用的过程。 如下图：</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/06/z5c.png"></p>
<p>上图中服务实例本身并不记录服务生产方的网络地址，所有服务实例内部都会包含<strong>服务发现客户端</strong>。</p>
<p>（1） 在每个服务启动时会向<strong>服务发现中心</strong>上报自己的网络位置。这样，在服务发现中心内部会形成一个<strong>服务注册</strong> <strong>表</strong>，<strong>服务注册表</strong>是服务发现的核心部分，是包含所有服务实例的网络地址的数据库。</p>
<p>（2） <strong>服务发现客户端</strong>会定期从<strong>服务发现中心</strong>同步<strong>服务注册表</strong>   ，并缓存在客户端。</p>
<p>（3） 当需要对某服务进行请求时，服务实例通过该注册表，定位目标服务网络地址。若目标服务存在多个网络地 址，则使用负载均衡算法从多个服务实例中选择出一个，然后发出请求。</p>
<p>总结，在微服务环境中，由于服务运行实例的网络地址是不断动态变化的，服务实例数量的动态变化   ，因此无法使用固定的配置文件来记录服务提供方的网络地址，必须使用动态的服务发现机制用于实现微服务间的<strong>相互感知</strong>。 各服务实例会上报自己的网络地址，这样服务中心就形成了一个完整的服务注册表，各服务实例会通过<strong>服务发现中</strong> <strong>心</strong>来获取访问目标服务的网络地址，从而实现<strong>服务发现</strong>的机制。</p>
<h2 id="2-Nacos-服务发现"><a href="#2-Nacos-服务发现" class="headerlink" title="2 Nacos 服务发现"></a>2 <strong>Nacos</strong> <strong>服务发现</strong></h2><h3 id="2-1-Nacos特性"><a href="#2-1-Nacos特性" class="headerlink" title="2.1. Nacos特性"></a>2.1. <strong>Nacos</strong>特性</h3><p>Nacos主要提供以下四大功能：</p>
<ol>
<li><strong>服务发现与服务健康检查</strong></li>
</ol>
<p>Nacos使服务更容易注册，并通过DNS或HTTP接口发现其他服务，Nacos还提供服务的实时健康检查，以防 止向不健康的主机或服务实例发送请求。</p>
<ol>
<li><strong>动态配置管理</strong></li>
</ol>
<p>动态配置服务允许您在所有环境中以集中和动态的方式管理所有服务的配置。Nacos消除了在更新配置时重新 部署应用程序，这使配置的更改更加高效和灵活。</p>
<ol>
<li><strong>动态DNS服务</strong></li>
</ol>
<p>Nacos提供基于DNS   协议的服务发现能力，旨在支持异构语言的服务发现，支持将注册在Nacos上的服务以域名的方式暴露端点，让三方应用方便的查阅及发现。</p>
<ol>
<li><strong>服务和元数据管理</strong></li>
</ol>
<p>Nacos 能让您从微服务平台建设的视角管理数据中心的所有服务及元数据，包括管理服务的描述、生命周期、服务的静态依赖分析、服务的健康状态、服务的流量管理、路由及安全策略。</p>
<h3 id="2-2-启动服务器"><a href="#2-2-启动服务器" class="headerlink" title="2.2 启动服务器"></a>2.2 <strong>启动服务器</strong></h3><p>nacos的默认端口是8848，需要保证8848默认端口没有被其他进程占用。 进入安装程序的bin目录：</p>
<p><strong>Windows</strong>启动方式： 启动命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmd startup.cmd</span><br></pre></td></tr></table></figure>
<p>或者双击startup.cmd运行文件。</p>
<p>启动成功，可通过浏览器访问   <a href="http://127.0.0.1:8848/nacos">http://127.0.0.1:8848/nacos</a>   ，打开如下nacos控制台登录页面：</p>
<p>启动成功，可通过浏览器访问   <a href="http://127.0.0.1:8848/nacos">http://127.0.0.1:8848/nacos</a>   ，打开如下nacos控制台登录页面：</p>
<h3 id="2-3外部mysql数据库支持"><a href="#2-3外部mysql数据库支持" class="headerlink" title="2.3外部mysql数据库支持"></a>2.3<strong>外部</strong>mysql<strong>数据库支持</strong></h3><p>单机模式时nacos默认使用嵌入式数据库实现数据的存储，若想使用外部mysql存储nacos数据，需要进行以下步 骤：</p>
<ol>
<li><p>安装数据库，版本要求：5.6.5+ ，mysql 8 以下</p>
</li>
<li><p>初始化mysql数据库，新建数据库nacos_conﬁg，数据库初始化文件：${nacoshome}/conf/nacos- mysql.sql</p>
</li>
<li><p>修改${nacoshome}/conf/application.properties文件，增加支持mysql数据源配置（目前只支持mysql），添加mysql数据源的url、用户名和密码。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring.datasource.platform=mysql</span><br><span class="line"></span><br><span class="line">db.num=1 db.url.0=jdbc:mysql://11.162.196.16:3306/nacos_config?</span><br><span class="line">characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true db.user=nacos_devtest</span><br><span class="line">db.password=youdontknow</span><br></pre></td></tr></table></figure>
<h3 id="2-4-服务注册"><a href="#2-4-服务注册" class="headerlink" title="2.4 服务注册"></a>2.4 <strong>服务注册</strong></h3><p>在服务提供工程中配置nacos服务发现相关的配置： </p>
<p>服务提供：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">application:</span><br><span class="line">name: nacos‐restful‐provider cloud:</span><br><span class="line">nacos:</span><br><span class="line">discovery:</span><br><span class="line">server‐addr: 127.0.0.1:8848</span><br></pre></td></tr></table></figure>
<p>启动nacos</p>
<p>启动服务提供</p>
<p>观察nacos服务列表，nacos-restful-provider注册成功</p>
<h2 id="3-服务发现数据模型"><a href="#3-服务发现数据模型" class="headerlink" title="3. 服务发现数据模型"></a>3. <strong>服务发现数据模型</strong></h2><h3 id="3-1-Namespace-隔离设计"><a href="#3-1-Namespace-隔离设计" class="headerlink" title="3.1 Namespace 隔离设计"></a>3.1 <strong>Namespace</strong> <strong>隔离设计</strong></h3><p><strong>命名空间**</strong>(Namespace)**用于进行租户粒度的隔离，Namespace    的常用场景之一是不同环境的隔离，例如开发测试环境和生产环境的资源（如配置、服务）隔离等。</p>
<p>从一个租户(用户)的角度来看，如果有多套不同的环境，那么这个时候可以根据指定的环境来创建不同的namespce，以此来实现多环境的隔离。例如，你可能有开发，测试和生产三个不同的环境，那么使用一套nacos 集群可以分别建以下三个不同的 namespace。如下图所示：</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/06/1lu2.png"></p>
<p>从多个租户(用户)的角度来看，每个租户(用户)可能会有自己的 namespace,每个租户(用户)的配置数据以及注册的服务数据都会归属到自己的 namespace 下，以此来实现多租户间的数据隔离。例如超级管理员分配了三个租户，分别为张三、李四和王五。分配好了之后，各租户用自己的账户名和密码登录后，创建自己的命名   空间。如下图所示：</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/06/1j07.png"></p>
<h3 id="3-2-命名空间管理"><a href="#3-2-命名空间管理" class="headerlink" title="3.2 命名空间管理"></a>3.2 <strong>命名空间管理</strong></h3><p>前面已经介绍过，命名空间(Namespace)是用于隔离多个环境的（如开发、测试、生产），而每个应用在不同环    境的同一个配置（如数据库数据源）的值是不一样的。因此，我们应针对企业项目实际研发流程、环境进行规划。 如某软件公司拥有开发、测试、生产三套环境，那么我们应该针对这三个环境分别建立三个namespace。</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/06/cpmx.png"></p>
<p>建立好所有namespace后，在<strong>配置管理</strong>与<strong>服务管理</strong>模块下所有页面，都会包含用于切换namespace(环境)的tab按   钮，如下图：</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/06/cwvj.png"></p>
<h2 id="4-Nacos配置管理"><a href="#4-Nacos配置管理" class="headerlink" title="4. Nacos配置管理"></a>4. <strong>Nacos</strong>配置管理</h2><p>首先在nacos发布配置，nacos-restful-consumer服务从nacos读取配置。</p>
<p>浏览器访问 <a href="http://127.0.0.1:8848/nacos">http://127.0.0.1:8848/nacos</a> ，打开nacos控制台，并点击菜单<strong>配置管理**</strong>-&gt;<strong>**配置列表</strong>： 在Nacos添加如下的配置：</p>
<p>nacos-restful-consumer:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Namespace: public</span><br><span class="line">Data ID:	nacos‐restful‐consumer.yaml Group :	DEFAULT_GROUP</span><br><span class="line">配置格式:	YAML</span><br><span class="line">配置内容：	common:</span><br><span class="line">name: application1 config</span><br></pre></td></tr></table></figure>
<p><img src="https://i.p04e.com/baid/i/2023/01/06/20rj.png"><br><img src="https://i.p04e.com/baid/i/2023/01/06/20rz.png"></p>
<p>要想从配置中心获取配置添加nacos-conﬁg的依赖：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring‐cloud‐starter‐alibaba‐nacos‐config&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>在bootstrap.yml添加配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">cloud:</span><br><span class="line">nacos:</span><br><span class="line">config:</span><br><span class="line">server‐addr: 127.0.0.1:8848 # 配置中心地址</span><br><span class="line">file‐extension: yaml group: DEFAULT_GROUP</span><br></pre></td></tr></table></figure>
<p>注意：要使用配置中心就要在bootstrap.yml中来配置，bootstrap.yml配置文件的加载顺序要比application.yml要优先。</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/06/et8n.png"></p>
<h2 id="5-定义扩展的-Data-Id-配置"><a href="#5-定义扩展的-Data-Id-配置" class="headerlink" title="5 定义扩展的 Data Id 配置"></a>5 <strong>定义扩展的</strong> <strong>Data</strong> <strong>Id</strong> <strong>配置</strong></h2><h3 id="5-1-ext-conﬁg扩展配置"><a href="#5-1-ext-conﬁg扩展配置" class="headerlink" title="5.1 ext-conﬁg扩展配置"></a>5.1 <strong>ext-conﬁg</strong>扩展配置</h3><p>Spring Cloud Alibaba Nacos Conﬁg可支持自定义 Data Id 的配置。 一个完整的配置案例如下所示：</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/06/1ynu.png"></p>
<p>扩展配置优先级是spring.cloud.nacos.config.ext-config[n].data-id中 n 的值越大，优先级越高。</p>
<p>通过内部相关规则(应用名、扩展名 )自动生成相关的 Data Id 配置的优先级最大。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h1><p>Nacos用来干什么？</p>
<p>Nacos是阿里巴巴公司开源的项目，它用来实现配置中心和服务注册中心。 什么是服务发现？</p>
<p>在微服务架构中一个业务流程需要多个微服务通过网络接口调用完成业务处理，服务消费方从服务注册中心获取服 务提供方的地址，从而进行远程调用，这个过程叫做服务发现。</p>
<p>服务发现的流程是什么？</p>
<p>1、服务发现的客户端从服务注册中心获取服务列表</p>
<p>2、服务消费方通过客户端负载均衡获取服务实例地址，进行远程调用。什么是配置中心？</p>
<p>在微服务架构中为了统一管理各各微服务的配置信息专门设置配置中心，配置中心就是一种统一管理各种应用配置 的基础服务组件。</p>
<p>配置中心的应用流程是什么？</p>
<p>1、发布配置，将配置信息发布到配置中心。</p>
<p>2、获取配置，配置中心客户端得到配置中心的通知，从配置中心获取配置。</p>
<p>Spring Cloud是什么？</p>
<p>Spring Cloud是一套微服务开发框架集合，包括微服务开发的方方页面，Spring   Cloud是一套微服务开发的标准， 集成了很多优秀的开源框架，比如有名的Netﬂix公司的众多项目。</p>
<p>Spring Cloud Alibaba是什么？</p>
<p>Spring Cloud Alibaba是阿里巴巴公司基于Spring Cloud标准实现一套微服务开发框架集合，它和Netﬂix一样都是Spring Cloud微服务开发实现方案。</p>
<p>Dubbo服务开发流程是什么？ 1、定义api工程。</p>
<p>方便其它服务原来api工程，远程调用dubbo服务。</p>
<p>2、定义api实现工程。</p>
<p>service实现类使用  @org.apache.dubbo.conﬁg.annotation.Service注解标记为dubbo服务。</p>
<p>3、服务消费方开发</p>
<p>引入api工程依赖</p>
<p>使用org.apache.dubbo.conﬁg.annotation.Reference注解注入service，发起远程调用</p>
]]></content>
      <tags>
        <tag>nacos</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis-Plus</title>
    <url>/2023/01/06/Mybatis-Plus/</url>
    <content><![CDATA[<h1 id="1-Mybatis-Plus介绍"><a href="#1-Mybatis-Plus介绍" class="headerlink" title="1 Mybatis-Plus介绍"></a>1 <strong>Mybatis-Plus</strong>介绍</h1><p>MyBatis-Plus（简称 MP）是一个 MyBatis 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发 提高效率而生。该框架由baomidou（苞米豆）组织开发并且开源的。我们的愿景是成为 MyBatis 最好的搭档，就像 魂斗罗 中的 1P 2P，基友搭配，效率翻倍。</p>
<span id="more"></span>
<h2 id="1-1-支持的数据库"><a href="#1-1-支持的数据库" class="headerlink" title="1.1 支持的数据库"></a>1.1 <strong>支持的数据库</strong></h2><p>MyBatisPlus支持如下数据库：</p>
<p>mysql mariadb  oracle  db2  h2  hsql  sqlite  postgresql  sqlserver</p>
<p>数据库 虚谷数据库 人大金仓数据库</p>
<h2 id="1-1-特性"><a href="#1-1-特性" class="headerlink" title="1.1 特性"></a>1.1 <strong>特性</strong></h2><p>无侵入<strong>：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑   </strong>损耗小**：启动即会自动注入基本 CRUD，性能基本无损耗，直接面向对象操作</p>
<p><strong>强大的</strong> <strong>CRUD</strong> <strong>操作</strong>：内置通用 Mapper 通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作， 更有强大的条件构造器，满足各类使用需求</p>
<p><strong>支持</strong> <strong>Lambda</strong> <strong>形式调用</strong>：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错</p>
<p><strong>支持多种数据库</strong>：支持 MySQL MariaDB Oracle DB2 H2 HSQL SQLite Postgre SQLServer2005 SQLServer</p>
<p>等多种数据库</p>
<p><strong>支持主键自动生成</strong>：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题1</p>
<p><strong>支持</strong> <strong>XML</strong> <strong>热加载</strong>：Mapper 对应的 XML 支持热加载，对于简单的 CRUD 操作，甚至可以无 XML 启动</p>
<p><strong>支持</strong> <strong>ActiveRecord</strong> <strong>模式</strong>：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD</p>
<p>操作</p>
<p><strong>支持自定义全局通用操作</strong>：支持全局通用方法注入（ Write once, use anywhere ）</p>
<p><strong>支持关键词自动转义</strong>：支持数据库关键词（order key    ）自动转义，还可自定义关键词</p>
<p><strong>内置代码生成器</strong>：采用代码或者 Maven 插件可快速生成 Mapper Model Service Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用</p>
<p><strong>内置分页插件</strong>：基于   MyBatis   物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通</p>
<p>List 查询</p>
<p><strong>内置性能分析插件</strong>：可输出 Sql 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询<strong>内置全局拦截插件</strong>：提供全表 delete     update 操作智能分析阻断，也可自定义拦截规则，预防误操作<strong>内置</strong> <strong>Sql</strong> <strong>注入剥离器</strong>：支持 Sql 注入剥离，有效预防 Sql 注入攻击</p>
<h2 id="1-1-架构"><a href="#1-1-架构" class="headerlink" title="1.1 架构"></a>1.1 <strong>架构</strong></h2><p><img src="https://i.p04e.com/baid/i/2023/01/06/2r80.png"></p>
<p>Mybatis主要包含以下模块：</p>
<p><strong>核心功能**</strong>(core)**，基于Mybatis的封装，提供了Mybatis Plus的基础配置类与核心功能，如内置通用 Mapper， Lambda 表达式查询等。</p>
<p><strong>注解**</strong>(annotation)**，提供了Mybatis Plus中注解的定义。</p>
<p><strong>扩展功能**</strong>(extension)**，提供扩展及插件功能，包括分页插件 通用 Service扩展 性能分析插件等。</p>
<p><strong>代码生成器**</strong>(generator)**：通过代码生成器可以快速生成 Mapper接口 Entity实体类 Mapper XML Service Controller 等各个模块的代码，极大的提升了开发效率。</p>
<p>执行流程：</p>
<p>（1） 扫描注解Entity，反射提取注解信息如：表名称   字段名称等信息。</p>
<p>（2） 分析注解信息并基于com.baomidou.mybatisplus.core.enums的SQL模板生成基本CRUD       SQL。</p>
<p>（3） 最后将这些SQL注入到Mybatis环境中。</p>
<p>因此Mybatis plus无需编写CRUD SQL语句，只需继承BaseMapper，就有了CRUD功能(通用CRUD)。</p>
<h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><h3 id="创建user表插入数据"><a href="#创建user表插入数据" class="headerlink" title="创建user表插入数据"></a>创建user表插入数据</h3><h3 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h3><p>新建一个<code>springboot</code>，<code>maven</code>项目</p>
<h3 id="引入对应依赖"><a href="#引入对应依赖" class="headerlink" title="引入对应依赖"></a>引入对应依赖</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 数据库驱动 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- lombok 简化set get toString --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- mybatis-plus --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.4.3.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="链接数据库-同mybatis"><a href="#链接数据库-同mybatis" class="headerlink" title="链接数据库(同mybatis)"></a>链接数据库(同mybatis)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    url: jdbc:mysql://localhost:3306/mybatis_plus?useUnicode=true&amp;useSSL=false&amp;characterEncoding=utf8&amp;serverTimezone=Asia/Shanghai</span><br><span class="line">    username: root</span><br><span class="line">    password: 123456</span><br><span class="line">#其中url中，数据库名称？是否使用安全链接，字符集编码，是否使用解码，设置时区</span><br><span class="line"></span><br><span class="line">#mysql数据库用的是gbk编码，而项目数据库用的是utf-8编码。这时候如果添加了useUnicode=true&amp;characterEncoding=UTF-8</span><br><span class="line">#存数据时：</span><br><span class="line">#数据库在存放项目数据的时候会先用UTF-8格式将数据解码成字节码，然后再将解码后的字节码重新使用GBK编码存放到数据库中。</span><br><span class="line">#取数据时：</span><br><span class="line">#在从数据库中取数据的时候，数据库会先将数据库中的数据按GBK格式解码成字节码，然后再将解码后的字节码重新按UTF-8格式编码数据，最后再将数据返回给客户端。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="使用mybatis-plus"><a href="#使用mybatis-plus" class="headerlink" title="使用mybatis-plus"></a>使用mybatis-plus</h3><p>创建pojo类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Data</span><br><span class="line">@AllArgsConstructor #有参构造器</span><br><span class="line">@NoArgsConstructor  #无参构造器</span><br><span class="line">public class User &#123;</span><br><span class="line">    //常见的数据库中主键自动设置方法有（uuid、自增id、雪花算法、redis生成、zookeeper生成）</span><br><span class="line">    private Long id;</span><br><span class="line">    private String name;</span><br><span class="line">    private Integer age;</span><br><span class="line">    private String email;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在启动类加上<code>@mapper</code>注解,扫描<code>mapper</code>文件夹</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@MapperScan(&quot;com.jdw.mapper&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>mapper接口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//在对应的Mapper 接口上 基础基本的 BaseMapper&lt;T&gt; T是对应的pojo类</span><br><span class="line">@Repository   //告诉容器你是持久层的 @Repository是spring提供的注释，能够将该类注册成Bean</span><br><span class="line">public interface UserMapper extends BaseMapper&lt;User&gt; &#123;</span><br><span class="line">    //所有的crud都编写完成了</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>支持，<code>mybatis-plus</code>已经配置完成，可以直接使用，<code>CRUD</code>。</li>
<li>使用测试类<code>@Test</code>测试</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//继承了BaseMapper ,所有方法来自父类，可扩展</span><br><span class="line">@Autowired</span><br><span class="line">private UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">void contextLoads() &#123;</span><br><span class="line">    System.out.println((&quot;----- selectAll method test 测试查询所有用户方法 ------&quot;));</span><br><span class="line">    //selectList 的参数wrapper 是条件构造器，可以先写null</span><br><span class="line">    List&lt;User&gt; userList = userMapper.selectList(null);</span><br><span class="line">    //forEach 的参数是 Consumer类型的 语法糖</span><br><span class="line">    userList.forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="日志配置"><a href="#日志配置" class="headerlink" title="日志配置"></a>日志配置</h1><p>使用yml添加日志配置项</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mybatis-plus:</span><br><span class="line">  configuration:</span><br><span class="line">    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行查询方法查看分析日志</p>
<p>执行上面的查询所有用户的方法查看日志</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/06/3xr0z.png"></p>
<p>插入测试</p>
<p>插入及日志分析</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//测试插入</span><br><span class="line">@Test</span><br><span class="line">public void testInsert()&#123;</span><br><span class="line">    User user = new User();</span><br><span class="line">    user.setName(&quot;小蒋&quot;);</span><br><span class="line">    user.setAge(3);</span><br><span class="line">    user.setEmail(&quot;24749559@qq.com&quot;);</span><br><span class="line">    //没有设置ID却自动生成的ID</span><br><span class="line">    int result = userMapper.insert(user);</span><br><span class="line">    System.out.println(&quot;result = &quot; + result);</span><br><span class="line">    System.out.println(&quot;user = &quot; + user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>日志分析</strong></p>
<p>我们可以看到，并没有给user设置id，数据库自动插入了id=1453311479846608897，</p>
<h3 id="主键生成策略"><a href="#主键生成策略" class="headerlink" title="主键生成策略"></a>主键生成策略</h3><p>因为在最开始建表的sql语句中就指明了，id是数据库的主键，主键不能唯空，</p>
<p>常见的数据库中主键自动设置方法有（uuid、自增id、雪花算法、redis生成、zookeeper生成）</p>
<h4 id="雪花算法"><a href="#雪花算法" class="headerlink" title="雪花算法"></a>雪花算法</h4><p>这里生成的id默认采用的是<strong>雪花算法</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">snowflake是Twitter开源的分布式ID生成算法，结果是一个long型的ID。其核心思想是：使用41bit作为毫秒数，10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID），12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 ID），最后还有一个符号位，永远是0。具体实现的代码可以参看https://github.com/twitter/snowflake。雪花算法支持的TPS可以达到419万左右（2^22*1000）,几乎保证全球唯一。</span><br><span class="line"></span><br><span class="line">雪花算法在工程实现上有单机版本和分布式版本。单机版本如下，分布式版本可以参看美团leaf算法：https://github.com/Meituan-Dianping/Leaf</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以在User类的id属性上加入注解TableId更改和查看策略</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type = IdType.ASSIGN_ID，全局唯一id，雪花算法</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line">    @TableId(type = IdType.ASSIGN_ID,value = &quot;id&quot;)//枚举注解,使用ID_WORKER策略,全局唯一ID，数据库设置自增也没用</span><br><span class="line">    private Long id;</span><br><span class="line">    private String name;</span><br><span class="line">    private Integer age;</span><br><span class="line">    private String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进入这个注解</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Documented</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(&#123;ElementType.FIELD&#125;)  //枚举注解</span><br><span class="line">public @interface TableId &#123;</span><br><span class="line">    //可以设置以下两个参数</span><br><span class="line">    String value() default &quot;&quot;;</span><br><span class="line">    IdType type() default IdType.NONE; //ID策略</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="主键自增策略"><a href="#主键自增策略" class="headerlink" title="主键自增策略"></a>主键自增策略</h4><p>要是自增策略，在id上加入下列代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@TableId(type = IdType.AUTO)</span><br><span class="line">private Long id;</span><br></pre></td></tr></table></figure>
<p>同时数据库设计时，一定要将id设计为自增，这样自增id会设置在最大值上加1</p>
<h1 id="更新测试"><a href="#更新测试" class="headerlink" title="更新测试"></a>更新测试</h1><h3 id="更新及日志分析"><a href="#更新及日志分析" class="headerlink" title="更新及日志分析"></a>更新及日志分析</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//更新测试</span><br><span class="line">@Test</span><br><span class="line">   public void testUpdateByID() &#123;</span><br><span class="line">       User user = new User();</span><br><span class="line">       user.setId(7L);</span><br><span class="line">       user.setName(&quot;小小&quot;);</span><br><span class="line">       user.setAge(18);//这一行后加</span><br><span class="line">       int i = userMapper.updateById(user);//受影响的行数,参数是一个user不是id,点击看源码</span><br><span class="line">       System.out.println(&quot;i = &quot; + i);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我可以发现，先只更新了名字，后面更新名字和年龄。mybatis-plus通过条件自动把我们进行了动态sql拼接</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/06/41dx0.png"></p>
<p>自动填充<br>创建时间、更新时间！这个操作是自动化完成的，不要手动更新！</p>
<p>gmt_create、gmt_modified几乎在所有表都要配置上，而且自动化填充。gmt是时间时间的意思</p>
<h4 id="方式一、数据库级别（不建议）"><a href="#方式一、数据库级别（不建议）" class="headerlink" title="方式一、数据库级别（不建议）"></a>方式一、数据库级别（不建议）</h4><p>在数据库种添加字段gmt_create、gmt_modified，然后在pojo类中添加这两个属性，下次就可以查看了.(博主使用的是Navigat)<br><img src="https://i.p04e.com/baid/i/2023/01/06/kxnm.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private Data gmtCreate;</span><br><span class="line">private Data gmtModified;</span><br></pre></td></tr></table></figure>
<h4 id="方式二、代码级别"><a href="#方式二、代码级别" class="headerlink" title="方式二、代码级别"></a>方式二、代码级别</h4><p>1、在数据库中删除掉根据当前时间戳更新的选项</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/06/438ai.png"></p>
<p>2、在实体类的成员变量上添加注解<code>@TableField</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//字段添加填充内容</span><br><span class="line">@TableField(fill = FieldFill.INSERT ,value = &quot;create_time&quot;)</span><br><span class="line">private LocalDateTime createTime;</span><br><span class="line">@TableField(fill = FieldFill.INSERT_UPDATE ,value = &quot;update_time&quot;)</span><br><span class="line">private LocalDateTime updateTime;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>3、编写处理器来处理这个注解</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Slf4j //日志</span><br><span class="line">@Component//以组件的形式把这个处理器注册到IOC容器中</span><br><span class="line">public class MyMetaObjectHandler implements MetaObjectHandler &#123;</span><br><span class="line"></span><br><span class="line">    //插入时启动  第三个参数 LocalDateTime 一定要和 createTime成员变量的值的类型一致，不然是null 如果是date就都设置date</span><br><span class="line">    @Override</span><br><span class="line">    public void insertFill(MetaObject metaObject) &#123;</span><br><span class="line">        log.info(&quot;start insert fill ....&quot;);</span><br><span class="line">        this.strictInsertFill(metaObject, &quot;createTime&quot;, LocalDateTime.class, LocalDateTime.now()); // 起始版本 3.3.0(推荐使用)</span><br><span class="line">        this.strictUpdateFill(metaObject, &quot;updateTime&quot;, LocalDateTime.class, LocalDateTime.now()); // 起始版本 3.3.0(推荐)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //更新时候启动</span><br><span class="line">    @Override</span><br><span class="line">    public void updateFill(MetaObject metaObject) &#123;</span><br><span class="line">        log.info(&quot;start update fill ....&quot;);</span><br><span class="line">        this.strictUpdateFill(metaObject, &quot;updateTime&quot;, LocalDateTime.class, LocalDateTime.now()); // 起始版本 3.3.0(推荐)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>接下来的代码执行插入、更新时都会自动设置时间了</p>
<h1 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h1><h3 id="乐观锁原理"><a href="#乐观锁原理" class="headerlink" title="乐观锁原理"></a>乐观锁原理</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当要更新一条记录的时候，希望这条记录没有被别人更新</span><br><span class="line"></span><br><span class="line">乐观锁实现方式：</span><br><span class="line"></span><br><span class="line">取出记录时，获取当前version</span><br><span class="line">更新时，带上这个version</span><br><span class="line">执行更新时， set version = newVersion where version = oldVersion</span><br><span class="line">如果version不对，就更新失败</span><br></pre></td></tr></table></figure>
<p>相当于给每一个记录都加一个version字段。当我们要改记录时，把version字段拿出来看一看，对比一下这个version 有没有在你操作数据时被其他线程更改，如果依然等于oldVersion，你就对数据进行操作同时把 version = newVersion 更新（比如+1），以此你在改数据的途中告诉其他线程不要读了脏数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--A 线程</span><br><span class="line">update user set name = &quot;jdw&quot; ,version = version + 1   --version = newVersion  version有默认值比如1 </span><br><span class="line">where id = 2 and version = 1  -- version = oldVersion</span><br><span class="line">--B 线程 抢先完成，此时version=2,导致A线程的  version = oldVersion 不匹配A的oldVersion A将会修改失败,防止数据库产生脏数据</span><br><span class="line">update user set name = &quot;jdw&quot; ,version = version + 1   --version = newVersion  version有默认值比如1 </span><br><span class="line">where id = 2 and version = 1  -- version = oldVersion</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="乐观锁的应用"><a href="#乐观锁的应用" class="headerlink" title="乐观锁的应用"></a>乐观锁的应用</h3><h4 id="测试更新"><a href="#测试更新" class="headerlink" title="测试更新"></a>测试更新</h4><p>1、在数据库添加version字段，int型,默认0,长度10,不自增</p>
<p>2、在User类中添加对应属性：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Version //乐观锁注解</span><br><span class="line">private int version;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">说明: Version</span><br><span class="line"></span><br><span class="line">支持的数据类型只有:int,Integer,long,Long,Date,Timestamp,LocalDateTime</span><br><span class="line">整数类型下 newVersion = oldVersion + 1</span><br><span class="line">newVersion 会回写到 entity 中</span><br><span class="line">仅支持 updateById(id) 与 update(entity, wrapper) 方法</span><br><span class="line">在 update(entity, wrapper) 方法下, wrapper 不能复用!!!</span><br></pre></td></tr></table></figure>
<p>3、在config下注册组件，开启乐观锁拦截器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@EnableTransactionManagement  //开启事务</span><br><span class="line">@Configuration  //配置类注解</span><br><span class="line">public class MybatisPlusConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public MybatisPlusInterceptor mybatisPlusInterceptor() &#123;</span><br><span class="line">        MybatisPlusInterceptor mybatisPlusInterceptor = new MybatisPlusInterceptor();</span><br><span class="line">        mybatisPlusInterceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor());//乐观锁插件拦截器OptimisticLockerInnerInterceptor</span><br><span class="line">        return mybatisPlusInterceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>4.测试乐观锁</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testOptimisticLocker()&#123;</span><br><span class="line">    //1、查询用户信息</span><br><span class="line">    User user = userMapper.selectById(1L);</span><br><span class="line">    //2、修改用户信息</span><br><span class="line">    user.setEmail(&quot;123@qq.com&quot;);</span><br><span class="line">    user.setName(&quot;小&quot;);</span><br><span class="line">    //3、更新操作</span><br><span class="line">    userMapper.updateById(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在测试代码中我们并没有更新version数据库的version已经变成2了</p>
<p>5.模拟多线程下乐观锁失败案例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">   public void testOptimisticLocker2()&#123;</span><br><span class="line">       //模拟多线程</span><br><span class="line">       User user = userMapper.selectById(3L);</span><br><span class="line">       user.setEmail(&quot;123jdw@qq.com&quot;);</span><br><span class="line">       user.setName(&quot;帅小伙111&quot;);//我们在这里对线程1修改值</span><br><span class="line"></span><br><span class="line">       //线程2插队</span><br><span class="line">       User user2 = userMapper.selectById(3L);</span><br><span class="line">       user2.setEmail(&quot;321jdw@qq.com&quot;);</span><br><span class="line">       user2.setName(&quot;帅小伙222&quot;);</span><br><span class="line">       userMapper.updateById(user2); //线程2抢先提交</span><br><span class="line"></span><br><span class="line">       userMapper.updateById(user);//线程1失败，乐观锁在这种情况下防止了脏数据存在，没有乐观锁就会有覆盖掉线程2的操作</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="测试查询"><a href="#测试查询" class="headerlink" title="测试查询"></a>测试查询</h4><p>1、查询单用户</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//查询单用户</span><br><span class="line">@Test</span><br><span class="line">public void testSelectBatchId()&#123;</span><br><span class="line">    User user = userMapper.selectById(1L);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>2、多用户查询</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//查询指定多用户</span><br><span class="line">@Test</span><br><span class="line">public void testSelectBatchIds() &#123;</span><br><span class="line">    //Arrays.asList()创建了一个固定大小的集合   </span><br><span class="line">    List&lt;User&gt; users = userMapper.selectBatchIds(Arrays.asList(1, 2, 3));//参数Collection的集合</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//  selectBatchIds 源码</span><br><span class="line">/**</span><br><span class="line"> * 查询（根据ID 批量查询）</span><br><span class="line"> *</span><br><span class="line"> * @param idList 主键ID列表(不能为 null 以及 empty)</span><br><span class="line"> */</span><br><span class="line">List&lt;T&gt; selectBatchIds(@Param(Constants.COLLECTION) Collection&lt;? extends Serializable&gt; idList);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>日志分析：内部解析的是一个 IN 条件</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/06/tfyee.png"></p>
<p>3、条件查询</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//条件查询，-- HashMap</span><br><span class="line">@Test</span><br><span class="line">public void testSelectByMap() &#123;</span><br><span class="line">    HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">    //定义查询条件</span><br><span class="line">    map.put(&quot;name&quot;, &quot;小蒋&quot;); //where k = v</span><br><span class="line">    map.put(&quot;age&quot;,3);</span><br><span class="line">    List&lt;User&gt; users = userMapper.selectByMap(map);</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>日志分析</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/06/tl57e.png"></p>
<h1 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h1><p>1、配置拦截器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MybatisPlusConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public MybatisPlusInterceptor mybatisPlusInterceptor() &#123;</span><br><span class="line">        MybatisPlusInterceptor mybatisPlusInterceptor = new MybatisPlusInterceptor();</span><br><span class="line">        mybatisPlusInterceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor());//创建乐观锁拦截器 OptimisticLockerInnerInterceptor</span><br><span class="line">        mybatisPlusInterceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL)); //插件分页拦截器，我的是mysql</span><br><span class="line">        return mybatisPlusInterceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>2、使用page对象即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//测试分页查询</span><br><span class="line">@Test</span><br><span class="line">public void testPage() &#123;</span><br><span class="line">    Page&lt;User&gt; page = new Page&lt;&gt;(1,5); //开启拦截器后，会注册一个page对象  当前页，每页条数</span><br><span class="line">    //方法源码：   &lt;P extends IPage&lt;T&gt;&gt; P selectPage(P page, @Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);</span><br><span class="line">    userMapper.selectPage(page,null); //分页查询</span><br><span class="line">    page.getRecords().forEach(System.out::println); //获取分页后的数据 打印</span><br><span class="line">    System.out.println(page.getTotal()); //获取记录总数</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**源码</span><br><span class="line"> * 分页构造函数</span><br><span class="line"> *</span><br><span class="line"> * @param current 当前页</span><br><span class="line"> * @param size    每页显示条数</span><br><span class="line"> */</span><br><span class="line">public Page(long current, long size) &#123;</span><br><span class="line">    this(current, size, 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="删除测试"><a href="#删除测试" class="headerlink" title="删除测试"></a>删除测试</h1><h3 id="常见删除"><a href="#常见删除" class="headerlink" title="常见删除"></a>常见删除</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//删除测试</span><br><span class="line">@Test</span><br><span class="line">public void testDeleteById()&#123;</span><br><span class="line">    userMapper.deleteById(1453324799370616833L);</span><br><span class="line">	// userMapper.delete(null); //全部删除</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从上往下分别是：根据id删除，根据 entity 条件删除记录，通过多个id批量删除，根据map条件删除</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/06/491ek.png"></p>
<h3 id="逻辑删除"><a href="#逻辑删除" class="headerlink" title="逻辑删除"></a>逻辑删除</h3><p>物理删除：在数据库中移除</p>
<p>逻辑删除：数据库中没有移除，而是在代码中使用一个变量来使他失效！(如：delete = 0 =&gt; delete = 1; )</p>
<p>就比如，管理员可以查看被删除的记录！防止数据丢失。类似于回收站。用户就没法查看删除记录。</p>
<p>1、在数据库添加deleted字段</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/06/49poj.png"></p>
<p>2、同步实体类中，同时添加<code>@TableLogic//逻辑删除</code>注解</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@TableLogic//逻辑删除</span><br><span class="line">private Integer deleted;</span><br></pre></td></tr></table></figure>
<p>3、在配置文件yml中配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mybatis-plus:</span><br><span class="line">  global-config:</span><br><span class="line">    db-config:</span><br><span class="line">      logic-delete-field: flag  # 全局逻辑删除的实体字段名(since 3.3.0,配置后可以不加步骤2的注解)</span><br><span class="line">      logic-delete-value: 1 # 逻辑已删除值(默认为 1)</span><br><span class="line">      logic-not-delete-value: 0 # 逻辑未删除值(默认为 0)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>4、测试删除</p>
<p>执行删除操作，实际上是执行更新操作，把deleted字段改为1了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    @Test</span><br><span class="line">public void testDeleteById()&#123;</span><br><span class="line">    userMapper.deleteById(1L);</span><br><span class="line">	// userMapper.delete(null); //全部删除</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://i.p04e.com/baid/i/2023/01/06/48zas.png"></p>
<p>数据库中也是没被删，改了值而已</p>
<p>如果我们再去查询这个id=1的用户发现，查不到，mybatis-plus 自动拼接了deleted字段在where中判断。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testSelectBatchId() &#123;</span><br><span class="line">    User user = userMapper.selectById(1L);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://i.p04e.com/baid/i/2023/01/06/twyz6.png"></p>
<p>性能分析插件<br>官方使用的p6spy性能有损耗，推荐使用其他第三方性能分析插件，比如阿里巴巴的Druid。</p>
<p>条件构造器Wrapper（重点）<br>之前我们写crud时候经常碰到一个参数叫做wrapper，我们写的都是null，他到底是什么。</p>
<p>官方链接，条件构造器</p>
<p>我们之前一直是增删改查，没有一个是带条件的，而这个条件构造器就相当于sql中加了一个where,</p>
<p>QueryWrapper和 UpdateWrapper,分别是用于生成查和改 的 sql 的 where 条件</p>
<p>例如, 查询多条记录与单条记录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   @Test</span><br><span class="line">   void contextLoads() &#123;</span><br><span class="line">       //----------查询多个</span><br><span class="line">       //查询一个复杂的，比如查询用户name、邮箱不为空，年龄大于20的用户</span><br><span class="line">       QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;(); //首先新建一个 QueryWrapper</span><br><span class="line">       //链式编程 添加查询条件</span><br><span class="line">       wrapper.isNotNull(&quot;name&quot;)</span><br><span class="line">               .eq(&quot;email&quot;,&quot;2455555659@qq.com&quot;)</span><br><span class="line">               .ge(&quot;age&quot;,12);  </span><br><span class="line">       userMapper.selectList(wrapper).forEach(System.out::println); </span><br><span class="line">	//----------查询单个</span><br><span class="line">       User user = userMapper.selectOne(wrapper); //出现多个结果会报错，查询一个</span><br><span class="line">       System.out.println(&quot;user = &quot; + user);</span><br><span class="line">   &#125;</span><br><span class="line">//        eq相等   ne不相等，   gt大于，    lt小于         ge大于等于       le 小于等于</span><br><span class="line">//        equal/ not equal/ greater than/ less than/ less than or equal/ great than or equal/</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>日志分析，就是在where中添加了多个条件</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/06/m1z7.png"></p>
<p>区间查询与计数，between()，selectCount()</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">void test2() &#123;</span><br><span class="line">    //查询区间内的记录</span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;();</span><br><span class="line">    wrapper.between(&quot;age&quot;,20,30);</span><br><span class="line">    Integer count = userMapper.selectCount(wrapper);</span><br><span class="line">    System.out.println(&quot;count = &quot; + count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">void test3() &#123;</span><br><span class="line">    //模糊查询</span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;();</span><br><span class="line">    wrapper.like(&quot;name&quot;,99)         //  名字中 存在 99</span><br><span class="line">            .notLike(&quot;name&quot;,6)      //  名字中 不存在 6</span><br><span class="line">            .likeRight(&quot;email&quot;,2)   //  邮箱 最右边是m  %m</span><br><span class="line">            .likeLeft(&quot;email&quot;,&quot;m&quot;); //  邮箱 最左边是2  2%</span><br><span class="line">    userMapper.selectMaps(wrapper);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://i.p04e.com/baid/i/2023/01/06/u3nbr.png"></p>
<p>子查询（多表查询）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void test4() &#123;</span><br><span class="line">    //子查询</span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;();</span><br><span class="line">    wrapper.inSql(&quot;id&quot;,&quot;select id from table where id &lt;2&quot;);</span><br><span class="line">    userMapper.selectObjs(wrapper).forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://i.p04e.com/baid/i/2023/01/06/m70o.png"></p>
<p>排序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">void test5() &#123;</span><br><span class="line">    //排序 </span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;();</span><br><span class="line">    wrapper.orderByAsc(&quot;id&quot;);  //根据id升序排列   降序orderByDesc()略</span><br><span class="line">    userMapper.selectList(wrapper).forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://i.p04e.com/baid/i/2023/01/06/4bnd9.png"></p>
<p>分组，条件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">void test7() &#123;</span><br><span class="line">    //分组排序</span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;();</span><br><span class="line">    wrapper.groupBy(&quot;version&quot;).having(&quot;version = 1&quot;);</span><br><span class="line">    userMapper.selectList(wrapper).forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://i.p04e.com/baid/i/2023/01/06/4c1xj.png"></p>
<h1 id="代码自动生成器（重点）"><a href="#代码自动生成器（重点）" class="headerlink" title="代码自动生成器（重点）"></a>代码自动生成器（重点）</h1><p>AutoGenerator 是 MyBatis-Plus 的代码生成器，通过 AutoGenerator 可以快速生成 Entity、Mapper、Mapper XML、Service、Controller 等各个模块的代码，极大的提升了开发效率。</p>
<p><strong>使用步骤</strong></p>
<p><strong>配置依赖，添加如下依赖</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- mp 代码生成器 依赖 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;com.baomidou&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;3.4.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- 导入swagger --&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;io.swagger&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;swagger-annotations&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;1.5.20&lt;/version&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">&lt;!-- 添加模板引擎，thymeleaf 还有freemarker都是模板引擎 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在任意文件夹新建立一个类进行配置</p>
<p>类的代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.jdw;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.annotation.DbType;</span><br><span class="line">import com.baomidou.mybatisplus.annotation.FieldFill;</span><br><span class="line">import com.baomidou.mybatisplus.annotation.IdType;</span><br><span class="line">import com.baomidou.mybatisplus.core.exceptions.MybatisPlusException;</span><br><span class="line">import com.baomidou.mybatisplus.core.toolkit.StringPool;</span><br><span class="line">import com.baomidou.mybatisplus.core.toolkit.StringUtils;</span><br><span class="line">import com.baomidou.mybatisplus.generator.AutoGenerator;</span><br><span class="line">import com.baomidou.mybatisplus.generator.InjectionConfig;</span><br><span class="line">import com.baomidou.mybatisplus.generator.config.*;</span><br><span class="line">import com.baomidou.mybatisplus.generator.config.po.TableFill;</span><br><span class="line">import com.baomidou.mybatisplus.generator.config.po.TableInfo;</span><br><span class="line">import com.baomidou.mybatisplus.generator.config.rules.DateType;</span><br><span class="line">import com.baomidou.mybatisplus.generator.config.rules.NamingStrategy;</span><br><span class="line">import com.baomidou.mybatisplus.generator.engine.FreemarkerTemplateEngine;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">// 演示例子，执行 main 方法控制台输入模块表名回车自动生成对应项目目录中</span><br><span class="line">public class CodeGenerator &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * 读取控制台内容</span><br><span class="line">     * &lt;/p&gt;</span><br><span class="line">     */</span><br><span class="line">    public static String scanner(String tip) &#123;</span><br><span class="line">        Scanner scanner = new Scanner(System.in);</span><br><span class="line">        StringBuilder help = new StringBuilder();</span><br><span class="line">        help.append(&quot;请输入&quot; + tip + &quot;：&quot;);</span><br><span class="line">        System.out.println(help.toString());</span><br><span class="line">        if (scanner.hasNext()) &#123;</span><br><span class="line">            String ipt = scanner.next();</span><br><span class="line">            if (StringUtils.isNotBlank(ipt)) &#123;</span><br><span class="line">                return ipt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        throw new MybatisPlusException(&quot;请输入正确的&quot; + tip + &quot;！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 代码生成器</span><br><span class="line">        //构建一个代码自动生成器对象</span><br><span class="line">        AutoGenerator mpg = new AutoGenerator();</span><br><span class="line"></span><br><span class="line">        // 1、创建全局配置类的对象</span><br><span class="line">        GlobalConfig gc = new GlobalConfig();</span><br><span class="line">        //获取当前项目路径</span><br><span class="line">        String projectPath = System.getProperty(&quot;user.dir&quot;);</span><br><span class="line">        System.out.println(&quot;projectPath = &quot; + projectPath);</span><br><span class="line">        //自动生成代码存放的路径</span><br><span class="line">        gc.setOutputDir(projectPath + &quot;/src/main/java&quot;);</span><br><span class="line">        //设置 --作者注释</span><br><span class="line">        gc.setAuthor(&quot;jdw&quot;);</span><br><span class="line">        //是否打开文件夹</span><br><span class="line">        gc.setOpen(false);</span><br><span class="line">        //是否覆盖已有文件</span><br><span class="line">        gc.setFileOverride(false);</span><br><span class="line">        //各层文件名称方式，例如： %sAction 生成 UserAction  %s占位符</span><br><span class="line">        gc.setServiceName(&quot;%sService&quot;);</span><br><span class="line">        //设置日期策略  date类型</span><br><span class="line">        gc.setDateType(DateType.ONLY_DATE);</span><br><span class="line">        //设置主键策略 雪花算法</span><br><span class="line">        gc.setIdType(IdType.ASSIGN_ID);</span><br><span class="line">        //设置开启 swagger2 模式</span><br><span class="line">        gc.setSwagger2(true);</span><br><span class="line">        //把全局配置放入代码生成器</span><br><span class="line">        mpg.setGlobalConfig(gc);</span><br><span class="line"></span><br><span class="line">        // 2、数据源配置</span><br><span class="line">        DataSourceConfig dsc = new DataSourceConfig();</span><br><span class="line">        dsc.setUrl(&quot;jdbc:mysql://localhost:3306/vueblog?useUnicode=true&amp;useSSL=false&amp;characterEncoding=utf8&amp;serverTimezone=Asia/Shanghai&quot;);</span><br><span class="line">        dsc.setDriverName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><span class="line">        dsc.setUsername(&quot;root&quot;);</span><br><span class="line">        dsc.setPassword(&quot;123456&quot;);</span><br><span class="line">        dsc.setDbType(DbType.MYSQL);</span><br><span class="line">        mpg.setDataSource(dsc); //把数据源配置加入到代码生成器</span><br><span class="line"></span><br><span class="line">        // 3、包配置</span><br><span class="line">        PackageConfig pc = new PackageConfig();</span><br><span class="line">        pc.setParent(&quot;com.jdw&quot;);</span><br><span class="line">        pc.setEntity(&quot;entity&quot;);</span><br><span class="line">        pc.setMapper(&quot;mapper&quot;);</span><br><span class="line">        pc.setService(&quot;service&quot;);</span><br><span class="line">        pc.setController(&quot;controller&quot;);</span><br><span class="line">        // ...  有默认值，点击查看源码</span><br><span class="line">        mpg.setPackageInfo(pc);//包加入代码生成器</span><br><span class="line"></span><br><span class="line">        // 4、策略配置</span><br><span class="line">        StrategyConfig strategy = new StrategyConfig();</span><br><span class="line">        //下划线转驼峰命名  表</span><br><span class="line">        strategy.setNaming(NamingStrategy.underline_to_camel);</span><br><span class="line">        // 下划线转驼峰命名字段</span><br><span class="line">        strategy.setColumnNaming(NamingStrategy.underline_to_camel);</span><br><span class="line">        //实体类是否加上lombok注解</span><br><span class="line">        strategy.setEntityLombokModel(true);</span><br><span class="line">        //控制层采用RestControllerStyle注解</span><br><span class="line">        strategy.setRestControllerStyle(true);</span><br><span class="line">        // RequestMapping中 驼峰转连字符 -</span><br><span class="line">        strategy.setControllerMappingHyphenStyle(true);</span><br><span class="line">        //要映射的数据库表名  （重点）</span><br><span class="line">        strategy.setInclude(scanner(&quot;表名，多个英文逗号分割&quot;).split(&quot;,&quot;));</span><br><span class="line">        //添加表名前缀</span><br><span class="line">        //strategy.setTablePrefix(&quot;m_&quot;); //自动拼接上m_</span><br><span class="line">        //逻辑删除字段名</span><br><span class="line">        strategy.setLogicDeleteFieldName(&quot;deleted&quot;);</span><br><span class="line">        //乐观锁字段名</span><br><span class="line">        strategy.setVersionFieldName(&quot;version&quot;);</span><br><span class="line">        // -------自动填充策略</span><br><span class="line">        ArrayList&lt;TableFill&gt; fillList = new ArrayList&lt;&gt;();</span><br><span class="line">        fillList.add(new TableFill(&quot;createTime&quot;, FieldFill.INSERT));</span><br><span class="line">        fillList.add(new TableFill(&quot;updateTime&quot;,FieldFill.INSERT_UPDATE));</span><br><span class="line">        // 参数是 List&lt;TableFill&gt; 的链表</span><br><span class="line">        strategy.setTableFillList(fillList);</span><br><span class="line">        mpg.setStrategy(strategy);</span><br><span class="line"></span><br><span class="line">        //---------------------------------</span><br><span class="line">        // 自定义配置</span><br><span class="line">        InjectionConfig cfg = new InjectionConfig() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void initMap() &#123;</span><br><span class="line">                // to do nothing</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        // 如果模板引擎是 freemarker</span><br><span class="line">        String templatePath = &quot;/templates/mapper.xml.ftl&quot;;</span><br><span class="line">        // 如果模板引擎是 velocity</span><br><span class="line">        // String templatePath = &quot;/templates/mapper.xml.vm&quot;;</span><br><span class="line"></span><br><span class="line">        // 自定义输出配置</span><br><span class="line">        List&lt;FileOutConfig&gt; focList = new ArrayList&lt;&gt;();</span><br><span class="line">        // 自定义配置会被优先输出</span><br><span class="line">        focList.add(new FileOutConfig(templatePath) &#123;</span><br><span class="line">            @Override </span><br><span class="line">            //输出了 静态资源下的 Mapper</span><br><span class="line">            public String outputFile(TableInfo tableInfo) &#123;</span><br><span class="line">                // 自定义输出文件名 ， 如果你 Entity 设置了前后缀、此处注意 xml 的名称会跟着发生变化！！</span><br><span class="line">                return projectPath + &quot;/src/main/resources/mapper/&quot; + pc.getModuleName()</span><br><span class="line">                        + &quot;/&quot; + tableInfo.getEntityName() + &quot;Mapper&quot; + StringPool.DOT_XML;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        cfg.setFileOutConfigList(focList);</span><br><span class="line">        mpg.setCfg(cfg);</span><br><span class="line"></span><br><span class="line">        //        FreemarkerTemplateEngine模板引擎</span><br><span class="line">        mpg.setTemplateEngine(new FreemarkerTemplateEngine());</span><br><span class="line">        mpg.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Mybatis-Plus</tag>
        <tag>乐观锁</tag>
        <tag>CRUD</tag>
        <tag>代码生成器</tag>
      </tags>
  </entry>
  <entry>
    <title>API接口文档利器：Swagger,Postman</title>
    <url>/2023/01/06/API%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3%E5%88%A9%E5%99%A8%EF%BC%9ASwagger-Postman/</url>
    <content><![CDATA[<h2 id="API接口文档利器：Swagger"><a href="#API接口文档利器：Swagger" class="headerlink" title="API接口文档利器：Swagger"></a><strong>API</strong>接口文档利器：Swagger</h2><h3 id="Swagger介绍"><a href="#Swagger介绍" class="headerlink" title="Swagger介绍"></a><strong>Swagger</strong>介绍</h3><p>Swagger 是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务</p>
<p>(<a href="https://swagger.io/">https://swagger.io/</a>)。 它的主要作用是：<span id="more"></span></p>
<ol>
<li><p>使得前后端分离开发更加方便，有利于团队协作</p>
</li>
<li><p>接口的文档在线自动生成，降低后端开发人员编写接口文档的负担</p>
</li>
<li><p>功能测试</p>
</li>
</ol>
<p>Spring已经将Swagger纳入自身的标准，建立了Spring-swagger项目，现在叫Springfox。通过在项目中引入Springfox ，即可非常简单快捷的使用Swagger。</p>
<h3 id="SpringBoot集成Swagger"><a href="#SpringBoot集成Swagger" class="headerlink" title="SpringBoot集成Swagger"></a><strong>SpringBoot</strong>集成Swagger</h3><p>项目中添加依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!‐‐ Swagger依赖 ‐‐&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;springfox‐swagger2&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;springfox‐swagger‐ui&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>工程的conﬁg包中添加一个Swagger配置类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.shanjupay.merchant.config;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty; import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration; import springfox.documentation.builders.ApiInfoBuilder; import springfox.documentation.builders.PathSelectors;</span><br><span class="line">import springfox.documentation.builders.RequestHandlerSelectors; import springfox.documentation.service.ApiInfo;</span><br><span class="line">import springfox.documentation.service.Contact; import springfox.documentation.spi.DocumentationType;</span><br><span class="line">import springfox.documentation.spring.web.plugins.Docket;</span><br><span class="line">import springfox.documentation.swagger2.annotations.EnableSwagger2;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">@ConditionalOnProperty(prefix = &quot;swagger&quot;,value = &#123;&quot;enable&quot;&#125;,havingValue = &quot;true&quot;) @EnableSwagger2</span><br><span class="line">public class SwaggerConfiguration &#123;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public Docket buildDocket() &#123;</span><br><span class="line">return new Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">.apiInfo(buildApiInfo())</span><br><span class="line">.select()</span><br><span class="line">// 要扫描的API(Controller)基础包</span><br><span class="line"></span><br><span class="line">.apis(RequestHandlerSelectors.basePackage(&quot;com.shanjupay.merchant.controller&quot;))</span><br><span class="line">.paths(PathSelectors.any())</span><br><span class="line">.build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">*@param</span><br><span class="line"></span><br><span class="line">*@return springfox.documentation.service.ApiInfo</span><br><span class="line">*@Title: 构建API基本信息</span><br><span class="line">*@methodName: buildApiInfo</span><br><span class="line">*/</span><br><span class="line">private ApiInfo buildApiInfo() &#123;</span><br><span class="line">Contact contact = new Contact(&quot;开发者&quot;,&quot;&quot;,&quot;&quot;); return new ApiInfoBuilder()</span><br><span class="line">.title(&quot;闪聚支付‐商户应用API文档&quot;)</span><br><span class="line">.description(&quot;&quot;)</span><br><span class="line">.contact(contact)</span><br><span class="line">.version(&quot;1.0.0&quot;).build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加SpringMVC配置类：WebMvcConﬁg，让外部可直接访问Swagger文档</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.shanjupay.merchant.config;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line">import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry; import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">public class WebMvcConfig implements WebMvcConfigurer &#123;</span><br><span class="line">/**</span><br><span class="line">*添加静态资源文件，外部可以直接访问地址</span><br><span class="line">*</span><br><span class="line">*@param registry</span><br><span class="line">*/ @Override</span><br><span class="line">public void addResourceHandlers(ResourceHandlerRegistry registry) &#123; registry.addResourceHandler(&quot;/**&quot;).addResourceLocations(&quot;classpath:/static/&quot;);</span><br><span class="line"></span><br><span class="line">registry.addResourceHandler(&quot;swagger‐ui.html&quot;)</span><br><span class="line">.addResourceLocations(&quot;classpath:/META‐INF/resources/&quot;);</span><br><span class="line"></span><br><span class="line">registry.addResourceHandler(&quot;/webjars/**&quot;)</span><br><span class="line">.addResourceLocations(&quot;classpath:/META‐INF/resources/webjars/&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Swagger常用注解"><a href="#Swagger常用注解" class="headerlink" title="Swagger常用注解"></a><strong>Swagger</strong>常用注解</h3><p>在Java类中添加Swagger的注解即可生成Swagger接口文档，常用Swagger注解如下：</p>
<p>@Api：修饰整个类，描述Controller的作用 @ApiOperation：描述一个类的一个方法，或者说一个接口@ApiParam：单个参数的描述信息</p>
<p>@ApiModel：用对象来接收参数</p>
<p>@ApiModelProperty：用对象接收参数时，描述对象的一个字段@ApiResponse：HTTP响应其中1个描述</p>
<p>在Java类中添加Swagger的注解即可生成Swagger接口文档，常用Swagger注解如下：</p>
<p>@Api：修饰整个类，描述Controller的作用 @ApiOperation：描述一个类的一个方法，或者说一个接口@ApiParam：单个参数的描述信息</p>
<p>@ApiModel：用对象来接收参数</p>
<p>@ApiModelProperty：用对象接收参数时，描述对象的一个字段@ApiResponse：HTTP响应其中1个描述</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>属性</strong></th>
<th><strong>取值</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>paramType</td>
<td></td>
<td>查询参数类型</td>
</tr>
<tr>
<td></td>
<td>path</td>
<td>以地址的形式提交数据</td>
</tr>
<tr>
<td></td>
<td>query</td>
<td>直接跟参数完成自动映射赋值</td>
</tr>
<tr>
<td></td>
<td>body</td>
<td>以流的形式提交 仅支持POST</td>
</tr>
<tr>
<td></td>
<td>header</td>
<td>参数在request headers 里边提交</td>
</tr>
<tr>
<td></td>
<td>form</td>
<td>以form表单的形式提交 仅支持POST</td>
</tr>
<tr>
<td>dataType</td>
<td></td>
<td>参数的数据类型 只作为标志说明，并没有实际验证</td>
</tr>
<tr>
<td></td>
<td>Long</td>
<td></td>
</tr>
<tr>
<td></td>
<td>String</td>
<td></td>
</tr>
<tr>
<td>name</td>
<td></td>
<td>接收参数名</td>
</tr>
<tr>
<td>value</td>
<td></td>
<td>接收参数的意义描述</td>
</tr>
<tr>
<td>required</td>
<td></td>
<td>参数是否必填</td>
</tr>
<tr>
<td></td>
<td>true</td>
<td>必填</td>
</tr>
<tr>
<td></td>
<td>false</td>
<td>非必填</td>
</tr>
<tr>
<td>defaultValue</td>
<td></td>
<td>默认值</td>
</tr>
</tbody>
</table>
</div>
<p>上边的属性后边编写程序时用到哪个我再详细讲解，下边写一个swagger的简单例子，我们在MerchantController   中添加Swagger注解，代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Api(value = &quot;商户平台‐商户相关&quot;, tags = &quot;商户平台‐商户相关&quot;, description = &quot;商户平台‐商户相关&quot;) @RestController</span><br><span class="line">public class MerchantController &#123;</span><br><span class="line"></span><br><span class="line">@Reference</span><br><span class="line">private MerchantService merchantService;</span><br></pre></td></tr></table></figure>
<p>Swagger生成API文档的工作原理：</p>
<p>1、shanjupay-merchant-application启动时会扫描到SwaggerConﬁguration类</p>
<p>2、在此类中指定了扫描包路径com.shanjupay.merchant.controller，会找到在此包下及子包下标记有@RestController注解的controller类</p>
<p>3、根据controller类中的Swagger注解生成API文档</p>
<h2 id="接口调试利器Postman"><a href="#接口调试利器Postman" class="headerlink" title="接口调试利器Postman"></a><strong>接口调试利器</strong>Postman</h2><p>Postman是一款功能强大的http接口测试工具，使用Postman可以完成http各种请求的功能测试。作为服务器端   开发人员，当一个业务功能开发完毕后，应该用Postman进行功能测试。</p>
<p>1、请自行在本机安装Postman</p>
<p>2、新建集合(建议一个微服务新建一个对应的集合)：商户应用</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/06/4nrlz.png"><br><img src="https://i.p04e.com/baid/i/2023/01/06/nysy.png"></p>
<p>填写新建商户接口地址和请求类型后，点击Send发送请求</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/06/6cromn.png"></p>
]]></content>
      <tags>
        <tag>Swagger</tag>
        <tag>Postman</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot系列：运行原理</title>
    <url>/2023/01/09/SpringBoot%E7%B3%BB%E5%88%97%EF%BC%9A%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>《SpringBoot系列部分摘于网络，仅供个人笔记学习使用》</p>
<h2 id="运行原理："><a href="#运行原理：" class="headerlink" title="运行原理："></a>运行原理：</h2><p>一个普通的HelloSpringBoot，是怎么运行的呢？</p>
<span id="more"></span>
<h3 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h3><p>父依赖</p>
<p>依赖于父项目，管理项目的资源过滤及插件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.2.5.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">&lt;/parent&gt;</span><br></pre></td></tr></table></figure>
<p>点进去，发现还有一个父依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.2.5.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;relativePath&gt;../../spring-boot-dependencies&lt;/relativePath&gt;</span><br><span class="line">&lt;/parent&gt;</span><br></pre></td></tr></table></figure>
<p>这是真正管理SpringBoot应用里面所有依赖版本的地方，SpringBoot的版本控制中心；</p>
<p><strong>以后我们导入依赖默认是不需要写版本；</strong></p>
<p><strong>但如果导入的包没有在依赖中管理着就需要手动配置版本了；</strong></p>
<h2 id="启动器-spring-boot-starter"><a href="#启动器-spring-boot-starter" class="headerlink" title="启动器 spring-boot-starter"></a>启动器 spring-boot-starter</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p><strong>springboot-boot-starter-xxx</strong>：就是spring-boot的场景启动器</p>
<p><strong>spring-boot-starter-web</strong>：帮我们导入了web模块正常运行所依赖的组件；</p>
<p>SpringBoot将所有的功能场景都抽取出来，做成一个个的starter （启动器），只需要在项目中引入这些starter即可，所有相关的依赖都会导入进来 ， 我们要用什么功能就导入什么样的场景启动器即可 ；我们未来也可以自己自定义 starter；</p>
<h2 id="主启动类"><a href="#主启动类" class="headerlink" title="主启动类"></a><strong>主启动类</strong></h2><p>分析完了 pom.xml 来看看这个启动类</p>
<h3 id="默认的主启动类"><a href="#默认的主启动类" class="headerlink" title="默认的主启动类"></a>默认的主启动类</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/@SpringBootApplication 来标注一个主程序类</span><br><span class="line">//说明这是一个Spring Boot应用</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class SpringbootApplication &#123;</span><br><span class="line"></span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">     //以为是启动了一个方法，没想到启动了一个服务</span><br><span class="line">      SpringApplication.run(SpringbootApplication.class, args);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是<strong>一个简单的启动类并不简单！</strong>我们来分析一下这些注解都干了什么</p>
<h3 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h3><p>作用：标注在某个类上说明这个类是SpringBoot的主配置类 ， SpringBoot就应该运行这个类的main方法来启动SpringBoot应用；</p>
<p>进入这个注解：可以看到上面还有很多其他注解！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SpringBootConfiguration</span><br><span class="line">@EnableAutoConfiguration</span><br><span class="line">@ComponentScan(</span><br><span class="line">    excludeFilters = &#123;@Filter(</span><br><span class="line">    type = FilterType.CUSTOM,</span><br><span class="line">    classes = &#123;TypeExcludeFilter.class&#125;</span><br><span class="line">), @Filter(</span><br><span class="line">    type = FilterType.CUSTOM,</span><br><span class="line">    classes = &#123;AutoConfigurationExcludeFilter.class&#125;</span><br><span class="line">)&#125;</span><br><span class="line">)</span><br><span class="line">public @interface SpringBootApplication &#123;</span><br><span class="line">    // ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h3><p>这个注解在Spring中很重要 ,它对应XML配置中的元素。</p>
<p>作用：自动扫描并加载符合条件的组件或者bean ， 将这个bean定义加载到IOC容器中</p>
<h3 id="SpringBootConfiguration"><a href="#SpringBootConfiguration" class="headerlink" title="@SpringBootConfiguration"></a>@SpringBootConfiguration</h3><p>作用：SpringBoot的配置类 ，标注在某个类上 ， 表示这是一个SpringBoot的配置类；</p>
<p>我们继续进去这个注解查看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">// 点进去得到下面的 @Component</span><br><span class="line">@Configuration</span><br><span class="line">public @interface SpringBootConfiguration &#123;&#125;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">public @interface Configuration &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 @Configuration，说明这是一个配置类 ，配置类就是对应Spring的xml 配置文件；</p>
<p>里面的 @Component 这就说明，启动类本身也是Spring中的一个组件而已，负责启动应用！</p>
<p>我们回到 SpringBootApplication 注解中继续看。</p>
<h3 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h3><p><strong>@EnableAutoConfiguration ：开启自动配置功能</strong></p>
<p>以前我们需要自己配置的东西，而现在SpringBoot可以自动帮我们配置 ；@EnableAutoConfiguration告诉SpringBoot开启自动配置功能，这样自动配置才能生效；</p>
<p>点进注解接续查看：</p>
<p><strong>@AutoConfigurationPackage ：自动配置包</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@Import(&#123;Registrar.class&#125;)</span><br><span class="line">public @interface AutoConfigurationPackage &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>@import</strong> ：Spring底层注解@import ， 给容器中导入一个组件</p>
<p>Registrar.class 作用：将主启动类的所在包及包下面所有子包里面的所有组件扫描到Spring容器 ；</p>
<p>这个分析完了，退到上一步，继续看</p>
<p><strong>@Import({AutoConfigurationImportSelector.class}) ：给容器导入组件 ；</strong></p>
<p>AutoConfigurationImportSelector ：自动配置导入选择器，那么它会导入哪些组件的选择器呢？我们点击去这个类看源码：</p>
<p>1、这个类中有一个这样的方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">// 获得候选的配置</span><br><span class="line">protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) &#123;</span><br><span class="line">    //这里的getSpringFactoriesLoaderFactoryClass（）方法</span><br><span class="line">    //返回的就是我们最开始看的启动自动导入配置文件的注解类；EnableAutoConfiguration</span><br><span class="line">    List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader());</span><br><span class="line">    Assert.notEmpty(configurations, &quot;No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.&quot;);</span><br><span class="line">    return configurations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、这个方法又调用了  SpringFactoriesLoader 类的静态方法！我们进入SpringFactoriesLoader类loadFactoryNames() 方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryClass, @Nullable ClassLoader classLoader) &#123;</span><br><span class="line">    String factoryClassName = factoryClass.getName();</span><br><span class="line">    //这里它又调用了 loadSpringFactories 方法</span><br><span class="line">    return (List)loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、我们继续点击查看 loadSpringFactories 方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">private static Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(@Nullable ClassLoader classLoader) &#123;</span><br><span class="line">    //获得classLoader ， 我们返回可以看到这里得到的就是EnableAutoConfiguration标注的类本身</span><br><span class="line">    MultiValueMap&lt;String, String&gt; result = (MultiValueMap)cache.get(classLoader);</span><br><span class="line">    if (result != null) &#123;</span><br><span class="line">        return result;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            //去获取一个资源 &quot;META-INF/spring.factories&quot;</span><br><span class="line">            Enumeration&lt;URL&gt; urls = classLoader != null ? classLoader.getResources(&quot;META-INF/spring.factories&quot;) : ClassLoader.getSystemResources(&quot;META-INF/spring.factories&quot;);</span><br><span class="line">            LinkedMultiValueMap result = new LinkedMultiValueMap();</span><br><span class="line"></span><br><span class="line">            //将读取到的资源遍历，封装成为一个Properties</span><br><span class="line">            while(urls.hasMoreElements()) &#123;</span><br><span class="line">                URL url = (URL)urls.nextElement();</span><br><span class="line">                UrlResource resource = new UrlResource(url);</span><br><span class="line">                Properties properties = PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line">                Iterator var6 = properties.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">                while(var6.hasNext()) &#123;</span><br><span class="line">                    Entry&lt;?, ?&gt; entry = (Entry)var6.next();</span><br><span class="line">                    String factoryClassName = ((String)entry.getKey()).trim();</span><br><span class="line">                    String[] var9 = StringUtils.commaDelimitedListToStringArray((String)entry.getValue());</span><br><span class="line">                    int var10 = var9.length;</span><br><span class="line"></span><br><span class="line">                    for(int var11 = 0; var11 &lt; var10; ++var11) &#123;</span><br><span class="line">                        String factoryName = var9[var11];</span><br><span class="line">                        result.add(factoryClassName, factoryName.trim());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            cache.put(classLoader, result);</span><br><span class="line">            return result;</span><br><span class="line">        &#125; catch (IOException var13) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;Unable to load factories from location [META-INF/spring.factories]&quot;, var13);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4、发现一个多次出现的文件：spring.factories，全局搜索它</p>
<h2 id="spring-factories"><a href="#spring-factories" class="headerlink" title="spring.factories"></a>spring.factories</h2><p>我们根据源头打开spring.factories ， 看到了很多自动配置的文件；这就是自动配置根源所在！</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/09/4309.png"></p>
<p><strong>WebMvcAutoConfiguration</strong></p>
<p>我们在上面的自动配置类随便找一个打开看看，比如 ：WebMvcAutoConfiguration</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/09/ucko.png"></p>
<p>可以看到这些一个个的都是JavaConfig配置类，而且都注入了一些Bean，可以找一些自己认识的类，看着熟悉一下！</p>
<p>所以，自动配置真正实现是从classpath中搜寻所有的META-INF/spring.factories配置文件 ，并将其中对应的 org.springframework.boot.autoconfigure. 包下的配置项，通过反射实例化为对应标注了 @Configuration的JavaConfig形式的IOC容器配置类 ， 然后将这些都汇总成为一个实例并加载到IOC容器中。</p>
<p><strong>结论：</strong></p>
<ol>
<li>SpringBoot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值</li>
<li>将这些值作为自动配置类导入容器 ， 自动配置类就生效 ， 帮我们进行自动配置工作；</li>
<li>整个J2EE的整体解决方案和自动配置都在springboot-autoconfigure的jar包中；</li>
<li>它会给容器中导入非常多的自动配置类 （xxxAutoConfiguration）, 就是给容器中导入这个场景需要的所有组件 ， 并配置好这些组件 ；</li>
<li>有了自动配置类 ， 免去了我们手动编写配置注入功能组件等的工作；</li>
</ol>
<h2 id="SpringApplication"><a href="#SpringApplication" class="headerlink" title="SpringApplication"></a><strong>SpringApplication</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class SpringbootApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(SpringbootApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>SpringApplication.run分析</strong></p>
<p>分析该方法主要分两部分，一部分是SpringApplication的实例化，二是run方法的执行；</p>
<p>SpringApplication这个类主要做了以下四件事情：</p>
<p>1、推断应用的类型是普通的项目还是Web项目</p>
<p>2、查找并加载所有可用初始化器 ， 设置到initializers属性中</p>
<p>3、找出所有的应用程序监听器，设置到listeners属性中</p>
<p>4、推断并设置main方法的定义类，找到运行的主类</p>
<p>查看构造器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public SpringApplication(ResourceLoader resourceLoader, Class... primarySources) &#123;</span><br><span class="line">    // ......</span><br><span class="line">    this.webApplicationType = WebApplicationType.deduceFromClasspath();</span><br><span class="line">    this.setInitializers(this.getSpringFactoriesInstances();</span><br><span class="line">    this.setListeners(this.getSpringFactoriesInstances(ApplicationListener.class));</span><br><span class="line">    this.mainApplicationClass = this.deduceMainApplicationClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot系列：yaml配置注入</title>
    <url>/2023/01/10/SpringBoot%E7%B3%BB%E5%88%97%EF%BC%9Ayaml%E9%85%8D%E7%BD%AE%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>SpringBoot使用一个全局的配置文件 ， 配置文件名称是固定的</p>
<span id="more"></span>
<ul>
<li><p>application.properties</p>
</li>
<li><ul>
<li>语法结构 ：key=value</li>
</ul>
</li>
<li><p>application.yml</p>
</li>
<li><ul>
<li>语法结构 ：key：空格 value</li>
</ul>
</li>
</ul>
<p><strong>配置文件的作用 ：</strong>修改SpringBoot自动配置的默认值，因为SpringBoot在底层都给我们自动配置好了；</p>
<p>比如我们可以在配置文件中修改Tomcat 默认启动的端口号！测试一下！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server.port=8081</span><br></pre></td></tr></table></figure>
<h2 id="yaml概述"><a href="#yaml概述" class="headerlink" title="yaml概述"></a>yaml概述</h2><p>YAML是 “YAML Ain’t a Markup Language” （YAML不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：”Yet Another Markup Language”（仍是一种标记语言）</p>
<p><strong>这种语言以数据作为中心，而不是以标记语言为重点！</strong></p>
<p>以前的配置文件，大多数都是使用xml来配置；比如一个简单的端口配置，我们来对比下yaml和xml</p>
<p>传统xml配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;server&gt;    &lt;port&gt;8081&lt;port&gt;&lt;/server&gt;</span><br></pre></td></tr></table></figure>
<p>yaml配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server：  prot: 8080</span><br></pre></td></tr></table></figure>
<h2 id="yaml基础语法"><a href="#yaml基础语法" class="headerlink" title="yaml基础语法"></a>yaml基础语法</h2><p>说明：语法要求严格！</p>
<p>1、空格不能省略</p>
<p>2、以缩进来控制层级关系，只要是左边对齐的一列数据都是同一个层级的。</p>
<p>3、属性和值的大小写都是十分敏感的。</p>
<p><strong>字面量：普通的值  [ 数字，布尔值，字符串  ]</strong></p>
<p>字面量直接写在后面就可以 ， 字符串默认不用加上双引号或者单引号；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">k: v</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li><p>“ ” 双引号，不会转义字符串里面的特殊字符 ， 特殊字符会作为本身想表示的意思；</p>
<p>比如 ：name: “bai \n du”   输出 ：bai  换行   du</p>
</li>
<li><p>‘’ 单引号，会转义特殊字符 ， 特殊字符最终会变成和普通字符一样输出</p>
<p>比如 ：name: ‘bai \n du’   输出 ：bai   \n   du</p>
</li>
</ul>
<p><strong>对象、Map（键值对）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#对象、Map格式</span><br><span class="line">k: </span><br><span class="line">    v1:</span><br><span class="line">    v2:</span><br></pre></td></tr></table></figure>
<p>在下一行来写对象的属性和值得关系，注意缩进；比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">student:</span><br><span class="line">    name: qinjiang</span><br><span class="line">    age: 3</span><br></pre></td></tr></table></figure>
<p>行内写法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">student: &#123;name: qinjiang,age: 3&#125;</span><br></pre></td></tr></table></figure>
<p><strong>数组（ List、set ）</strong></p>
<p>用 - 值表示数组中的一个元素,比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pets:</span><br><span class="line"> - cat</span><br><span class="line"> - dog</span><br><span class="line"> - pig</span><br></pre></td></tr></table></figure>
<p>行内写法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pets: [cat,dog,pig]</span><br></pre></td></tr></table></figure>
<p><strong>修改SpringBoot的默认端口号</strong></p>
<p>配置文件中添加，端口号的参数，就可以切换端口；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">server:</span><br><span class="line">  port: 8082</span><br></pre></td></tr></table></figure>
<p>注入配置文件</p>
<p>yaml文件更强大的地方在于，他可以给我们的实体类直接注入匹配值！</p>
<h2 id="yaml注入配置文件"><a href="#yaml注入配置文件" class="headerlink" title="yaml注入配置文件"></a>yaml注入配置文件</h2><p>1、在springboot项目中的resources目录下新建一个文件 application.yml</p>
<p>2、编写一个实体类 Dog；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">package com.kuang.springboot.pojo;</span><br><span class="line"></span><br><span class="line">@Component  //注册bean到容器中</span><br><span class="line">public class Dog &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private Integer age;</span><br><span class="line">    </span><br><span class="line">    //有参无参构造、get、set方法、toString()方法  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、思考，我们原来是如何给bean注入属性值的！@Value，给狗狗类测试一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span> <span class="comment">//注册bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;大黄&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Value(&quot;8&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4、在SpringBoot的测试类下注入狗狗输出一下；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SpringBootTest</span><br><span class="line">class DemoApplicationTests &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired //将狗狗自动注入进来</span><br><span class="line">    Dog dog;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void contextLoads() &#123;</span><br><span class="line">        System.out.println(dog); //打印看下狗狗对象</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果成功输出，@Value注入成功，这是我们原来的办法对吧。</p>
<p>5、我们在编写一个复杂一点的实体类：Person 类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component //注册bean到容器中</span><br><span class="line">public class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private Integer age;</span><br><span class="line">    private Boolean happy;</span><br><span class="line">    private Date birth;</span><br><span class="line">    private Map&lt;String,Object&gt; maps;</span><br><span class="line">    private List&lt;Object&gt; lists;</span><br><span class="line">    private Dog dog;</span><br><span class="line">    </span><br><span class="line">    //有参无参构造、get、set方法、toString()方法  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>6、我们来使用yaml配置的方式进行注入，大家写的时候注意区别和优势，我们编写一个yaml配置！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">person:</span><br><span class="line">  name: baidu</span><br><span class="line">  age: 3</span><br><span class="line">  happy: false</span><br><span class="line">  birth: 2000/01/01</span><br><span class="line">  maps: &#123;k1: v1,k2: v2&#125;</span><br><span class="line">  lists:</span><br><span class="line">   - code</span><br><span class="line">   - girl</span><br><span class="line">   - music</span><br><span class="line">  dog:</span><br><span class="line">    name: 旺财</span><br><span class="line">    age: 1</span><br></pre></td></tr></table></figure>
<p>7、我们刚才已经把person这个对象的所有值都写好了，我们现在来注入到我们的类中！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">@ConfigurationProperties作用：</span><br><span class="line">将配置文件中配置的每一个属性的值，映射到这个组件中；</span><br><span class="line">告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定</span><br><span class="line">参数 prefix = “person” : 将配置文件中的person下面的所有属性一一对应</span><br><span class="line">*/</span><br><span class="line">@Component //注册bean</span><br><span class="line">@ConfigurationProperties(prefix = &quot;person&quot;)</span><br><span class="line">public class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private Integer age;</span><br><span class="line">    private Boolean happy;</span><br><span class="line">    private Date birth;</span><br><span class="line">    private Map&lt;String,Object&gt; maps;</span><br><span class="line">    private List&lt;Object&gt; lists;</span><br><span class="line">    private Dog dog;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>8、IDEA 提示，springboot配置注解处理器没有找到，让我们看文档，我们可以查看文档，找到一个依赖！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 导入配置文件处理器，配置文件进行绑定就会有提示，需要重启 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;</span><br><span class="line">  &lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>9、确认以上配置都OK之后，我们去测试类中测试一下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@SpringBootTest</span><br><span class="line">class DemoApplicationTests &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    Person person; //将person自动注入进来</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void contextLoads() &#123;</span><br><span class="line">        System.out.println(person); //打印person信息</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：所有值全部注入成功</p>
<p><strong>yaml配置注入到实体类完全OK！</strong></p>
<p>课堂测试：</p>
<p>1、将配置文件的key 值 和 属性的值设置为不一样，则结果输出为null，注入失败</p>
<p>2、在配置一个person2，然后将 @ConfigurationProperties(prefix = “person2”) 指向我们的person2；</p>
<h2 id="加载指定的配置文件"><a href="#加载指定的配置文件" class="headerlink" title="加载指定的配置文件"></a>加载指定的配置文件</h2><p><strong>@PropertySource ：</strong>加载指定的配置文件；</p>
<p><strong>@configurationProperties</strong>：默认从全局配置文件中获取值；</p>
<p>1、我们去在resources目录下新建一个<strong>person.properties</strong>文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">name=kuangshen</span><br></pre></td></tr></table></figure>
<p>2、然后在我们的代码中指定加载person.properties文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@PropertySource(value = &quot;classpath:person.properties&quot;)</span><br><span class="line">@Component //注册bean</span><br><span class="line">public class Person &#123;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;name&#125;&quot;)</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    ......  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、再次输出测试一下：指定配置文件绑定成功！</p>
<h2 id="配置文件占位符"><a href="#配置文件占位符" class="headerlink" title="配置文件占位符"></a>配置文件占位符</h2><p>配置文件还可以编写占位符生成随机数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">person:</span><br><span class="line">    name: qinjiang$&#123;random.uuid&#125; # 随机uuid</span><br><span class="line">    age: $&#123;random.int&#125;  # 随机int</span><br><span class="line">    happy: false</span><br><span class="line">    birth: 2000/01/01</span><br><span class="line">    maps: &#123;k1: v1,k2: v2&#125;</span><br><span class="line">    lists:</span><br><span class="line">      - code</span><br><span class="line">      - girl</span><br><span class="line">      - music</span><br><span class="line">    dog:</span><br><span class="line">      name: $&#123;person.hello:other&#125;_旺财</span><br><span class="line">      age: 1</span><br></pre></td></tr></table></figure>
<h2 id="回顾properties配置"><a href="#回顾properties配置" class="headerlink" title="回顾properties配置"></a>回顾properties配置</h2><p>我们上面采用的yaml方法都是最简单的方式，开发中最常用的；也是springboot所推荐的！那我们来唠唠其他的实现方式，道理都是相同的；写还是那样写；配置文件除了yml还有我们之前常用的properties ， 我们没有讲，我们来唠唠！</p>
<p>【注意】properties配置文件在写中文的时候，会有乱码 ， 我们需要去IDEA中设置编码格式为UTF-8；</p>
<p>settings—&gt;FileEncodings 中配置；</p>
<p><strong>测试步骤：</strong></p>
<p>1、新建一个实体类User</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component //注册bean</span><br><span class="line">public class User &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    private String sex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、编辑配置文件 user.properties</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">user1.name=kuangshen</span><br><span class="line">user1.age=18</span><br><span class="line">user1.sex=男</span><br></pre></td></tr></table></figure>
<p>3、我们在User类上使用@Value来进行注入！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component //注册bean</span><br><span class="line">@PropertySource(value = &quot;classpath:user.properties&quot;)</span><br><span class="line">public class User &#123;</span><br><span class="line">    //直接使用@value</span><br><span class="line">    @Value(&quot;$&#123;user.name&#125;&quot;) //从配置文件中取值</span><br><span class="line">    private String name;</span><br><span class="line">    @Value(&quot;#&#123;9*2&#125;&quot;)  // #&#123;SPEL&#125; Spring表达式</span><br><span class="line">    private int age;</span><br><span class="line">    @Value(&quot;男&quot;)  // 字面量</span><br><span class="line">    private String sex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4、Springboot测试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SpringBootTest</span><br><span class="line">class DemoApplicationTests &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    User user;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void contextLoads() &#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果正常输出：</p>
<h2 id="对比小结"><a href="#对比小结" class="headerlink" title="对比小结"></a>对比小结</h2><p>@Value这个使用起来并不友好！我们需要为每个属性单独注解赋值，比较麻烦；我们来看个功能对比图</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7KtjyIb9NEaYlz0tCWSiboOYjMibiaov73iaTsiaWEPoArDcAB1Ooibx9uR5JxtacIuicHblEtUI9SrySX2A/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p>
<p>1、@ConfigurationProperties只需要写一次即可 ， @Value则需要每个字段都添加</p>
<p>2、松散绑定：这个什么意思呢? 比如我的yml中写的last-name，这个和lastName是一样的， - 后面跟着的字母默认是大写的。这就是松散绑定。可以测试一下</p>
<p>3、JSR303数据校验 ， 这个就是我们可以在字段是增加一层过滤器验证 ， 可以保证数据的合法性</p>
<p>4、复杂类型封装，yml中可以封装对象 ， 使用value就不支持</p>
<p><strong>结论：</strong></p>
<p>配置yml和配置properties都可以获取到值 ， 强烈推荐 yml；</p>
<p>如果我们在某个业务中，只需要获取配置文件中的某个值，可以使用一下 @value；</p>
<p>如果说，我们专门编写了一个JavaBean来和配置文件进行一一映射，就直接@configurationProperties，不要犹豫！</p>
]]></content>
      <tags>
        <tag>SpringBoot</tag>
        <tag>yaml</tag>
        <tag>properties</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot系列：JSR303数据校验及多环境切换</title>
    <url>/2023/01/10/SpringBoot%E7%B3%BB%E5%88%97%EF%BC%9AJSR303%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C%E5%8F%8A%E5%A4%9A%E7%8E%AF%E5%A2%83%E5%88%87%E6%8D%A2/</url>
    <content><![CDATA[<p>Springboot中可以用@validated来校验数据，如果数据异常则会统一抛出异常，方便异常中心统一处理。我们这里来写个注解让我们的name只能支持Email格式；</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component //注册bean@ConfigurationProperties(prefix = &quot;person&quot;)@Validated  //数据校验public class Person &#123;</span><br><span class="line">    @Email(message=&quot;邮箱格式错误&quot;) //name必须是邮箱格式    private String name;&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果 ：default message [不是一个合法的电子邮件地址];</p>
<p><strong>使用数据校验，可以保证数据的正确性；</strong> </p>
<h2 id="常见参数"><a href="#常见参数" class="headerlink" title="常见参数"></a>常见参数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@NotNull(message=&quot;名字不能为空&quot;)</span><br><span class="line">private String userName;</span><br><span class="line">@Max(value=120,message=&quot;年龄最大不能查过120&quot;)</span><br><span class="line">private int age;</span><br><span class="line">@Email(message=&quot;邮箱格式错误&quot;)</span><br><span class="line">private String email;</span><br><span class="line"></span><br><span class="line">空检查</span><br><span class="line">@Null       验证对象是否为null</span><br><span class="line">@NotNull    验证对象是否不为null, 无法查检长度为0的字符串</span><br><span class="line">@NotBlank   检查约束字符串是不是Null还有被Trim的长度是否大于0,只对字符串,且会去掉前后空格.</span><br><span class="line">@NotEmpty   检查约束元素是否为NULL或者是EMPTY.</span><br><span class="line">    </span><br><span class="line">Booelan检查</span><br><span class="line">@AssertTrue     验证 Boolean 对象是否为 true  </span><br><span class="line">@AssertFalse    验证 Boolean 对象是否为 false  </span><br><span class="line">    </span><br><span class="line">长度检查</span><br><span class="line">@Size(min=, max=) 验证对象（Array,Collection,Map,String）长度是否在给定的范围之内  </span><br><span class="line">@Length(min=, max=) string is between min and max included.</span><br><span class="line"></span><br><span class="line">日期检查</span><br><span class="line">@Past       验证 Date 和 Calendar 对象是否在当前时间之前  </span><br><span class="line">@Future     验证 Date 和 Calendar 对象是否在当前时间之后  </span><br><span class="line">@Pattern    验证 String 对象是否符合正则表达式的规则</span><br><span class="line"></span><br><span class="line">.......等等</span><br><span class="line">除此以外，我们还可以自定义一些数据校验规则</span><br></pre></td></tr></table></figure>
<h2 id="多环境切换"><a href="#多环境切换" class="headerlink" title="多环境切换"></a>多环境切换</h2><p>profile是Spring对不同环境提供不同配置功能的支持，可以通过激活不同的环境版本，实现快速切换环境；</p>
<h3 id="多配置文件"><a href="#多配置文件" class="headerlink" title="多配置文件"></a>多配置文件</h3><p>我们在主配置文件编写的时候，文件名可以是 application-{profile}.properties/yml , 用来指定多个环境版本；</p>
<p><strong>例如：</strong></p>
<p>application-test.properties 代表测试环境配置</p>
<p>application-dev.properties 代表开发环境配置</p>
<p>但是Springboot并不会直接启动这些配置文件，它<strong>默认使用application.properties主配置文件</strong>；</p>
<p>我们需要通过一个配置来选择需要激活的环境：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#比如在配置文件中指定使用dev环境，我们可以通过设置不同的端口号进行测试；</span><br><span class="line">#我们启动SpringBoot，就可以看到已经切换到dev下的配置了；</span><br><span class="line">spring.profiles.active=dev</span><br></pre></td></tr></table></figure>
<h3 id="yaml的多文档块"><a href="#yaml的多文档块" class="headerlink" title="yaml的多文档块"></a>yaml的多文档块</h3><p>和properties配置文件中一样，但是使用yml去实现不需要创建多个配置文件，更加方便了 !</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8081</span><br><span class="line">#选择要激活那个环境块</span><br><span class="line">spring:</span><br><span class="line">  profiles:</span><br><span class="line">    active: prod</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">server:</span><br><span class="line">  port: 8083</span><br><span class="line">spring:</span><br><span class="line">  profiles: dev #配置环境的名称</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">server:</span><br><span class="line">  port: 8084</span><br><span class="line">spring:</span><br><span class="line">  profiles: prod  #配置环境的名称</span><br></pre></td></tr></table></figure>
<p><strong>注意：如果yml和properties同时都配置了端口，并且没有激活其他环境 ， 默认会使用properties配置文件的！</strong></p>
<h3 id="配置文件加载位置"><a href="#配置文件加载位置" class="headerlink" title="配置文件加载位置"></a>配置文件加载位置</h3><p><strong>外部加载配置文件的方式十分多，我们选择最常用的即可，在开发的资源文件中进行配置！</strong></p>
<p>springboot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">优先级1：项目路径下的config文件夹配置文件</span><br><span class="line">优先级2：项目路径下配置文件</span><br><span class="line">优先级3：资源路径下的config文件夹配置文件</span><br><span class="line">优先级4：资源路径下配置文件</span><br></pre></td></tr></table></figure>
<p>优先级由高到底，高优先级的配置会覆盖低优先级的配置；</p>
<p><strong>SpringBoot会从这四个位置全部加载主配置文件；互补配置；</strong></p>
<p>我们在最低级的配置文件中设置一个项目访问路径的配置来测试互补问题；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#配置项目的访问路径</span><br><span class="line">server.servlet.context-path=/baidu</span><br></pre></td></tr></table></figure>
<h2 id="拓展，运维小技巧"><a href="#拓展，运维小技巧" class="headerlink" title="拓展，运维小技巧"></a>拓展，运维小技巧</h2><p>指定位置加载配置文件</p>
<p>我们还可以通过spring.config.location来改变默认的配置文件位置</p>
<p>项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；这种情况，一般是后期运维做的多，相同配置，外部指定的配置文件优先级最高</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -jar spring-boot-config.jar --spring.config.location=F:/application.properties</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>SpringBoot</tag>
        <tag>yaml</tag>
        <tag>多环境切换</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot整理：Web开发静态资源处理</title>
    <url>/2023/01/13/SpringBoot%E6%95%B4%E7%90%86%EF%BC%9AWeb%E5%BC%80%E5%8F%91%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>开始学习SpringBoot与Web开发;</p>
<p>其实SpringBoot的东西用起来非常简单，因为SpringBoot最大的特点就是自动装配。</p>
<span id="more"></span>
<p><strong>使用SpringBoot的步骤：</strong></p>
<p>1、创建一个SpringBoot应用，选择我们需要的模块，SpringBoot就会默认将我们的需要的模块自动配置好</p>
<p>2、手动在配置文件中配置部分配置项目就可以运行起来了</p>
<p>3、专注编写业务代码，不需要考虑以前那样一大堆的配置了。</p>
<p>要熟悉掌握开发，之前学习的自动配置的原理一定要搞明白！</p>
<p>比如SpringBoot到底帮我们配置了什么？我们能不能修改？我们能修改哪些配置？我们能不能扩展？</p>
<ul>
<li>向容器中自动配置组件 ： Autoconfiguration</li>
<li>自动配置类，封装配置文件的内容：Poperties</li>
</ul>
<p>没事就找找类，看看自动装配原理！</p>
<p>我们之后来进行一个单体项目的小项目测试，让大家能够快速上手开发！</p>
<p>静态资源处理</p>
<h2 id="静态资源映射规则"><a href="#静态资源映射规则" class="headerlink" title="静态资源映射规则"></a>静态资源映射规则</h2><p><strong>首先，我们搭建一个普通的SpringBoot项目，回顾一下HelloWorld程序！</strong></p>
<p>写请求非常简单，那我们要引入我们前端资源，我们项目中有许多的静态资源，比如css，js等文件，这个SpringBoot怎么处理呢？</p>
<p>如果我们是一个web应用，我们的main下会有一个webapp，我们以前都是将所有的页面导在这里面的，对吧！但是我们现在的pom呢，打包方式是为jar的方式，那么这种方式SpringBoot能不能来给我们写页面呢？当然是可以的，但是SpringBoot对于静态资源放置的位置，是有规定的！</p>
<p><strong>我们先来聊聊这个静态资源映射规则：</strong></p>
<p>SpringBoot中，SpringMVC的web配置都在 WebMvcAutoConfiguration 这个配置类里面；</p>
<p>我们可以去看看 WebMvcAutoConfigurationAdapter 中有很多配置方法；</p>
<p>有一个方法：addResourceHandlers 添加资源处理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void addResourceHandlers(ResourceHandlerRegistry registry) &#123;</span><br><span class="line">    if (!this.resourceProperties.isAddMappings()) &#123;</span><br><span class="line">        // 已禁用默认资源处理</span><br><span class="line">        logger.debug(&quot;Default resource handling disabled&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 缓存控制</span><br><span class="line">    Duration cachePeriod = this.resourceProperties.getCache().getPeriod();</span><br><span class="line">    CacheControl cacheControl = this.resourceProperties.getCache().getCachecontrol().toHttpCacheControl();</span><br><span class="line">    // webjars 配置</span><br><span class="line">    if (!registry.hasMappingForPattern(&quot;/webjars/**&quot;)) &#123;</span><br><span class="line">        customizeResourceHandlerRegistration(registry.addResourceHandler(&quot;/webjars/**&quot;)</span><br><span class="line">                                             .addResourceLocations(&quot;classpath:/META-INF/resources/webjars/&quot;)</span><br><span class="line">                                             .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl));</span><br><span class="line">    &#125;</span><br><span class="line">    // 静态资源配置</span><br><span class="line">    String staticPathPattern = this.mvcProperties.getStaticPathPattern();</span><br><span class="line">    if (!registry.hasMappingForPattern(staticPathPattern)) &#123;</span><br><span class="line">        customizeResourceHandlerRegistration(registry.addResourceHandler(staticPathPattern)</span><br><span class="line">                                             .addResourceLocations(getResourceLocations(this.resourceProperties.getStaticLocations()))</span><br><span class="line">                                             .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读一下源代码：比如所有的 /webjars/** ， 都需要去 classpath:/META-INF/resources/webjars/ 找对应的资源；</p>
<h2 id="什么是webjars-呢？"><a href="#什么是webjars-呢？" class="headerlink" title="什么是webjars 呢？"></a>什么是webjars 呢？</h2><p>Webjars本质就是以jar包的方式引入我们的静态资源 ， 我们以前要导入一个静态资源文件，直接导入即可。</p>
<p>使用SpringBoot需要使用Webjars，我们可以去搜索一下：</p>
<p>网站：<a href="https://www.webjars.org">https://www.webjars.org</a> </p>
<p>要使用jQuery，我们只要要引入jQuery对应版本的pom依赖即可！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.webjars&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jquery&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.4.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>导入完毕，查看webjars目录结构，并访问Jquery.js文件！</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/13/6iqs9.png"></p>
<p>访问：只要是静态资源，SpringBoot就会去对应的路径寻找资源，我们这里访问：<a href="http://localhost:8080/webjars/jquery/3.4.1/jquery.js">http://localhost:8080/webjars/jquery/3.4.1/jquery.js</a></p>
<p><img src="https://i.p04e.com/baid/i/2023/01/13/4slo.png"></p>
<h2 id="第二种静态资源映射规则"><a href="#第二种静态资源映射规则" class="headerlink" title="第二种静态资源映射规则"></a>第二种静态资源映射规则</h2><p>那我们项目中要是使用自己的静态资源该怎么导入呢？我们看下一行代码；</p>
<p>我们去找staticPathPattern发现第二种映射规则 ：/** , 访问当前的项目任意资源，它会去找 resourceProperties 这个类，我们可以点进去看一下分析：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 进入方法</span><br><span class="line">public String[] getStaticLocations() &#123;</span><br><span class="line">    return this.staticLocations;</span><br><span class="line">&#125;</span><br><span class="line">// 找到对应的值</span><br><span class="line">private String[] staticLocations = CLASSPATH_RESOURCE_LOCATIONS;</span><br><span class="line">// 找到路径</span><br><span class="line">private static final String[] CLASSPATH_RESOURCE_LOCATIONS = &#123; </span><br><span class="line">    &quot;classpath:/META-INF/resources/&quot;,</span><br><span class="line">  &quot;classpath:/resources/&quot;, </span><br><span class="line">    &quot;classpath:/static/&quot;, </span><br><span class="line">    &quot;classpath:/public/&quot; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>ResourceProperties 可以设置和我们静态资源有关的参数；这里面指向了它会去寻找资源的文件夹，即上面数组的内容。</p>
<p>所以得出结论，以下四个目录存放的静态资源可以被我们识别：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;classpath:/META-INF/resources/&quot;</span><br><span class="line">&quot;classpath:/resources/&quot;</span><br><span class="line">&quot;classpath:/static/&quot;</span><br><span class="line">&quot;classpath:/public/&quot;</span><br></pre></td></tr></table></figure>
<p>我们可以在resources根目录下新建对应的文件夹，都可以存放我们的静态文件；</p>
<p>比如我们访问 <a href="http://localhost:8080/1.js">http://localhost:8080/1.js</a> , 他就会去这些文件夹中寻找对应的静态资源文件；</p>
<h2 id="自定义静态资源路径"><a href="#自定义静态资源路径" class="headerlink" title="自定义静态资源路径"></a>自定义静态资源路径</h2><p>我们也可以自己通过配置文件来指定一下，哪些文件夹是需要我们放静态资源文件的，在application.properties中配置；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring.resources.static-locations=classpath:/coding/,classpath:/bai/</span><br></pre></td></tr></table></figure>
<p>一旦自己定义了静态文件夹的路径，原来的自动配置就都会失效了！</p>
<p>首页处理</p>
<p>静态资源文件夹说完后，我们继续向下看源码！可以看到一个欢迎页的映射，就是我们的首页！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public WelcomePageHandlerMapping welcomePageHandlerMapping(ApplicationContext applicationContext,</span><br><span class="line">                                                           FormattingConversionService mvcConversionService,</span><br><span class="line">                                                           ResourceUrlProvider mvcResourceUrlProvider) &#123;</span><br><span class="line">    WelcomePageHandlerMapping welcomePageHandlerMapping = new WelcomePageHandlerMapping(</span><br><span class="line">        new TemplateAvailabilityProviders(applicationContext), applicationContext, getWelcomePage(), // getWelcomePage 获得欢迎页</span><br><span class="line">        this.mvcProperties.getStaticPathPattern());</span><br><span class="line">    welcomePageHandlerMapping.setInterceptors(getInterceptors(mvcConversionService, mvcResourceUrlProvider));</span><br><span class="line">    return welcomePageHandlerMapping;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>点进去继续看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private Optional&lt;Resource&gt; getWelcomePage() &#123;</span><br><span class="line">    String[] locations = getResourceLocations(this.resourceProperties.getStaticLocations());</span><br><span class="line">    // ::是java8 中新引入的运算符</span><br><span class="line">    // Class::function的时候function是属于Class的，应该是静态方法。</span><br><span class="line">    // this::function的funtion是属于这个对象的。</span><br><span class="line">    // 简而言之，就是一种语法糖而已，是一种简写</span><br><span class="line">    return Arrays.stream(locations).map(this::getIndexHtml).filter(this::isReadable).findFirst();</span><br><span class="line">&#125;</span><br><span class="line">// 欢迎页就是一个location下的的 index.html 而已</span><br><span class="line">private Resource getIndexHtml(String location) &#123;</span><br><span class="line">    return this.resourceLoader.getResource(location + &quot;index.html&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>欢迎页，静态资源文件夹下的所有 index.html 页面；被 /** 映射。</p>
<p>比如我访问  <a href="http://localhost:8080/">http://localhost:8080/</a> ，就会找静态资源文件夹下的 index.html</p>
<p>新建一个 index.html ，在我们上面的3个目录中任意一个；然后访问测试  <a href="http://localhost:8080/">http://localhost:8080/</a>  看结果！</p>
<p><strong>关于网站图标说明</strong>：</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/13/6j0z6.png"></p>
<p>与其他静态资源一样，Spring Boot在配置的静态内容位置中查找 favicon.ico。如果存在这样的文件，它将自动用作应用程序的favicon。</p>
<p>1、关闭SpringBoot默认图标</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#关闭默认图标</span><br><span class="line">spring.mvc.favicon.enabled=false</span><br></pre></td></tr></table></figure>
<p>2、自己放一个图标在静态资源目录下，我放在 public 目录下</p>
<p>3、清除浏览器缓存！刷新网页，发现图标已经变成自己的了！</p>
]]></content>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot系列：整合Druid</title>
    <url>/2023/01/13/SpringBoot%E7%B3%BB%E5%88%97%EF%BC%9A%E6%95%B4%E5%90%88Druid/</url>
    <content><![CDATA[<h2 id="Druid简介"><a href="#Druid简介" class="headerlink" title="Druid简介"></a>Druid简介</h2><p>Java程序很大一部分要操作数据库，为了提高性能操作数据库的时候，又不得不使用数据库连接池。</p>
<p>Druid 是阿里巴巴开源平台上一个数据库连接池实现，结合了 C3P0、DBCP 等 DB 池的优点，同时加入了日志监控。<span id="more"></span></p>
<p>Druid 可以很好的监控 DB 池连接和 SQL 的执行情况，天生就是针对监控而生的 DB 连接池。</p>
<p>Druid已经在阿里巴巴部署了超过600个应用，经过一年多生产环境大规模部署的严苛考验。</p>
<p>Spring Boot 2.0 以上默认使用 Hikari 数据源，可以说 Hikari 与 Driud 都是当前 Java Web 上最优秀的数据源，我们来重点介绍 Spring Boot 如何集成 Druid 数据源，如何实现数据库监控。</p>
<p>Github地址：<a href="https://github.com/alibaba/druid/">https://github.com/alibaba/druid/</a></p>
<p><strong>com.alibaba.druid.pool.DruidDataSource 基本配置参数如下：</strong></p>
<p><img src="https://i.p04e.com/baid/i/2023/01/13/5ix23.png"></p>
<h2 id="配置数据源"><a href="#配置数据源" class="headerlink" title="配置数据源"></a>配置数据源</h2><p>1、添加上 Druid 数据源依赖。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;druid&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.1.21&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>2、切换数据源；之前已经说过 Spring Boot 2.0 以上默认使用 com.zaxxer.hikari.HikariDataSource 数据源，但可以 通过 spring.datasource.type 指定数据源。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    username: root</span><br><span class="line">    password: 123456</span><br><span class="line">    url: jdbc:mysql://localhost:3306/springboot?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    type: com.alibaba.druid.pool.DruidDataSource # 自定义数据源</span><br></pre></td></tr></table></figure>
<p>3、数据源切换之后，在测试类中注入 DataSource，然后获取到它，输出一看便知是否成功切换；</p>
<p>4、切换成功！既然切换成功，就可以设置数据源连接初始化大小、最大连接数、等待时间、最小连接数 等设置项；可以查看源码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    username: root</span><br><span class="line">    password: root</span><br><span class="line">    #?serverTimezone=UTC解决时区的报错</span><br><span class="line">    url: jdbc:mysql://localhost:3306/springboot?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    type: com.alibaba.druid.pool.DruidDataSource</span><br><span class="line"></span><br><span class="line">    #Spring Boot 默认是不注入这些属性值的，需要自己绑定</span><br><span class="line">    #druid 数据源专有配置</span><br><span class="line">    initialSize: 5</span><br><span class="line">    minIdle: 5</span><br><span class="line">    maxActive: 20</span><br><span class="line">    maxWait: 60000</span><br><span class="line">    timeBetweenEvictionRunsMillis: 60000</span><br><span class="line">    minEvictableIdleTimeMillis: 300000</span><br><span class="line">    validationQuery: SELECT 1 FROM DUAL</span><br><span class="line">    testWhileIdle: true</span><br><span class="line">    testOnBorrow: false</span><br><span class="line">    testOnReturn: false</span><br><span class="line">    poolPreparedStatements: true</span><br><span class="line"></span><br><span class="line">    #配置监控统计拦截的filters，stat:监控统计、log4j：日志记录、wall：防御sql注入</span><br><span class="line">    #如果允许时报错  java.lang.ClassNotFoundException: org.apache.log4j.Priority</span><br><span class="line">    #则导入 log4j 依赖即可，Maven 地址：https://mvnrepository.com/artifact/log4j/log4j</span><br><span class="line">    filters: stat,wall,log4j</span><br><span class="line">    maxPoolPreparedStatementPerConnectionSize: 20</span><br><span class="line">    useGlobalDataSourceStat: true</span><br><span class="line">    connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500</span><br></pre></td></tr></table></figure>
<p>5、导入Log4j 的依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/log4j/log4j --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;log4j&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;log4j&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2.17&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>6、现在需要程序员自己为 DruidDataSource 绑定全局配置文件中的参数，再添加到容器中，而不再使用 Spring Boot 的自动生成了；我们需要 自己添加 DruidDataSource 组件到容器中，并绑定属性；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">package com.kuang.config;</span><br><span class="line"></span><br><span class="line">import com.alibaba.druid.pool.DruidDataSource;</span><br><span class="line">import org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line">import javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class DruidConfig &#123;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">       将自定义的 Druid数据源添加到容器中，不再让 Spring Boot 自动创建</span><br><span class="line">       绑定全局配置文件中的 druid 数据源属性到 com.alibaba.druid.pool.DruidDataSource从而让它们生效</span><br><span class="line">       @ConfigurationProperties(prefix = &quot;spring.datasource&quot;)：作用就是将 全局配置文件中</span><br><span class="line">       前缀为 spring.datasource的属性值注入到 com.alibaba.druid.pool.DruidDataSource 的同名参数中</span><br><span class="line">     */</span><br><span class="line">    @ConfigurationProperties(prefix = &quot;spring.datasource&quot;)</span><br><span class="line">    @Bean</span><br><span class="line">    public DataSource druidDataSource() &#123;</span><br><span class="line">        return new DruidDataSource();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>7、去测试类中测试一下；看是否成功！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SpringBootTest</span><br><span class="line">class SpringbootDataJdbcApplicationTests &#123;</span><br><span class="line"></span><br><span class="line">    //DI注入数据源</span><br><span class="line">    @Autowired</span><br><span class="line">    DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void contextLoads() throws SQLException &#123;</span><br><span class="line">        //看一下默认数据源</span><br><span class="line">        System.out.println(dataSource.getClass());</span><br><span class="line">        //获得连接</span><br><span class="line">        Connection connection =   dataSource.getConnection();</span><br><span class="line">        System.out.println(connection);</span><br><span class="line"></span><br><span class="line">        DruidDataSource druidDataSource = (DruidDataSource) dataSource;</span><br><span class="line">        System.out.println(&quot;druidDataSource 数据源最大连接数：&quot; + druidDataSource.getMaxActive());</span><br><span class="line">        System.out.println(&quot;druidDataSource 数据源初始化连接数：&quot; + druidDataSource.getInitialSize());</span><br><span class="line"></span><br><span class="line">        //关闭连接</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果 ：可见配置参数已经生效！</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/13/5jglr.png"></p>
<h2 id="配置Druid数据源监控"><a href="#配置Druid数据源监控" class="headerlink" title="配置Druid数据源监控"></a>配置Druid数据源监控</h2><p>Druid 数据源具有监控的功能，并提供了一个 web 界面方便用户查看，类似安装 路由器 时，人家也提供了一个默认的 web 页面。</p>
<p>所以第一步需要设置 Druid 的后台管理页面，比如 登录账号、密码 等；配置后台管理；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//配置 Druid 监控管理后台的Servlet；</span><br><span class="line">//内置 Servlet 容器时没有web.xml文件，所以使用 Spring Boot 的注册 Servlet 方式</span><br><span class="line">@Bean</span><br><span class="line">public ServletRegistrationBean statViewServlet() &#123;</span><br><span class="line">    ServletRegistrationBean bean = new ServletRegistrationBean(new StatViewServlet(), &quot;/druid/*&quot;);</span><br><span class="line"></span><br><span class="line">    // 这些参数可以在 com.alibaba.druid.support.http.StatViewServlet </span><br><span class="line">    // 的父类 com.alibaba.druid.support.http.ResourceServlet 中找到</span><br><span class="line">    Map&lt;String, String&gt; initParams = new HashMap&lt;&gt;();</span><br><span class="line">    initParams.put(&quot;loginUsername&quot;, &quot;admin&quot;); //后台管理界面的登录账号</span><br><span class="line">    initParams.put(&quot;loginPassword&quot;, &quot;root&quot;); //后台管理界面的登录密码</span><br><span class="line"></span><br><span class="line">    //后台允许谁可以访问</span><br><span class="line">    //initParams.put(&quot;allow&quot;, &quot;localhost&quot;)：表示只有本机可以访问</span><br><span class="line">    //initParams.put(&quot;allow&quot;, &quot;&quot;)：为空或者为null时，表示允许所有访问</span><br><span class="line">    initParams.put(&quot;allow&quot;, &quot;&quot;);</span><br><span class="line">    //deny：Druid 后台拒绝谁访问</span><br><span class="line">    //initParams.put(&quot;baidu&quot;, &quot;192.168.1.0.1&quot;);表示禁止此ip访问</span><br><span class="line"></span><br><span class="line">    //设置初始化参数</span><br><span class="line">    bean.setInitParameters(initParams);</span><br><span class="line">    return bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置完毕后，我们可以选择访问 ：<a href="http://localhost:8080/druid/login.html">http://localhost:8080/druid/login.html</a></p>
<p><img src="https://i.p04e.com/baid/i/2023/01/13/42sp.png"></p>
<p><strong>配置 Druid web 监控 filter 过滤器</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">//配置 Druid 监控 之  web 监控的 filter</span><br><span class="line">//WebStatFilter：用于配置Web和Druid数据源之间的管理关联监控统计</span><br><span class="line">@Bean</span><br><span class="line">public FilterRegistrationBean webStatFilter() &#123;</span><br><span class="line">    FilterRegistrationBean bean = new FilterRegistrationBean();</span><br><span class="line">    bean.setFilter(new WebStatFilter());</span><br><span class="line"></span><br><span class="line">    //exclusions：设置哪些请求进行过滤排除掉，从而不进行统计</span><br><span class="line">    Map&lt;String, String&gt; initParams = new HashMap&lt;&gt;();</span><br><span class="line">    initParams.put(&quot;exclusions&quot;, &quot;*.js,*.css,/druid/*,/jdbc/*&quot;);</span><br><span class="line">    bean.setInitParameters(initParams);</span><br><span class="line"></span><br><span class="line">    //&quot;/*&quot; 表示过滤所有请求</span><br><span class="line">    bean.setUrlPatterns(Arrays.asList(&quot;/*&quot;));</span><br><span class="line">    return bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>平时在工作中，按需求进行配置即可，主要用作监控！</p>
]]></content>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Druid</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot系列：整合JDBC</title>
    <url>/2023/01/12/SpringBoot%E7%B3%BB%E5%88%97%EF%BC%9A%E6%95%B4%E5%90%88JDBC/</url>
    <content><![CDATA[<p>对于数据访问层，无论是 SQL(关系型数据库) 还是 NOSQL(非关系型数据库)，Spring Boot 底层都是采用 Spring Data 的方式进行统一处理。</p>
<p>Spring Boot 底层都是采用 Spring Data 的方式进行统一处理各种数据库，Spring Data 也是 Spring 中与 Spring Boot、Spring Cloud 等齐名的知名项目。</p>
<span id="more"></span>
<h2 id="创建测试项目测试数据源"><a href="#创建测试项目测试数据源" class="headerlink" title="创建测试项目测试数据源"></a>创建测试项目测试数据源</h2><p>1、我去新建一个项目测试：springboot-data-jdbc ; 引入相应的模块！基础模块</p>
<p>2、项目建好之后，发现自动帮我们导入了如下的启动器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">    &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>3、编写yaml配置文件连接数据库；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    username: root</span><br><span class="line">    password: root</span><br><span class="line">    url: jdbc:mysql://localhost:3306/springboot?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br></pre></td></tr></table></figure>
<p>4、配置完这一些东西后，我们就可以直接去使用了，因为SpringBoot已经默认帮我们进行了自动配置；去测试类测试一下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@SpringBootTest</span><br><span class="line">class SpringbootDataJdbcApplicationTests &#123;</span><br><span class="line"></span><br><span class="line">    //DI注入数据源</span><br><span class="line">    @Autowired</span><br><span class="line">    DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void contextLoads() throws SQLException &#123;</span><br><span class="line">        //看一下默认数据源</span><br><span class="line">        System.out.println(dataSource.getClass());</span><br><span class="line">        //获得连接</span><br><span class="line">        Connection connection =   dataSource.getConnection();</span><br><span class="line">        System.out.println(connection);</span><br><span class="line">        //关闭连接</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：我们可以看到他默认给我们配置的数据源为 : class com.zaxxer.hikari.HikariDataSource ， 我们并没有手动配置</p>
<p>我们来全局搜索一下，找到数据源的所有自动配置都在 ：DataSourceAutoConfiguration文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Import(</span><br><span class="line">    &#123;Hikari.class, Tomcat.class, Dbcp2.class, Generic.class, DataSourceJmxConfiguration.class&#125;</span><br><span class="line">)</span><br><span class="line">protected static class PooledDataSourceConfiguration &#123;</span><br><span class="line">    protected PooledDataSourceConfiguration() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里导入的类都在 DataSourceConfiguration 配置类下，可以看出 Spring Boot 2.2.5 默认使用HikariDataSource 数据源，而以前版本，如 Spring Boot 1.5 默认使用 org.apache.tomcat.jdbc.pool.DataSource 作为数据源；</p>
<p><strong>HikariDataSource 号称 Java WEB 当前速度最快的数据源，相比于传统的 C3P0 、DBCP、Tomcat jdbc 等连接池更加优秀；</strong></p>
<p><strong>可以使用 spring.datasource.type 指定自定义的数据源类型，值为 要使用的连接池实现的完全限定名。</strong></p>
<p>关于数据源我们并不做介绍，有了数据库连接，显然就可以 CRUD 操作数据库了。但是我们需要先了解一个对象 JdbcTemplate</p>
<h2 id="JDBCTemplate"><a href="#JDBCTemplate" class="headerlink" title="JDBCTemplate"></a>JDBCTemplate</h2><p>1、有了数据源(com.zaxxer.hikari.HikariDataSource)，然后可以拿到数据库连接(java.sql.Connection)，有了连接，就可以使用原生的 JDBC 语句来操作数据库；</p>
<p>2、即使不使用第三方第数据库操作框架，如 MyBatis等，Spring 本身也对原生的JDBC 做了轻量级的封装，即JdbcTemplate。</p>
<p>3、数据库操作的所有 CRUD 方法都在 JdbcTemplate 中。</p>
<p>4、Spring Boot 不仅提供了默认的数据源，同时默认已经配置好了 JdbcTemplate 放在了容器中，程序员只需自己注入即可使用</p>
<p>5、JdbcTemplate 的自动配置是依赖 org.springframework.boot.autoconfigure.jdbc 包下的 JdbcTemplateConfiguration 类</p>
<p><strong>JdbcTemplate主要提供以下几类方法：</strong></p>
<ul>
<li>execute方法：可以用于执行任何SQL语句，一般用于执行DDL语句；</li>
<li>update方法及batchUpdate方法：update方法用于执行新增、修改、删除等语句；batchUpdate方法用于执行批处理相关语句；</li>
<li>query方法及queryForXXX方法：用于执行查询相关语句；</li>
<li>call方法：用于执行存储过程、函数相关语句。</li>
</ul>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>编写一个Controller，注入 jdbcTemplate，编写测试方法进行访问测试；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">package com.kuang.controller;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">import java.util.Date;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/jdbc&quot;)</span><br><span class="line">public class JdbcController &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Spring Boot 默认提供了数据源，默认提供了 org.springframework.jdbc.core.JdbcTemplate</span><br><span class="line">     * JdbcTemplate 中会自己注入数据源，用于简化 JDBC操作</span><br><span class="line">     * 还能避免一些常见的错误,使用起来也不用再自己来关闭数据库连接</span><br><span class="line">     */</span><br><span class="line">    @Autowired</span><br><span class="line">    JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    //查询employee表中所有数据</span><br><span class="line">    //List 中的1个 Map 对应数据库的 1行数据</span><br><span class="line">    //Map 中的 key 对应数据库的字段名，value 对应数据库的字段值</span><br><span class="line">    @GetMapping(&quot;/list&quot;)</span><br><span class="line">    public List&lt;Map&lt;String, Object&gt;&gt; userList()&#123;</span><br><span class="line">        String sql = &quot;select * from employee&quot;;</span><br><span class="line">        List&lt;Map&lt;String, Object&gt;&gt; maps = jdbcTemplate.queryForList(sql);</span><br><span class="line">        return maps;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //新增一个用户</span><br><span class="line">    @GetMapping(&quot;/add&quot;)</span><br><span class="line">    public String addUser()&#123;</span><br><span class="line">        //插入语句，注意时间问题</span><br><span class="line">        String sql = &quot;insert into employee(last_name, email,gender,department,birth)&quot; +</span><br><span class="line">                &quot; values (&#x27;bai&#x27;,&#x27;25453@qq.com&#x27;,1,101,&#x27;&quot;+ new Date().toLocaleString() +&quot;&#x27;)&quot;;</span><br><span class="line">        jdbcTemplate.update(sql);</span><br><span class="line">        //查询</span><br><span class="line">        return &quot;addOk&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //修改用户信息</span><br><span class="line">    @GetMapping(&quot;/update/&#123;id&#125;&quot;)</span><br><span class="line">    public String updateUser(@PathVariable(&quot;id&quot;) int id)&#123;</span><br><span class="line">        //插入语句</span><br><span class="line">        String sql = &quot;update employee set last_name=?,email=? where id=&quot;+id;</span><br><span class="line">        //数据</span><br><span class="line">        Object[] objects = new Object[2];</span><br><span class="line">        objects[0] = &quot;秦&quot;;</span><br><span class="line">        objects[1] = &quot;25445465@qq.com&quot;;</span><br><span class="line">        jdbcTemplate.update(sql,objects);</span><br><span class="line">        //查询</span><br><span class="line">        return &quot;updateOk&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //删除用户</span><br><span class="line">    @GetMapping(&quot;/delete/&#123;id&#125;&quot;)</span><br><span class="line">    public String delUser(@PathVariable(&quot;id&quot;) int id)&#123;</span><br><span class="line">        //插入语句</span><br><span class="line">        String sql = &quot;delete from employee where id=?&quot;;</span><br><span class="line">        jdbcTemplate.update(sql,id);</span><br><span class="line">        //查询</span><br><span class="line">        return &quot;deleteOk&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>测试请求，结果正常；</p>
<p>到此，CURD的基本操作，使用 JDBC 就搞定了。</p>
]]></content>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot系列：自动配置原理</title>
    <url>/2023/01/12/SpringBoot%E7%B3%BB%E5%88%97%EF%BC%9A%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="分析自动配置原理"><a href="#分析自动配置原理" class="headerlink" title="分析自动配置原理"></a>分析自动配置原理</h2><p>我们以<strong>HttpEncodingAutoConfiguration（Http编码自动配置）</strong>为例解释自动配置原理；</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">//表示这是一个配置类，和以前编写的配置文件一样，也可以给容器中添加组件；</span><br><span class="line">@Configuration </span><br><span class="line"></span><br><span class="line">//启动指定类的ConfigurationProperties功能；</span><br><span class="line">  //进入这个HttpProperties查看，将配置文件中对应的值和HttpProperties绑定起来；</span><br><span class="line">  //并把HttpProperties加入到ioc容器中</span><br><span class="line">@EnableConfigurationProperties(&#123;HttpProperties.class&#125;) </span><br><span class="line"></span><br><span class="line">//Spring底层@Conditional注解</span><br><span class="line">  //根据不同的条件判断，如果满足指定的条件，整个配置类里面的配置就会生效；</span><br><span class="line">  //这里的意思就是判断当前应用是否是web应用，如果是，当前配置类生效</span><br><span class="line">@ConditionalOnWebApplication(</span><br><span class="line">    type = Type.SERVLET</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">//判断当前项目有没有这个类CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器；</span><br><span class="line">@ConditionalOnClass(&#123;CharacterEncodingFilter.class&#125;)</span><br><span class="line"></span><br><span class="line">//判断配置文件中是否存在某个配置：spring.http.encoding.enabled；</span><br><span class="line">  //如果不存在，判断也是成立的</span><br><span class="line">  //即使我们配置文件中不配置pring.http.encoding.enabled=true，也是默认生效的；</span><br><span class="line">@ConditionalOnProperty(</span><br><span class="line">    prefix = &quot;spring.http.encoding&quot;,</span><br><span class="line">    value = &#123;&quot;enabled&quot;&#125;,</span><br><span class="line">    matchIfMissing = true</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">public class HttpEncodingAutoConfiguration &#123;</span><br><span class="line">    //他已经和SpringBoot的配置文件映射了</span><br><span class="line">    private final Encoding properties;</span><br><span class="line">    //只有一个有参构造器的情况下，参数的值就会从容器中拿</span><br><span class="line">    public HttpEncodingAutoConfiguration(HttpProperties properties) &#123;</span><br><span class="line">        this.properties = properties.getEncoding();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //给容器中添加一个组件，这个组件的某些值需要从properties中获取</span><br><span class="line">    @Bean</span><br><span class="line">    @ConditionalOnMissingBean //判断容器没有这个组件？</span><br><span class="line">    public CharacterEncodingFilter characterEncodingFilter() &#123;</span><br><span class="line">        CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter();</span><br><span class="line">        filter.setEncoding(this.properties.getCharset().name());</span><br><span class="line">        filter.setForceRequestEncoding(this.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.REQUEST));</span><br><span class="line">        filter.setForceResponseEncoding(this.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.RESPONSE));</span><br><span class="line">        return filter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>一句话总结 ：根据当前不同的条件判断，决定这个配置类是否生效！</strong></p>
<ul>
<li>一但这个配置类生效；这个配置类就会给容器中添加各种组件；</li>
<li>这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的；</li>
<li>所有在配置文件中能配置的属性都是在xxxxProperties类中封装着；</li>
<li>配置文件能配置什么就可以参照某个功能对应的这个属性类</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//从配置文件中获取指定的值和bean的属性进行绑定</span><br><span class="line">@ConfigurationProperties(prefix = &quot;spring.http&quot;) </span><br><span class="line">public class HttpProperties &#123;</span><br><span class="line">    // .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们去配置文件里面试试前缀，看提示！</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/12/4lfo.png"></p>
<p><strong>这就是自动装配的原理！</strong></p>
<h2 id="精髓"><a href="#精髓" class="headerlink" title="精髓"></a>精髓</h2><p>1、SpringBoot启动会加载大量的自动配置类</p>
<p>2、我们看我们需要的功能有没有在SpringBoot默认写好的自动配置类当中；</p>
<p>3、我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件存在在其中，我们就不需要再手动配置了）</p>
<p>4、给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们只需要在配置文件中指定这些属性的值即可；</p>
<p><strong>xxxxAutoConfigurartion：自动配置类；</strong>给容器中添加组件</p>
<p><strong>xxxxProperties:封装配置文件中相关属性；</strong></p>
<h2 id="了解：-Conditional"><a href="#了解：-Conditional" class="headerlink" title="了解：@Conditional"></a>了解：@Conditional</h2><p>了解完自动装配的原理后，我们来关注一个细节问题，<strong>自动配置类必须在一定的条件下才能生效；</strong></p>
<p><strong>@Conditional派生注解（Spring注解版原生的@Conditional作用）</strong></p>
<p>作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效；</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/12/w76n.png"></p>
<p><strong>那么多的自动配置类，必须在一定的条件下才能生效；也就是说，我们加载了这么多的配置类，但不是所有的都生效了。</strong></p>
<p>我们怎么知道哪些自动配置类生效？</p>
<p><strong>我们可以通过启用 debug=true属性；来让控制台打印自动配置报告，这样我们就可以很方便的知道哪些自动配置类生效；</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#开启springboot的调试类debug=true</span><br></pre></td></tr></table></figure>
<p><strong>Positive matches:（自动配置类启用的：正匹配）</strong></p>
<p><strong>Negative matches:（没有启动，没有匹配成功的自动配置类：负匹配）</strong></p>
<p><strong>Unconditional classes: （没有条件的类）</strong></p>
]]></content>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot系列：Thymeleaf模板引擎</title>
    <url>/2023/01/14/SpringBoot%E7%B3%BB%E5%88%97%EF%BC%9AThymeleaf%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/</url>
    <content><![CDATA[<h2 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h2><p>前端交给我们的页面，是html页面。如果是我们以前开发，我们需要把他们转成jsp页面，jsp好处就是当我们查出一些数据转发到JSP页面以后，我们可以用jsp轻松实现数据的显示，及交互等。</p>
<span id="more"></span>
<p>jsp支持非常强大的功能，包括能写Java代码，但是呢，我们现在的这种情况，SpringBoot这个项目首先是以jar的方式，不是war，像第二，我们用的还是嵌入式的Tomcat，所以呢，<strong>他现在默认是不支持jsp的</strong>。</p>
<p>那不支持jsp，如果我们直接用纯静态页面的方式，那给我们开发会带来非常大的麻烦，那怎么办呢？</p>
<p><strong>SpringBoot推荐你可以来使用模板引擎：</strong></p>
<p>模板引擎，我们其实大家听到很多，其实jsp就是一个模板引擎，还有用的比较多的freemarker，包括SpringBoot给我们推荐的Thymeleaf，模板引擎有非常多，但再多的模板引擎，他们的思想都是一样的，什么样一个思想呢我们来看一下这张图：</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/14/87cb5m.png"></p>
<p>模板引擎的作用就是我们来写一个页面模板，比如有些值呢，是动态的，我们写一些表达式。而这些值，从哪来呢，就是我们在后台封装一些数据。然后把这个模板和这个数据交给我们模板引擎，模板引擎按照我们这个数据帮你把这表达式解析、填充到我们指定的位置，然后把这个数据最终生成一个我们想要的内容给我们写出去，这就是我们这个模板引擎，不管是jsp还是其他模板引擎，都是这个思想。只不过呢，就是说不同模板引擎之间，他们可能这个语法有点不一样。其他的我就不介绍了，我主要来介绍一下SpringBoot给我们推荐的Thymeleaf模板引擎，这模板引擎呢，是一个高级语言的模板引擎，他的这个语法更简单。而且呢，功能更强大。</p>
<p>我们呢，就来看一下这个模板引擎，那既然要看这个模板引擎。首先，我们来看SpringBoot里边怎么用。</p>
<h2 id="引入Thymeleaf"><a href="#引入Thymeleaf" class="headerlink" title="引入Thymeleaf"></a>引入Thymeleaf</h2><p>怎么引入呢，对于springboot来说，什么事情不都是一个start的事情嘛，我们去在项目中引入一下。给大家三个网址：</p>
<p>Thymeleaf 官网：<a href="https://www.thymeleaf.org/">https://www.thymeleaf.org/</a></p>
<p>Thymeleaf 在Github 的主页：<a href="https://github.com/thymeleaf/thymeleaf">https://github.com/thymeleaf/thymeleaf</a></p>
<p>Spring官方文档：找到我们对应的版本</p>
<p><a href="https://docs.spring.io/spring-boot/docs/2.2.5.RELEASE/reference/htmlsingle/#using-boot-starter">https://docs.spring.io/spring-boot/docs/2.2.5.RELEASE/reference/htmlsingle/#using-boot-starter</a> </p>
<p>找到对应的pom依赖：可以适当点进源码看下本来的包！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--thymeleaf--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>Maven会自动下载jar包，我们可以去看下下载的东西；</p>
<p>!<img src="https://i.p04e.com/baid/i/2023/01/14/61cxh.png"></p>
<h2 id="Thymeleaf分析"><a href="#Thymeleaf分析" class="headerlink" title="Thymeleaf分析"></a>Thymeleaf分析</h2><p>前面呢，我们已经引入了Thymeleaf，那这个要怎么使用呢？</p>
<p>我们首先得按照SpringBoot的自动配置原理看一下我们这个Thymeleaf的自动配置规则，在按照那个规则，我们进行使用。</p>
<p>我们去找一下Thymeleaf的自动配置类：ThymeleafProperties</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ConfigurationProperties(</span><br><span class="line">    prefix = &quot;spring.thymeleaf&quot;</span><br><span class="line">)</span><br><span class="line">public class ThymeleafProperties &#123;</span><br><span class="line">    private static final Charset DEFAULT_ENCODING;</span><br><span class="line">    public static final String DEFAULT_PREFIX = &quot;classpath:/templates/&quot;;</span><br><span class="line">    public static final String DEFAULT_SUFFIX = &quot;.html&quot;;</span><br><span class="line">    private boolean checkTemplate = true;</span><br><span class="line">    private boolean checkTemplateLocation = true;</span><br><span class="line">    private String prefix = &quot;classpath:/templates/&quot;;</span><br><span class="line">    private String suffix = &quot;.html&quot;;</span><br><span class="line">    private String mode = &quot;HTML&quot;;</span><br><span class="line">    private Charset encoding;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以在其中看到默认的前缀和后缀！</p>
<p>我们只需要把我们的html页面放在类路径下的templates下，thymeleaf就可以帮我们自动渲染了。</p>
<p>使用thymeleaf什么都不需要配置，只需要将他放在指定的文件夹下即可！</p>
<p><strong>测试</strong></p>
<p>1、编写一个TestController</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class TestController &#123;</span><br><span class="line">    </span><br><span class="line">    @RequestMapping(&quot;/t1&quot;)</span><br><span class="line">    public String test1()&#123;</span><br><span class="line">        //classpath:/templates/test.html</span><br><span class="line">        return &quot;test&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、编写一个测试页面  test.html 放在 templates 目录下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;测试页面&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>3、启动项目请求测试</p>
<h2 id="Thymeleaf-语法学习"><a href="#Thymeleaf-语法学习" class="headerlink" title="Thymeleaf 语法学习"></a>Thymeleaf 语法学习</h2><p>要学习语法，还是参考官网文档最为准确，我们找到对应的版本看一下；</p>
<p>Thymeleaf 官网：<a href="https://www.thymeleaf.org/">https://www.thymeleaf.org/</a> ， 简单看一下官网！我们去下载Thymeleaf的官方文档！</p>
<p><strong>我们做个最简单的练习 ：我们需要查出一些数据，在页面中展示</strong></p>
<p>1、修改测试请求，增加数据传输；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequestMapping(&quot;/t1&quot;)</span><br><span class="line">public String test1(Model model)&#123;</span><br><span class="line">    //存入数据</span><br><span class="line">    model.addAttribute(&quot;msg&quot;,&quot;Hello,Thymeleaf&quot;);</span><br><span class="line">    //classpath:/templates/test.html</span><br><span class="line">    return &quot;test&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、我们要使用thymeleaf，需要在html文件中导入命名空间的约束，方便提示。</p>
<p>我们可以去官方文档的#3中看一下命名空间拿来过来：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xmlns:th=&quot;http://www.thymeleaf.org&quot;</span><br></pre></td></tr></table></figure>
<p>3、我们去编写下前端页面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;测试页面&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--th:text就是将div中的内容设置为它指定的值，和之前学习的Vue一样--&gt;</span><br><span class="line">&lt;div th:text=&quot;$&#123;msg&#125;&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>4、启动测试！</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Idia351qHgmH2vbzurk1Pp6ia0fYFrNsXdHekjLfPlq4ZMpF0rtPzFRBTWsw6K8zic3ywna1LgcM6Gw/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p>
<p><strong>OK，入门搞定，我们来认真研习一下Thymeleaf的使用语法！</strong></p>
<p><strong>1、我们可以使用任意的 th:attr 来替换Html中原生属性的值！</strong></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Idia351qHgmH2vbzurk1Pp6fGYIwv043icVDYuybRJDCGTSNTMEibFzzMdlKS4t07TQoicQJKQAe0slQ/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p>
<p>1、 我们编写一个Controller，放一些数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequestMapping(&quot;/t2&quot;)</span><br><span class="line">public String test2(Map&lt;String,Object&gt; map)&#123;</span><br><span class="line">    //存入数据</span><br><span class="line">    map.put(&quot;msg&quot;,&quot;&lt;h1&gt;Hello&lt;/h1&gt;&quot;);</span><br><span class="line">    map.put(&quot;users&quot;, Arrays.asList(&quot;qinjiang&quot;,&quot;kuangshen&quot;));</span><br><span class="line">    //classpath:/templates/test.html</span><br><span class="line">    return &quot;test&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、测试页面取出数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;div th:text=&quot;$&#123;msg&#125;&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;!--不转义--&gt;</span><br><span class="line">&lt;div th:utext=&quot;$&#123;msg&#125;&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--遍历数据--&gt;</span><br><span class="line">&lt;!--th:each每次遍历都会生成当前这个标签：官网#9--&gt;</span><br><span class="line">&lt;h4 th:each=&quot;user :$&#123;users&#125;&quot; th:text=&quot;$&#123;user&#125;&quot;&gt;&lt;/h4&gt;</span><br><span class="line"></span><br><span class="line">&lt;h4&gt;</span><br><span class="line">    &lt;!--行内写法：官网#12--&gt;</span><br><span class="line">    &lt;span th:each=&quot;user:$&#123;users&#125;&quot;&gt;[[$&#123;user&#125;]]&lt;/span&gt;</span><br><span class="line">&lt;/h4&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>3、启动项目测试！</p>
<p><strong>我们看完语法，很多样式，我们即使现在学习了，也会忘记，所以我们在学习过程中，需要使用什么，根据官方文档来查询，才是最重要的，要熟练使用官方文档！</strong></p>
]]></content>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Thymeleaf</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot系列：MVC自动配置原理</title>
    <url>/2023/01/14/SpringBoot%E7%B3%BB%E5%88%97%EF%BC%9AMVC%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>官网阅读</p>
<p>在进行项目编写前，我们还需要知道一个东西，就是SpringBoot对我们的SpringMVC还做了哪些配置，包括如何扩展，如何定制。</p>
<span id="more"></span>
<p>只有把这些都搞清楚了，我们在之后使用才会更加得心应手。途径一：源码分析，途径二：官方文档！</p>
<p>地址 ：<a href="https://docs.spring.io/spring-boot/docs/2.2.5.RELEASE/reference/htmlsingle/#boot-features-spring-mvc-auto-configuration">https://docs.spring.io/spring-boot/docs/2.2.5.RELEASE/reference/htmlsingle/#boot-features-spring-mvc-auto-configuration</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Spring MVC Auto-configuration</span><br><span class="line">// Spring Boot为Spring MVC提供了自动配置，它可以很好地与大多数应用程序一起工作。</span><br><span class="line">Spring Boot provides auto-configuration for Spring MVC that works well with most applications.</span><br><span class="line">// 自动配置在Spring默认设置的基础上添加了以下功能：</span><br><span class="line">The auto-configuration adds the following features on top of Spring’s defaults:</span><br><span class="line">// 包含视图解析器</span><br><span class="line">Inclusion of ContentNegotiatingViewResolver and BeanNameViewResolver beans.</span><br><span class="line">// 支持静态资源文件夹的路径，以及webjars</span><br><span class="line">Support for serving static resources, including support for WebJars </span><br><span class="line">// 自动注册了Converter：</span><br><span class="line">// 转换器，这就是我们网页提交数据到后台自动封装成为对象的东西，比如把&quot;1&quot;字符串自动转换为int类型</span><br><span class="line">// Formatter：【格式化器，比如页面给我们了一个2019-8-10，它会给我们自动格式化为Date对象】</span><br><span class="line">Automatic registration of Converter, GenericConverter, and Formatter beans.</span><br><span class="line">// HttpMessageConverters</span><br><span class="line">// SpringMVC用来转换Http请求和响应的的，比如我们要把一个User对象转换为JSON字符串，可以去看官网文档解释；</span><br><span class="line">Support for HttpMessageConverters (covered later in this document).</span><br><span class="line">// 定义错误代码生成规则的</span><br><span class="line">Automatic registration of MessageCodesResolver (covered later in this document).</span><br><span class="line">// 首页定制</span><br><span class="line">Static index.html support.</span><br><span class="line">// 图标定制</span><br><span class="line">Custom Favicon support (covered later in this document).</span><br><span class="line">// 初始化数据绑定器：帮我们把请求数据绑定到JavaBean中！</span><br><span class="line">Automatic use of a ConfigurableWebBindingInitializer bean (covered later in this document).</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">如果您希望保留Spring Boot MVC功能，并且希望添加其他MVC配置（拦截器、格式化程序、视图控制器和其他功能），则可以添加自己</span><br><span class="line">的@configuration类，类型为webmvcconfiguer，但不添加@EnableWebMvc。如果希望提供</span><br><span class="line">RequestMappingHandlerMapping、RequestMappingHandlerAdapter或ExceptionHandlerExceptionResolver的自定义</span><br><span class="line">实例，则可以声明WebMVCregistrationAdapter实例来提供此类组件。</span><br><span class="line">*/</span><br><span class="line">If you want to keep Spring Boot MVC features and you want to add additional MVC configuration </span><br><span class="line">(interceptors, formatters, view controllers, and other features), you can add your own </span><br><span class="line">@Configuration class of type WebMvcConfigurer but without @EnableWebMvc. If you wish to provide </span><br><span class="line">custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter, or </span><br><span class="line">ExceptionHandlerExceptionResolver, you can declare a WebMvcRegistrationsAdapter instance to provide such components.</span><br><span class="line"></span><br><span class="line">// 如果您想完全控制Spring MVC，可以添加自己的@Configuration，并用@EnableWebMvc进行注释。</span><br><span class="line">If you want to take complete control of Spring MVC, you can add your own @Configuration annotated with @EnableWebMvc.</span><br></pre></td></tr></table></figure>
<p>我们来仔细对照，看一下它怎么实现的，它告诉我们SpringBoot已经帮我们自动配置好了SpringMVC，然后自动配置了哪些东西呢？</p>
<h2 id="ContentNegotiatingViewResolver-内容协商视图解析器"><a href="#ContentNegotiatingViewResolver-内容协商视图解析器" class="headerlink" title="ContentNegotiatingViewResolver 内容协商视图解析器"></a><strong>ContentNegotiatingViewResolver 内容协商视图解析器</strong></h2><p>自动配置了ViewResolver，就是我们之前学习的SpringMVC的视图解析器；</p>
<p>即根据方法的返回值取得视图对象（View），然后由视图对象决定如何渲染（转发，重定向）。</p>
<p>我们去看看这里的源码：我们找到 WebMvcAutoConfiguration ， 然后搜索ContentNegotiatingViewResolver。找到如下方法！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">@ConditionalOnBean(ViewResolver.class)</span><br><span class="line">@ConditionalOnMissingBean(name = &quot;viewResolver&quot;, value = ContentNegotiatingViewResolver.class)</span><br><span class="line">public ContentNegotiatingViewResolver viewResolver(BeanFactory beanFactory) &#123;</span><br><span class="line">    ContentNegotiatingViewResolver resolver = new ContentNegotiatingViewResolver();</span><br><span class="line">    resolver.setContentNegotiationManager(beanFactory.getBean(ContentNegotiationManager.class));</span><br><span class="line">    // ContentNegotiatingViewResolver使用所有其他视图解析器来定位视图，因此它应该具有较高的优先级</span><br><span class="line">    resolver.setOrder(Ordered.HIGHEST_PRECEDENCE);</span><br><span class="line">    return resolver;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以点进这类看看！找到对应的解析视图的代码；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@Nullable // 注解说明：@Nullable 即参数可为null</span><br><span class="line">public View resolveViewName(String viewName, Locale locale) throws Exception &#123;</span><br><span class="line">    RequestAttributes attrs = RequestContextHolder.getRequestAttributes();</span><br><span class="line">    Assert.state(attrs instanceof ServletRequestAttributes, &quot;No current ServletRequestAttributes&quot;);</span><br><span class="line">    List&lt;MediaType&gt; requestedMediaTypes = this.getMediaTypes(((ServletRequestAttributes)attrs).getRequest());</span><br><span class="line">    if (requestedMediaTypes != null) &#123;</span><br><span class="line">        // 获取候选的视图对象</span><br><span class="line">        List&lt;View&gt; candidateViews = this.getCandidateViews(viewName, locale, requestedMediaTypes);</span><br><span class="line">        // 选择一个最适合的视图对象，然后把这个对象返回</span><br><span class="line">        View bestView = this.getBestView(candidateViews, requestedMediaTypes, attrs);</span><br><span class="line">        if (bestView != null) &#123;</span><br><span class="line">            return bestView;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们继续点进去看，他是怎么获得候选的视图的呢？</p>
<p>getCandidateViews中看到他是把所有的视图解析器拿来，进行while循环，挨个解析！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Iterator var5 = this.viewResolvers.iterator();</span><br></pre></td></tr></table></figure>
<p>所以得出结论：<strong>ContentNegotiatingViewResolver 这个视图解析器就是用来组合所有的视图解析器的</strong> </p>
<p>我们再去研究下他的组合逻辑，看到有个属性viewResolvers，看看它是在哪里进行赋值的！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">protected void initServletContext(ServletContext servletContext) &#123;</span><br><span class="line">    // 这里它是从beanFactory工具中获取容器中的所有视图解析器</span><br><span class="line">    // ViewRescolver.class 把所有的视图解析器来组合的</span><br><span class="line">    Collection&lt;ViewResolver&gt; matchingBeans = BeanFactoryUtils.beansOfTypeIncludingAncestors(this.obtainApplicationContext(), ViewResolver.class).values();</span><br><span class="line">    ViewResolver viewResolver;</span><br><span class="line">    if (this.viewResolvers == null) &#123;</span><br><span class="line">        this.viewResolvers = new ArrayList(matchingBeans.size());</span><br><span class="line">    &#125;</span><br><span class="line">    // ...............</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>既然它是在容器中去找视图解析器，我们是否可以猜想，我们就可以去实现一个视图解析器了呢？</p>
<p>我们可以自己给容器中去添加一个视图解析器；这个类就会帮我们自动的将它组合进来；<strong>我们去实现一下</strong></p>
<p>1、我们在我们的主程序中去写一个视图解析器来试试；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected void initServletContext(ServletContext servletContext) &#123;</span><br><span class="line">    // 这里它是从beanFactory工具中获取容器中的所有视图解析器</span><br><span class="line">    // ViewRescolver.class 把所有的视图解析器来组合的</span><br><span class="line">    Collection&lt;ViewResolver&gt; matchingBeans = BeanFactoryUtils.beansOfTypeIncludingAncestors(this.obtainApplicationContext(), ViewResolver.class).values();</span><br><span class="line">    ViewResolver viewResolver;</span><br><span class="line">    if (this.viewResolvers == null) &#123;</span><br><span class="line">        this.viewResolvers = new ArrayList(matchingBeans.size());</span><br><span class="line">    &#125;</span><br><span class="line">    // ...............</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、怎么看我们自己写的视图解析器有没有起作用呢？</p>
<p>我们给 DispatcherServlet 中的 doDispatch方法 加个断点进行调试一下，因为所有的请求都会走到这个方法中</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/14/oy2.png"></p>
<p>3、我们启动我们的项目，然后随便访问一个页面，看一下Debug信息；</p>
<p>找到this</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/14/y2ce.png"></p>
<p>找到视图解析器，我们看到我们自己定义的就在这里了；</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/14/y5v7.png"></p>
<p>所以说，我们如果想要使用自己定制化的东西，我们只需要给容器中添加这个组件就好了！剩下的事情SpringBoot就会帮我们做了！</p>
<h2 id="转换器和格式化器"><a href="#转换器和格式化器" class="headerlink" title="转换器和格式化器"></a>转换器和格式化器</h2><p>找到格式化转换器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">@Override</span><br><span class="line">public FormattingConversionService mvcConversionService() &#123;</span><br><span class="line">    // 拿到配置文件中的格式化规则</span><br><span class="line">    WebConversionService conversionService = </span><br><span class="line">        new WebConversionService(this.mvcProperties.getDateFormat());</span><br><span class="line">    addFormatters(conversionService);</span><br><span class="line">    return conversionService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>点击去：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public String getDateFormat() &#123;</span><br><span class="line">    return this.dateFormat;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* Date format to use. For instance, `dd/MM/yyyy`. 默认的</span><br><span class="line"> */</span><br><span class="line">private String dateFormat;</span><br></pre></td></tr></table></figure>
<p>可以看到在我们的Properties文件中，我们可以进行自动配置它！</p>
<p>如果配置了自己的格式化方式，就会注册到Bean中生效，我们可以在配置文件中配置日期格式化的规则：</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/14/4vm5.png"></p>
<p>其余的就不一一举例了，大家可以下去多研究探讨即可！</p>
<h2 id="修改SpringBoot的默认配置"><a href="#修改SpringBoot的默认配置" class="headerlink" title="修改SpringBoot的默认配置"></a>修改SpringBoot的默认配置</h2><p>这么多的自动配置，原理都是一样的，通过这个WebMVC的自动配置原理分析，我们要学会一种学习方式，通过源码探究，得出结论；这个结论一定是属于自己的，而且一通百通。</p>
<p>SpringBoot的底层，大量用到了这些设计细节思想，所以，没事需要多阅读源码！得出结论；</p>
<p>SpringBoot在自动配置很多组件的时候，先看容器中有没有用户自己配置的（如果用户自己配置@bean），如果有就用用户配置的，如果没有就用自动配置的；</p>
<p>如果有些组件可以存在多个，比如我们的视图解析器，就将用户配置的和自己默认的组合起来！</p>
<p><strong>扩展使用SpringMVC</strong>  官方文档如下：</p>
<p>If you want to keep Spring Boot MVC features and you want to add additional MVC configuration (interceptors, formatters, view controllers, and other features), you can add your own @Configuration class of type WebMvcConfigurer but without @EnableWebMvc. If you wish to provide custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter, or ExceptionHandlerExceptionResolver, you can declare a WebMvcRegistrationsAdapter instance to provide such components.</p>
<p>我们要做的就是编写一个@Configuration注解类，并且类型要为WebMvcConfigurer，还不能标注@EnableWebMvc注解；我们去自己写一个；我们新建一个包叫config，写一个类MyMvcConfig；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">//应为类型要求为WebMvcConfigurer，所以我们实现其接口</span><br><span class="line">//可以使用自定义类扩展MVC的功能</span><br><span class="line">@Configuration</span><br><span class="line">public class MyMvcConfig implements WebMvcConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void addViewControllers(ViewControllerRegistry registry) &#123;</span><br><span class="line">        // 浏览器发送/test ， 就会跳转到test页面；</span><br><span class="line">        registry.addViewController(&quot;/test&quot;).setViewName(&quot;test&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们去浏览器访问一下：</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/14/ozk.png"></p>
<p><strong>确实也跳转过来了！所以说，我们要扩展SpringMVC，官方就推荐我们这么去使用，既保SpringBoot留所有的自动配置，也能用我们扩展的配置！</strong></p>
<p>我们可以去分析一下原理：</p>
<p>1、WebMvcAutoConfiguration 是 SpringMVC的自动配置类，里面有一个类WebMvcAutoConfigurationAdapter</p>
<p>2、这个类上有一个注解，在做其他自动配置时会导入：@Import(EnableWebMvcConfiguration.class)</p>
<p>3、我们点进EnableWebMvcConfiguration这个类看一下，它继承了一个父类：DelegatingWebMvcConfiguration</p>
<p>这个父类中有这样一段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport &#123;</span><br><span class="line">    private final WebMvcConfigurerComposite configurers = new WebMvcConfigurerComposite();</span><br><span class="line">    </span><br><span class="line">  // 从容器中获取所有的webmvcConfigurer</span><br><span class="line">    @Autowired(required = false)</span><br><span class="line">    public void setConfigurers(List&lt;WebMvcConfigurer&gt; configurers) &#123;</span><br><span class="line">        if (!CollectionUtils.isEmpty(configurers)) &#123;</span><br><span class="line">            this.configurers.addWebMvcConfigurers(configurers);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4、我们可以在这个类中去寻找一个我们刚才设置的viewController当做参考，发现它调用了一个</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected void addViewControllers(ViewControllerRegistry registry) &#123;</span><br><span class="line">    this.configurers.addViewControllers(registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5、我们点进去看一下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public void addViewControllers(ViewControllerRegistry registry) &#123;</span><br><span class="line">    Iterator var2 = this.delegates.iterator();</span><br><span class="line"></span><br><span class="line">    while(var2.hasNext()) &#123;</span><br><span class="line">        // 将所有的WebMvcConfigurer相关配置来一起调用！包括我们自己配置的和Spring给我们配置的</span><br><span class="line">        WebMvcConfigurer delegate = (WebMvcConfigurer)var2.next();</span><br><span class="line">        delegate.addViewControllers(registry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以得出结论：所有的WebMvcConfiguration都会被作用，不止Spring自己的配置类，我们自己的配置类当然也会被调用；</p>
<h2 id="全面接管SpringMVC"><a href="#全面接管SpringMVC" class="headerlink" title="全面接管SpringMVC"></a>全面接管SpringMVC</h2><p>官方文档：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">If you want to take complete control of Spring MVC</span><br><span class="line">you can add your own @Configuration annotated with @EnableWebMvc.</span><br></pre></td></tr></table></figure>
<p>全面接管即：SpringBoot对SpringMVC的自动配置不需要了，所有都是我们自己去配置！</p>
<p>只需在我们的配置类中要加一个@EnableWebMvc。</p>
<p>我们看下如果我们全面接管了SpringMVC了，我们之前SpringBoot给我们配置的静态资源映射一定会无效，我们可以去测试一下；</p>
<p>不加注解之前，访问首页：</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/14/p61.png"></p>
<p>给配置类加上注解：@EnableWebMvc</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/14/4w7q.png"></p>
<p>我们发现所有的SpringMVC自动配置都失效了！回归到了最初的样子；</p>
<p><strong>当然，我们开发中，不推荐使用全面接管SpringMVC</strong></p>
<p>思考问题？为什么加了一个注解，自动配置就失效了！我们看下源码：</p>
<p>1、这里发现它是导入了一个类，我们可以继续进去看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Import(&#123;DelegatingWebMvcConfiguration.class&#125;)</span><br><span class="line">public @interface EnableWebMvc &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、它继承了一个父类 WebMvcConfigurationSupport</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport &#123;</span><br><span class="line">  // ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、我们来回顾一下Webmvc自动配置类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration(proxyBeanMethods = false)</span><br><span class="line">@ConditionalOnWebApplication(type = Type.SERVLET)</span><br><span class="line">@ConditionalOnClass(&#123; Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class &#125;)</span><br><span class="line">// 这个注解的意思就是：容器中没有这个组件的时候，这个自动配置类才生效</span><br><span class="line">@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)</span><br><span class="line">@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)</span><br><span class="line">@AutoConfigureAfter(&#123; DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class,</span><br><span class="line">    ValidationAutoConfiguration.class &#125;)</span><br><span class="line">public class WebMvcAutoConfiguration &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结一句话：@EnableWebMvc将WebMvcConfigurationSupport组件导入进来了；</p>
<p>而导入的WebMvcConfigurationSupport只是SpringMVC最基本的功能！</p>
<p><strong>在SpringBoot中会有非常多的扩展配置，只要看见了这个，我们就应该多留心注意~</strong></p>
]]></content>
      <tags>
        <tag>SpringBoot</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot：集成Swagger</title>
    <url>/2023/01/15/SpringBoot%EF%BC%9A%E9%9B%86%E6%88%90Swagger/</url>
    <content><![CDATA[<h3 id="Swagger简介"><a href="#Swagger简介" class="headerlink" title="Swagger简介"></a>Swagger简介</h3><p><strong>前后端分离</strong></p>
<ul>
<li>前端 -&gt; 前端控制层、视图层</li>
<li>后端 -&gt; 后端控制层、服务层、数据访问层</li>
<li>前后端通过API进行交互</li>
<li>前后端相对独立且松耦合<span id="more"></span></li>
</ul>
<p><strong>产生的问题</strong></p>
<ul>
<li>前后端集成，前端或者后端无法做到“及时协商，尽早解决”，最终导致问题集中爆发</li>
</ul>
<p><strong>解决方案</strong></p>
<ul>
<li>首先定义schema [ 计划的提纲 ]，并实时跟踪最新的API，降低集成风险</li>
</ul>
<p><strong>Swagger</strong></p>
<ul>
<li>号称世界上最流行的API框架</li>
<li>Restful Api 文档在线自动生成器 =&gt; <strong>API 文档 与API 定义同步更新</strong></li>
<li>直接运行，在线测试API</li>
<li>支持多种语言 （如：Java，PHP等）</li>
<li>官网：<a href="https://swagger.io/">https://swagger.io/</a></li>
</ul>
<h3 id="SpringBoot集成Swagger"><a href="#SpringBoot集成Swagger" class="headerlink" title="SpringBoot集成Swagger"></a>SpringBoot集成Swagger</h3><p><strong>SpringBoot集成Swagger</strong> =&gt; <strong>springfox</strong>，两个jar包</p>
<ul>
<li><strong>Springfox-swagger2</strong></li>
<li>swagger-springmvc</li>
</ul>
<p><strong>使用Swagger</strong></p>
<p>要求：jdk 1.8 + 否则swagger2无法运行</p>
<p>步骤：</p>
<p>1、新建一个SpringBoot-web项目</p>
<p>2、添加Maven依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger2 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;2.9.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger-ui --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;2.9.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>3、编写HelloController，测试确保运行成功！</p>
<p>4、要使用Swagger，我们需要编写一个配置类-SwaggerConfig来配置 Swagger</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration //配置类</span><br><span class="line">@EnableSwagger2// 开启Swagger2的自动配置</span><br><span class="line">public class SwaggerConfig &#123;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5、访问测试 ：<a href="http://localhost:8080/swagger-ui.html">http://localhost:8080/swagger-ui.html</a> ，可以看到swagger的界面；</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/15/m6f9.png"></p>
<h3 id="配置Swagger"><a href="#配置Swagger" class="headerlink" title="配置Swagger"></a>配置Swagger</h3><p>1、Swagger实例Bean是Docket，所以通过配置Docket实例来配置Swaggger。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean //配置docket以配置Swagger具体参数</span><br><span class="line">public Docket docket() &#123;</span><br><span class="line">   return new Docket(DocumentationType.SWAGGER_2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、可以通过apiInfo()属性配置文档信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//配置文档信息</span><br><span class="line">private ApiInfo apiInfo() &#123;</span><br><span class="line">   Contact contact = new Contact(&quot;联系人名字&quot;, &quot;http://xxx.xxx.com/联系人访问链接&quot;, &quot;联系人邮箱&quot;);</span><br><span class="line">   return new ApiInfo(</span><br><span class="line">           &quot;Swagger学习&quot;, // 标题</span><br><span class="line">           &quot;学习演示如何配置Swagger&quot;, // 描述</span><br><span class="line">           &quot;v1.0&quot;, // 版本</span><br><span class="line">           &quot;http://terms.service.url/组织链接&quot;, // 组织链接</span><br><span class="line">           contact, // 联系人信息</span><br><span class="line">           &quot;Apach 2.0 许可&quot;, // 许可</span><br><span class="line">           &quot;许可链接&quot;, // 许可连接</span><br><span class="line">           new ArrayList&lt;&gt;()// 扩展</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、Docket 实例关联上 apiInfo()</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public Docket docket() &#123;</span><br><span class="line">   return new Docket(DocumentationType.SWAGGER_2).apiInfo(apiInfo());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4、重启项目，访问测试 <a href="http://localhost:8080/swagger-ui.html">http://localhost:8080/swagger-ui.html</a>  看下效果；</p>
<h3 id="配置扫描接口"><a href="#配置扫描接口" class="headerlink" title="配置扫描接口"></a>配置扫描接口</h3><p>1、构建Docket时通过select()方法配置怎么扫描接口。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public Docket docket() &#123;</span><br><span class="line">   return new Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">      .apiInfo(apiInfo())</span><br><span class="line">      .select()// 通过.select()方法，去配置扫描接口,RequestHandlerSelectors配置如何扫描接口</span><br><span class="line">      .apis(RequestHandlerSelectors.basePackage(&quot;com.kuang.swagger.controller&quot;))</span><br><span class="line">      .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、重启项目测试，由于我们配置根据包的路径扫描接口，所以我们只能看到一个类</p>
<p>3、除了通过包路径配置扫描接口外，还可以通过配置其他方式扫描接口，这里注释一下所有的配置方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">any() // 扫描所有，项目中的所有接口都会被扫描到</span><br><span class="line">none() // 不扫描接口</span><br><span class="line">// 通过方法上的注解扫描，如withMethodAnnotation(GetMapping.class)只扫描get请求</span><br><span class="line">withMethodAnnotation(final Class&lt;? extends Annotation&gt; annotation)</span><br><span class="line">// 通过类上的注解扫描，如.withClassAnnotation(Controller.class)只扫描有controller注解的类中的接口</span><br><span class="line">withClassAnnotation(final Class&lt;? extends Annotation&gt; annotation)</span><br><span class="line">basePackage(final String basePackage) // 根据包路径扫描接口</span><br></pre></td></tr></table></figure>
<p>4、除此之外，我们还可以配置接口扫描过滤：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public Docket docket() &#123;</span><br><span class="line">   return new Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">      .apiInfo(apiInfo())</span><br><span class="line">      .select()// 通过.select()方法，去配置扫描接口,RequestHandlerSelectors配置如何扫描接口</span><br><span class="line">      .apis(RequestHandlerSelectors.basePackage(&quot;com.kuang.swagger.controller&quot;))</span><br><span class="line">       // 配置如何通过path过滤,即这里只扫描请求以/kuang开头的接口</span><br><span class="line">      .paths(PathSelectors.ant(&quot;/kuang/**&quot;))</span><br><span class="line">      .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5、这里的可选值还有</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">any() // 任何请求都扫描</span><br><span class="line">none() // 任何请求都不扫描</span><br><span class="line">regex(final String pathRegex) // 通过正则表达式控制</span><br><span class="line">ant(final String antPattern) // 通过ant()控制</span><br></pre></td></tr></table></figure>
<p><img src="https://i.p04e.com/baid/i/2023/01/15/2y28.png"></p>
<h3 id><a href="#" class="headerlink" title=" "></a> </h3><h3 id="配置Swagger开关"><a href="#配置Swagger开关" class="headerlink" title="配置Swagger开关"></a>配置Swagger开关</h3><p>1、通过enable()方法配置是否启用swagger，如果是false，swagger将不能在浏览器中访问了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public Docket docket() &#123;</span><br><span class="line">   return new Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">      .apiInfo(apiInfo())</span><br><span class="line">      .enable(false) //配置是否启用Swagger，如果是false，在浏览器将无法访问</span><br><span class="line">      .select()// 通过.select()方法，去配置扫描接口,RequestHandlerSelectors配置如何扫描接口</span><br><span class="line">      .apis(RequestHandlerSelectors.basePackage(&quot;com.kuang.swagger.controller&quot;))</span><br><span class="line">       // 配置如何通过path过滤,即这里只扫描请求以/kuang开头的接口</span><br><span class="line">      .paths(PathSelectors.ant(&quot;/kuang/**&quot;))</span><br><span class="line">      .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、如何动态配置当项目处于test、dev环境时显示swagger，处于prod时不显示？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public Docket docket(Environment environment) &#123;</span><br><span class="line">   // 设置要显示swagger的环境</span><br><span class="line">   Profiles of = Profiles.of(&quot;dev&quot;, &quot;test&quot;);</span><br><span class="line">   // 判断当前是否处于该环境</span><br><span class="line">   // 通过 enable() 接收此参数判断是否要显示</span><br><span class="line">   boolean b = environment.acceptsProfiles(of);</span><br><span class="line">   </span><br><span class="line">   return new Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">      .apiInfo(apiInfo())</span><br><span class="line">      .enable(b) //配置是否启用Swagger，如果是false，在浏览器将无法访问</span><br><span class="line">      .select()// 通过.select()方法，去配置扫描接口,RequestHandlerSelectors配置如何扫描接口</span><br><span class="line">      .apis(RequestHandlerSelectors.basePackage(&quot;com.kuang.swagger.controller&quot;))</span><br><span class="line">       // 配置如何通过path过滤,即这里只扫描请求以/kuang开头的接口</span><br><span class="line">      .paths(PathSelectors.ant(&quot;/kuang/**&quot;))</span><br><span class="line">      .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、可以在项目中增加一个dev的配置文件查看效果！</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/15/280.png"></p>
<h3 id="配置API分组"><a href="#配置API分组" class="headerlink" title="配置API分组"></a>配置API分组</h3><p><img src="https://i.p04e.com/baid/i/2023/01/15/33ce.png"></p>
<p>1、如果没有配置分组，默认是default。通过groupName()方法即可配置分组：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public Docket docket(Environment environment) &#123;</span><br><span class="line">   return new Docket(DocumentationType.SWAGGER_2).apiInfo(apiInfo())</span><br><span class="line">      .groupName(&quot;hello&quot;) // 配置分组</span><br><span class="line">       // 省略配置....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、重启项目查看分组</p>
<p>3、如何配置多个分组？配置多个分组只需要配置多个docket即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public Docket docket1()&#123;</span><br><span class="line">   return new Docket(DocumentationType.SWAGGER_2).groupName(&quot;group1&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@Bean</span><br><span class="line">public Docket docket2()&#123;</span><br><span class="line">   return new Docket(DocumentationType.SWAGGER_2).groupName(&quot;group2&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@Bean</span><br><span class="line">public Docket docket3()&#123;</span><br><span class="line">   return new Docket(DocumentationType.SWAGGER_2).groupName(&quot;group3&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4、重启项目查看即可</p>
<h3 id="实体配置"><a href="#实体配置" class="headerlink" title="实体配置"></a>实体配置</h3><p>1、新建一个实体类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ApiModel(&quot;用户实体&quot;)</span><br><span class="line">public class User &#123;</span><br><span class="line">   @ApiModelProperty(&quot;用户名&quot;)</span><br><span class="line">   public String username;</span><br><span class="line">   @ApiModelProperty(&quot;密码&quot;)</span><br><span class="line">   public String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、只要这个实体在<strong>请求接口</strong>的返回值上（即使是泛型），都能映射到实体项中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequestMapping(&quot;/getUser&quot;)</span><br><span class="line">public User getUser()&#123;</span><br><span class="line">   return new User();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、重启查看测试</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/15/36qu.png"></p>
<p>注：并不是因为@ApiModel这个注解让实体显示在这里了，而是只要出现在接口方法的返回值上的实体都会显示在这里，而@ApiModel和@ApiModelProperty这两个注解只是为实体添加注释的。</p>
<p>@ApiModel为类添加注释</p>
<p>@ApiModelProperty为类属性添加注释</p>
<h3 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h3><p>Swagger的所有注解定义在io.swagger.annotations包下</p>
<p>下面列一些经常用到的，未列举出来的可以另行查阅说明：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Swagger注解</th>
<th>简单说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>@Api(tags = “xxx模块说明”)</td>
<td>作用在模块类上</td>
</tr>
<tr>
<td>@ApiOperation(“xxx接口说明”)</td>
<td>作用在接口方法上</td>
</tr>
<tr>
<td>@ApiModel(“xxxPOJO说明”)</td>
<td>作用在模型类上：如VO、BO</td>
</tr>
<tr>
<td>@ApiModelProperty(value = “xxx属性说明”,hidden = true)</td>
<td>作用在类方法和属性上，hidden设置为true可以隐藏该属性</td>
</tr>
<tr>
<td>@ApiParam(“xxx参数说明”)</td>
<td>作用在参数、方法和字段上，类似@ApiModelProperty</td>
</tr>
</tbody>
</table>
</div>
<p>我们也可以给请求的接口配置一些注释</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ApiOperation(&quot;狂神的接口&quot;)</span><br><span class="line">@PostMapping(&quot;/kuang&quot;)</span><br><span class="line">@ResponseBody</span><br><span class="line">public String kuang(@ApiParam(&quot;这个名字会被返回&quot;)String username)&#123;</span><br><span class="line">   return username;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的话，可以给一些比较难理解的属性或者接口，增加一些配置信息，让人更容易阅读！</p>
<p>相较于传统的Postman或Curl方式测试接口，使用swagger简直就是傻瓜式操作，不需要额外说明文档(写得好本身就是文档)而且更不容易出错，只需要录入数据然后点击Execute，如果再配合自动化框架，可以说基本就不需要人为操作了。</p>
<p>Swagger是个优秀的工具，现在国内已经有很多的中小型互联网公司都在使用它，相较于传统的要先出Word接口文档再测试的方式，显然这样也更符合现在的快速迭代开发行情。当然了，提醒下大家在正式环境要记得关闭Swagger，一来出于安全考虑二来也可以节省运行时内存。</p>
<h3 id="拓展：其他皮肤"><a href="#拓展：其他皮肤" class="headerlink" title="拓展：其他皮肤"></a>拓展：其他皮肤</h3><p>我们可以导入不同的包实现不同的皮肤定义：</p>
<p>1、默认的   <strong>访问 <a href="http://localhost:8080/swagger-ui.html">http://localhost:8080/swagger-ui.html</a></strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;2.9.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.p04e.com/baid/i/2023/01/15/39av.png"></p>
<p>2、bootstrap-ui  <strong>访问 <a href="http://localhost:8080/doc.html">http://localhost:8080/doc.html</a></strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 引入swagger-bootstrap-ui包 /doc.html--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;swagger-bootstrap-ui&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;1.9.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>3、Layui-ui   <strong>访问 <a href="http://localhost:8080/docs.html">http://localhost:8080/docs.html</a></strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 引入swagger-ui-layer包 /docs.html--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;com.github.caspar-chen&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;swagger-ui-layer&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;1.1.3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>4、mg-ui   <strong>访问 <a href="http://localhost:8080/document.html">http://localhost:8080/document.html</a></strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 引入swagger-ui-layer包 /document.html--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;com.zyplayer&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;swagger-mg-ui&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;1.0.6&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Swagger</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot：页面国际化</title>
    <url>/2023/01/15/SpringBoot%EF%BC%9A%E9%A1%B5%E9%9D%A2%E5%9B%BD%E9%99%85%E5%8C%96/</url>
    <content><![CDATA[<p>有的时候，我们的网站会去涉及中英文甚至多语言的切换，这时候我们就需要学习国际化了！</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>先在IDEA中统一设置properties的编码问题！</p>
<span id="more"></span>
<p><img src="https://i.p04e.com/baid/i/2023/01/15/6psjl.png"></p>
<p>编写国际化配置文件，抽取页面需要显示的国际化页面消息。我们可以去登录页面查看一下，哪些内容我们需要编写国际化的配置！</p>
<h2 id="配置文件编写"><a href="#配置文件编写" class="headerlink" title="配置文件编写"></a>配置文件编写</h2><p>1、我们在resources资源文件下新建一个i18n目录，存放国际化配置文件</p>
<p>2、建立一个login.properties文件，还有一个login_zh_CN.properties；发现IDEA自动识别了我们要做国际化操作；文件夹变了！</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/15/ylwh.png"></p>
<p>3、我们可以在这上面去新建一个文件；</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/15/6q2ve.png"></p>
<p>弹出如下页面：我们再添加一个英文的；</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/15/ykj7.png"></p>
<p>这样就快捷多了！</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/15/yc9r.png"></p>
<p><strong>4、接下来，我们就来编写配置，我们可以看到idea下面有另外一个视图；</strong></p>
<p><img src="https://i.p04e.com/baid/i/2023/01/15/paf.png"></p>
<p>这个视图我们点击 + 号就可以直接添加属性了；我们新建一个login.tip，可以看到边上有三个文件框可以输入</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/15/yicj.png"></p>
<p>我们添加一下首页的内容！</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/15/yaqx.png"></p>
<p>然后依次添加其他页面内容即可！</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/15/3lw.png"></p>
<p>然后去查看我们的配置文件；</p>
<p>login.properties ：默认</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">login.btn=登录</span><br><span class="line">login.password=密码</span><br><span class="line">login.remember=记住我</span><br><span class="line">login.tip=请登录</span><br><span class="line">login.username=用户名</span><br></pre></td></tr></table></figure>
<p>英文：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">login.btn=Sign in</span><br><span class="line">login.password=Password</span><br><span class="line">login.remember=Remember me</span><br><span class="line">login.tip=Please sign in</span><br><span class="line">login.username=Username</span><br></pre></td></tr></table></figure>
<p>中文：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">login.btn=登录</span><br><span class="line">login.password=密码</span><br><span class="line">login.remember=记住我</span><br><span class="line">login.tip=请登录</span><br><span class="line">login.username=用户名</span><br></pre></td></tr></table></figure>
<p>OK，配置文件步骤搞定！</p>
<h2 id="配置文件生效探究"><a href="#配置文件生效探究" class="headerlink" title="配置文件生效探究"></a>配置文件生效探究</h2><p>我们去看一下SpringBoot对国际化的自动配置！这里又涉及到一个类：MessageSourceAutoConfiguration</p>
<p>里面有一个方法，这里发现SpringBoot已经自动配置好了管理我们国际化资源文件的组件 ResourceBundleMessageSource；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 获取 properties 传递过来的值进行判断</span><br><span class="line">@Bean</span><br><span class="line">public MessageSource messageSource(MessageSourceProperties properties) &#123;</span><br><span class="line">    ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource();</span><br><span class="line">    if (StringUtils.hasText(properties.getBasename())) &#123;</span><br><span class="line">        // 设置国际化文件的基础名（去掉语言国家代码的）</span><br><span class="line">        messageSource.setBasenames(</span><br><span class="line">            StringUtils.commaDelimitedListToStringArray(</span><br><span class="line">                                       StringUtils.trimAllWhitespace(properties.getBasename())));</span><br><span class="line">    &#125;</span><br><span class="line">    if (properties.getEncoding() != null) &#123;</span><br><span class="line">        messageSource.setDefaultEncoding(properties.getEncoding().name());</span><br><span class="line">    &#125;</span><br><span class="line">    messageSource.setFallbackToSystemLocale(properties.isFallbackToSystemLocale());</span><br><span class="line">    Duration cacheDuration = properties.getCacheDuration();</span><br><span class="line">    if (cacheDuration != null) &#123;</span><br><span class="line">        messageSource.setCacheMillis(cacheDuration.toMillis());</span><br><span class="line">    &#125;</span><br><span class="line">    messageSource.setAlwaysUseMessageFormat(properties.isAlwaysUseMessageFormat());</span><br><span class="line">    messageSource.setUseCodeAsDefaultMessage(properties.isUseCodeAsDefaultMessage());</span><br><span class="line">    return messageSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们真实 的情况是放在了i18n目录下，所以我们要去配置这个messages的路径；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring.messages.basename=i18n.login</span><br></pre></td></tr></table></figure>
<h2 id="配置页面国际化值"><a href="#配置页面国际化值" class="headerlink" title="配置页面国际化值"></a>配置页面国际化值</h2><p>去页面获取国际化的值，查看Thymeleaf的文档，找到message取值操作为：#{…}。我们去页面测试下：</p>
<p>IDEA还有提示，非常智能的！</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/15/6pby7.png"></p>
<p>我们可以去启动项目，访问一下，发现已经自动识别为中文的了！</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/15/yj1f.png">)</p>
<p><strong>但是我们想要更好！可以根据按钮自动切换中文英文！</strong></p>
<h2 id="配置国际化解析"><a href="#配置国际化解析" class="headerlink" title="配置国际化解析"></a>配置国际化解析</h2><p>在Spring中有一个国际化的Locale （区域信息对象）；里面有一个叫做LocaleResolver （获取区域信息对象）的解析器！</p>
<p>我们去我们webmvc自动配置文件，寻找一下！看到SpringBoot默认配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">@ConditionalOnMissingBean</span><br><span class="line">@ConditionalOnProperty(prefix = &quot;spring.mvc&quot;, name = &quot;locale&quot;)</span><br><span class="line">public LocaleResolver localeResolver() &#123;</span><br><span class="line">    // 容器中没有就自己配，有的话就用用户配置的</span><br><span class="line">    if (this.mvcProperties.getLocaleResolver() == WebMvcProperties.LocaleResolver.FIXED) &#123;</span><br><span class="line">        return new FixedLocaleResolver(this.mvcProperties.getLocale());</span><br><span class="line">    &#125;</span><br><span class="line">    // 接收头国际化分解</span><br><span class="line">    AcceptHeaderLocaleResolver localeResolver = new AcceptHeaderLocaleResolver();</span><br><span class="line">    localeResolver.setDefaultLocale(this.mvcProperties.getLocale());</span><br><span class="line">    return localeResolver;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AcceptHeaderLocaleResolver 这个类中有一个方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public Locale resolveLocale(HttpServletRequest request) &#123;</span><br><span class="line">    Locale defaultLocale = this.getDefaultLocale();</span><br><span class="line">    // 默认的就是根据请求头带来的区域信息获取Locale进行国际化</span><br><span class="line">    if (defaultLocale != null &amp;&amp; request.getHeader(&quot;Accept-Language&quot;) == null) &#123;</span><br><span class="line">        return defaultLocale;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Locale requestLocale = request.getLocale();</span><br><span class="line">        List&lt;Locale&gt; supportedLocales = this.getSupportedLocales();</span><br><span class="line">        if (!supportedLocales.isEmpty() &amp;&amp; !supportedLocales.contains(requestLocale)) &#123;</span><br><span class="line">            Locale supportedLocale = this.findSupportedLocale(request, supportedLocales);</span><br><span class="line">            if (supportedLocale != null) &#123;</span><br><span class="line">                return supportedLocale;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return defaultLocale != null ? defaultLocale : requestLocale;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return requestLocale;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那假如我们现在想点击链接让我们的国际化资源生效，就需要让我们自己的Locale生效！</p>
<p>我们去自己写一个自己的LocaleResolver，可以在链接上携带区域信息！</p>
<p>修改一下前端页面的跳转连接：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 这里传入参数不需要使用 ？使用 （key=value）--&gt;</span><br><span class="line">&lt;a class=&quot;btn btn-sm&quot; th:href=&quot;@&#123;/index.html(l=&#x27;zh_CN&#x27;)&#125;&quot;&gt;中文&lt;/a&gt;</span><br><span class="line">&lt;a class=&quot;btn btn-sm&quot; th:href=&quot;@&#123;/index.html(l=&#x27;en_US&#x27;)&#125;&quot;&gt;English&lt;/a&gt;</span><br></pre></td></tr></table></figure>
<p>我们去写一个处理的组件类！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">package com.kuang.component;</span><br><span class="line"></span><br><span class="line">import org.springframework.util.StringUtils;</span><br><span class="line">import org.springframework.web.servlet.LocaleResolver;</span><br><span class="line"></span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line">import java.util.Locale;</span><br><span class="line"></span><br><span class="line">//可以在链接上携带区域信息</span><br><span class="line">public class MyLocaleResolver implements LocaleResolver &#123;</span><br><span class="line"></span><br><span class="line">    //解析请求</span><br><span class="line">    @Override</span><br><span class="line">    public Locale resolveLocale(HttpServletRequest request) &#123;</span><br><span class="line"></span><br><span class="line">        String language = request.getParameter(&quot;l&quot;);</span><br><span class="line">        Locale locale = Locale.getDefault(); // 如果没有获取到就使用系统默认的</span><br><span class="line">        //如果请求链接不为空</span><br><span class="line">        if (!StringUtils.isEmpty(language))&#123;</span><br><span class="line">            //分割请求参数</span><br><span class="line">            String[] split = language.split(&quot;_&quot;);</span><br><span class="line">            //国家，地区</span><br><span class="line">            locale = new Locale(split[0],split[1]);</span><br><span class="line">        &#125;</span><br><span class="line">        return locale;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setLocale(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Locale locale) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了让我们的区域化信息能够生效，我们需要再配置一下这个组件！在我们自己的MvcConofig下添加bean；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public LocaleResolver localeResolver()&#123;</span><br><span class="line">    return new MyLocaleResolver();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Springboot系列：整合Mybatis-puls</title>
    <url>/2023/01/13/SpringBoot%E7%B3%BB%E5%88%97%EF%BC%9A%E6%95%B4%E5%90%88Mybatis-puls/</url>
    <content><![CDATA[<h1 id="一、SpringBoot-Mybatis-plus整合"><a href="#一、SpringBoot-Mybatis-plus整合" class="headerlink" title="一、SpringBoot+Mybatis-plus整合"></a>一、SpringBoot+Mybatis-plus整合</h1><p><a href="https://so.csdn.net/so/search?q=MyBatis-Plus&amp;spm=1001.2101.3001.7020">MyBatis-Plus</a> 是一个 Mybatis 增强版工具，在 MyBatis 上扩充了其他功能没有改变其基本功能，为了简化开发提交效率而存在。</p>
<span id="more"></span>
<p>官网文档地址：<a href="https://mp.baomidou.com/guide/">https://mp.baomidou.com/guide/</a></p>
<p>添加 MyBatis-Plus 依赖（mybatis-plus-boot-starter）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--mybatis-plus依赖--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.4.2&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>（4）为了测试开发，此处使用 mysql8，需要引入 mysql 相关依赖。　　</p>
<p>为了简化代码，引入 lombok 依赖（减少 getter、setter 等方法）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--mysql依赖--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--lombok依赖--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">            &lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>（5）在  <build> </build>里面添加如下进行yml、properties、xml自动扫描</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">        &lt;resources&gt;</span><br><span class="line">            &lt;resource&gt;</span><br><span class="line">                &lt;directory&gt;src/main/java&lt;/directory&gt;</span><br><span class="line">                &lt;includes&gt;</span><br><span class="line">                    &lt;include&gt;**/*.yml&lt;/include&gt;</span><br><span class="line">                    &lt;include&gt;**/*.properties&lt;/include&gt;</span><br><span class="line">                    &lt;include&gt;**/*.xml&lt;/include&gt;</span><br><span class="line">                &lt;/includes&gt;</span><br><span class="line">                &lt;filtering&gt;false&lt;/filtering&gt;</span><br><span class="line">            &lt;/resource&gt;</span><br><span class="line">            &lt;resource&gt;</span><br><span class="line">                &lt;directory&gt;src/main/resources&lt;/directory&gt;</span><br><span class="line">                &lt;includes&gt;</span><br><span class="line">                    &lt;include&gt;**/*.yml&lt;/include&gt;</span><br><span class="line">                    &lt;include&gt;**/*.properties&lt;/include&gt;</span><br><span class="line">                    &lt;include&gt;**/*.xml&lt;/include&gt;</span><br><span class="line">                &lt;/includes&gt;</span><br><span class="line">                &lt;filtering&gt;false&lt;/filtering&gt;</span><br><span class="line">            &lt;/resource&gt;</span><br><span class="line">        &lt;/resources&gt;</span><br><span class="line">    &lt;/build&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在 application.yml 文件中配置 mysql 数据源信息。</span><br><span class="line"></span><br><span class="line">mysql5如下配置</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    driver-class-name: com.mysql.jdbc.Driver</span><br><span class="line">    url: jdbc:mysql://localhost:3306/testMyBatisPlus?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8</span><br><span class="line">    username: root</span><br><span class="line">    password: root</span><br><span class="line">  thymeleaf:</span><br><span class="line">    cache: false   #设置为false，否则会有缓存，导致页面没法及时看到更新后的效果。</span><br><span class="line"></span><br><span class="line">修改端口号默认是8080</span><br><span class="line"></span><br><span class="line">server:</span><br><span class="line">  port: 8888</span><br><span class="line"></span><br><span class="line">mybatis-plus相关配置</span><br><span class="line"></span><br><span class="line">mybatis-plus:</span><br><span class="line">  mapper-locations: classpath:mapper/*.xml #扫描mapper下的所有xml文件</span><br><span class="line">  configuration:</span><br><span class="line">    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl</span><br><span class="line">  type-aliases-package: com.zwl.entity   #扫描实体类包/配置别名 </span><br></pre></td></tr></table></figure>
<p>（8）编写实体类、Service、ServiceImpl、UserMapper、UserMapper.xml等文件文件</p>
<p>方法一：手动编写（容易出错）</p>
<p>（1）编写表对应的 实体类User。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import lombok.Data;</span><br><span class="line"></span><br><span class="line">@Data</span><br><span class="line">public class Users &#123;</span><br><span class="line">    private Long id;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    private String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（2）编写操作实体类的 Mapper 类。　　</p>
<p> 直接继承 BaseMapper，这是 mybatis-plus 封装好的类。</p>
<pre><code>import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.zx.mybatis_plus.bean.Users;

public interface UsersMapper extends BaseMapper&lt;Users&gt; &#123;
&#125;
</code></pre><p>BaseMapper封装了CRUD相关的方法</p>
<p>（3）实体类、Mapper 类都写好了，就可以使用了。　　</p>
<p>​    Step1：先得在启动类里扫描 Mapper 类，即添加 @MapperScan 注解</p>
<pre><code>import org.mybatis.spring.annotation.MapperScan;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
@MapperScan(&quot;com.zwl.mapper&quot;)  //填写对应mapper存放位置，自动识别mapper下的所有**Mapper
@SpringBootApplication
public class MybatisplusDemoApplication &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(MybatisplusDemoApplication.class, args);
    &#125;

&#125;
</code></pre><p>　Step2：写一个测试类测试一下。</p>
<pre><code>import com.zwl.entity.User;
import com.zwl.mapper.UserMapper;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

import java.util.List;

@SpringBootTest
class Springboot05ApplicationTests &#123;
</code></pre><p>​<br>​        @Autowired<br>​        UserMapper userMapper;<br>​<br>        //查询所有用户<br>        @Test<br>        void contextLoads() {<br>            List<User> users = userMapper.selectList(null);<br>            for (User user : users) {<br>                System.out.println(user);<br>            }<br>        }</User></p>
<pre><code>    //根据ID查询当前用户
    @Test
    void test1() &#123;
        User user = userMapper.selectById(2);
        System.out.println(user);
    &#125;
&#125;
</code></pre><h1 id="二、Mybatis-Plus内置方法"><a href="#二、Mybatis-Plus内置方法" class="headerlink" title="二、Mybatis-Plus内置方法"></a>二、Mybatis-Plus内置方法</h1><h2 id="1-插入方法"><a href="#1-插入方法" class="headerlink" title="1 插入方法"></a>1 插入方法</h2><h3 id="1-1-save"><a href="#1-1-save" class="headerlink" title="1.1 save()"></a>1.1 save()</h3><p>插入单条数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用内置方法save(插入)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/save&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">save</span><span class="params">(<span class="meta">@RequestBody</span> UserEntity userEntity)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> userService.save(userEntity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-saveBatch"><a href="#1-2-saveBatch" class="headerlink" title="1.2 saveBatch()"></a>1.2 saveBatch()</h3><p>批量插入数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用内置方法saveBatch(插入)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/saveBatch&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">saveBatch</span><span class="params">(<span class="meta">@RequestBody</span> List&lt;UserEntity&gt; userList)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> userService.saveBatch(userList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-更新方法"><a href="#2-更新方法" class="headerlink" title="2 更新方法"></a>2 更新方法</h2><h3 id="2-1-updateById"><a href="#2-1-updateById" class="headerlink" title="2.1 updateById()"></a>2.1 updateById()</h3><p>更新单条数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用内置方法updateById(更新)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/updateById&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">updateById</span><span class="params">(<span class="meta">@RequestBody</span> UserEntity userEntity)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> userService.updateById(userEntity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-updateBatchById"><a href="#2-2-updateBatchById" class="headerlink" title="2.2 updateBatchById()"></a>2.2 updateBatchById()</h3><p>批量更新数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用内置方法updateBatchById(更新)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/updateBatchById&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">updateBatchById</span><span class="params">(<span class="meta">@RequestBody</span> List&lt;UserEntity&gt; userList)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> userService.updateBatchById(userList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-插入或更新方法"><a href="#3-插入或更新方法" class="headerlink" title="3 插入或更新方法"></a>3 插入或更新方法</h2><h3 id="3-1-saveOrUpdate"><a href="#3-1-saveOrUpdate" class="headerlink" title="3.1 saveOrUpdate()"></a>3.1 saveOrUpdate()</h3><p>插入或更新单条数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用内置方法saveOrUpdate(插入或更新)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/saveOrUpdate&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">saveOrUpdate</span><span class="params">(<span class="meta">@RequestBody</span> UserEntity userEntity)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> userService.saveOrUpdate(userEntity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-saveOrUpdateBatch"><a href="#3-2-saveOrUpdateBatch" class="headerlink" title="3.2 saveOrUpdateBatch()"></a>3.2 saveOrUpdateBatch()</h3><p>批量插入或更新数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用内置方法saveOrUpdateBatch(插入或更新)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/saveOrUpdateBatch&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">saveOrUpdateBatch</span><span class="params">(<span class="meta">@RequestBody</span> List&lt;UserEntity&gt; userList)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> userService.saveOrUpdateBatch(userList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-删除方法"><a href="#4-删除方法" class="headerlink" title="4 删除方法"></a>4 删除方法</h2><h3 id="4-1-removeById"><a href="#4-1-removeById" class="headerlink" title="4.1 removeById()"></a>4.1 removeById()</h3><p>删除单条数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用内置方法removeById(删除)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@DeleteMapping(&quot;/removeById/&#123;username&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeById</span><span class="params">(<span class="meta">@PathVariable(&quot;username&quot;)</span> String username)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> userService.removeById(username);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-2-removeByIds"><a href="#4-2-removeByIds" class="headerlink" title="4.2 removeByIds()"></a>4.2 removeByIds()</h3><p>批量删除数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用内置方法removeByIds(删除)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@DeleteMapping(&quot;removeByIds&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeByIds</span><span class="params">(<span class="meta">@RequestBody</span> List&lt;String&gt; usernameList)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> userService.removeByIds(usernameList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-查询数据"><a href="#5-查询数据" class="headerlink" title="5 查询数据"></a>5 查询数据</h2><h3 id="5-1-list"><a href="#5-1-list" class="headerlink" title="5.1 list()"></a>5.1 list()</h3><p>根据指定条件查询列表数据，返回数据类型为实体类类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用内置方法list(查询)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;list&quot;)</span></span><br><span class="line"><span class="keyword">public</span> List&lt;UserEntity&gt; <span class="title function_">list</span><span class="params">()</span> &#123;</span><br><span class="line">    QueryWrapper&lt;UserEntity&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>();</span><br><span class="line">    queryWrapper.lambda().eq(UserEntity::getUsername, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> userService.list(queryWrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-2-listMaps"><a href="#5-2-listMaps" class="headerlink" title="5.2 listMaps()"></a>5.2 listMaps()</h3><p>根据指定条件查询列表数据，返回数据类型为Map类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用内置方法listMaps(查询)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;listMaps&quot;)</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">listMaps</span><span class="params">()</span> &#123;</span><br><span class="line">    QueryWrapper&lt;UserEntity&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>();</span><br><span class="line">    queryWrapper.lambda().eq(UserEntity::getUsername, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> userService.listMaps(queryWrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-3-listObjs"><a href="#5-3-listObjs" class="headerlink" title="5.3 listObjs()"></a>5.3 listObjs()</h3><p>根据指定条件查询列表数据，返回数据类型为Object类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用内置方法listObjs(查询)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;listObjs&quot;)</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Object&gt; <span class="title function_">listObjs</span><span class="params">()</span> &#123;</span><br><span class="line">    QueryWrapper&lt;UserEntity&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>();</span><br><span class="line">    queryWrapper.lambda().eq(UserEntity::getUsername, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> userService.listObjs(queryWrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-4-listByIds"><a href="#5-4-listByIds" class="headerlink" title="5.4 listByIds()"></a>5.4 listByIds()</h3><p>根据主键列表查询列表数据，返回数据类型为实体类类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用内置方法listByIds(查询)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;listByIds&quot;)</span></span><br><span class="line"><span class="keyword">public</span> List&lt;UserEntity&gt; <span class="title function_">listByIds</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> userService.listByIds(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="string">&quot;123&quot;</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-5-listByMap"><a href="#5-5-listByMap" class="headerlink" title="5.5 listByMap()"></a>5.5 listByMap()</h3><p>根据指定条件查询列表数据，返回数据类型为实体类类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用内置方法listByMap(查询)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;listByMap&quot;)</span></span><br><span class="line"><span class="keyword">public</span> List&lt;UserEntity&gt; <span class="title function_">listByMap</span><span class="params">()</span> &#123;</span><br><span class="line">    Map&lt;String, Object&gt; columnMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    columnMap.put(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> userService.listByMap(columnMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-6-getById"><a href="#5-6-getById" class="headerlink" title="5.6 getById()"></a>5.6 getById()</h3><p>根据主键查询单条数据，返回数据类型为实体类类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用内置方法getById(查询)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;getById&quot;)</span></span><br><span class="line"><span class="keyword">public</span> UserEntity <span class="title function_">getById</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> userService.getById(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-7-getOne"><a href="#5-7-getOne" class="headerlink" title="5.7 getOne()"></a>5.7 getOne()</h3><p>根据指定条件查询单条数据，返回数据类型为实体类类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用内置方法getOne(查询)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;getOne&quot;)</span></span><br><span class="line"><span class="keyword">public</span> UserEntity <span class="title function_">getOne</span><span class="params">()</span> &#123;</span><br><span class="line">    QueryWrapper&lt;UserEntity&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>();</span><br><span class="line">    queryWrapper.lambda().eq(UserEntity::getUsername, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> userService.getOne(queryWrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-8-getMap"><a href="#5-8-getMap" class="headerlink" title="5.8 getMap()"></a>5.8 getMap()</h3><p>根据指定条件查询单条数据，返回数据类型为Map类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用内置方法getMap(查询)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;getMap&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title function_">getMap</span><span class="params">()</span> &#123;</span><br><span class="line">    QueryWrapper&lt;UserEntity&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>();</span><br><span class="line">    queryWrapper.lambda().eq(UserEntity::getUsername, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> userService.getMap(queryWrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-9-count"><a href="#5-9-count" class="headerlink" title="5.9 count()"></a>5.9 count()</h3><p>根据指定条件查询记录条数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用内置方法count(查询)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;count&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">count</span><span class="params">()</span> &#123;</span><br><span class="line">    QueryWrapper&lt;UserEntity&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>();</span><br><span class="line">    queryWrapper.lambda().eq(UserEntity::getUsername, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> userService.count(queryWrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-10-page"><a href="#5-10-page" class="headerlink" title="5.10 page()"></a>5.10 page()</h3><p>根据指定条件查询数据并分页，返回数据类型为实体类类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用内置方法page(查询)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;page&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Page&lt;UserEntity&gt; <span class="title function_">page</span><span class="params">()</span> &#123;</span><br><span class="line">    Page&lt;UserEntity&gt; page = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">    QueryWrapper&lt;UserEntity&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>();</span><br><span class="line">    queryWrapper.lambda().eq(UserEntity::getUsername, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> userService.page(page, queryWrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-11-page"><a href="#5-11-page" class="headerlink" title="5.11 page"></a>5.11 page</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用内置方法pageMaps(查询)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;pageMaps&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Page&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">pageMaps</span><span class="params">()</span> &#123;</span><br><span class="line">    Page&lt;Map&lt;String, Object&gt;&gt; page = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">    QueryWrapper&lt;UserEntity&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>();</span><br><span class="line">    queryWrapper.lambda().eq(UserEntity::getUsername, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> userService.pageMaps(page, queryWrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Maps"><a href="#Maps" class="headerlink" title="Maps()"></a>Maps()</h3><p>根据指定条件查询数据并分页，返回数据类型为Map类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用内置方法pageMaps(查询)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;pageMaps&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Page&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">pageMaps</span><span class="params">()</span> &#123;</span><br><span class="line">    Page&lt;Map&lt;String, Object&gt;&gt; page = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">    QueryWrapper&lt;UserEntity&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>();</span><br><span class="line">    queryWrapper.lambda().eq(UserEntity::getUsername, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> userService.pageMaps(page, queryWrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Mybatis-plus</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot系列：异步、定时、邮件任务</title>
    <url>/2023/02/01/SpringBoot%E7%B3%BB%E5%88%97%EF%BC%9A%E5%BC%82%E6%AD%A5%E3%80%81%E5%AE%9A%E6%97%B6%E3%80%81%E9%82%AE%E4%BB%B6%E4%BB%BB%E5%8A%A1/</url>
    <content><![CDATA[<h2 id="异步任务"><a href="#异步任务" class="headerlink" title="异步任务"></a>异步任务</h2><p>1、创建一个service包</p>
<p>2、创建一个类AsyncService</p>
<span id="more"></span>
<p>异步处理还是非常常用的，比如我们在网站上发送邮件，后台会去发送邮件，此时前台会造成响应不动，直到邮件发送完毕，响应才会成功，所以我们一般会采用多线程的方式去处理这些任务。</p>
<p>编写方法，假装正在处理数据，使用线程设置一些延时，模拟同步等待的情况；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class AsyncService &#123;</span><br><span class="line"></span><br><span class="line">   public void hello()&#123;</span><br><span class="line">       try &#123;</span><br><span class="line">           Thread.sleep(3000);</span><br><span class="line">      &#125; catch (InterruptedException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">       System.out.println(&quot;业务进行中....&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、编写controller包</p>
<p>4、编写AsyncController类</p>
<p>我们去写一个Controller测试一下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class AsyncController &#123;</span><br><span class="line"></span><br><span class="line">   @Autowired</span><br><span class="line">   AsyncService asyncService;</span><br><span class="line"></span><br><span class="line">   @GetMapping(&quot;/hello&quot;)</span><br><span class="line">   public String hello()&#123;</span><br><span class="line">       asyncService.hello();</span><br><span class="line">       return &quot;success&quot;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5、访问<a href="http://localhost:8080/hello进行测试，3秒后出现success，这是同步等待的情况。">http://localhost:8080/hello进行测试，3秒后出现success，这是同步等待的情况。</a></p>
<p>问题：我们如果想让用户直接得到消息，就在后台使用多线程的方式进行处理即可，但是每次都需要自己手动去编写多线程的实现的话，太麻烦了，我们只需要用一个简单的办法，在我们的方法上加一个简单的注解即可，如下：</p>
<p>6、给hello方法添加@Async注解；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//告诉Spring这是一个异步方法</span><br><span class="line">@Async</span><br><span class="line">public void hello()&#123;</span><br><span class="line">   try &#123;</span><br><span class="line">       Thread.sleep(3000);</span><br><span class="line">  &#125; catch (InterruptedException e) &#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">   System.out.println(&quot;业务进行中....&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SpringBoot就会自己开一个线程池，进行调用！但是要让这个注解生效，我们还需要在主程序上添加一个注解@EnableAsync ，开启异步注解功能；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@EnableAsync //开启异步注解功能</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class SpringbootTaskApplication &#123;</span><br><span class="line"></span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">       SpringApplication.run(SpringbootTaskApplication.class, args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>7、重启测试，网页瞬间响应，后台代码依旧执行！</p>
<h2 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h2><p>项目开发中经常需要执行一些定时任务，比如需要在每天凌晨的时候，分析一次前一天的日志信息，Spring为我们提供了异步执行任务调度的方式，提供了两个接口。</p>
<ul>
<li>TaskExecutor接口</li>
<li>TaskScheduler接口</li>
</ul>
<p>两个注解：</p>
<ul>
<li>@EnableScheduling</li>
<li>@Scheduled</li>
</ul>
<p><strong>测试步骤：</strong></p>
<p>1、创建一个ScheduledService</p>
<p>我们里面存在一个hello方法，他需要定时执行，怎么处理呢？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class ScheduledService &#123;</span><br><span class="line">   </span><br><span class="line">   //秒   分   时     日   月   周几</span><br><span class="line">   //0 * * * * MON-FRI</span><br><span class="line">   //注意cron表达式的用法；</span><br><span class="line">   @Scheduled(cron = &quot;0 * * * * 0-7&quot;)</span><br><span class="line">   public void hello()&#123;</span><br><span class="line">       System.out.println(&quot;hello.....&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、这里写完定时任务之后，我们需要在主程序上增加@EnableScheduling 开启定时任务功能</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@EnableAsync //开启异步注解功能</span><br><span class="line">@EnableScheduling //开启基于注解的定时任务</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class SpringbootTaskApplication &#123;</span><br><span class="line"></span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">       SpringApplication.run(SpringbootTaskApplication.class, args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、我们来详细了解下cron表达式；</p>
<p><a href="http://www.bejson.com/othertools/cron/">http://www.bejson.com/othertools/cron/</a></p>
<p>4、常用的表达式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）0/2 * * * * ?   表示每2秒 执行任务</span><br><span class="line">（1）0 0/2 * * * ?   表示每2分钟 执行任务</span><br><span class="line">（1）0 0 2 1 * ?   表示在每月的1日的凌晨2点调整任务</span><br><span class="line">（2）0 15 10 ? * MON-FRI   表示周一到周五每天上午10:15执行作业</span><br><span class="line">（3）0 15 10 ? 6L 2002-2006   表示2002-2006年的每个月的最后一个星期五上午10:15执行作</span><br><span class="line">（4）0 0 10,14,16 * * ?   每天上午10点，下午2点，4点</span><br><span class="line">（5）0 0/30 9-17 * * ?   朝九晚五工作时间内每半小时</span><br><span class="line">（6）0 0 12 ? * WED   表示每个星期三中午12点</span><br><span class="line">（7）0 0 12 * * ?   每天中午12点触发</span><br><span class="line">（8）0 15 10 ? * *   每天上午10:15触发</span><br><span class="line">（9）0 15 10 * * ?     每天上午10:15触发</span><br><span class="line">（10）0 15 10 * * ?   每天上午10:15触发</span><br><span class="line">（11）0 15 10 * * ? 2005   2005年的每天上午10:15触发</span><br><span class="line">（12）0 * 14 * * ?     在每天下午2点到下午2:59期间的每1分钟触发</span><br><span class="line">（13）0 0/5 14 * * ?   在每天下午2点到下午2:55期间的每5分钟触发</span><br><span class="line">（14）0 0/5 14,18 * * ?     在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发</span><br><span class="line">（15）0 0-5 14 * * ?   在每天下午2点到下午2:05期间的每1分钟触发</span><br><span class="line">（16）0 10,44 14 ? 3 WED   每年三月的星期三的下午2:10和2:44触发</span><br><span class="line">（17）0 15 10 ? * MON-FRI   周一至周五的上午10:15触发</span><br><span class="line">（18）0 15 10 15 * ?   每月15日上午10:15触发</span><br><span class="line">（19）0 15 10 L * ?   每月最后一日的上午10:15触发</span><br><span class="line">（20）0 15 10 ? * 6L   每月的最后一个星期五上午10:15触发</span><br><span class="line">（21）0 15 10 ? * 6L 2002-2005   2002年至2005年的每月的最后一个星期五上午10:15触发</span><br><span class="line">（22）0 15 10 ? * 6#3   每月的第三个星期五上午10:15触发</span><br></pre></td></tr></table></figure>
<h2 id="邮件任务"><a href="#邮件任务" class="headerlink" title="邮件任务"></a>邮件任务</h2><p>邮件发送，在我们的日常开发中，也非常的多，Springboot也帮我们做了支持</p>
<ul>
<li>邮件发送需要引入spring-boot-start-mail</li>
<li>SpringBoot 自动配置MailSenderAutoConfiguration</li>
<li>定义MailProperties内容，配置在application.yml中</li>
<li>自动装配JavaMailSender</li>
<li>测试邮件发送</li>
</ul>
<p><strong>测试：</strong></p>
<p>1、引入pom依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>看它引入的依赖，可以看到 jakarta.mail</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;com.sun.mail&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;jakarta.mail&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;1.6.4&lt;/version&gt;</span><br><span class="line">   &lt;scope&gt;compile&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>2、查看自动配置类：MailSenderAutoConfiguration</p>
<p><img src="https://i.p04e.com/baid/i/2023/02/01/3sbk5.png"></p>
<p>这个类中存在bean，JavaMailSenderImpl</p>
<p><img src="https://i.p04e.com/baid/i/2023/02/01/2ta6.png"></p>
<p>然后我们去看下配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ConfigurationProperties(</span><br><span class="line">   prefix = &quot;spring.mail&quot;</span><br><span class="line">)</span><br><span class="line">public class MailProperties &#123;</span><br><span class="line">   private static final Charset DEFAULT_CHARSET;</span><br><span class="line">   private String host;</span><br><span class="line">   private Integer port;</span><br><span class="line">   private String username;</span><br><span class="line">   private String password;</span><br><span class="line">   private String protocol = &quot;smtp&quot;;</span><br><span class="line">   private Charset defaultEncoding;</span><br><span class="line">   private Map&lt;String, String&gt; properties;</span><br><span class="line">   private String jndiName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、配置文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring.mail.username=24736743@qq.com</span><br><span class="line">spring.mail.password=你的qq授权码</span><br><span class="line">spring.mail.host=smtp.qq.com</span><br><span class="line"># qq需要配置ssl</span><br><span class="line">spring.mail.properties.mail.smtp.ssl.enable=true</span><br></pre></td></tr></table></figure>
<p>获取授权码：在QQ邮箱中的设置-&gt;账户-&gt;开启pop3和smtp服务</p>
<p><img src="https://i.p04e.com/baid/i/2023/02/01/jko3.png"></p>
<p>4、Spring单元测试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">JavaMailSenderImpl mailSender;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void contextLoads() &#123;</span><br><span class="line">   //邮件设置1：一个简单的邮件</span><br><span class="line">   SimpleMailMessage message = new SimpleMailMessage();</span><br><span class="line">   message.setSubject(&quot;通知-明天来狂神这听课&quot;);</span><br><span class="line">   message.setText(&quot;今晚7:30开会&quot;);</span><br><span class="line"></span><br><span class="line">   message.setTo(&quot;24736743@qq.com&quot;);</span><br><span class="line">   message.setFrom(&quot;24736743@qq.com&quot;);</span><br><span class="line">   mailSender.send(message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void contextLoads2() throws MessagingException &#123;</span><br><span class="line">   //邮件设置2：一个复杂的邮件</span><br><span class="line">   MimeMessage mimeMessage = mailSender.createMimeMessage();</span><br><span class="line">   MimeMessageHelper helper = new MimeMessageHelper(mimeMessage, true);</span><br><span class="line"></span><br><span class="line">   helper.setSubject(&quot;通知-明天来狂神这听课&quot;);</span><br><span class="line">   helper.setText(&quot;&lt;b style=&#x27;color:red&#x27;&gt;今天 7:30来开会&lt;/b&gt;&quot;,true);</span><br><span class="line"></span><br><span class="line">   //发送附件</span><br><span class="line">   helper.addAttachment(&quot;1.jpg&quot;,new File(&quot;&quot;));</span><br><span class="line">   helper.addAttachment(&quot;2.jpg&quot;,new File(&quot;&quot;));</span><br><span class="line"></span><br><span class="line">   helper.setTo(&quot;24736743@qq.com&quot;);</span><br><span class="line">   helper.setFrom(&quot;24736743@qq.com&quot;);</span><br><span class="line"></span><br><span class="line">   mailSender.send(mimeMessage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看邮箱，邮件接收成功！</p>
]]></content>
      <tags>
        <tag>SpringBoot</tag>
        <tag>邮箱</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot：Dubbo和Zookeeper集成</title>
    <url>/2023/02/01/SpringBoot%EF%BC%9ADubbo%E5%92%8CZookeeper%E9%9B%86%E6%88%90/</url>
    <content><![CDATA[<p>随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，急需<strong>一个治理系统</strong>确保架构有条不紊的演进。<span id="more"></span></p>
<p>在Dubbo的官网文档有这样一张图</p>
<p><img src="https://i.p04e.com/baid/i/2023/02/01/rpme0.png"></p>
<h2 id="单一应用架构"><a href="#单一应用架构" class="headerlink" title="单一应用架构"></a><strong>单一应用架构</strong></h2><p>当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(ORM)是关键。</p>
<p><img src="https://i.p04e.com/baid/i/2023/02/01/3ykez.png"></p>
<p>适用于小型网站，小型管理系统，将所有功能都部署到一个功能里，简单易用。</p>
<p><strong>缺点：</strong></p>
<p>1、性能扩展比较难</p>
<p>2、协同开发问题</p>
<p>3、不利于升级维护</p>
<h2 id="垂直应用架构"><a href="#垂直应用架构" class="headerlink" title="垂直应用架构"></a><strong>垂直应用架构</strong></h2><p>当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的Web框架(MVC)是关键。</p>
<p><img src="https://i.p04e.com/baid/i/2023/02/01/2wud.png"></p>
<p>通过切分业务来实现各个模块独立部署，降低了维护和部署的难度，团队各司其职更易管理，性能扩展也更方便，更有针对性。</p>
<p>缺点：公用模块无法重复利用，开发性的浪费</p>
<h2 id="分布式服务架构"><a href="#分布式服务架构" class="headerlink" title="分布式服务架构"></a><strong>分布式服务架构</strong></h2><p>当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的<strong>分布式服务框架(RPC)</strong>是关键。</p>
<p><img src="https://i.p04e.com/baid/i/2023/02/01/2wy1.png"></p>
<h2 id="流动计算架构"><a href="#流动计算架构" class="headerlink" title="流动计算架构"></a><strong>流动计算架构</strong></h2><p>当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于<strong>提高机器利用率的资源调度和治理中心</strong>(SOA)[ Service Oriented Architecture]是关键。</p>
<p><img src="https://i.p04e.com/baid/i/2023/02/01/3yxfg.png"></p>
<p>什么是RPC</p>
<p>RPC【Remote Procedure Call】是指远程过程调用，是一种进程间通信方式，他是一种技术的思想，而不是规范。它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。即程序员无论是调用本地的还是远程的函数，本质上编写的调用代码基本相同。</p>
<p>也就是说两台服务器A，B，一个应用部署在A服务器上，想要调用B服务器上应用提供的函数/方法，由于不在一个内存空间，不能直接调用，需要通过网络来表达调用的语义和传达调用的数据。为什么要用RPC呢？就是无法在一个进程内，甚至一个计算机内通过本地调用的方式完成的需求，比如不同的系统间的通讯，甚至不同的组织间的通讯，由于计算能力需要横向扩展，需要在多台机器组成的集群上部署应用。RPC就是要像调用本地的函数一样去调远程函数；</p>
<p>推荐阅读文章：<a href="https://www.jianshu.com/p/2accc2840a1b">https://www.jianshu.com/p/2accc2840a1b</a></p>
<p><strong>RPC基本原理</strong></p>
<p><img src="https://i.p04e.com/baid/i/2023/02/01/kfzp.png"></p>
<p><strong>步骤解析：</strong></p>
<p><img src="https://i.p04e.com/baid/i/2023/02/01/kgjb.png"></p>
<p>RPC两个核心模块：通讯，序列化。</p>
<p>测试环境搭建</p>
<h2 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a><strong>Dubbo</strong></h2><p>Apache Dubbo |ˈdʌbəʊ| 是一款高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。</p>
<p>dubbo官网 <a href="http://dubbo.apache.org/zh-cn/index.html">http://dubbo.apache.org/zh-cn/index.html</a></p>
<p>1.了解Dubbo的特性</p>
<p>2.查看官方文档</p>
<p><strong>dubbo基本概念</strong></p>
<p><img src="https://i.p04e.com/baid/i/2023/02/01/3z7jj.png"></p>
<p><strong>服务提供者</strong>（Provider）：暴露服务的服务提供方，服务提供者在启动时，向注册中心注册自己提供的服务。</p>
<p><strong>服务消费者</strong>（Consumer）：调用远程服务的服务消费方，服务消费者在启动时，向注册中心订阅自己所需的服务，服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</p>
<p><strong>注册中心</strong>（Registry）：注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者</p>
<p><strong>监控中心</strong>（Monitor）：服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心</p>
<p><strong>调用关系说明</strong></p>
<p>l 服务容器负责启动，加载，运行服务提供者。</p>
<p>l 服务提供者在启动时，向注册中心注册自己提供的服务。</p>
<p>l 服务消费者在启动时，向注册中心订阅自己所需的服务。</p>
<p>l 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</p>
<p>l 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</p>
<p>l 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</p>
<h2 id="Dubbo环境搭建"><a href="#Dubbo环境搭建" class="headerlink" title="Dubbo环境搭建"></a><strong>Dubbo环境搭建</strong></h2><p>点进dubbo官方文档，推荐我们使用Zookeeper 注册中心</p>
<p>什么是zookeeper呢？可以查看官方文档</p>
<h2 id="Window下安装zookeeper"><a href="#Window下安装zookeeper" class="headerlink" title="Window下安装zookeeper"></a><strong>Window下安装zookeeper</strong></h2><p>1、下载zookeeper ：地址， 我们下载3.4.14 ， 最新版！解压zookeeper</p>
<p>2、运行/bin/zkServer.cmd ，初次运行会报错，没有zoo.cfg配置文件；</p>
<p>可能遇到问题：闪退 !</p>
<p>解决方案：编辑zkServer.cmd文件末尾添加pause 。这样运行出错就不会退出，会提示错误信息，方便找到原因。</p>
<p><img src="https://i.p04e.com/baid/i/2023/02/01/2wzz.png"></p>
<p>3、修改zoo.cfg配置文件</p>
<p>将conf文件夹下面的zoo_sample.cfg复制一份改名为zoo.cfg即可。</p>
<p>注意几个重要位置：</p>
<p>dataDir=./   临时数据存储的目录（可写相对路径）</p>
<p>clientPort=2181   zookeeper的端口号</p>
<p>修改完成后再次启动zookeeper</p>
<p>4、使用zkCli.cmd测试</p>
<p>ls /：列出zookeeper根下保存的所有节点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[zk: 127.0.0.1:2181(CONNECTED) 4] ls /</span><br><span class="line">[zookeeper]</span><br></pre></td></tr></table></figure>
<p>create –e /baidu 123：创建一个kuangshen节点，值为123</p>
<p>get /baidu：获取/baidu节点的值</p>
<h2 id="window下安装dubbo-admin"><a href="#window下安装dubbo-admin" class="headerlink" title="window下安装dubbo-admin"></a><strong>window下安装dubbo-admin</strong></h2><p>dubbo本身并不是一个服务软件。它其实就是一个jar包，能够帮你的java程序连接到zookeeper，并利用zookeeper消费、提供服务。</p>
<p>但是为了让用户更好的管理监控众多的dubbo服务，官方提供了一个可视化的监控程序dubbo-admin，不过这个监控即使不装也不影响使用。</p>
<p>我们这里来安装一下：</p>
<p><strong>1、下载dubbo-admin</strong></p>
<p>地址 ：<a href="https://github.com/apache/dubbo-admin/tree/master">https://github.com/apache/dubbo-admin/tree/master</a></p>
<p><strong>2、解压进入目录</strong></p>
<p>修改 dubbo-admin\src\main\resources \application.properties 指定zookeeper地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server.port=7001</span><br><span class="line">spring.velocity.cache=false</span><br><span class="line">spring.velocity.charset=UTF-8</span><br><span class="line">spring.velocity.layout-url=/templates/default.vm</span><br><span class="line">spring.messages.fallback-to-system-locale=false</span><br><span class="line">spring.messages.basename=i18n/message</span><br><span class="line">spring.root.password=root</span><br><span class="line">spring.guest.password=guest</span><br><span class="line"></span><br><span class="line">dubbo.registry.address=zookeeper://127.0.0.1:2181</span><br></pre></td></tr></table></figure>
<p><strong>3、在项目目录下</strong>打包dubbo-admin</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn clean package -Dmaven.test.skip=true</span><br></pre></td></tr></table></figure>
<p>4、执行 dubbo-admin\target 下的dubbo-admin-0.0.1-SNAPSHOT.jar</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -jar dubbo-admin-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure>
<p>【注意：zookeeper的服务一定要打开！】</p>
<p>执行完毕，我们去访问一下 <a href="http://localhost:7001/">http://localhost:7001/</a> ， 这时候我们需要输入登录账户和密码，我们都是默认的root-root；</p>
<p>登录成功后，查看界面</p>
<p><img src="https://i.p04e.com/baid/i/2023/02/01/kjoh.png"></p>
<p>安装完成！</p>
<h2 id="SpringBoot-Dubbo-zookeeper"><a href="#SpringBoot-Dubbo-zookeeper" class="headerlink" title="SpringBoot + Dubbo + zookeeper"></a>SpringBoot + Dubbo + zookeeper</h2><h2 id="框架搭建"><a href="#框架搭建" class="headerlink" title="框架搭建"></a><strong>框架搭建</strong></h2><p><strong>1. 启动zookeeper ！</strong></p>
<p><strong>2. IDEA创建一个空项目；</strong></p>
<p><strong>3.创建一个模块，实现服务提供者：provider-server ， 选择web依赖即可</strong></p>
<p><strong>4.项目创建完毕，我们写一个服务，比如卖票的服务；</strong></p>
<p>编写接口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">public interface TicketService &#123;</span><br><span class="line">   public String getTicket();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编写实现类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">public class TicketServiceImpl implements TicketService &#123;</span><br><span class="line">   @Override</span><br><span class="line">   public String getTicket() &#123;</span><br><span class="line">       return &quot;《狂神说Java》&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>5.创建一个模块，实现服务消费者：consumer-server ， 选择web依赖即可</strong></p>
<p><strong>6.项目创建完毕，我们写一个服务，比如用户的服务；</strong></p>
<p>编写service</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">public class UserService &#123;</span><br><span class="line">   //我们需要去拿去注册中心的服务</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>需求：现在我们的用户想使用买票的服务，这要怎么弄呢 ？</strong></p>
<h2 id="服务提供者"><a href="#服务提供者" class="headerlink" title="服务提供者"></a><strong>服务提供者</strong></h2><p><strong>1、将服务提供者注册到注册中心，我们需要整合Dubbo和zookeeper，所以需要导包</strong></p>
<p><strong>我们从dubbo官网进入github，看下方的帮助文档，找到dubbo-springboot，找到依赖包</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- Dubbo Spring Boot Starter --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;2.7.3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;    </span><br></pre></td></tr></table></figure>
<p><strong>zookeeper的包我们去maven仓库下载，zkclient；</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/com.github.sgroschupf/zkclient --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;com.github.sgroschupf&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;zkclient&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;0.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p><strong>【新版的坑】zookeeper及其依赖包，解决日志冲突，还需要剔除日志依赖；</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 引入zookeeper --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;curator-framework&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;2.12.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;2.12.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;3.4.14&lt;/version&gt;</span><br><span class="line">   &lt;!--排除这个slf4j-log4j12--&gt;</span><br><span class="line">   &lt;exclusions&gt;</span><br><span class="line">       &lt;exclusion&gt;</span><br><span class="line">           &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;</span><br><span class="line">       &lt;/exclusion&gt;</span><br><span class="line">   &lt;/exclusions&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p><strong>2、在springboot配置文件中配置dubbo相关属性！</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#当前应用名字</span><br><span class="line">dubbo.application.name=provider-server</span><br><span class="line">#注册中心地址</span><br><span class="line">dubbo.registry.address=zookeeper://127.0.0.1:2181</span><br><span class="line">#扫描指定包下服务</span><br><span class="line">dubbo.scan.base-packages=com.bai.provider.service</span><br></pre></td></tr></table></figure>
<p><strong>3、在service的实现类中配置服务注解，发布服务！注意导包问题</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import org.apache.dubbo.config.annotation.Service;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">@Service //将服务发布出去</span><br><span class="line">@Component //放在容器中</span><br><span class="line">public class TicketServiceImpl implements TicketService &#123;</span><br><span class="line">   @Override</span><br><span class="line">   public String getTicket() &#123;</span><br><span class="line">       return &quot;Java&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>逻辑理解 ：应用启动起来，dubbo就会扫描指定的包下带有@component注解的服务，将它发布在指定的注册中心中！</strong></p>
<h2 id="服务消费者"><a href="#服务消费者" class="headerlink" title="服务消费者"></a><strong>服务消费者</strong></h2><p><strong>1、导入依赖，和之前的依赖一样；</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--dubbo--&gt;</span><br><span class="line">&lt;!-- Dubbo Spring Boot Starter --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;2.7.3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--zookeeper--&gt;</span><br><span class="line">&lt;!-- https://mvnrepository.com/artifact/com.github.sgroschupf/zkclient --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;com.github.sgroschupf&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;zkclient&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;0.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- 引入zookeeper --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;curator-framework&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;2.12.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;2.12.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;3.4.14&lt;/version&gt;</span><br><span class="line">   &lt;!--排除这个slf4j-log4j12--&gt;</span><br><span class="line">   &lt;exclusions&gt;</span><br><span class="line">       &lt;exclusion&gt;</span><br><span class="line">           &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;</span><br><span class="line">       &lt;/exclusion&gt;</span><br><span class="line">   &lt;/exclusions&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>2、<strong>配置参数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#当前应用名字</span><br><span class="line">dubbo.application.name=consumer-server</span><br><span class="line">#注册中心地址</span><br><span class="line">dubbo.registry.address=zookeeper://127.0.0.1:2181</span><br></pre></td></tr></table></figure>
<p><strong>3. 本来正常步骤是需要将服务提供者的接口打包，然后用pom文件导入，我们这里使用简单的方式，直接将服务的接口拿过来，路径必须保证正确，即和服务提供者相同；</strong></p>
<p><strong>4. 完善消费者的服务类</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">import com.bai.provider.service.TicketService;</span><br><span class="line">import org.apache.dubbo.config.annotation.Reference;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line">@Service //注入到容器中</span><br><span class="line">public class UserService &#123;</span><br><span class="line"></span><br><span class="line">   @Reference //远程引用指定的服务，他会按照全类名进行匹配，看谁给注册中心注册了这个全类名</span><br><span class="line">   TicketService ticketService;</span><br><span class="line"></span><br><span class="line">   public void bugTicket()&#123;</span><br><span class="line">       String ticket = ticketService.getTicket();</span><br><span class="line">       System.out.println(&quot;在注册中心买到&quot;+ticket);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>5. 测试类编写；</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class ConsumerServerApplicationTests &#123;</span><br><span class="line"></span><br><span class="line">   @Autowired</span><br><span class="line">   UserService userService;</span><br><span class="line"></span><br><span class="line">   @Test</span><br><span class="line">   public void contextLoads() &#123;</span><br><span class="line"></span><br><span class="line">       userService.bugTicket();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="启动测试"><a href="#启动测试" class="headerlink" title="启动测试"></a><strong>启动测试</strong></h2><p><strong>1. 开启zookeeper</strong></p>
<p><strong>2. 打开dubbo-admin实现监控【可以不用做】</strong></p>
<p><strong>3. 开启服务者</strong></p>
<p><strong>4. 消费者消费测试：</strong></p>
<p><strong>ok , 这就是SpingBoot + dubbo + zookeeper实现分布式开发的应用，其实就是一个服务拆分的思想；</strong></p>
]]></content>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Dubbo</tag>
        <tag>Zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot系列：集成SpringSecurity</title>
    <url>/2023/02/01/SpringBoot%E7%B3%BB%E5%88%97%EF%BC%9A%E9%9B%86%E6%88%90SpringSecurity/</url>
    <content><![CDATA[<p>在 Web 开发中，安全一直是非常重要的一个方面。安全虽然属于应用的非功能性需求，但是应该在应用开发的初期就考虑进来。如果在应用开发的后期才考虑安全的问题，就可能陷入一个两难的境地：一方面，应用存在严重的安全漏洞，无法满足用户的要求，并可能造成用户的隐私数据被攻击者窃取；另一方面，应用的基本架构已经确定，要修复安全漏洞，可能需要对系统的架构做出比较重大的调整，因而需要更多的开发时间，影响应用的发布进程。因此，从应用开发的第一天就应该把安全相关的因素考虑进来，并在整个应用的开发过程中。</p>
<span id="more"></span>
<p>市面上存在比较有名的：Shiro，Spring Security ！</p>
<p>这里需要阐述一下的是，每一个框架的出现都是为了解决某一问题而产生了，那么Spring Security框架的出现是为了解决什么问题呢？</p>
<p>首先我们看下它的官网介绍：Spring Security官网地址</p>
<p>Spring Security is a powerful and highly customizable authentication and access-control framework. It is the de-facto standard for securing Spring-based applications.</p>
<p>Spring Security is a framework that focuses on providing both authentication and authorization to Java applications. Like all Spring projects, the real power of Spring Security is found in how easily it can be extended to meet custom requirements</p>
<p>Spring Security是一个功能强大且高度可定制的身份验证和访问控制框架。它实际上是保护基于spring的应用程序的标准。</p>
<p>Spring Security是一个框架，侧重于为Java应用程序提供身份验证和授权。与所有Spring项目一样，Spring安全性的真正强大之处在于它可以轻松地扩展以满足定制需求</p>
<p>从官网的介绍中可以知道这是一个权限框架。想我们之前做项目是没有使用框架是怎么控制权限的？对于权限 一般会细分为功能权限，访问权限，和菜单权限。代码会写的非常的繁琐，冗余。</p>
<p>怎么解决之前写权限代码繁琐，冗余的问题，一些主流框架就应运而生而Spring Scecurity就是其中的一种。</p>
<p>Spring 是一个非常流行和成功的 Java 应用开发框架。Spring Security 基于 Spring 框架，提供了一套 Web 应用安全性的完整解决方案。一般来说，Web 应用的安全性包括用户认证（Authentication）和用户授权（Authorization）两个部分。用户认证指的是验证某个用户是否为系统中的合法主体，也就是说用户能否访问该系统。用户认证一般要求用户提供用户名和密码。系统通过校验用户名和密码来完成认证过程。用户授权指的是验证某个用户是否有权限执行某个操作。在一个系统中，不同用户所具有的权限是不同的。比如对一个文件来说，有的用户只能进行读取，而有的用户可以进行修改。一般来说，系统会为不同的用户分配不同的角色，而每个角色则对应一系列的权限。</p>
<p>对于上面提到的两种应用情景，Spring Security 框架都有很好的支持。在用户认证方面，Spring Security 框架支持主流的认证方式，包括 HTTP 基本认证、HTTP 表单验证、HTTP 摘要认证、OpenID 和 LDAP 等。在用户授权方面，Spring Security 提供了基于角色的访问控制和访问控制列表（Access Control List，ACL），可以对应用中的领域对象进行细粒度的控制。</p>
<h2 id="实战测试"><a href="#实战测试" class="headerlink" title="实战测试"></a>实战测试</h2><h3 id="实验环境搭建"><a href="#实验环境搭建" class="headerlink" title="实验环境搭建"></a>实验环境搭建</h3><p>1、新建一个初始的springboot项目web模块，thymeleaf模块</p>
<p>2、导入静态资源</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">welcome.html</span><br><span class="line">|views</span><br><span class="line">|level1</span><br><span class="line">1.html</span><br><span class="line">2.html</span><br><span class="line">3.html</span><br><span class="line">|level2</span><br><span class="line">1.html</span><br><span class="line">2.html</span><br><span class="line">3.html</span><br><span class="line">|level3</span><br><span class="line">1.html</span><br><span class="line">2.html</span><br><span class="line">3.html</span><br><span class="line">Login.html</span><br></pre></td></tr></table></figure>
<p>3、controller跳转！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line">import org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"></span><br><span class="line">@Controller</span><br><span class="line">public class RouterController &#123;</span><br><span class="line"></span><br><span class="line">   @RequestMapping(&#123;&quot;/&quot;,&quot;/index&quot;&#125;)</span><br><span class="line">   public String index()&#123;</span><br><span class="line">       return &quot;index&quot;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   @RequestMapping(&quot;/toLogin&quot;)</span><br><span class="line">   public String toLogin()&#123;</span><br><span class="line">       return &quot;views/login&quot;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   @RequestMapping(&quot;/level1/&#123;id&#125;&quot;)</span><br><span class="line">   public String level1(@PathVariable(&quot;id&quot;) int id)&#123;</span><br><span class="line">       return &quot;views/level1/&quot;+id;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   @RequestMapping(&quot;/level2/&#123;id&#125;&quot;)</span><br><span class="line">   public String level2(@PathVariable(&quot;id&quot;) int id)&#123;</span><br><span class="line">       return &quot;views/level2/&quot;+id;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   @RequestMapping(&quot;/level3/&#123;id&#125;&quot;)</span><br><span class="line">   public String level3(@PathVariable(&quot;id&quot;) int id)&#123;</span><br><span class="line">       return &quot;views/level3/&quot;+id;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4、测试实验环境是否OK！</p>
<h3 id="认识SpringSecurity"><a href="#认识SpringSecurity" class="headerlink" title="认识SpringSecurity"></a>认识SpringSecurity</h3><p>Spring Security 是针对Spring项目的安全框架，也是Spring Boot底层安全模块默认的技术选型，他可以实现强大的Web安全控制，对于安全控制，我们仅需要引入 spring-boot-starter-security 模块，进行少量的配置，即可实现强大的安全管理！</p>
<p>记住几个类：</p>
<ul>
<li>WebSecurityConfigurerAdapter：自定义Security策略</li>
<li>AuthenticationManagerBuilder：自定义认证策略</li>
<li>@EnableWebSecurity：开启WebSecurity模式</li>
</ul>
<p>Spring Security的两个主要目标是 “认证” 和 “授权”（访问控制）。</p>
<p><strong>“认证”（Authentication）</strong></p>
<p>身份验证是关于验证您的凭据，如用户名/用户ID和密码，以验证您的身份。</p>
<p>身份验证通常通过用户名和密码完成，有时与身份验证因素结合使用。</p>
<p> <strong>“授权” （Authorization）</strong></p>
<p>授权发生在系统成功验证您的身份后，最终会授予您访问资源（如信息，文件，数据库，资金，位置，几乎任何内容）的完全权限。</p>
<p>这个概念是通用的，而不是只在Spring Security 中存在。</p>
<h3 id="认证和授权"><a href="#认证和授权" class="headerlink" title="认证和授权"></a>认证和授权</h3><p>目前，我们的测试环境，是谁都可以访问的，我们使用 Spring Security 增加上认证和授权的功能</p>
<p>1、引入 Spring Security 模块</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>2、编写 Spring Security 配置类</p>
<p>参考官网：<a href="https://spring.io/projects/spring-security">https://spring.io/projects/spring-security</a> </p>
<p>查看我们自己项目中的版本，找到对应的帮助文档：</p>
<p><a href="https://docs.spring.io/spring-security/site/docs/5.3.0.RELEASE/reference/html5">https://docs.spring.io/spring-security/site/docs/5.3.0.RELEASE/reference/html5</a>   #servlet-applications 8.16.4</p>
<p><img src="https://i.p04e.com/baid/i/2023/02/01/ktj9.png"></p>
<p>3、编写基础配置类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.kuang.config;</span><br><span class="line"></span><br><span class="line">import org.springframework.security.config.annotation.web.builders.HttpSecurity;</span><br><span class="line">import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;</span><br><span class="line">import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;</span><br><span class="line"></span><br><span class="line">@EnableWebSecurity // 开启WebSecurity模式</span><br><span class="line">public class SecurityConfig extends WebSecurityConfigurerAdapter &#123;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   protected void configure(HttpSecurity http) throws Exception &#123;</span><br><span class="line">       </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4、定制请求的授权规则</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void configure(HttpSecurity http) throws Exception &#123;</span><br><span class="line">   // 定制请求的授权规则</span><br><span class="line">   // 首页所有人可以访问</span><br><span class="line">   http.authorizeRequests().antMatchers(&quot;/&quot;).permitAll()</span><br><span class="line">  .antMatchers(&quot;/level1/**&quot;).hasRole(&quot;vip1&quot;)</span><br><span class="line">  .antMatchers(&quot;/level2/**&quot;).hasRole(&quot;vip2&quot;)</span><br><span class="line">  .antMatchers(&quot;/level3/**&quot;).hasRole(&quot;vip3&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5、测试一下：发现除了首页都进不去了！因为我们目前没有登录的角色，因为请求需要登录的角色拥有对应的权限才可以！</p>
<p>6、在configure()方法中加入以下配置，开启自动配置的登录功能！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 开启自动配置的登录功能</span><br><span class="line">// /login 请求来到登录页</span><br><span class="line">// /login?error 重定向到这里表示登录失败</span><br><span class="line">http.formLogin();</span><br></pre></td></tr></table></figure>
<p>7、测试一下：发现，没有权限的时候，会跳转到登录的页面！</p>
<p><img src="https://i.p04e.com/baid/i/2023/02/01/41wgh.png"></p>
<p>8、查看刚才登录页的注释信息；</p>
<p>我们可以定义认证规则，重写configure(AuthenticationManagerBuilder auth)方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//定义认证规则</span><br><span class="line">@Override</span><br><span class="line">protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;</span><br><span class="line">   </span><br><span class="line">   //在内存中定义，也可以在jdbc中去拿....</span><br><span class="line">   auth.inMemoryAuthentication()</span><br><span class="line">          .withUser(&quot;kuangshen&quot;).password(&quot;123456&quot;).roles(&quot;vip2&quot;,&quot;vip3&quot;)</span><br><span class="line">          .and()</span><br><span class="line">          .withUser(&quot;root&quot;).password(&quot;123456&quot;).roles(&quot;vip1&quot;,&quot;vip2&quot;,&quot;vip3&quot;)</span><br><span class="line">          .and()</span><br><span class="line">          .withUser(&quot;guest&quot;).password(&quot;123456&quot;).roles(&quot;vip1&quot;,&quot;vip2&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>9、测试，我们可以使用这些账号登录进行测试！发现会报错！</p>
<p>There is no PasswordEncoder mapped for the id “null”</p>
<p>10、原因，我们要将前端传过来的密码进行某种方式加密，否则就无法登录，修改代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//定义认证规则</span><br><span class="line">@Override</span><br><span class="line">protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;</span><br><span class="line">   //在内存中定义，也可以在jdbc中去拿....</span><br><span class="line">   //Spring security 5.0中新增了多种加密方式，也改变了密码的格式。</span><br><span class="line">   //要想我们的项目还能够正常登陆，需要修改一下configure中的代码。我们要将前端传过来的密码进行某种方式加密</span><br><span class="line">   //spring security 官方推荐的是使用bcrypt加密方式。</span><br><span class="line">   </span><br><span class="line">   auth.inMemoryAuthentication().passwordEncoder(new BCryptPasswordEncoder())</span><br><span class="line">          .withUser(&quot;kuangshen&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip2&quot;,&quot;vip3&quot;)</span><br><span class="line">          .and()</span><br><span class="line">          .withUser(&quot;root&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip1&quot;,&quot;vip2&quot;,&quot;vip3&quot;)</span><br><span class="line">          .and()</span><br><span class="line">          .withUser(&quot;guest&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip1&quot;,&quot;vip2&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>11、测试，发现，登录成功，并且每个角色只能访问自己认证下的规则！搞定</p>
<h3 id="权限控制和注销"><a href="#权限控制和注销" class="headerlink" title="权限控制和注销"></a>权限控制和注销</h3><p>1、开启自动配置的注销的功能</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//定制请求的授权规则</span><br><span class="line">@Override</span><br><span class="line">protected void configure(HttpSecurity http) throws Exception &#123;</span><br><span class="line">   //....</span><br><span class="line">   //开启自动配置的注销的功能</span><br><span class="line">      // /logout 注销请求</span><br><span class="line">   http.logout();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、我们在前端，增加一个注销的按钮，index.html 导航栏中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a class=&quot;item&quot; th:href=&quot;@&#123;/logout&#125;&quot;&gt;</span><br><span class="line">   &lt;i class=&quot;address card icon&quot;&gt;&lt;/i&gt; 注销</span><br><span class="line">&lt;/a&gt;</span><br></pre></td></tr></table></figure>
<p>3、我们可以去测试一下，登录成功后点击注销，发现注销完毕会跳转到登录页面！</p>
<p>4、但是，我们想让他注销成功后，依旧可以跳转到首页，该怎么处理呢？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// .logoutSuccessUrl(&quot;/&quot;); 注销成功来到首页</span><br><span class="line">http.logout().logoutSuccessUrl(&quot;/&quot;);</span><br></pre></td></tr></table></figure>
<p>5、测试，注销完毕后，发现跳转到首页OK</p>
<p>6、我们现在又来一个需求：用户没有登录的时候，导航栏上只显示登录按钮，用户登录之后，导航栏可以显示登录的用户信息及注销按钮！还有就是，比如kuangshen这个用户，它只有 vip2，vip3功能，那么登录则只显示这两个功能，而vip1的功能菜单不显示！这个就是真实的网站情况了！该如何做呢？</p>
<p>我们需要结合thymeleaf中的一些功能</p>
<p>sec：authorize=”isAuthenticated()”:是否认证登录！来显示不同的页面</p>
<p>Maven依赖：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/org.thymeleaf.extras/thymeleaf-extras-springsecurity4 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;thymeleaf-extras-springsecurity5&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;3.0.4.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>7、修改我们的 前端页面</p>
<ol>
<li><p>导入命名空间</p>
</li>
<li><p>```<br>xmlns:sec=”<a href="http://www.thymeleaf.org/thymeleaf-extras-springsecurity5">http://www.thymeleaf.org/thymeleaf-extras-springsecurity5</a>“</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">3. 修改导航栏，增加认证判断</span><br><span class="line"></span><br><span class="line">4. ```</span><br><span class="line">   &lt;!--登录注销--&gt;</span><br><span class="line">   &lt;div class=&quot;right menu&quot;&gt;</span><br><span class="line">   </span><br><span class="line">      &lt;!--如果未登录--&gt;</span><br><span class="line">      &lt;div sec:authorize=&quot;!isAuthenticated()&quot;&gt;</span><br><span class="line">          &lt;a class=&quot;item&quot; th:href=&quot;@&#123;/login&#125;&quot;&gt;</span><br><span class="line">              &lt;i class=&quot;address card icon&quot;&gt;&lt;/i&gt; 登录</span><br><span class="line">          &lt;/a&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">   </span><br><span class="line">      &lt;!--如果已登录--&gt;</span><br><span class="line">      &lt;div sec:authorize=&quot;isAuthenticated()&quot;&gt;</span><br><span class="line">          &lt;a class=&quot;item&quot;&gt;</span><br><span class="line">              &lt;i class=&quot;address card icon&quot;&gt;&lt;/i&gt;</span><br><span class="line">             用户名：&lt;span sec:authentication=&quot;principal.username&quot;&gt;&lt;/span&gt;</span><br><span class="line">             角色：&lt;span sec:authentication=&quot;principal.authorities&quot;&gt;&lt;/span&gt;</span><br><span class="line">          &lt;/a&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">   </span><br><span class="line">      &lt;div sec:authorize=&quot;isAuthenticated()&quot;&gt;</span><br><span class="line">          &lt;a class=&quot;item&quot; th:href=&quot;@&#123;/logout&#125;&quot;&gt;</span><br><span class="line">              &lt;i class=&quot;address card icon&quot;&gt;&lt;/i&gt; 注销</span><br><span class="line">          &lt;/a&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">   &lt;/div&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>8、重启测试，我们可以登录试试看，登录成功后确实，显示了我们想要的页面；</p>
<p>9、如果注销404了，就是因为它默认防止csrf跨站请求伪造，因为会产生安全问题，我们可以将请求改为post表单提交，或者在spring security中关闭csrf功能；我们试试：在 配置中增加 <code>http.csrf().disable();</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http.csrf().disable();//关闭csrf功能:跨站请求伪造,默认只能通过post方式提交logout请求</span><br><span class="line">http.logout().logoutSuccessUrl(&quot;/&quot;);</span><br></pre></td></tr></table></figure>
<p>10、我们继续将下面的角色功能块认证完成！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- sec:authorize=&quot;hasRole(&#x27;vip1&#x27;)&quot; --&gt;</span><br><span class="line">&lt;div class=&quot;column&quot; sec:authorize=&quot;hasRole(&#x27;vip1&#x27;)&quot;&gt;</span><br><span class="line">   &lt;div class=&quot;ui raised segment&quot;&gt;</span><br><span class="line">       &lt;div class=&quot;ui&quot;&gt;</span><br><span class="line">           &lt;div class=&quot;content&quot;&gt;</span><br><span class="line">               &lt;h5 class=&quot;content&quot;&gt;Level 1&lt;/h5&gt;</span><br><span class="line">               &lt;hr&gt;</span><br><span class="line">               &lt;div&gt;&lt;a th:href=&quot;@&#123;/level1/1&#125;&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-1-1&lt;/a&gt;&lt;/div&gt;</span><br><span class="line">               &lt;div&gt;&lt;a th:href=&quot;@&#123;/level1/2&#125;&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-1-2&lt;/a&gt;&lt;/div&gt;</span><br><span class="line">               &lt;div&gt;&lt;a th:href=&quot;@&#123;/level1/3&#125;&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-1-3&lt;/a&gt;&lt;/div&gt;</span><br><span class="line">           &lt;/div&gt;</span><br><span class="line">       &lt;/div&gt;</span><br><span class="line">   &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;column&quot; sec:authorize=&quot;hasRole(&#x27;vip2&#x27;)&quot;&gt;</span><br><span class="line">   &lt;div class=&quot;ui raised segment&quot;&gt;</span><br><span class="line">       &lt;div class=&quot;ui&quot;&gt;</span><br><span class="line">           &lt;div class=&quot;content&quot;&gt;</span><br><span class="line">               &lt;h5 class=&quot;content&quot;&gt;Level 2&lt;/h5&gt;</span><br><span class="line">               &lt;hr&gt;</span><br><span class="line">               &lt;div&gt;&lt;a th:href=&quot;@&#123;/level2/1&#125;&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-2-1&lt;/a&gt;&lt;/div&gt;</span><br><span class="line">               &lt;div&gt;&lt;a th:href=&quot;@&#123;/level2/2&#125;&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-2-2&lt;/a&gt;&lt;/div&gt;</span><br><span class="line">               &lt;div&gt;&lt;a th:href=&quot;@&#123;/level2/3&#125;&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-2-3&lt;/a&gt;&lt;/div&gt;</span><br><span class="line">           &lt;/div&gt;</span><br><span class="line">       &lt;/div&gt;</span><br><span class="line">   &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;column&quot; sec:authorize=&quot;hasRole(&#x27;vip3&#x27;)&quot;&gt;</span><br><span class="line">   &lt;div class=&quot;ui raised segment&quot;&gt;</span><br><span class="line">       &lt;div class=&quot;ui&quot;&gt;</span><br><span class="line">           &lt;div class=&quot;content&quot;&gt;</span><br><span class="line">               &lt;h5 class=&quot;content&quot;&gt;Level 3&lt;/h5&gt;</span><br><span class="line">               &lt;hr&gt;</span><br><span class="line">               &lt;div&gt;&lt;a th:href=&quot;@&#123;/level3/1&#125;&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-3-1&lt;/a&gt;&lt;/div&gt;</span><br><span class="line">               &lt;div&gt;&lt;a th:href=&quot;@&#123;/level3/2&#125;&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-3-2&lt;/a&gt;&lt;/div&gt;</span><br><span class="line">               &lt;div&gt;&lt;a th:href=&quot;@&#123;/level3/3&#125;&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-3-3&lt;/a&gt;&lt;/div&gt;</span><br><span class="line">           &lt;/div&gt;</span><br><span class="line">       &lt;/div&gt;</span><br><span class="line">   &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>11、测试一下！</p>
<p>12、权限控制和注销搞定！</p>
<h3 id="记住我"><a href="#记住我" class="headerlink" title="记住我"></a>记住我</h3><p>现在的情况，我们只要登录之后，关闭浏览器，再登录，就会让我们重新登录，但是很多网站的情况，就是有一个记住密码的功能，这个该如何实现呢？很简单</p>
<p>1、开启记住我功能</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//定制请求的授权规则</span><br><span class="line">@Override</span><br><span class="line">protected void configure(HttpSecurity http) throws Exception &#123;</span><br><span class="line">//。。。。。。。。。。。</span><br><span class="line">   //记住我</span><br><span class="line">   http.rememberMe();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、我们再次启动项目测试一下，发现登录页多了一个记住我功能，我们登录之后关闭 浏览器，然后重新打开浏览器访问，发现用户依旧存在！</p>
<p>思考：如何实现的呢？其实非常简单</p>
<p>我们可以查看浏览器的cookie</p>
<p>3、我们点击注销的时候，可以发现，spring security 帮我们自动删除了这个 cookie</p>
<p><img src="https://i.p04e.com/baid/i/2023/02/01/41oo3.png"></p>
<p>4、结论：登录成功后，将cookie发送给浏览器保存，以后登录带上这个cookie，只要通过检查就可以免登录了。如果点击注销，则会删除这个cookie，具体的原理我们在JavaWeb阶段都讲过了，这里就不在多说了！</p>
<h3 id="定制登录页"><a href="#定制登录页" class="headerlink" title="定制登录页"></a>定制登录页</h3><p>现在这个登录页面都是spring security 默认的，怎么样可以使用我们自己写的Login界面呢？</p>
<p>1、在刚才的登录页配置后面指定 loginpage</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http.formLogin().loginPage(&quot;/toLogin&quot;);</span><br></pre></td></tr></table></figure>
<p>2、然后前端也需要指向我们自己定义的 login请求</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a class=&quot;item&quot; th:href=&quot;@&#123;/toLogin&#125;&quot;&gt;</span><br><span class="line">   &lt;i class=&quot;address card icon&quot;&gt;&lt;/i&gt; 登录</span><br><span class="line">&lt;/a&gt;</span><br></pre></td></tr></table></figure>
<p>3、我们登录，需要将这些信息发送到哪里，我们也需要配置，login.html 配置提交请求及方式，方式必须为post:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;form th:action=&quot;@&#123;/login&#125;&quot; method=&quot;post&quot;&gt;</span><br><span class="line">   &lt;div class=&quot;field&quot;&gt;</span><br><span class="line">       &lt;label&gt;Username&lt;/label&gt;</span><br><span class="line">       &lt;div class=&quot;ui left icon input&quot;&gt;</span><br><span class="line">           &lt;input type=&quot;text&quot; placeholder=&quot;Username&quot; name=&quot;username&quot;&gt;</span><br><span class="line">           &lt;i class=&quot;user icon&quot;&gt;&lt;/i&gt;</span><br><span class="line">       &lt;/div&gt;</span><br><span class="line">   &lt;/div&gt;</span><br><span class="line">   &lt;div class=&quot;field&quot;&gt;</span><br><span class="line">       &lt;label&gt;Password&lt;/label&gt;</span><br><span class="line">       &lt;div class=&quot;ui left icon input&quot;&gt;</span><br><span class="line">           &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;</span><br><span class="line">           &lt;i class=&quot;lock icon&quot;&gt;&lt;/i&gt;</span><br><span class="line">       &lt;/div&gt;</span><br><span class="line">   &lt;/div&gt;</span><br><span class="line">   &lt;input type=&quot;submit&quot; class=&quot;ui blue submit button&quot;/&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>
<p>4、这个请求提交上来，我们还需要验证处理，怎么做呢？我们可以查看formLogin()方法的源码！我们配置接收登录的用户名和密码的参数！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http.formLogin()</span><br><span class="line">  .usernameParameter(&quot;username&quot;)</span><br><span class="line">  .passwordParameter(&quot;password&quot;)</span><br><span class="line">  .loginPage(&quot;/toLogin&quot;)</span><br><span class="line">  .loginProcessingUrl(&quot;/login&quot;); // 登陆表单提交请求</span><br></pre></td></tr></table></figure>
<p>5、在登录页增加记住我的多选框</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;checkbox&quot; name=&quot;remember&quot;&gt; 记住我</span><br></pre></td></tr></table></figure>
<p>6、后端验证处理！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//定制记住我的参数！</span><br><span class="line">http.rememberMe().rememberMeParameter(&quot;remember&quot;);</span><br></pre></td></tr></table></figure>
<p>7、测试，OK</p>
<h2 id="完整配置代码"><a href="#完整配置代码" class="headerlink" title="完整配置代码"></a>完整配置代码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.kuang.config;</span><br><span class="line"></span><br><span class="line">import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;</span><br><span class="line">import org.springframework.security.config.annotation.web.builders.HttpSecurity;</span><br><span class="line">import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;</span><br><span class="line">import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;</span><br><span class="line">import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;</span><br><span class="line"></span><br><span class="line">@EnableWebSecurity</span><br><span class="line">public class SecurityConfig extends WebSecurityConfigurerAdapter &#123;</span><br><span class="line"></span><br><span class="line">   //定制请求的授权规则</span><br><span class="line">   @Override</span><br><span class="line">   protected void configure(HttpSecurity http) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">       http.authorizeRequests().antMatchers(&quot;/&quot;).permitAll()</span><br><span class="line">      .antMatchers(&quot;/level1/**&quot;).hasRole(&quot;vip1&quot;)</span><br><span class="line">      .antMatchers(&quot;/level2/**&quot;).hasRole(&quot;vip2&quot;)</span><br><span class="line">      .antMatchers(&quot;/level3/**&quot;).hasRole(&quot;vip3&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       //开启自动配置的登录功能：如果没有权限，就会跳转到登录页面！</span><br><span class="line">           // /login 请求来到登录页</span><br><span class="line">           // /login?error 重定向到这里表示登录失败</span><br><span class="line">       http.formLogin()</span><br><span class="line">          .usernameParameter(&quot;username&quot;)</span><br><span class="line">          .passwordParameter(&quot;password&quot;)</span><br><span class="line">          .loginPage(&quot;/toLogin&quot;)</span><br><span class="line">          .loginProcessingUrl(&quot;/login&quot;); // 登陆表单提交请求</span><br><span class="line"></span><br><span class="line">       //开启自动配置的注销的功能</span><br><span class="line">           // /logout 注销请求</span><br><span class="line">           // .logoutSuccessUrl(&quot;/&quot;); 注销成功来到首页</span><br><span class="line"></span><br><span class="line">       http.csrf().disable();//关闭csrf功能:跨站请求伪造,默认只能通过post方式提交logout请求</span><br><span class="line">       http.logout().logoutSuccessUrl(&quot;/&quot;);</span><br><span class="line"></span><br><span class="line">       //记住我</span><br><span class="line">       http.rememberMe().rememberMeParameter(&quot;remember&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   //定义认证规则</span><br><span class="line">   @Override</span><br><span class="line">   protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;</span><br><span class="line">       //在内存中定义，也可以在jdbc中去拿....</span><br><span class="line">       //Spring security 5.0中新增了多种加密方式，也改变了密码的格式。</span><br><span class="line">       //要想我们的项目还能够正常登陆，需要修改一下configure中的代码。我们要将前端传过来的密码进行某种方式加密</span><br><span class="line">       //spring security 官方推荐的是使用bcrypt加密方式。</span><br><span class="line"></span><br><span class="line">       auth.inMemoryAuthentication().passwordEncoder(new BCryptPasswordEncoder())</span><br><span class="line">              .withUser(&quot;kuangshen&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip2&quot;,&quot;vip3&quot;)</span><br><span class="line">              .and()</span><br><span class="line">              .withUser(&quot;root&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip1&quot;,&quot;vip2&quot;,&quot;vip3&quot;)</span><br><span class="line">              .and()</span><br><span class="line">              .withUser(&quot;guest&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip1&quot;,&quot;vip2&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>SpringBoot</tag>
        <tag>SpringSecurity</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot：系列整合Shiro</title>
    <url>/2023/02/01/SpringBoot%EF%BC%9A%E7%B3%BB%E5%88%97%E6%95%B4%E5%90%88Shiro/</url>
    <content><![CDATA[<p>SpringBoot系列仅供自己学习！</p>
<p>shiro是什么</p>
<span id="more"></span>
<p>Shiro是Apache下的一个开源项目。shiro属于轻量级框架，相对于SpringSecurity简单的多，也没有SpringSecurity那么复杂。以下是我自己学习之后的记录。<br>官方架构图如下：</p>
<p>shiro主要有三大功能模块：</p>
<ol>
<li><p>Subject：主体，一般指用户。</p>
</li>
<li><p>SecurityManager：安全管理器，管理所有Subject，可以配合内部安全组件。(类似于SpringMVC中的DispatcherServlet)</p>
</li>
<li><p>Realms：用于进行权限信息的验证，一般需要自己实现。</p>
</li>
</ol>
<p>  细分功能</p>
<ol>
<li><p>Authentication：身份认证/登录(账号密码验证)。</p>
</li>
<li><p>Authorization：授权，即角色或者权限验证。</p>
</li>
<li><p>Session Manager：会话管理，用户登录后的session相关管理。</p>
</li>
<li><p>Cryptography：加密，密码加密等。</p>
</li>
<li><p>Web Support：Web支持，集成Web环境。</p>
</li>
<li><p>Caching：缓存，用户信息、角色、权限等缓存到如redis等缓存中。</p>
</li>
<li><p>Concurrency：多线程并发验证，在一个线程中开启另一个线程，可以把权限自动传播过去。</p>
</li>
<li><p>Testing：测试支持；</p>
</li>
<li><p>Run As：允许一个用户假装为另一个用户（如果他们允许）的身份进行访问。</p>
</li>
<li><p>Remember Me：记住我，登录后，下次再来的话不用登录了。</p>
</li>
</ol>
<h2 id="目录："><a href="#目录：" class="headerlink" title="目录："></a>目录：</h2><p><img src="https://i.p04e.com/baid/i/2023/02/01/2vxg.png"></p>
<h3 id="1-该整合项目所需的依赖"><a href="#1-该整合项目所需的依赖" class="headerlink" title="1.该整合项目所需的依赖"></a>1.该整合项目所需的依赖</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    &lt;dependencies&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--</span><br><span class="line">        subject 用户</span><br><span class="line">        securityManager 管理所有用户</span><br><span class="line">        realm  连接数据</span><br><span class="line">        --&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--连接数据库的依赖--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;8.0.15&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;log4j&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;log4j&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.2.17&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;druid&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.1.13&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--引入mybatis,这是mybatis官方提供的适配springboot的，而不是springboot自己的--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.1.2&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--不想书写setter、getter方法，导入此依赖--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.16.22&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--shiro整合spring的包--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.4.2&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">            &lt;exclusions&gt;</span><br><span class="line">                &lt;exclusion&gt;</span><br><span class="line">                    &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;</span><br><span class="line">                    &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;</span><br><span class="line">                &lt;/exclusion&gt;</span><br><span class="line">            &lt;/exclusions&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--导入thymeleaf依赖--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.thymeleaf&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;thymeleaf-spring5&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.0.11.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;thymeleaf-extras-java8time&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.0.4.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--shiro-thymeleaf整合--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.github.theborakompanioni&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;thymeleaf-extras-shiro&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.0.0&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;repositories&gt;</span><br><span class="line">        &lt;repository&gt;</span><br><span class="line">            &lt;id&gt;aliyun-repos&lt;/id&gt;</span><br><span class="line">            &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;</span><br><span class="line">            &lt;snapshots&gt;</span><br><span class="line">                &lt;enabled&gt;false&lt;/enabled&gt;</span><br><span class="line">            &lt;/snapshots&gt;</span><br><span class="line">        &lt;/repository&gt;</span><br><span class="line">    &lt;/repositories&gt;</span><br><span class="line">    &lt;pluginRepositories&gt;</span><br><span class="line">        &lt;pluginRepository&gt;</span><br><span class="line">            &lt;id&gt;aliyun-plugin&lt;/id&gt;</span><br><span class="line">            &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;</span><br><span class="line">            &lt;snapshots&gt;</span><br><span class="line">                &lt;enabled&gt;false&lt;/enabled&gt;</span><br><span class="line">            &lt;/snapshots&gt;</span><br><span class="line">        &lt;/pluginRepository&gt;</span><br><span class="line">    &lt;/pluginRepositories&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br><span class="line">    </span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>
<h3 id="2-application-yml设置连接数据库的相关配置"><a href="#2-application-yml设置连接数据库的相关配置" class="headerlink" title="2. application.yml设置连接数据库的相关配置"></a>2. application.yml设置连接数据库的相关配置</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    username: root</span><br><span class="line">    password: 123456</span><br><span class="line">    #?serverTimezone=UTC解决时区的报错</span><br><span class="line">    url: jdbc:mysql://localhost:3306/mybatis?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    type: com.alibaba.druid.pool.DruidDataSource</span><br><span class="line"></span><br><span class="line">    #Spring Boot 默认是不注入这些属性值的，需要自己绑定</span><br><span class="line">    #druid 数据源专有配置</span><br><span class="line">    initialSize: 5</span><br><span class="line">    minIdle: 5</span><br><span class="line">    maxActive: 20</span><br><span class="line">    maxWait: 60000</span><br><span class="line">    timeBetweenEvictionRunsMillis: 60000</span><br><span class="line">    minEvictableIdleTimeMillis: 300000</span><br><span class="line">    validationQuery: SELECT 1 FROM DUAL</span><br><span class="line">    testWhileIdle: true</span><br><span class="line">    testOnBorrow: false</span><br><span class="line">    testOnReturn: false</span><br><span class="line">    poolPreparedStatements: true</span><br><span class="line"></span><br><span class="line">    #配置监控统计拦截的filters，stat:监控统计、log4j：日志记录、wall：防御sql注入</span><br><span class="line">    #如果允许时报错  java.lang.ClassNotFoundException: org.apache.log4j.Priority</span><br><span class="line">    #则导入 log4j 依赖即可，Maven 地址：https://mvnrepository.com/artifact/log4j/log4j</span><br><span class="line">    filters: stat,wall,log4j</span><br><span class="line">    maxPoolPreparedStatementPerConnectionSize: 20</span><br><span class="line">    useGlobalDataSourceStat: true</span><br><span class="line">    connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500</span><br></pre></td></tr></table></figure>
<h3 id="3-index-html"><a href="#3-index-html" class="headerlink" title="3.index.html"></a>3.index.html</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.w3.org/1999/xhtml?&quot;</span><br><span class="line">      xmlns:shiro=&quot;http://www.thymeleaf.org/thymeleaf-extras-shiro&quot; &gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;首页&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div th:if=&quot;$&#123;session.loginUser==null&#125;&quot;&gt;</span><br><span class="line">        &lt;a th:href=&quot;@&#123;/toLogin&#125;&quot;&gt;登录&lt;/a&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;p th:text=&quot;$&#123;msg&#125;&quot;&gt;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">    &lt;hr&gt;</span><br><span class="line">    &lt;div shiro:hasPermission=&quot;user:add&quot;&gt;</span><br><span class="line">        &lt;a th:href=&quot;@&#123;/user/add&#125;&quot;&gt;add&lt;/a&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div shiro:hasPermission=&quot;user:update&quot;&gt;</span><br><span class="line">        &lt;a th:href=&quot;@&#123;/user/update&#125;&quot;&gt;update&lt;/a&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;a th:href=&quot;@&#123;/logout&#125;&quot;&gt;注销&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h3 id="4-add-html和update-html"><a href="#4-add-html和update-html" class="headerlink" title="4.add.html和update.html"></a>4.add.html和update.html</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;add&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line">-------------------------------------------------</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;update&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h3 id="5-login-html"><a href="#5-login-html" class="headerlink" title="5.login.html"></a>5.login.html</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.w3.org/1999/xhtml?&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;登录&lt;/h1&gt;</span><br><span class="line">&lt;hr&gt;</span><br><span class="line">&lt;p th:text=&quot;$&#123;msg&#125;&quot; style=&quot;color:red;&quot;&gt;&lt;/p&gt;</span><br><span class="line">&lt;form th:action=&quot;@&#123;/login&#125;&quot;&gt;</span><br><span class="line">    用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt;</span><br><span class="line">    密码：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;</span><br><span class="line">    &lt;br&gt;</span><br><span class="line">    &lt;input type=&quot;submit&quot; name=&quot;提交&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h3 id="6-MyController-java"><a href="#6-MyController-java" class="headerlink" title="6.MyController.java"></a>6.MyController.java</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class MyController &#123;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&#123;&quot;/&quot;,&quot;/index&quot;&#125;)</span><br><span class="line">    public String toIndex(Model model)&#123;</span><br><span class="line">        model.addAttribute(&quot;msg&quot;,&quot;hello,shiro!&quot;);</span><br><span class="line">        return &quot;index&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/user/add&quot;)</span><br><span class="line">    public String add()&#123;</span><br><span class="line">        return &quot;user/add&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/user/update&quot;)</span><br><span class="line">    public String update()&#123;</span><br><span class="line">        return &quot;user/update&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/toLogin&quot;)</span><br><span class="line">    public String toLogin()&#123;</span><br><span class="line">        return &quot;login&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/login&quot;)</span><br><span class="line">    public String login(String username,String password,Model model)&#123;</span><br><span class="line">        //获取当前用户</span><br><span class="line">        Subject subject = SecurityUtils.getSubject();</span><br><span class="line">        //封装用户的登录数据</span><br><span class="line">        UsernamePasswordToken token = new UsernamePasswordToken(username, password);</span><br><span class="line"></span><br><span class="line">        try&#123;</span><br><span class="line">            subject.login(token); //执行登录的方法，如果没有异常就说明ok了</span><br><span class="line">            return &quot;index&quot;;</span><br><span class="line">        &#125;catch (UnknownAccountException e)&#123; //用户名不存在</span><br><span class="line">            model.addAttribute(&quot;msg&quot;,&quot;用户名不存在！&quot;);</span><br><span class="line">            return &quot;login&quot;;</span><br><span class="line">        &#125;catch (IncorrectCredentialsException e)&#123;</span><br><span class="line">            model.addAttribute(&quot;msg&quot;,&quot;密码错误！&quot;);</span><br><span class="line">            return &quot;login&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">//在一个shiro的demo中，设计共有两个页面，add页面和update页面，add页面只能具有user:add字段的用 //户可以访问，update页面只能具有user:update字段的用户去访问，如果某用户访问add页面，但是没     //有user:add字段的话，则会呈现用户：未经授权不得访问 这样的一个页面。</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/noauth&quot;)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public String unauthorized()&#123;</span><br><span class="line">        return &quot;未授权无法访问此页面&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/logout&quot;)</span><br><span class="line">    public String logout()&#123;</span><br><span class="line">        //获取当前用户</span><br><span class="line">        Subject subject = SecurityUtils.getSubject();</span><br><span class="line">        System.out.println(subject.getSession().getAttribute(&quot;loginUser&quot;));</span><br><span class="line">        subject.logout(); // session 会销毁，在SessionListener监听session销毁，清理权限缓存</span><br><span class="line">        System.out.println(subject.getSession().getAttribute(&quot;loginUser&quot;));</span><br><span class="line">        System.out.println(&quot;执行了退出&quot;);</span><br><span class="line">        return &quot;login&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-ShiroConfig-java"><a href="#7-ShiroConfig-java" class="headerlink" title="7.ShiroConfig.java"></a>7.ShiroConfig.java</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class ShiroConfig &#123;</span><br><span class="line"></span><br><span class="line">    //ShiroFilterFactoryBean （第三步:连接到前端）</span><br><span class="line">    @Bean</span><br><span class="line">    public ShiroFilterFactoryBean getShiroFilterBean(@Qualifier(&quot;securityManager&quot;) DefaultWebSecurityManager defaultWebSecurityManager)&#123;</span><br><span class="line">        ShiroFilterFactoryBean bean = new ShiroFilterFactoryBean();</span><br><span class="line">        //设置安全管理器</span><br><span class="line">        bean.setSecurityManager(defaultWebSecurityManager);</span><br><span class="line"></span><br><span class="line">        //添加shiro的内置过滤器</span><br><span class="line">        /*</span><br><span class="line">        anon: 无需认证即可访问</span><br><span class="line">        authc: 必须认证才能用</span><br><span class="line">        user: 必须拥有 “记住我” 功能才能用</span><br><span class="line">        perms: 拥有对某个资源的权限才能用</span><br><span class="line">        role: 拥有某个角色权限才能访问</span><br><span class="line">        */</span><br><span class="line"></span><br><span class="line">        Map&lt;String,String&gt; filterMap = new LinkedHashMap&lt;&gt;();</span><br><span class="line">        //拦截</span><br><span class="line">        filterMap.put(&quot;/user/add&quot;,&quot;authc&quot;);</span><br><span class="line">        filterMap.put(&quot;/user/update&quot;,&quot;authc&quot;);</span><br><span class="line">        //也可使用通配符*</span><br><span class="line">        //filterMap.put(&quot;/user/*&quot;,&quot;authc&quot;);</span><br><span class="line"></span><br><span class="line">        //授权，正常情况下没有授权会跳转到未授权页面</span><br><span class="line">        filterMap.put(&quot;/user/add&quot;,&quot;perms[user:add]&quot;);</span><br><span class="line">        filterMap.put(&quot;/user/update&quot;,&quot;perms[user:update]&quot;);</span><br><span class="line"></span><br><span class="line">        bean.setFilterChainDefinitionMap(filterMap);</span><br><span class="line"></span><br><span class="line">        //若访问时用户未认证，则跳转至登录页面</span><br><span class="line">        bean.setLoginUrl(&quot;/toLogin&quot;);</span><br><span class="line">        //若访问时用户未被授权，则跳转至未授权页面</span><br><span class="line">        bean.setUnauthorizedUrl(&quot;/noauth&quot;);</span><br><span class="line"></span><br><span class="line">        return bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //DefaultWebSecurityManager （第二步：管理realm对象）</span><br><span class="line">    @Bean(name=&quot;securityManager&quot;) //@Bean注解后便被spring托管,不加name属性，默认name值为方法名,这里就加一下吧</span><br><span class="line">    public DefaultWebSecurityManager getDefaultWebSecurityManager(@Qualifier(&quot;userRealm&quot;) UserRealm userRealm)&#123;</span><br><span class="line">        DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();</span><br><span class="line">        //关联UserRealm</span><br><span class="line">        securityManager.setRealm(userRealm);</span><br><span class="line">        return securityManager;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //创建realm对象，需要自定义类 (第一步:创建realm对象)</span><br><span class="line">    @Bean(name=&quot;userRealm&quot;)  //@Bean注解后便被spring托管,不加name属性，默认name值为方法名,这里就加一下吧</span><br><span class="line">    public UserRealm userRealm()&#123;</span><br><span class="line">        return new UserRealm();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //整合ShiroDialect:用来整合shiro thymeleaf</span><br><span class="line">    @Bean</span><br><span class="line">    public ShiroDialect getShiroDialect()&#123;</span><br><span class="line">        return new ShiroDialect();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-UserRealm-java"><a href="#8-UserRealm-java" class="headerlink" title="8.UserRealm.java"></a>8.UserRealm.java</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//自定义UserRealm extends AuthorizingRealm</span><br><span class="line">public class UserRealm extends AuthorizingRealm &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //授权</span><br><span class="line">    @Override</span><br><span class="line">    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) &#123;</span><br><span class="line">        System.out.println(&quot;执行了授权&quot;);</span><br><span class="line"></span><br><span class="line">        SimpleAuthorizationInfo info = new SimpleAuthorizationInfo();</span><br><span class="line">        //info.addStringPermission(&quot;user:add&quot;);</span><br><span class="line"></span><br><span class="line">        //拿到当前登录的对象</span><br><span class="line">        Subject subject = SecurityUtils.getSubject();</span><br><span class="line">        User currentUser = (User) subject.getPrincipal(); //拿到user对象</span><br><span class="line"></span><br><span class="line">        info.addStringPermission(currentUser.getPerms());</span><br><span class="line"></span><br><span class="line">        return info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //认证</span><br><span class="line">    @Override</span><br><span class="line">    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123;</span><br><span class="line">        System.out.println(&quot;执行了认证&quot;);</span><br><span class="line"></span><br><span class="line">        UsernamePasswordToken userToken = (UsernamePasswordToken) token;</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">        //用户名、密码  模拟从数据库中获取</span><br><span class="line">        String name = &quot;root&quot;;</span><br><span class="line">        String password = &quot;1111&quot;;</span><br><span class="line"></span><br><span class="line">        if (!userToken.getUsername().equals(name))&#123;</span><br><span class="line">            return null; //抛出异常 UnknownAccountException</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //密码认证，shiro做~</span><br><span class="line">        return new SimpleAuthenticationInfo(&quot;&quot;,password,&quot;&quot;);</span><br><span class="line">        */</span><br><span class="line"></span><br><span class="line">        //连接真实数据库</span><br><span class="line">        User user = userService.queryUserByName(userToken.getUsername());</span><br><span class="line">        if (user==null)&#123; //没有这个人</span><br><span class="line">            return null; //抛出异常 UnknownAccountException</span><br><span class="line">        &#125;</span><br><span class="line">        Subject currentSubject = SecurityUtils.getSubject();</span><br><span class="line">        Session session = currentSubject.getSession();</span><br><span class="line">        session.setAttribute(&quot;loginUser&quot;,user);</span><br><span class="line"></span><br><span class="line">        //可以加密： MD5加密   MD5盐值加密</span><br><span class="line">        //密码认证，shiro做~</span><br><span class="line">        return new SimpleAuthenticationInfo(user,user.getPwd(),&quot;&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-UserMapper-java"><a href="#9-UserMapper-java" class="headerlink" title="9.UserMapper.java"></a>9.UserMapper.java</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Repository</span><br><span class="line">@Mapper</span><br><span class="line">public interface UserMapper &#123;</span><br><span class="line"></span><br><span class="line">    public User queryUserByName(String name);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="10-UserMapper-xml"><a href="#10-UserMapper-xml" class="headerlink" title="10.UserMapper.xml"></a>10.UserMapper.xml</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace=&quot;com.ztx.mapper.UserMapper&quot;&gt;</span><br><span class="line">    &lt;select id=&quot;queryUserByName&quot; parameterType=&quot;String&quot; resultType=&quot;User&quot;&gt;</span><br><span class="line">        select * from mybatis.user where name=#&#123;name&#125;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>
<h3 id="11-User-java"><a href="#11-User-java" class="headerlink" title="11.User.java"></a>11.User.java</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Data</span><br><span class="line">@AllArgsConstructor</span><br><span class="line">@NoArgsConstructor</span><br><span class="line">public class User &#123;</span><br><span class="line"></span><br><span class="line">    private int id;</span><br><span class="line">    private String name;</span><br><span class="line">    private String pwd;</span><br><span class="line">    private String perms;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="12-UserService-java和UserServiceImpl-java"><a href="#12-UserService-java和UserServiceImpl-java" class="headerlink" title="12.UserService.java和UserServiceImpl.java"></a>12.UserService.java和UserServiceImpl.java</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface UserService &#123;</span><br><span class="line"></span><br><span class="line">    public User queryUserByName(String name);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-----------------------------------------------------</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class UserServiceImpl implements UserService&#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public User queryUserByName(String name) &#123;</span><br><span class="line">        return userMapper.queryUserByName(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="13-数据库中的user表"><a href="#13-数据库中的user表" class="headerlink" title="13.数据库中的user表"></a>13.数据库中的user表</h3><p><img src="https://i.p04e.com/baid/i/2023/02/01/2nbp.png"></p>
<p>个人对该项目执行流程进行了梳理，如有错误，请指正：</p>
<p>　　1.ShiroConf.java中设置好拦截器，规定哪些页面需要用户具备何种要求才可访问，同时还设置当用户不满足要求时应该跳转至什么页面。对应本项目的代码：</p>
<p>　<img src="https://i.p04e.com/baid/i/2023/02/01/20y.png"></p>
<p>　　2.用户在未认证下，会跳转到登陆页面login.html。输入用户名密码，提交执行controller中的login()方法，该方法内将用户信息封装成token对象，传入subject.login()方法内进行登录验证。对应项目代码：</p>
<p>　　<img src="https://i.p04e.com/baid/i/2023/02/01/dbj.png"> </p>
<p>　　3.执行登录验证时会跳转到UserRealm类，首先执行认证(doGetAuthenticationInfo)：连接数据库判断是否有此人，若没有则返回结果null，若有，则将数据库中的用户信息存储在subject的session中。接着进行密码验证，若验证失败，则将登录不通过返回失败认证信息，反之，返回成功的认证信息，并执行用户授权(doGetAuthorizationInfo)操作，返回授权信息。对应项目代码：</p>
<p>　　认证：</p>
<p> 　<img src="https://i.p04e.com/baid/i/2023/02/01/d0x.png"></p>
<p>　　授权：</p>
<p>　　 <img src="https://i.p04e.com/baid/i/2023/02/02/3s2i.png"></p>
<p>　　4.本项目中登录成功后跳转到index.html时依旧会再次执行授权操作，因为前端页面需要一个判断展示功能，代码如下：</p>
<p>　<img src="https://i.p04e.com/baid/i/2023/02/01/3prr7.png"></p>
<p>　　故控制台信息会是这样：（出现两次授权）</p>
<p>　　 <img src="https://i.p04e.com/baid/i/2023/02/01/3ould.png"></p>
<p>　　5.之后进入add.html或update.html时，因为会被拦截，所以都要进行授权验证，而此时认证将不会在执行。</p>
]]></content>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Shiro</tag>
      </tags>
  </entry>
  <entry>
    <title>java基础复习笔记：冯·诺依曼结构</title>
    <url>/2023/02/01/java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%86%AF%C2%B7%E8%AF%BA%E4%BE%9D%E6%9B%BC%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>冯·诺依曼结构（也称普林斯顿结构）<br>  数学家冯·诺依曼提出了计算机制造的三个基本原则，即采用二进制逻辑、程序存储执行以及计算机由五个部分组成（运算器、控制器、存储器、输入设备、输出设备），这套理论被称为冯·诺依曼体系结构。<span id="more"></span></p>
<p>特点：<br>  “程序存储，共享数据，顺序执行”，需要 CPU 从存储器取出指令和数据进行相应的计算。<br>主要特点有：<br>（1）将软件和硬件完全分离；<br>（2）单处理机结构，机器以运算器为中心；<br>（3）采用程序存储思想；<br>（4） 指令和数据一样可以参与运算；<br>（5）数据以二进制表示；<br>（6） 指令由操作码和地址码组成且按顺序执行。<br>操作码：表示操作的性质。 地址码:表示操作数在存储器中的位置。</p>
<p>局限：</p>
<p>  CPU 与共享存储器间的信息交换的速度成为影响系统性能的主要因素，而信息交换速度的提高又受制于存储元件的速度、存储器的性能和结构等诸多条件。如：</p>
<p>（1）指令和数据存储在同一个存储器中，形成系统对存储器的过分依赖。<br>（2）指令在存储器中按其执行顺序存放，由指令计数器PC指明要执行的指令所在的单元地址。 然后取出指令执行操作任务。所以指令的执行是串行。影响了系统执行的速度。<br>（3）存储器是按地址访问的线性编址，按顺序排列的地址访问，利于存储和执行的机器语言指令，适用于作数值计算。但是高级语言表示的存储器则是一组有名字的变量，按名字调用变量，不按地址访问。机器语言同高级语言在语义上存在很大的间隔，称之为冯·诺依曼语义间隔。消除语义间隔成了计算机发展面临的一大难题。<br>（4）冯·诺依曼体系结构计算机是为算术和逻辑运算而诞生的，目前在数值处理方面已经到达较高的速度和精度，而非数值处理应用领域发展缓慢，需要在体系结构方面有重大的突破。<br>（5）传统的冯·诺依曼型结构属于控制驱动方式。它是执行指令代码对数值代码进行处理，只要指令明确，输入数据准确，启动程序后自动运行而且结果是预期的。一旦指令和数据有错误，机器不会主动修改指令并完善程序。而人类生活中有许多信息是模糊的，事件的发生、发展和结果是不能预期的，现代计算机的智能是无法应对如此复杂任务的。</p>
<p><img src="https://i.p04e.com/baid/i/2023/02/01/nmu5.png"></p>
<p><img src="https://i.p04e.com/baid/i/2023/02/01/o5to.png"></p>
]]></content>
      <tags>
        <tag>java基础复习</tag>
      </tags>
  </entry>
  <entry>
    <title>sendredirect与getrequestdispatcher的区别</title>
    <url>/2023/02/13/sendredirect%E4%B8%8Egetrequestdispatcher%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>(1)request.getRequestDispatcher()是请求转发，前后页面共享一个request ; 这个是在服务端运行的，对浏览器来说是透明的。<br>(2)response.sendRedirect()是重新定向，前后页面不是一个request。而这个是在浏览器端运行的。<br>redirect()方式:</p>
<span id="more"></span>
<p>response.sendRedirect(“/a.jsp”);<br>　　 页面的路径是相对路径。sendRedirect可以将页面跳转到任何页面，不一定局限于本web应用中，如：<br>　　 response.sendRedirect(“URL”);<br>　　 跳转后浏览器地址栏变化。<br>　　 这种方式要传值出去的话，只能在url中带parameter或者放在session中，无法使用request.setAttribute来 传递。所以该方式只适用于无传值跳转<br>　　<br>　　2) forward方式<br>　　 request.getRequestDispatcher(“/路径（可以是jsp路径也可以是servlet）”) .forward(request, response);</p>
<p>如：<br>“request.getRequestDispatcher(”/2.jsp）”) .forward(request, response);”</p>
<p>“request.getRequestDispatcher(”/servlet/HomeServlet）”) .forward(request, response);”<br>　　Servlet页面跳转的路径是相对路径。forward方式只能跳转到本web应用中的页面上。<br>　　跳转后浏览器地址栏不会变化。<br>　　使用这种方式跳转，传值可以使用三种方法：url中带parameter，session，request.setAttribute</p>
<p>实例：</p>
<p>用户登录模块</p>
<p>login.jsp</p>
<p>loginServlet.java</p>
<p>loginOK.jsp</p>
<p>用户访问login.jsp，输入用户名和密码进行登录，请求到达loginServlet，loginServet中，在session中加入user属性，值为输入的用户名。接着loginServlet把请求转发给loginOK.jsp，loginOK.jsp显示用户名。</p>
<p>代码简单描述</p>
<p><code>login.jsp中：</code><br><code>username=aaa，password=123；</code></p>
<p><code>loginServlet.java中：</code><br><code>String username=request.getParameter(&quot;username&quot;);</code><br><code>session.setAttribute(&quot;username&quot;,username);</code></p>
<p><code>loginOK.jsp中:</code></p>
<p><code>显示request中的用户名 $&#123;username&#125;，</code></p>
<p><code>显示session中的用户名 $&#123;username&#125;，</code></p>
<p>第一种情况：</p>
<p>由loginServlet调用forward方法进行转发，首先观察浏览器的地址栏，发现了地址是形如<a href="http://.../login.do?username=..&amp;..的样子的。页面中的request里的用户名和session的用户名都显示了出来。">http://.../login.do?username=..&amp;..的样子的。页面中的request里的用户名和session的用户名都显示了出来。</a></p>
<p>第二种情况：</p>
<p>由loginServlet调用sendRedirect方法进行转发，还是观察地址栏，发现地址已经变成<a href="http://.../loginOK.jsp了，">http://.../loginOK.jsp了，</a></p>
<p>页面中request里面的用户名没有显示出来，但是session里的用户名却显示了出来。</p>
<p>这是为什么呢？</p>
<p>原来，forward 是服务器端的跳转，也就是客户端根本不知道这个动作，从一个java程序转到了另一个java程序，所以此时request会被作为参数传递过去。<br>但是，sendRedirect 这个是客户端的跳转，服务器端会发送一个跳转的代码和url给浏览器，浏览器会重新请求指定的URL,所以此时，request已经无效了。当然，此时session还是生效的。</p>
]]></content>
      <tags>
        <tag>转发</tag>
        <tag>重定向</tag>
        <tag>javaweb</tag>
      </tags>
  </entry>
  <entry>
    <title>过滤器、拦截器</title>
    <url>/2023/02/14/%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E6%8B%A6%E6%88%AA%E5%99%A8/</url>
    <content><![CDATA[<h3 id="Springboot实现拦截器功能"><a href="#Springboot实现拦截器功能" class="headerlink" title="Springboot实现拦截器功能"></a>Springboot实现拦截器功能</h3><p><img src="https://i.p04e.com/baid/i/2023/02/14/ixq.png"></p>
<span id="more"></span>
<blockquote>
<p>preHandle: 预先处理,在目标的controller方法执行之前,进行处理</p>
<p>postHandle: 在目标的controller方法执行之后,到达指定页面之前进行处理</p>
<p>afterCompletion: 在页面渲染之后进行处理</p>
</blockquote>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><blockquote>
<p>1.Springboot通过实现<a href="https://so.csdn.net/so/search?q=HandlerInterceptor&amp;spm=1001.2101.3001.7020">HandlerInterceptor</a>接口实现拦截器</p>
<p>2.通过WebMvcConfigurer实现一个配置类,再通过@Configuration 注解注入到容器</p>
<p>3.指定拦截规则</p>
</blockquote>
<p> 以用户登录为案例,若用户没有登录session里面就没有用户的数据,就会转到首页登录页面</p>
<p>在正确登录之后，就将reglister保存到session中，再次访问页面的时候，登录<a href="https://so.csdn.net/so/search?q=%E6%8B%A6%E6%88%AA%E5%99%A8&amp;spm=1001.2101.3001.7020">拦截器</a>就可以找到这个reglister对象，就不需要再次拦截到登录界面了.</p>
<p><img src="https://i.p04e.com/baid/i/2023/02/14/q3ho.png"><br><img src="https://i.p04e.com/baid/i/2023/02/14/52nh1.png"></p>
<blockquote>
<p>注意:拦截器  \ 会拦截一切资源,包括静态资源,需要将静态资源放行</p>
</blockquote>
<p><img src="https://i.p04e.com/baid/i/2023/02/14/qbbp.jpg"><br><img src="https://i.p04e.com/baid/i/2023/02/14/3rc4.jpg"></p>
<h3 id="SpringBoot使用过滤器Filter"><a href="#SpringBoot使用过滤器Filter" class="headerlink" title="SpringBoot使用过滤器Filter"></a>SpringBoot使用过滤器Filter</h3><blockquote>
<p>SpringBoot中使用过滤器Filter有两种方式</p>
<p>方式一： 通过注解方式实现</p>
<p>方式二：通过 Spring Boot 的配置类实现</p>
</blockquote>
<h4 id="方式一：-通过注解方式实现"><a href="#方式一：-通过注解方式实现" class="headerlink" title="方式一： 通过注解方式实现"></a>方式一： 通过注解方式实现</h4><p>首先先写一个过滤器Filter，在类的上方使用 @WebFilter 注解来创建Filter即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//过滤器</span></span><br><span class="line"><span class="meta">@WebFilter(urlPatterns = &quot;/myfilter&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;---------您已进入过滤器----------&quot;</span>);</span><br><span class="line">        filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在SpringBoot项目的入口类上方使用注解 @ServletComponentScan 扫描filter包中的注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.servlet.ServletComponentScan;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@ServletComponentScan(basePackages = &quot;com.springboot.filter&quot;)</span>  <span class="comment">//第一种方式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringbootTest14Application</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(SpringbootTest14Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.p04e.com/baid/i/2023/02/14/qihe.png"></p>
<h4 id="方式二：通过-Spring-Boot-的配置类实现"><a href="#方式二：通过-Spring-Boot-的配置类实现" class="headerlink" title="方式二：通过 Spring Boot 的配置类实现"></a>方式二：通过 Spring Boot 的配置类实现</h4><p>首先先写一个过滤器Filter,不使用注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//过滤器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;---------您已进入过滤器222----------&quot;</span>);</span><br><span class="line">        filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再写一个配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  <span class="comment">//定义此类为配置类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FilterConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> FilterRegistrationBean <span class="title function_">myFilterRegistrationBean</span><span class="params">()</span>&#123;</span><br><span class="line">        FilterRegistrationBean filterRegistrationBean=<span class="keyword">new</span> <span class="title class_">FilterRegistrationBean</span>(<span class="keyword">new</span> <span class="title class_">MyFilter</span>());</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//添加过滤路径</span></span><br><span class="line">        filterRegistrationBean.addUrlPatterns(<span class="string">&quot;/user/*&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> filterRegistrationBean;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后写一个controller类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/user/detail&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="meta">@ResponseBody</span> String <span class="title function_">userDetail</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/user/detail&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/center&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="meta">@ResponseBody</span> String <span class="title function_">center</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/center&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.p04e.com/baid/i/2023/02/14/2sn.png"><br><img src="https://i.p04e.com/baid/i/2023/02/14/qmzo.png"></p>
<h3 id="过滤器和拦截器的区别"><a href="#过滤器和拦截器的区别" class="headerlink" title="过滤器和拦截器的区别"></a>过滤器和拦截器的区别</h3><ol>
<li>过滤器和拦截器触发时机不一样，过滤器是在请求进入容器后，但请求进入servlet之前进行预处理的。请求结束返回也是，是在servlet处理完后，返回给前端之前。</li>
<li>拦截器可以获取IOC容器中的各个bean，而过滤器就不行，因为拦截器是spring提供并管理的，spring的功能可以被拦截器使用，在拦截器里注入一个service，可以调用业务逻辑。而过滤器是JavaEE标准，只需依赖servlet<br>api ，不需要依赖spring。</li>
<li>过滤器的实现基于回调函数。而拦截器（代理模式）的实现基于反射</li>
<li>Filter是依赖于Servlet容器，属于Servlet规范的一部分，而拦截器则是独立存在的，可以在任何情况下使用。</li>
<li>Filter的执行由Servlet容器回调完成，而拦截器通常通过动态代理（反射）的方式来执行。</li>
<li>Filter的生命周期由Servlet容器管理，而拦截器则可以通过IoC容器来管理，因此可以通过注入等方式来获取其他Bean的实例，因此使用会更方便。</li>
</ol>
<p>过滤器和拦截器非常相似，但是它们有很大的区别，最简单明了的区别就是<strong>过滤器可以修改request，而拦截器不能过滤器需要在servlet容器中实现，拦截器可以适用于javaEE，javaSE等各种环境拦截器可以调用IOC容器中的各种依赖，而过滤器不能过滤器只能在请求的前后使用，而拦截器可以详细到每个方法</strong></p>
<h3 id="JavaWeb之过滤器-filter"><a href="#JavaWeb之过滤器-filter" class="headerlink" title="JavaWeb之过滤器(filter)"></a>JavaWeb之过滤器(filter)</h3><p>filter的使用（xml配置）<br>1，声明一个过滤器类要实现Filter接口(CusFilter类)</p>
<pre><code>public class CusFilter implements Filter &#123;
    @Override
    public void init(FilterConfig filterConfig) throws ServletException &#123;
        System.out.println(&quot;filter 初始化了&quot;);
    &#125;

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;
        /*过滤方法 主要是对request和response进行一些处理，然后交给下一个过滤器或Servlet处理*/
        System.out.println(&quot;过滤请求了！！！&quot;);
        //给请求放行 请求真正的资源/或者到下一个过滤器
        filterChain.doFilter(servletRequest, servletResponse);
    &#125;

    @Override
    public void destroy() &#123;
        System.out.println(&quot;filter 销毁了&quot;);
    &#125;
&#125;
</code></pre><p>2、配置 web.xml 文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line">  &lt;filter-name&gt;filter&lt;/filter-name&gt;</span><br><span class="line">  &lt;filter-class&gt;com.codeyancy.filter.CusFilter&lt;/filter-class&gt;</span><br><span class="line">&lt;/filter&gt;</span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">  &lt;filter-name&gt;filter&lt;/filter-name&gt;</span><br><span class="line">  &lt;url-pattern&gt;<span class="comment">/*&lt;/url-pattern&gt;</span></span><br><span class="line"><span class="comment">&lt;/filter-mapping&gt;</span></span><br><span class="line"><span class="comment"></span></span><br></pre></td></tr></table></figure>
<p>过滤器(Filter)的生命周期<br>构造 —&gt; 初始化 —&gt; 过滤 —&gt; 销毁</p>
<p>构造和初始化是在应用部署好后就执行的而不是第一次访问，而且是只执行一次<br>过滤方法是每次指定的请求发送过来的时候执行<br>销毁方法是应用卸载或者TOMCAT关闭的时候执行<br>过滤器(Filter)的拦截路径写法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">    &lt;filter-name&gt;filter&lt;/filter-name&gt;</span><br><span class="line">    &lt;!--       <span class="comment">/* 表示过滤所有请求  --&gt;</span></span><br><span class="line"><span class="comment">    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</span></span><br><span class="line"><span class="comment">    &lt;!--精确路径过滤--&gt;</span></span><br><span class="line"><span class="comment">    &lt;url-pattern&gt;/ajaSearch.html&lt;/url-pattern&gt;</span></span><br><span class="line"><span class="comment">    &lt;!--后缀名匹配过滤--&gt;</span></span><br><span class="line"><span class="comment">    &lt;url-pattern&gt;*.html&lt;/url-pattern&gt;</span></span><br><span class="line"><span class="comment">    &lt;!--目录匹配过滤--&gt;</span></span><br><span class="line"><span class="comment">    &lt;url-pattern&gt;/html/*&lt;/url-pattern&gt;</span></span><br><span class="line"><span class="comment">&lt;/filter-mapping&gt;</span></span><br><span class="line"><span class="comment"></span></span><br></pre></td></tr></table></figure>
<p>filter的使用（注解形式）<br>使用注解形式，就不需要再配置web.xml了</p>
<p>只需要在实现Filter接口的类上添加注解@WebFilter(“/*”)即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebFilter(&quot;/*&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CusFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br></pre></td></tr></table></figure>
<p>多个过滤器(Filter)的执行顺序<br>在请求到达Servle之间是可以经过多个过滤器(Filter)的，一般情况下，建议过滤器(Filter)之间不要有关联，各自处理各自的逻辑即可。这样，我们也不需要关心执行顺序问题。</p>
<p>如果一定要确保执行顺序，就要对配置进行修改了，多个过滤器(Filter)的执行顺序如下</p>
<p>使用web.xml 配置，filter执行顺序跟的顺序有关，先声明的就会先执行<br>使用注解配置，filter的执行顺序跟filter名称的字母顺序有关，例如AFilter会比BFilter先执行<br>如果既有在web.xml中声明的Filter，也有通过注解配置的Filter，那么会优先执行web.xml中配置的Filter<br>FilterConfig配置类<br>每个filter都有一个配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">    <span class="comment">//获取filter的初始化参数</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">jdbcUrl</span> <span class="operator">=</span> filterConfig.getInitParameter(<span class="string">&quot;jdbcUrl&quot;</span>);</span><br><span class="line">    System.out.println(jdbcUrl);</span><br><span class="line">    <span class="comment">// 获取上下文对象</span></span><br><span class="line">    <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> filterConfig.getServletContext();</span><br><span class="line">    System.out.println(<span class="string">&quot;filter 初始化了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>web.xml文件配置初始化参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用过滤器处理请求响应乱码案例<br>主要代码演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> (HttpServletRequest) servletRequest;</span><br><span class="line">        <span class="type">HttpServletResponse</span> <span class="variable">response</span> <span class="operator">=</span> (HttpServletResponse) servletResponse;</span><br><span class="line">        <span class="comment">//处理乱码</span></span><br><span class="line">        request.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        response.setContentType(<span class="string">&quot;text/json;charset=UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">requestURI</span> <span class="operator">=</span> request.getRequestURI();</span><br><span class="line">        <span class="comment">//System.out.println(&quot;filter1 拦截了请求...&quot; + requestURI);</span></span><br><span class="line">        filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">        <span class="comment">//System.out.println(&quot;filter1 响应了请求...&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用过滤器进行校验登陆权限案例</p>
<p>1.前端login.html</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form action=<span class="string">&quot;/auth&quot;</span> method = <span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">    user &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;username&quot;</span>&gt; &lt;br&gt;</span><br><span class="line">    pass &lt;input type=<span class="string">&quot;password&quot;</span> name=<span class="string">&quot;password&quot;</span>&gt; &lt;br&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;登录&quot;</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
<p>2.后端权限校验servlet(AuthController 类)</p>
<p>@WebServlet(“/auth”)<br>public class AuthController extends HttpServlet {</p>
<pre><code>@Override
protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
    String username = req.getParameter(&quot;username&quot;);
    String password = req.getParameter(&quot;password&quot;);
    if(&quot;tom&quot;.equals(username)&amp;&amp;&quot;666&quot;.equals(password))&#123;
        //验证成功后往session域中存放登录信息
        HttpSession session = req.getSession();
        session.setAttribute(&quot;user&quot;,new User(username,password));

        resp.sendRedirect(&quot;/index.html&quot;);
    &#125;else &#123;
        resp.sendRedirect(&quot;/login.html&quot;);
    &#125;
&#125;
@Override
protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
    doGet(req, resp);
&#125;
</code></pre><p>3.后端过滤器(CusFilter2类)</p>
<pre><code>@WebFilter(&quot;/*&quot;)
public class CusFilter2 implements Filter &#123;
    public CusFilter2() &#123;
        System.out.println(&quot;filter2 过滤器构造了&quot;);
    &#125;

    @Override
    public void init(FilterConfig filterConfig) throws ServletException &#123;
        System.out.println(&quot;filter2 初始化&quot;);
    &#125;

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;
        HttpServletRequest request = (HttpServletRequest) servletRequest;
        HttpServletResponse response = (HttpServletResponse) servletResponse;

            HttpSession session = request.getSession();
            Object user = session.getAttribute(&quot;user&quot;);
            if(user==null)&#123;
                response.sendRedirect(&quot;/login.html&quot;);
            &#125;else &#123;
                //放行，请求真正的资源/到下一个过滤器
                filterChain.doFilter(servletRequest, servletResponse);
            &#125;
        &#125;
    &#125;

    @Override
    public void destroy() &#123;
    &#125;
&#125;
</code></pre><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.xufengnian.servlet<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>filter<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>SpringBoot</tag>
        <tag>javaweb</tag>
        <tag>过滤器</tag>
        <tag>拦截器</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程</title>
    <url>/2023/03/27/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><p>进程是执行程序的一次执行过程，它是一个动态的概念，是系统资源分配的单位</p>
<span id="more"></span>
<p>通常在一个进程中可以包含若干个线程，当然一个进程中至少有一个线程，不然没有存在的一次，线程是CPU调度和执行的单位</p>
<p>注：很多多线程是模拟出来的，真正的多线程是指有多个cpu，即多核，如服务器，如果是模拟出来的多线程，即在一个cpu的情况下，在同一个时间点，cpu只能执行一个代码，因为切换的很快，所以就有同时执行的错觉。</p>
<p>多线程其实就是让不同的线程去操作同一个对象</p>
<h2 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h2><p>Thread class 继承Thread类(重点)<br>Runnable接口(重点)<br>Callable实现Callable接口(了解)<br>Thread类本身实现了Runnable接口</p>
<p>直接调用run方法和start方法的区别：</p>
<p>直接调用run方法相当于是调用了一个普通的方法，而调用start方法才相当于是开启了一个线程。当我们在main线程与分线程分别执行2000次输出语句，那么就会发现两个输出语句混杂在一起，也就是多线程。</p>
<h4 id="继承Thread方法"><a href="#继承Thread方法" class="headerlink" title="继承Thread方法"></a>继承Thread方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hty.demo;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 创建线程的第一种方式   继承Thread类，重写run()方法，调用start()方法开启线程</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Demo1</span> <span class="variable">demo1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo1</span>();</span><br><span class="line">        demo1.start();<span class="comment">//调用start方法来开启线程</span></span><br><span class="line">        <span class="comment">//主方法，main线程</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2000</span>;++i)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是main线程---&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//run()方法线程体</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2000</span>;++i)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是分线程---&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注：线程开启后并不一定立即执行，而是由CPU进行调度</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hty.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.FileUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 案例一：使用多线程模拟同步图片下载功能</span></span><br><span class="line"><span class="comment">* 需要下载一个commons-io包，就是一个文件操作类</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo2</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String url;<span class="comment">//网络图片地址</span></span><br><span class="line">    <span class="keyword">private</span> String name;<span class="comment">//保存的文件名</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Demo2</span><span class="params">(String url,String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.url = url;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">WebDownLoader</span> <span class="variable">wdl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WebDownLoader</span>();</span><br><span class="line">        wdl.downloader(url,name);</span><br><span class="line">        System.out.println(<span class="string">&quot;下载&quot;</span>+name+<span class="string">&quot;成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Demo2</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo2</span>(<span class="string">&quot;https://cdn.acwing.com/media/user/profile/photo/1_lg_844c66b332.jpg&quot;</span>,<span class="string">&quot;pic1.jpg&quot;</span>);</span><br><span class="line">        <span class="type">Demo2</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo2</span>(<span class="string">&quot;https://cdn.acwing.com/media/user/profile/photo/1_lg_844c66b332.jpg&quot;</span>,<span class="string">&quot;pic2.jpg&quot;</span>);</span><br><span class="line">        <span class="type">Demo2</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo2</span>(<span class="string">&quot;https://cdn.acwing.com/media/user/profile/photo/1_lg_844c66b332.jpg&quot;</span>,<span class="string">&quot;pic3.jpg&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下载器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WebDownLoader</span>&#123;</span><br><span class="line">    <span class="comment">//下载方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">downloader</span><span class="params">(String url,String name)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileUtils.copyURLToFile(<span class="keyword">new</span> <span class="title class_">URL</span>(url),<span class="keyword">new</span> <span class="title class_">File</span>(name));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;IO异常,downloader方法出现问题 &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最后的结果是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">下载pic3.jpg成功</span><br><span class="line">下载pic1.jpg成功</span><br><span class="line">下载pic2.jpg成功</span><br></pre></td></tr></table></figure>
<p>我们发现并不是按照我们预想的那样，首先下载pic1,之后是pic2,pic3，每次下载完成后的结果都不尽相同，说明了线程的执行顺序与程序的顺序无关，是由CPU进行调度的</p>
<h4 id="实现Runnable接口方法"><a href="#实现Runnable接口方法" class="headerlink" title="实现Runnable接口方法"></a>实现Runnable接口方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hty.demo;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 线程创建方法二：实现Runnable接口 重写run方法</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo3</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        //创建Runnable接口的实现类对象</span></span><br><span class="line">        <span class="type">Demo3</span> <span class="variable">demo3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo3</span>();</span><br><span class="line"><span class="comment">//        //创建一个线程对象，通过线程对象，开启线程 ------代理</span></span><br><span class="line"><span class="comment">//        Thread thread = new Thread(demo3);</span></span><br><span class="line"><span class="comment">//        thread.start();</span></span><br><span class="line">        <span class="comment">//简写</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(demo3).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//主方法，main线程</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2000</span>;++i)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是main线程---&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//run()方法线程体</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2000</span>;++i)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是分线程---&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hty.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.FileUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 同步下载图片的案例使用实现Runnable的方法做</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo4</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String url;<span class="comment">//网络图片地址</span></span><br><span class="line">    <span class="keyword">private</span> String name;<span class="comment">//保存的文件名</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Demo4</span><span class="params">(String url,String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.url = url;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">WebDownLoader</span> <span class="variable">wdl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WebDownLoader</span>();</span><br><span class="line">        wdl.downloader(url,name);</span><br><span class="line">        System.out.println(<span class="string">&quot;下载&quot;</span>+name+<span class="string">&quot;成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Demo2</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo2</span>(<span class="string">&quot;https://cdn.acwing.com/media/user/profile/photo/1_lg_844c66b332.jpg&quot;</span>,<span class="string">&quot;pic1.jpg&quot;</span>);</span><br><span class="line">        <span class="type">Demo2</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo2</span>(<span class="string">&quot;https://cdn.acwing.com/media/user/profile/photo/1_lg_844c66b332.jpg&quot;</span>,<span class="string">&quot;pic2.jpg&quot;</span>);</span><br><span class="line">        <span class="type">Demo2</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo2</span>(<span class="string">&quot;https://cdn.acwing.com/media/user/profile/photo/1_lg_844c66b332.jpg&quot;</span>,<span class="string">&quot;pic3.jpg&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(t1).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(t2).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(t3).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下载器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WebDownLoader1</span>&#123;</span><br><span class="line">    <span class="comment">//下载方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">downloader</span><span class="params">(String url,String name)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileUtils.copyURLToFile(<span class="keyword">new</span> <span class="title class_">URL</span>(url),<span class="keyword">new</span> <span class="title class_">File</span>(name));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;IO异常,downloader方法出现问题 &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>我们更推荐使用的是实现Runnable接口的方法来实现多线程，避免了java的单继承局限性</strong></p>
<h4 id="使用多个线程操作同一个对象"><a href="#使用多个线程操作同一个对象" class="headerlink" title="使用多个线程操作同一个对象"></a>使用多个线程操作同一个对象</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hty.demo;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 多个线程操作同一个对象</span></span><br><span class="line"><span class="comment">* 买火车票的例子</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 运行之后会发现有些票会被买了两次，这就是并发的问题</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo5</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">ticketNums</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Demo5</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo5</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(t1).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(t1).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(t1).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//买票</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ticketNums == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;--&gt;购买了第&quot;</span>+ticketNums--+<span class="string">&quot;张票&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hty.demo;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 使用多线程，完成龟兔赛跑的案例</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo6</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String winner;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//模拟兔子休息</span></span><br><span class="line">            <span class="keyword">if</span>(Thread.currentThread().getName().equals(<span class="string">&quot;兔子&quot;</span>) &amp;&amp; i%<span class="number">10</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断比赛是否结束</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> gameOver(i);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;跑了&quot;</span>+i+<span class="string">&quot;步&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否完成比赛</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">gameOver</span><span class="params">(<span class="type">int</span> steps)</span>&#123;</span><br><span class="line">        <span class="comment">//判断是否有胜利者</span></span><br><span class="line">        <span class="keyword">if</span>(winner != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//结束比赛</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(steps &gt;= <span class="number">100</span>)&#123;</span><br><span class="line">                winner = Thread.currentThread().getName();</span><br><span class="line">                System.out.println(<span class="string">&quot;winner is &quot;</span>+winner);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Demo6</span> <span class="variable">demo6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo6</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(demo6,<span class="string">&quot;兔子&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(demo6,<span class="string">&quot;乌龟&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hty.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 静态代理部分的知识</span></span><br><span class="line"><span class="comment">* 案例：</span></span><br><span class="line"><span class="comment">*   我结婚，但是是婚庆公司承接，看上去是婚庆公司结婚，但实际上是我结婚</span></span><br><span class="line"><span class="comment">* 静态代理模式总结</span></span><br><span class="line"><span class="comment">*   真实对象(目标对象)都要实现同一个接口</span></span><br><span class="line"><span class="comment">*   代理对象要代理真实对象</span></span><br><span class="line"><span class="comment">* 好处：代理对象可以做很多真实对象做不了的东西</span></span><br><span class="line"><span class="comment">*      真实对象专注做自己的事情</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo7</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">hunqinggongsi</span> <span class="variable">h</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">hunqinggongsi</span>(<span class="keyword">new</span> <span class="title class_">You</span>());</span><br><span class="line">        h.marry();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Marry</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">marry</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">You</span> <span class="keyword">implements</span> <span class="title class_">Marry</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">marry</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;结婚&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代理角色</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hunqinggongsi</span> <span class="keyword">implements</span> <span class="title class_">Marry</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Marry target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">hunqinggongsi</span><span class="params">(Marry target)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">marry</span><span class="params">()</span> &#123;</span><br><span class="line">        before();</span><br><span class="line">        <span class="built_in">this</span>.target.marry();</span><br><span class="line">        after();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;结婚前，布置现场&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;结婚后,收尾款&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>主要作用是：避免匿名内部类定义过多</p>
<p>可以让代码看起来很简洁</p>
<p>去掉一堆没有意义的代码，只留下核心的逻辑</p>
<p>其实质属于函数式编程的概念</p>
<p>(params)-&gt;experssion[表达式]</p>
<p>(params)-&gt;statement[语句]</p>
<p>(params)-&gt;{statement}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a-&gt;System.out.println(&quot;i like lambda&quot;+a);</span><br><span class="line"></span><br><span class="line">new Thread(()-&gt;System.out.println(&quot;多次线程学习....&quot;)).start();</span><br></pre></td></tr></table></figure>
<h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><p>创建状态：new出来的线程就处于创建状态</p>
<p>就绪状态：调用start()方法之后就处于就绪状态</p>
<p>运行状态：当线程获取到了CPU资源的时候就进入了运行状态</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">setPriority(<span class="type">int</span> newPriority);  <span class="comment">//更改线程的优先级</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">long</span> millis)</span>; <span class="comment">//在指定的毫秒数内让当前正在执行的线程休眠</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">join</span><span class="params">()</span>;<span class="comment">//等待该线程终止</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">yield</span><span class="params">()</span>;<span class="comment">//暂停当前正在执行的线程对象，并执行其他线程</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">interrupt</span><span class="params">()</span>;<span class="comment">//中断线程，别用这个方式</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isAlive</span><span class="params">()</span>;<span class="comment">//测试线程是否处于活动状态</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="线程停止"><a href="#线程停止" class="headerlink" title="线程停止"></a>线程停止</h4><p>不推荐使用JDK提供的stop()、destroy()方法[已废弃]</p>
<p>推荐线程自己停下来</p>
<p>建议使用一个标志位进行终止变量当flag=false，则终止线程运行</p>
<p>如果强行终止线程可能会导致数据丢失</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hty.demo;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 线程停止的方法</span></span><br><span class="line"><span class="comment">* 方法一：线程正常执行完毕然后停止</span></span><br><span class="line"><span class="comment">* 方法二：利用死循环和flag标记进行停止循环</span></span><br><span class="line"><span class="comment">* 方法三：不建议适应stop、destroy等方法</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo8</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="comment">//设置标志位</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Demo8</span> <span class="variable">demo8</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo8</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(demo8).start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;main&quot;</span>+i);</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">900</span>)&#123;</span><br><span class="line">                demo8.Stop();</span><br><span class="line">                System.out.println(<span class="string">&quot;分线程停止了&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(flag)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程运行了&quot;</span>+ (i++) +<span class="string">&quot;次&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置一个公开的方法停止线程 即修改flag的值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Stop</span><span class="params">()</span>&#123;</span><br><span class="line">        flag = !flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="线程休眠sleep"><a href="#线程休眠sleep" class="headerlink" title="线程休眠sleep"></a>线程休眠sleep</h4><p>sleep(时间)指定当前线程阻塞的毫秒数</p>
<p>sleep存在异常InterruptedException</p>
<p>sleep时间达到后线程进入就绪状态</p>
<p>sleep可以模拟网络延时，倒计时等</p>
<p>每个对象都有一个锁，sleep不会释放锁</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.hty.demo;</span><br><span class="line">/*</span><br><span class="line">* 使用多线程的sleep函数模拟倒计时</span><br><span class="line">* */</span><br><span class="line">public class Demo10 &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Demo10.tenDown();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void tenDown() throws InterruptedException &#123;</span><br><span class="line">        int num=10;</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">            System.out.println(num--);</span><br><span class="line">            if(num&lt;=0) break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="线程礼让-yield"><a href="#线程礼让-yield" class="headerlink" title="线程礼让 yield"></a>线程礼让 yield</h4><p>礼让线程，让线程正在执行的线程暂停，但不阻塞</p>
<p>将线程从运行状态转为就绪状态</p>
<p>让CPU重新调度，礼让不一定成功</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hty.demo;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 测试礼让线程</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo11</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyYield</span> <span class="variable">my1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyYield</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(my1,<span class="string">&quot;1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(my1,<span class="string">&quot;2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyYield</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;start&quot;</span>);</span><br><span class="line">        Thread.yield();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="线程强制执行-Join"><a href="#线程强制执行-Join" class="headerlink" title="线程强制执行-Join"></a>线程强制执行-Join</h4><p>join合并线程，待此线程执行完成后，再执行其他线程，其他线程阻塞</p>
<p>可以想象成插队</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hty.demo;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 测试join方法</span></span><br><span class="line"><span class="comment">* 我们最终结果就会发现，即使在main线程执行到第50次之前两个线程都会执行，但是在50之后，</span></span><br><span class="line"><span class="comment">* 就会先把分线程完全执行完毕之后才会执行主线程</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo12</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程vip&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Demo12</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo12</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(d);</span><br><span class="line">        t.start();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//主线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;主线程&quot;</span>+i);</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">50</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//插队</span></span><br><span class="line">                    t.join();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="观测线程状态"><a href="#观测线程状态" class="headerlink" title="观测线程状态"></a>观测线程状态</h2><h4 id="线程的各种状态表示"><a href="#线程的各种状态表示" class="headerlink" title="线程的各种状态表示"></a>线程的各种状态表示</h4><p>Thread.State类中的静态不可修改的常量</p>
<p>NEW：尚未启动的线程处于此状态。</p>
<p>RUNNABLE：在Java虚拟机中执行的线程处于此状态。</p>
<p>BLOCKED：被阻塞等待监视器锁定的线程处于此状态。</p>
<p>WAITING：正在等待另一个线程执行特定动作的线程处于此状态。</p>
<p>TIMED_WAITING：正在等待另一个线程执行动作达到指定等待时间的线程处于此状态。</p>
<p>TERMINATED：已退出的线程处于此状态。</p>
<p>一个线程可以在给定时间点处于一个状态，这些状态是不反应任何操作系统线程状态的虚拟机状态</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.hty.demo;</span><br><span class="line">/*</span><br><span class="line">* 监测线程的状态</span><br><span class="line">* */</span><br><span class="line"></span><br><span class="line">public class Demo13 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Thread thread = new Thread(()-&gt; &#123;</span><br><span class="line">            for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;-----------&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">        //观察线程状态</span><br><span class="line">        Thread.State state = thread.getState();</span><br><span class="line">        System.out.println(state);//NEW 因为是刚刚创建出来并没有启动</span><br><span class="line"></span><br><span class="line">        //启动线程</span><br><span class="line">        thread.start();</span><br><span class="line">        state = thread.getState();</span><br><span class="line">        System.out.println(state);//RUNNABLE 处于运行状态</span><br><span class="line"></span><br><span class="line">        while(state != Thread.State.TERMINATED)&#123;</span><br><span class="line">            state = thread.getState();</span><br><span class="line">            System.out.println(state);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h2><p>Java提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程，线程调度器按照优先级决定应该调度哪个线程来执行</p>
<p>线程的优先级用数字表示 范围从1-10</p>
<p>static int MAX_PRIORITY 线程可以拥有的最大优先级。<br>static int MIN_PRIORITY 线程可以拥有的最小优先级。<br>static int NORM_PRIORITY 分配给线程的默认优先级。</p>
<p>使用一下方式改变或者获取优先级</p>
<p>getPriority.setPriority(int xxx)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.hty.demo;</span><br><span class="line">/*</span><br><span class="line">* 测试线程的优先级</span><br><span class="line">* */</span><br><span class="line">public class Demo14 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //主线程的优先级</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+&quot;--&gt;&quot;+Thread.currentThread().getPriority());</span><br><span class="line">        MyPriority mp = new MyPriority();</span><br><span class="line">        Thread thread1 = new Thread(mp);</span><br><span class="line">        Thread thread2 = new Thread(mp);</span><br><span class="line">        Thread thread3 = new Thread(mp);</span><br><span class="line">        Thread thread4 = new Thread(mp);</span><br><span class="line">        Thread thread5 = new Thread(mp);</span><br><span class="line">        Thread thread6 = new Thread(mp);</span><br><span class="line">        //首先设置优先级</span><br><span class="line">        thread1.start();</span><br><span class="line"></span><br><span class="line">        thread2.setPriority(1);</span><br><span class="line">        thread2.start();</span><br><span class="line"></span><br><span class="line">        thread3.setPriority(2);</span><br><span class="line">        thread3.start();</span><br><span class="line"></span><br><span class="line">        thread4.setPriority(3);</span><br><span class="line">        thread4.start();</span><br><span class="line"></span><br><span class="line">        thread5.setPriority(4);</span><br><span class="line">        thread5.start();</span><br><span class="line"></span><br><span class="line">        thread6.setPriority(5);</span><br><span class="line">        thread6.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyPriority implements Runnable&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+&quot;--&gt;&quot;+Thread.currentThread().getPriority());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意：并不是t1线程的优先级高于t2就必定先执行，这只是一个参考，最主要还是看CPU的调度</p>
<p>优先级低只是意味着获得调度的概率低，并不是优先级低就不会被调用了</p>
<h3 id="守护线程-daemon"><a href="#守护线程-daemon" class="headerlink" title="守护线程 daemon"></a>守护线程 daemon</h3><p>线程分为用户线程和守护线程</p>
<p>虚拟机必须确保用户线程执行完毕</p>
<p>虚拟机不用等待守护线程执行完毕</p>
<p>如：后台记录操作日志，监控内存，垃圾回收等待</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.hty.demo;</span><br><span class="line"></span><br><span class="line">import java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">* 守护线程</span><br><span class="line">* 上帝守护人民</span><br><span class="line">* */</span><br><span class="line">public class Demo15 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        God god = new God();</span><br><span class="line">        You1 you = new You1();</span><br><span class="line"></span><br><span class="line">        Thread thread = new Thread(god);</span><br><span class="line">        thread.setDaemon(true);//默认是false  正常的线程都是用户线程</span><br><span class="line"></span><br><span class="line">        thread.start();//上帝守护线程启动</span><br><span class="line"></span><br><span class="line">        new Thread(you).start();//用户线程启动</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//上帝</span><br><span class="line">class God implements Runnable&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while(true) &#123;</span><br><span class="line">            System.out.println(&quot;上帝保佑&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//人民</span><br><span class="line">class You1 implements Runnable&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for (int i = 0; i &lt; 36500; i++) &#123;</span><br><span class="line">            System.out.println(&quot;已经活了&quot;+i+&quot;天&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;死亡&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p>线程操作同一个资源</p>
<h4 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h4><p>同一个对象被多个线程同时操作</p>
<p>例：抢火车票，两个银行同时取钱</p>
<p>处理多线程问题时，多个线程访问同一个对象，并且某些线程还想修改这个对象，这时候我们就需要线程同步，线程同步就是一种等待机制，多个需要同时访问此对象的线程进入这个对象的等待池形成队列，等待前面线程使用完毕，下一个线程再使用</p>
<h4 id="队列和锁"><a href="#队列和锁" class="headerlink" title="队列和锁"></a>队列和锁</h4><p>线程同步的形成条件：队列+锁</p>
<p>同步代码块的锁就是括号中的Obj对象<br>同步方法的锁就是当前对象 this<br>静态的同步方法锁对象就是该类的字节码文件<br>由于统一进程的多个线程共享同一块存储空间，在带来方便的同时，也带来了访问冲突问题，为了保证数据在方法中被访问时的正确性，在访问时加入了锁机制，synchronized,当一个线程获得对象的排它锁，独占资源，其他线程必须等待，使用后释放锁集合，但是会存在一下问题:</p>
<p>一个线程持有锁会导致其他所有需要此锁的线程挂起<br>在多线程竞争下，加锁，释放锁会导致比较多的上下文切换和调度延时，引起性能问题<br>如果一个优先级高的线程等待一个优先级低的线程释放锁，会导致优先级倒置，引起性能问题<br>案例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hty.demo;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 不安全买票的案例</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo16</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">BuyTicket</span> <span class="variable">bt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BuyTicket</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(bt,<span class="string">&quot;小明&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(bt,<span class="string">&quot;小红&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//买票</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BuyTicket</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Integer</span> <span class="variable">ticketcount</span> <span class="operator">=</span> <span class="number">10</span>;<span class="comment">//票的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//买票</span></span><br><span class="line">        <span class="keyword">while</span>(flag)&#123;</span><br><span class="line">            buy();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">buy</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//判断是否还有票</span></span><br><span class="line">        <span class="keyword">if</span>(ticketcount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            flag =<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//模拟延时</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;买了一张票,现在还有&quot;</span>+(--ticketcount)+<span class="string">&quot;张票&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>由于我们可以通过private关键字来保证数据对象只能被方法访问，所以我们只需要针对方法提出一套机制，这套机制就是synchronized关键字，他包括两种用法：synchronized方法和synchronized块</p>
<p>同步方法：public synchronized void method(int args){}</p>
<p>synchronized方法控制对“对象”的访问，每个对象对应一把锁，每个synchronized方法都必须获得调用该方法的对象的锁才能执行，否则线程会阻塞，方法一旦执行，就独占该锁，知道该方法返回才释放锁，后面被阻塞的线程才能获得这个锁，继续执行</p>
<p>缺陷：若将一个打的方法声明为synchronized将会影响效率</p>
<p>一般是将执行修改功能的代码块加上synchronized</p>
<p>同步块<br>synchronized(Obj){}</p>
<p>Obj称之为同步监视器</p>
<p> Obj可以是任何对象，但是推荐使用共享资源作为同步监视器</p>
<p> 同步方法中无需指定同步监视器，因为同步方法的同步监视器就是this，就是这个对象本身，或者是class[反射中讲解]</p>
<p>同步监视器的执行过程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 第一个线程访问，锁定同步监视器，执行其中代码</span><br><span class="line"><span class="number">2.</span> 第二个线程访问，发现同步监视器被锁定，无法访问</span><br><span class="line"><span class="number">3.</span> 第一个线程访问完毕，解锁同步监视器</span><br><span class="line"><span class="number">4.</span> 第二个线程访问，发现同步监视器没有锁，然后锁定并访问</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hty.demo;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 安全买票的案例</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo16</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">BuyTicket</span> <span class="variable">bt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BuyTicket</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(bt,<span class="string">&quot;小明&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(bt,<span class="string">&quot;小红&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//买票</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BuyTicket</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Integer</span> <span class="variable">ticketcount</span> <span class="operator">=</span> <span class="number">10</span>;<span class="comment">//票的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//买票</span></span><br><span class="line">        <span class="keyword">while</span>(flag)&#123;</span><br><span class="line">            buy();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">buy</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//判断是否还有票</span></span><br><span class="line">        <span class="keyword">if</span>(ticketcount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            flag =<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//模拟延时</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;买了一张票,现在还有&quot;</span>+(--ticketcount)+<span class="string">&quot;张票&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>多个线程各自占有一些共享资源，并且相互等待其他线程占有的资源才能运行，而导致两个或者多个线程都在等待对方释放资源，都停止执行的情形，某一个同步块同时拥有两个以上对象锁时，就可能发生死锁的问题</p>
<p>线程1拿着对象1的锁，线程2拿着对象2的锁，线程1需要拿到对象2的锁才能放下对象1的锁，但是线程2必须拿到对象1的锁才能放下对象2的锁，此时就形成了死锁</p>
<h4 id="死锁产生条件"><a href="#死锁产生条件" class="headerlink" title="死锁产生条件"></a>死锁产生条件</h4><p>互斥条件：一个资源每次只能被一个进程使用<br>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放<br>不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺<br>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系<br>以上四个必要条件，只要其中一个不满足，死锁便不能产生</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.hty.demo;</span><br><span class="line">/*</span><br><span class="line">* 死锁程序演示</span><br><span class="line">* 死锁：多个线程互相拿着对方需要的资源，然后形成僵持</span><br><span class="line">* */</span><br><span class="line">public class Demo18 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Makeup g1 = new Makeup(0,&quot;小红&quot;);</span><br><span class="line">        Makeup g2 = new Makeup(1,&quot;小明&quot;);</span><br><span class="line">        g1.start();</span><br><span class="line">        g2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Lipstick&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Mirror&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Makeup extends Thread&#123;</span><br><span class="line">    //需要的资源只有一份  使用static来标记</span><br><span class="line">    static Lipstick l = new Lipstick();</span><br><span class="line">    static Mirror m = new Mirror();</span><br><span class="line"></span><br><span class="line">    int choice;//选择</span><br><span class="line">    String girlName;//使用化妆品的人</span><br><span class="line">    public Makeup(int choice,String girlName)&#123;</span><br><span class="line">        this.choice = choice;</span><br><span class="line">        this.girlName = girlName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        makeup();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //化妆</span><br><span class="line">    private void makeup()&#123;</span><br><span class="line">        //互相持有对方的锁</span><br><span class="line">        if(choice == 0)&#123;</span><br><span class="line">            //获得口红的锁</span><br><span class="line">            synchronized (l)&#123;</span><br><span class="line">                System.out.println(this.girlName+&quot;获得口红的锁&quot;);</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                //拿到镜子的锁</span><br><span class="line">//                synchronized (m)&#123;</span><br><span class="line">//                    System.out.println(this.girlName+&quot;获得镜子的锁&quot;);</span><br><span class="line">//                &#125;</span><br><span class="line">                //此处进行synchronized的嵌套就行成了死锁 解决方法就是将嵌套的synchronized放在外面</span><br><span class="line">            &#125;</span><br><span class="line">            synchronized (m)&#123;</span><br><span class="line">                System.out.println(this.girlName+&quot;获得镜子的锁&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            //获得口红的锁</span><br><span class="line">            synchronized (m)&#123;</span><br><span class="line">                System.out.println(this.girlName+&quot;获得镜子的锁&quot;);</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(2000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                //拿到镜子的锁</span><br><span class="line">//                synchronized (l)&#123;</span><br><span class="line">//                    System.out.println(this.girlName+&quot;获得口红  的锁&quot;);</span><br><span class="line">//                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            synchronized (l)&#123;</span><br><span class="line">                System.out.println(this.girlName+&quot;获得口红的锁&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="线程协作——生产者消费者模式"><a href="#线程协作——生产者消费者模式" class="headerlink" title="线程协作——生产者消费者模式"></a>线程协作——生产者消费者模式</h2><p>应用场景：</p>
<p>假设仓库中只能存放一件产品，生产者将生产出来的产品放入仓库，消费者将仓库中产品取走消费</p>
<p>如果仓库中没有产品，则生产者将产品放入仓库，否则停止生产并等待，直到仓库中的产品被消费者取走为止</p>
<p>如果仓库中放有产品，则消费者可以将产品取走消费，否则停止消费并等待，知道仓库中再次放入产品为止</p>
<h4 id="线程通信-分析"><a href="#线程通信-分析" class="headerlink" title="线程通信-分析"></a>线程通信-分析</h4><p>这是一个线程同步问题，生产者和消费者共享同一个资源，并且生产者和消费者之间相互依赖，互为条件</p>
<p> 对于生产者，没有生产产品之前，要通知消费者等待，而生产了产品之后，有需要马上通知消费者消费</p>
<p> 对于消费者，在消费 之后，要通知生产者已经结束消费，需要生产新的产品以供消费</p>
<p> 在生产者消费者问题中，仅有synchronized是不够的</p>
<p> synchronized可阻止并发更新同一个共享资源，实现了同步</p>
<p> synchronized不能用来实现不同线程之间的消息传递(通信)</p>
<p>Java提供了几个方法解决线程之间的通信问题</p>
<p>wait() 表示线程一直等待，直到其他线程通知，与sleep不同，会释放锁</p>
<p>wait(long timeout) 指定等待的毫秒数</p>
<p>notify() 唤醒一个处于等待状态的线程</p>
<p>notifyAll() 唤醒同一个对象上所有调用wait()方法的线程，优先级高的线程优先调度</p>
<p><strong>注：</strong>均是Oject类的方法，都只能在同步方法或者同步代码块中使用，否则会抛出异常</p>
<p>解决方法1——管程法<br>并发协作模型”生产者/消费者模式” ——&gt;管程法</p>
<p>生产者：负责生产数据的模块(可能是方法，对象，线程，进程)<br>消费者：负责处理数据的模块(可能是方法，对象，线程，进程)<br>缓冲区：消费者不能直接使用生产者的数据，他们之间有个“缓冲区”，生产者将生产好的数据放入缓冲区，消费者从缓冲区拿出数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hty.demo;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 管程法：实现生产者消费者模式</span></span><br><span class="line"><span class="comment">* 利用的是缓冲区来解决</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo19</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">huanchongqu</span> <span class="variable">h</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">huanchongqu</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">shengchanzhe</span>(h).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">xiaofeizhe</span>(h).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//生产者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">shengchanzhe</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    huanchongqu hcq;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">shengchanzhe</span><span class="params">(huanchongqu hcq)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.hcq = hcq;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">101</span>; i++) &#123;</span><br><span class="line">            hcq.push(<span class="keyword">new</span> <span class="title class_">chanpin</span>(i));</span><br><span class="line">            System.out.println(<span class="string">&quot;生产了&quot;</span>+i+<span class="string">&quot;个产品&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//消费者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">xiaofeizhe</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    huanchongqu hcq;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">xiaofeizhe</span><span class="params">(huanchongqu hcq)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.hcq = hcq;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">101</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消费了&quot;</span>+hcq.use().id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//产品</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">chanpin</span>&#123;</span><br><span class="line">    <span class="type">int</span> id;<span class="comment">//产品编号</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">chanpin</span><span class="params">(<span class="type">int</span> id)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//缓冲区</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">huanchongqu</span>&#123;</span><br><span class="line">    chanpin[] chanpins = <span class="keyword">new</span> <span class="title class_">chanpin</span>[<span class="number">10</span>];<span class="comment">//需要一个容器大小</span></span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>;<span class="comment">//容器计数器</span></span><br><span class="line">    <span class="comment">//生产者放入产品</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(chanpin c)</span>&#123;</span><br><span class="line">        <span class="comment">//如果容器满了就需要等待消费者消费</span></span><br><span class="line">        <span class="keyword">if</span>(count == chanpins.length)&#123;</span><br><span class="line">            <span class="comment">//通知消费者消费，生产者等待</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//若没满就需要放入产品</span></span><br><span class="line">        chanpins[count++] = c;</span><br><span class="line">        <span class="comment">//可以通知消费者消费了</span></span><br><span class="line">        <span class="built_in">this</span>.notify();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消费者消费产品</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> chanpin <span class="title function_">use</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//如果容器满了就需要消费者消费</span></span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//等待生产者生产，消费者等待</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果可以消费就消费</span></span><br><span class="line">        count--;</span><br><span class="line">        <span class="type">chanpin</span> <span class="variable">chanpin</span> <span class="operator">=</span> chanpins[count];</span><br><span class="line">        <span class="comment">//通知生产者生产</span></span><br><span class="line">        <span class="built_in">this</span>.notify();</span><br><span class="line">        <span class="keyword">return</span> chanpin;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="解决方法2——信号灯法"><a href="#解决方法2——信号灯法" class="headerlink" title="解决方法2——信号灯法"></a>解决方法2——信号灯法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hty.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 信号灯法</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo20</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">TV</span> <span class="variable">tv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TV</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Player</span>(tv).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Watcher</span>(tv).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//生产者-----演员</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    TV tv;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Player</span><span class="params">(TV tv)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.tv = tv;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">this</span>.tv.play(<span class="string">&quot;快乐大本营&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">this</span>.tv.play(<span class="string">&quot;抖音&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者-----观众</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Watcher</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    TV tv;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Watcher</span><span class="params">(TV tv)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.tv = tv;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            tv.watch();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//产品-----节目</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TV</span>&#123;</span><br><span class="line">    <span class="comment">//演员表演 观众等待 T</span></span><br><span class="line">    <span class="comment">//观众观看 演员等待 F</span></span><br><span class="line">    String voice;<span class="comment">//表演的节目</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//表演</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">(String voice)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!flag) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;演员表演了:&quot;</span>+voice);</span><br><span class="line">        <span class="comment">//通知观众观看</span></span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.voice = voice;</span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//看</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">watch</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;观看了&quot;</span>+voice);</span><br><span class="line">        <span class="comment">//通知演员表演</span></span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">        flag = !<span class="built_in">this</span>.flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>背景：经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大</p>
<p>思路：提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。类似生活着的公共交通工具</p>
<p>好处：</p>
<p>提高响应速度(减少了创建新线程的时间)<br>降低资源消耗(重复利用线程池中线程，不需要每次都创建)<br>便于线程管理<br>corePoolSize 核心池的大小<br>maximumPoolSize 最大线程数<br>keepAliveTime 线程没有任务时，最多保持多长时间后会终止<br>0; i++) {<br>tv.watch();<br>}<br>}<br>}<br>//产品——-节目<br>class TV{<br>//演员表演 观众等待 T<br>//观众观看 演员等待 F<br>String voice;//表演的节目<br>boolean flag = true;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//表演</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">(String voice)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!flag) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.wait();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;演员表演了:&quot;</span>+voice);</span><br><span class="line">    <span class="comment">//通知观众观看</span></span><br><span class="line">    <span class="built_in">this</span>.notifyAll();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.voice = voice;</span><br><span class="line">    flag = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//看</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">watch</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.wait();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;观看了&quot;</span>+voice);</span><br><span class="line">    <span class="comment">//通知演员表演</span></span><br><span class="line">    <span class="built_in">this</span>.notifyAll();</span><br><span class="line">    flag = !<span class="built_in">this</span>.flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">## 线程池</span><br><span class="line"></span><br><span class="line">背景：经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大</span><br><span class="line"></span><br><span class="line">思路：提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。类似生活着的公共交通工具</span><br><span class="line"></span><br><span class="line">好处：</span><br><span class="line"></span><br><span class="line">* 提高响应速度(减少了创建新线程的时间)</span><br><span class="line">* 降低资源消耗(重复利用线程池中线程，不需要每次都创建)</span><br><span class="line">* 便于线程管理</span><br><span class="line">    * corePoolSize 核心池的大小</span><br><span class="line">    * maximumPoolSize 最大线程数</span><br><span class="line">    * keepAliveTime  线程没有任务时，最多保持多长时间后会终止</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Lambda表达式</tag>
        <tag>生产者消费者模式</tag>
        <tag>死锁</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>注解与反射</title>
    <url>/2023/03/28/%E6%B3%A8%E8%A7%A3%E4%B8%8E%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<p>新词    解析    归类</p>
<span id="more"></span>
<p>Annotation    注解    注解<br>package    包<br>class    类<br>method    方法<br>field    属性<br>constructor    构造器<br>Override    重写注解    注解<br>Deprecated    不鼓励使用    注解<br>SuppressWarnings    删除警告    注解<br>.getAnnotation()    获得指定注解    注解<br>.getAnnotations()    获得所有注解    注解<br>Target    目标，使用范围    元注解<br>Retention    保留级别    元注解<br>RetentionPolicy.    保留策略    Retention（）<br>Documented    该注解生产在javadoc中    元注解<br>Inherited    可继承父类中的该注解    元注解<br>interface    自定义注解    注解<br>value    价值    参数常用名<br>Reflection    反射    反射<br>.getClass()    对象获取    反射<br>.forName    地址获取    反射<br>.class    类名获取    反射<br>.TYP    基本内置类型获取    反射<br>.getSuperclass()    父类获取    反射<br>ClassLoader    类加载器    ClassLoader<br>.getSystemClassLoader()    系统加载器    ClassLoader<br>.getParent()    扩展类加载器    ClassLoader<br>.getParent()    根加载器（c/c++编写)    ClassLoader<br>.getClassLoader()    获取类加载器类型    ClassLoader<br>.getName()    获得类名+包名    Class<br>.getSimpleName()    获得类名    Class<br>.getFields()    获得类的公开属性（public)    Class<br>.getDeclaredFields()    获得类的全部属性    Class<br>.getDeclared()    获得指定公开属性值    Class<br>.getDeclaredField()    获得指定全部属性值    Class<br>.getDeclaredMethods()    获得本类的所有方法    Class<br>.getMethods()    获得本类及父类全部公开属性    Class<br>.getMethod    获得指定方法    Class<br>.getConstructors()    获得全部构造器    Class<br>.getDeclaredConstructor    获得指定构造器    Class<br>.newInstance()    调用无参构造器    Class<br>.invoke()    激活（激活对象，对象值）    Class<br>.setAccessible(true)    设置可访问，操作私有属性    Class<br>Generic    泛型    泛型<br>ParameterTypes    参数类型    泛型<br>ParameterizedType    参数化类型    泛型<br>ActualTypeArguments    实际参数类型    泛型</p>
<h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p>java.Annotation</p>
<h4 id="什么是注解"><a href="#什么是注解" class="headerlink" title="什么是注解"></a>什么是注解</h4><p>Annotation是从JDK5.0开始引入的<br>Annotation的作用<br>不是程序本身，可以对程序作出解释（这一点和 comment 没什么区别）<br>可以被其他程序（比如：编译器等）读取<br>Annotation的格式<br>注解是以“@注释名”在代码中存在的，还可以添加一些参数值，例如：@SuppressWarnings(value=“unchecked”).<br>Annotation在哪里使用？<br>可以附加在package，class，method，field 等上面，相当于给他们添加了额外的辅助信息，我们可以通过反射机制编程实现对这些元数据的访问</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//什么是注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01</span> <span class="keyword">extends</span> <span class="title class_">Object</span>&#123;</span><br><span class="line">    <span class="comment">//@Override 重写的注解</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="内置注解"><a href="#内置注解" class="headerlink" title="内置注解"></a>内置注解</h4><p>@Override ：定义在 java.lang.Override中，此注释只适用于修辞方法，表示一个方法声明打算重写超类中的另一个方法声明<br>@Deprecated：定义在 java.lang.Deprecated 中，此注释可以用于修辞方法，属性，类，表示不鼓励程序员使用这样的元素，通常是因为它很危险或者存在更好的选择。<br>@SuppressWarnings：定义在java.lang.SuppressWarnings 中，用来抑制编译时的警告信息。（可以放到方法上，也可以放到类上）<br>与前两个注释有所不同，你需要添加一个参数才能正确使用，这些参数都是已经定义好了的，我们选择性的使用就好了。<br>@SuppressWarnings(“all”)<br>@SuppressWarnings(“unchecked”)<br>@SuppressWarnings(value={“uncheckes”,“deprecation”})<br>等待…</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//镇压警告，可以放到方法上，也可以放到类上</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h4><p>元注解的作用就是负责注解其他注解，Java 定义了4个标准的 meta-annotation 类型，他们被用来提供对其他annotation 类型作说明<br>这些类型和它们所支持的类在 java.lang.annotation 包中可以找到 .(@Target,@Retention,@Documented,@Inherited)<br>@Target：用于描述注解的使用范围（即：被描述的注解可以用在什么地方）<br>@Retention：表示需要在什么级别保存该注解信息，用于描述注解的生命周期<br>（SOURCE &lt; CLASS &lt; RUNTIME）<br>@Documented：说明该注解将包含在 javadoc 中<br>@Inherited：说明子类可以继承父类中的该注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个注解</span></span><br><span class="line"><span class="comment">//Target 表示我们的注解可以用在哪些地方</span></span><br><span class="line"><span class="meta">@Target</span> (value = &#123;ElementType.METHOD,ElementType.TYPE&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Retention 表示我们的注解在什么地方还有效</span></span><br><span class="line"><span class="comment">//SOURCE &lt; CLASS &lt; RUNTIME</span></span><br><span class="line"><span class="meta">@Retention(value = RetentionPolicy.RUNTIME)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Documented 表示是否将我们的注解生成在 JAVAdoc 中</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Inherited 子类可以继承父类的注解</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h4><p>使用 @interface 自定义注解时，自动继承了java.lang.annotation.Annotation接口</p>
<p>分析：</p>
<p>@interface 用来声明一个注解，格式：public @interface注解{定义内容}<br>注解的参数：参数类型 + 参数名 + （）; + default( 还可以加默认值 )<br>其中的每一个方法实际上是声明了一个配置参数<br>方法的名字就是参数的名称<br>返回值类型就是参数的类型（返回值只能是基本类型，Class , String , enum)<br>可以通过 default 来声明参数的默认值<br>如果只有一个参数成员，一般参数名为 value ，定义时 value 可以省略，其他不能省略<br>注解元素必须要有值，我们定义注解元素时，经常使用空字符串，0作为默认值</p>
<h3 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h3><p>目录</p>
<p>Java 反射机制概述<br>理解 Class 类并获取 Class 实例<br>类的加载与 ClassLoader<br>创建运行时类的对象<br>获取运行时类的完整结构<br>调用运行时类的指定结构</p>
<h4 id="Java-反射机制概述"><a href="#Java-反射机制概述" class="headerlink" title="Java 反射机制概述"></a>Java 反射机制概述</h4><p>静态 VS 动态语言<br>动态语言</p>
<p>是一类在运行时可以改变其结构的语言：例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或是其他结构上的变化。通俗点说就是在运行时代码可以根据某些条件改变自身结构<br>主要动态语言：Object-C、C#、JavaScript、PHP、Python 等<br>静态语言</p>
<p>与动态语言相对应的，运行时结构不可变得语言就是静态语言。例如Java、C、C++<br>Java 不是动态语言，但 Java 可以称之为“准动态语言”。即 Java 有一定的动态性，我们可以利用反射机制获得类似动态语言的特性。Java 的动态性让编程的时候更加灵活<br>Java Reflection<br>Reflection（反射）是 Java 被视为动态语言的关键，反射机制允许程序在执行期借助 Reflection API 取得任何类的内部信息，并能直接操作任意对象的内部属性及方法</p>
<p>Class c = Class.forName(“java.lang.String”)</p>
<p>加载完类之后，在堆内存的方法区中就产生了一个 Class 类型的对象（一个类只有一个 Class 对象），这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所有，我们形象的称之为：反射</p>
<h4 id="Java反射机制研究及应用"><a href="#Java反射机制研究及应用" class="headerlink" title="Java反射机制研究及应用"></a>Java反射机制研究及应用</h4><p>Java反射机制提供的功能</p>
<p>在运行时判断任意一个对象所属的类<br>在运行时构造任意一个类的对象<br>在运行时判断任意一个类所具有的成员变量和方法<br>在运行时获取泛型信息<br>在运行时调用任意一个对象的成员变量和方法<br>在运行时处理注解<br>生成动态代理<br>… …<br>优点</p>
<p>可以实现动态创建对象和编译，体现出很大的灵活性<br>缺点</p>
<p>对性能有影响。使用反射基本上有一种解释操作，我们可以告诉 JVM，我们希望做什么并且它满足我们的要求。这类操作总是慢于 直接执行相同的操作。</p>
<h4 id="反射相关的主要API"><a href="#反射相关的主要API" class="headerlink" title="反射相关的主要API"></a>反射相关的主要API</h4><p>java.lang.Class：代表一个类<br>java.lang.reflect.Method：代表类的方法<br>java.lang.reflect.Field：代表类的成员变量<br>java.lang.reflect.Constructor：代表类的构造器<br>… …</p>
<h4 id="什么叫反射"><a href="#什么叫反射" class="headerlink" title="什么叫反射"></a>什么叫反射</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//什么叫反射</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">//通过反射获取类的class对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.ssxxz.reflection.user&quot;</span>);</span><br><span class="line">        System.out.println(c1);</span><br><span class="line">        <span class="type">Class</span> <span class="variable">c2</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.ssxxz.reflection.user&quot;</span>);</span><br><span class="line">        <span class="type">Class</span> <span class="variable">c3</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.ssxxz.reflection.user&quot;</span>);</span><br><span class="line">        <span class="type">Class</span> <span class="variable">c4</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.ssxxz.reflection.user&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//一个类在内存中只有一个Class对象</span></span><br><span class="line">        <span class="comment">//一个类被加载后，类的整个结构都会被封装在Class对象中</span></span><br><span class="line">        System.out.println(c2.hashCode());</span><br><span class="line">        System.out.println(c3.hashCode());</span><br><span class="line">        System.out.println(c4.hashCode());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实体类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">user</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">//Constructor</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">user</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">user</span><span class="params">(String name, <span class="type">int</span> id, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Gettor</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//toString</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;user&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="理解-Class-类并获取-Class-实例"><a href="#理解-Class-类并获取-Class-实例" class="headerlink" title="理解 Class 类并获取 Class 实例"></a>理解 Class 类并获取 Class 实例</h4><p>在Objiect类中定义了一下的方法，词方法将被所有子类继承</p>
<p>public final Class getClass()</p>
<p>以上的方法返回值的类型是一个Class类，词类的Java反射的源头，实际上所谓反射重程序的运行结果来看也很好理解，即：可以通过对象反射求出类的名字<br>get Class后可以得到的信息：某个类的属性、方法和构造器、某个类到底实现了那些接口。对于每个类而言，JRE都为了其保留一个不变得Class类型的对象。一个Class对象包含了特定某个结构（class/interface/enum/annotation/primitive type/void/[])的有关信息。</p>
<p>Class本身也是一个类<br>Class对象只能由系统建立对象<br>一个加载的类在JVM中只会有一个Class实例<br>一个Class对象对应的是一个加载到JVM中一个<strong>.class</strong>文件<br>每个类的实例都会记得自己是由哪个Class实例所生成<br>通过Class可以完整地得到一个类中的所有被加载的结构<br>Class类是Reflection的根源，针对任何你想动态加载、运行的类、唯有先获得相应的Class对象</p>
<h4 id="Class类的常用方法"><a href="#Class类的常用方法" class="headerlink" title="Class类的常用方法"></a>Class类的常用方法</h4><p>方法名    功能说明<br>static ClassforName(String name)    返回指定类名name的Class对象<br>Object newlnstance()    调用缺省构造函数，返回Class对象的一个实例<br>getName()    返回此Class对象所表示的实例（类、接口、数组类或void）的名字<br>Class getSuperClass()    返回当前Class对象的父类的Class对象<br>Class[] getinterfaces()    获取当前Class对象的接口<br>ClassLoader getClassLoader()    返回该类的类加速器<br>Constructor[] getConstructors    返回一个包含某些Constructor对象的数组<br>Method getMother(String name,Class… T)    返回一个Method对象，此对象的形参类型为paramType<br>Field[] getDeclaredFields()    返回Field对象的一个数组<br>获取Class类的实例<br>若已知具体的类，通过类的Class属性获取，该方法最为安全可靠，程序性能最高。</p>
<p>Class clazz = Person.class;</p>
<p>已知某个类的实例，调用该实例的getClass()方法获取Class对象</p>
<p>Class clazz = person.getClass();</p>
<p>已知一个类的全类名，且该类在类路径下，可通过Class类的静态方法forName()获取，可能抛出ClassNotFoundException</p>
<p>Class clazz = Class.forName(“demo01.Student”);</p>
<p>内置基本数据类型可以直接用类名<strong>.Type</strong></p>
<p>还可以利用ClassLoader</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;这个人是：&quot;</span>+person.name);</span><br><span class="line">        <span class="comment">//方法一：通过对象获得</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> person.getClass();</span><br><span class="line">        System.out.println(c1.hashCode());</span><br><span class="line">        <span class="comment">//方法二：forname 获得</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c2</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.ssxxz.reflection.Student&quot;</span>);</span><br><span class="line">        System.out.println(c2.hashCode());</span><br><span class="line">        <span class="comment">//方法三：通过类名.class 获得</span></span><br><span class="line">        Class&lt;Student&gt; c3 = Student.class;</span><br><span class="line">        System.out.println(c3.hashCode());</span><br><span class="line">        <span class="comment">//方式四：基本内置类型的包装类都有一个Type属性</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">type</span> <span class="operator">=</span> Integer.TYPE;</span><br><span class="line">        System.out.println(type.hashCode());</span><br><span class="line">        <span class="comment">//获得父类类型</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c5</span> <span class="operator">=</span> c1.getSuperclass();</span><br><span class="line">        System.out.println(c5.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = <span class="string">&quot;学生&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Teacher</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = <span class="string">&quot;老师&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="类的加载与-ClassLoader"><a href="#类的加载与-ClassLoader" class="headerlink" title="类的加载与 ClassLoader"></a>类的加载与 ClassLoader</h4><h4 id="什么时候会发生类初始化"><a href="#什么时候会发生类初始化" class="headerlink" title="什么时候会发生类初始化"></a>什么时候会发生类初始化</h4><p>类的主动引用（一定会发生类的初始化）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试类什么时候会初始化</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test06</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main类被加载&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">       <span class="comment">//主动引用</span></span><br><span class="line">      <span class="comment">// Son son = new Son();     //由于父类没有被初始化，所以先回去初始化它的父类</span></span><br><span class="line">        <span class="comment">//反射也会产生主动引用</span></span><br><span class="line">        Class.forName(<span class="string">&quot;com.ssxxz.reflection.Son&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类被加载&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类被加载&quot;</span>);</span><br><span class="line">        m = <span class="number">300</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">M</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">main类被加载</span><br><span class="line">父类被加载</span><br><span class="line">子类被加载</span><br></pre></td></tr></table></figure>
<ul>
<li>当虚拟机启动，先初始化<strong>main</strong>方法所在类</li>
<li><strong>new</strong>一个类的对象</li>
<li>调用类的静态成员（除了<strong>final</strong>常量）和静态方法</li>
<li>使用<strong>java.lang.reflect</strong>包的方法对类进行反射调用</li>
<li>当初始化一个类，如果其父类没有被初始化，则先回初始化它的父类</li>
</ul>
<p><strong>类的被动引用（不会发生类的初始化）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试类什么时候会初始化</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test06</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main类被加载&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">//不会产生类引用的方法</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//当访问一个静态域时，只有真正声明这个域的类才会被初始化</span></span><br><span class="line">        <span class="comment">//System.out.println(Son.b);</span></span><br><span class="line">        <span class="comment">//通过数组定义类引用，不会触发此类的初始化</span></span><br><span class="line">        <span class="comment">//Son[] array = new Son[5];</span></span><br><span class="line">        <span class="comment">//引用常量不会触发此类的初始化（常量在链接阶段就存入调用类的常量池中了）</span></span><br><span class="line">        System.out.println(Son.M);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类被加载&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类被加载&quot;</span>);</span><br><span class="line">        m = <span class="number">300</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">M</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当访问一个静态域时，只有真正声明这个域的类才会被初始化</p>
<p> 如：当通过子类引用父类的静态变量，不会导致子类初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">main类被加载</span><br><span class="line">父类被加载</span><br><span class="line"><span class="number">2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通过数组定义类引用，不会触发此类的初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">main类被加载</span><br></pre></td></tr></table></figure>
<p>引用常量不会触发此类的初始化（常量在链接阶段就存入调用类的常量池中了）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main类被加载</span><br></pre></td></tr></table></figure>
<h4 id="类加载器的作用"><a href="#类加载器的作用" class="headerlink" title="类加载器的作用"></a>类加载器的作用</h4><p>类加载的作用：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后在堆中生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口<br>类缓存：标准的JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，它将维持加载（缓存）一段时间。不过JVM垃圾回收机制可以回收这些Class对象<br>类加载器作用是用来把类（class）装载进内存的。JVM规范定义了如下类型的类的加载器</p>
<p>引导类加载器：用 C++ 编写的，是JVM自带的类加载器，负责Java平台核心库用来装载核心类库。该加载器无法直接获取<br>扩展类加载：负责 jre/lib/ext 目录下的 jar 包或 -D java.ext.dirs 指定目录下的 jar 包装入工作库<br>系统类加载器：负责 java -classpath 或 -D java.class.path 所指的目录下的类与 jar 包装入工作，是最常用的加载器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test07</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">//获取系统类的加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">systemClassLoader</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader();</span><br><span class="line">        System.out.println(systemClassLoader);</span><br><span class="line">        <span class="comment">//获取系统类加载器的父类加载器--&gt;扩展类加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">parent</span> <span class="operator">=</span> systemClassLoader.getParent();</span><br><span class="line">        System.out.println(parent);</span><br><span class="line">        <span class="comment">//获取扩展类加载器的父类加载器--&gt;根加载器（c/c++）</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">parent1</span> <span class="operator">=</span> parent.getParent();</span><br><span class="line">        System.out.println(parent1);    <span class="comment">//因为是c/c++编写，读取不出来，现实null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试当前类是那个加载器加载的</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.ssxxz.reflection.Test07&quot;</span>).getClassLoader();</span><br><span class="line">        System.out.println(classLoader);</span><br><span class="line">        <span class="comment">//测试JDK内置的类是谁加载的</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader1</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getClassLoader();</span><br><span class="line">        System.out.println(classLoader1);   <span class="comment">//根加载器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如何获取系统类加载器可以加载的路径</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//如何获取系统类加载器可以加载的路径</span><br><span class="line">System.out.println(System.getProperty(&quot;java.class.path&quot;));</span><br><span class="line"></span><br><span class="line">//双亲委派机制</span><br><span class="line">//如：java.lang.String</span><br><span class="line">//如果你所创建的类，在其他加载器中已经存在，它不会用你所写的包，保证java的安全性</span><br></pre></td></tr></table></figure>
<h4 id="创建运行时类的对象"><a href="#创建运行时类的对象" class="headerlink" title="创建运行时类的对象"></a>创建运行时类的对象</h4><p>获取运行时类的完整结构<br>通过反射获取运行时类的完整结构</p>
<p>Field、Method、Constructor、Superclass、interface、annotation</p>
<p>实现的全部接口<br>所继承的父类<br>全部的构造器<br>全部的方法<br>全部的Field<br>注解<br>…</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得类的信息</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test08</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchFieldException, NoSuchMethodException &#123;</span><br><span class="line">        Class&lt;?&gt; c1 = Class.forName(<span class="string">&quot;Test.user&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获得类的名字</span></span><br><span class="line">        System.out.println(c1.getName());   <span class="comment">//获得包名+类名</span></span><br><span class="line">        System.out.println(c1.getSimpleName()); <span class="comment">//获得类名</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获得类的属性</span></span><br><span class="line">        Field[] fields = c1.getFields();    <span class="comment">//只能找到 public 属性</span></span><br><span class="line"></span><br><span class="line">        fields = c1.getDeclaredFields();    <span class="comment">//找到全部的属性</span></span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">            System.out.println(field);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获得指定属性的值</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> c1.getDeclaredField(<span class="string">&quot;name&quot;</span>);   <span class="comment">//Declared全部公开的属性</span></span><br><span class="line">        System.out.println(name);</span><br><span class="line">        System.out.println(<span class="string">&quot;=========================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获得类的方法</span></span><br><span class="line">        Method[] methods = c1.getMethods();     <span class="comment">//获得本类及父类的全部 public 方法</span></span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;普通的Methods:&quot;</span>+method);</span><br><span class="line">        &#125;</span><br><span class="line">        methods = c1.getDeclaredMethods();      <span class="comment">//获得本类的所有方法</span></span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;DeclaredMethods:&quot;</span>+method);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获得指定方法</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">getName</span> <span class="operator">=</span> c1.getMethod(<span class="string">&quot;getName&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="type">Method</span> <span class="variable">setName</span> <span class="operator">=</span> c1.getMethod(<span class="string">&quot;setName&quot;</span>, String.class);</span><br><span class="line">        System.out.println(getName);</span><br><span class="line">        System.out.println(setName);</span><br><span class="line">        System.out.println(<span class="string">&quot;=========================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获得全部的构造器</span></span><br><span class="line">        Constructor[] constructors = c1.getConstructors();</span><br><span class="line">        <span class="keyword">for</span> (Constructor constructor : constructors) &#123;</span><br><span class="line">            System.out.println(constructor);</span><br><span class="line">        &#125;</span><br><span class="line">        constructors = c1.getDeclaredConstructors();</span><br><span class="line">        <span class="keyword">for</span> (Constructor constructor : constructors) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;#&quot;</span>+constructor);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获得指定的构造器</span></span><br><span class="line">        Constructor&lt;?&gt; declaredConstructor = c1.getDeclaredConstructor(String.class, <span class="type">int</span>.class, <span class="type">int</span>.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;指定：&quot;</span>+declaredConstructor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在实际的操作中，取得类的信息的操作代码，并不会经常开发<br>一定要熟悉java.lang.reflect包的作用，反射机制<br>如何取得属性、方法、构造器的名字，修饰符等</p>
<h4 id="有Class对象，能做什么？"><a href="#有Class对象，能做什么？" class="headerlink" title="有Class对象，能做什么？"></a>有Class对象，能做什么？</h4><p>创建类的对象：调用Class对象的<strong>nawlnstance()</strong>方法</p>
<p>（1） 类必须由一个无参数的构造器</p>
<p>（2）类的构造器的访问权限需要足够</p>
<p>没有无参构造器时</p>
<p>（1）通过Class类的<strong>getDeclaredConstructor(Class … parameterTypes)</strong>取得本类的指定形参类型的构造器</p>
<p>（2）向构造器的形参中传递一个对象数组进去，里面包含了构造器中所需的各个参数</p>
<p>（3）通过Constructor实例化对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">//动态的创建对象，通过反射</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test09</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException &#123;</span><br><span class="line">        <span class="comment">//获得Class对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;Test.user&quot;</span>);</span><br><span class="line">        <span class="comment">//构造一个对象</span></span><br><span class="line">        <span class="type">user</span> <span class="variable">user</span> <span class="operator">=</span> (user) c1.newInstance();    <span class="comment">//本质是调用类的无参构造器</span></span><br><span class="line">        System.out.println(user);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过构造器创建对象,调用有参构造器</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> c1.getDeclaredConstructor(String.class, <span class="type">int</span>.class, <span class="type">int</span>.class);</span><br><span class="line">        <span class="type">user</span> <span class="variable">user2</span> <span class="operator">=</span> (user) constructor.newInstance(<span class="string">&quot;六六六&quot;</span>, <span class="number">001</span>, <span class="number">11</span>);</span><br><span class="line">        System.out.println(user2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过反射调用普通方法</span></span><br><span class="line">        <span class="type">user</span> <span class="variable">user3</span> <span class="operator">=</span> (user) c1.newInstance();</span><br><span class="line">        <span class="comment">//通过反射获取一个方法</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">setName</span> <span class="operator">=</span> c1.getDeclaredMethod(<span class="string">&quot;setName&quot;</span>, String.class);</span><br><span class="line">        setName.invoke(user3,<span class="string">&quot;六六七&quot;</span>);    <span class="comment">//.invoke激活（对象，对象值）</span></span><br><span class="line">        System.out.println(user3.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;=========================&quot;</span>);</span><br><span class="line">        <span class="comment">//通过反射操作属性</span></span><br><span class="line">        <span class="type">user</span> <span class="variable">user4</span> <span class="operator">=</span> (user) c1.newInstance();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> c1.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="comment">//不能直接操作私有属性，我们需要关闭程序的安全检查，属性或者方法的.setAccessible</span></span><br><span class="line">        name.setAccessible(<span class="literal">true</span>);       <span class="comment">//取消安全检查，可以操作私有属性</span></span><br><span class="line">        name.set(user4,<span class="string">&quot;七七七&quot;</span>);      <span class="comment">//私有不能直接访问</span></span><br><span class="line">        System.out.println(user4.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="调用指定的方法"><a href="#调用指定的方法" class="headerlink" title="调用指定的方法"></a>调用指定的方法</h4><p>通过反射，调用类中的方法，通过Method类完成</p>
<p>（1）通过Class的getMethod(String nam,Class … parameterTypes)方法取得一个Method对象，并设置此方法操作时所需要的参数类型</p>
<p>（2）之后使用Object invoke(Object obj , Object[] aegs)进行调用，并向方法中传递要设置的obj对象的参数信息</p>
<p>Object invoke(Object obj,Object … args)</p>
<p>Object 对应原方法的返回值，若原方法无返回值，此时返回null<br>若原方法若为静态方法，此时形参Object obj可为null<br>若原方法形参列表为空，则Object[] args为null<br>若原方法声明为private，则需要在调用此invoke()方法前，显示调用方法对象的setAccessible(true)方法，将可访问private的方法<br>setAssessible<br>Method和Field、Constructor对象都有<strong>setAccessible()</strong>方法<br><strong>setAccessible()</strong>作用是启动和禁用访问安全检查的开关<br>参数值true则指示反射的对象在使用时应该取消Java语言访问检查<br>提高反射的效率。如果代码中必须用反射，而该句代码需要频繁的被调用，那么请设置为true<br>使得原本无法访问的私有成员也可以访问<br>参数为false则指示反射的对象应该实施Java语言访问检查</p>
<h4 id="分析性能问题"><a href="#分析性能问题" class="headerlink" title="分析性能问题"></a>分析性能问题</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">//分析性能问题</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test10</span> &#123;</span><br><span class="line">    <span class="comment">//普通方式调用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">user</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">user</span>();</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000000000</span>; i++) &#123;</span><br><span class="line">            user.getName();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;普通方式执行10亿次：&quot;</span>+(endTime-startTime)+<span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//反射方式调用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123;</span><br><span class="line">        <span class="type">user</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">user</span>();</span><br><span class="line">        <span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> user.getClass();</span><br><span class="line">        <span class="type">Method</span> <span class="variable">getName</span> <span class="operator">=</span> c1.getDeclaredMethod(<span class="string">&quot;getName&quot;</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000000000</span>; i++) &#123;</span><br><span class="line">            getName.invoke(user,<span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;反射方式执行10亿次：&quot;</span>+(endTime-startTime)+<span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//反射方法调用 关闭检测</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test03</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123;</span><br><span class="line">        <span class="type">user</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">user</span>();</span><br><span class="line">        <span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> user.getClass();</span><br><span class="line">        <span class="type">Method</span> <span class="variable">getName</span> <span class="operator">=</span> c1.getDeclaredMethod(<span class="string">&quot;getName&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">        getName.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000000000</span>; i++) &#123;</span><br><span class="line">            getName.invoke(user,<span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;反射关闭检测方式执行10亿次：&quot;</span>+(endTime-startTime)+<span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, IllegalAccessException, InvocationTargetException &#123;</span><br><span class="line">        test01();</span><br><span class="line">        test02();</span><br><span class="line">        test03();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="反射操作泛型"><a href="#反射操作泛型" class="headerlink" title="反射操作泛型"></a>反射操作泛型</h4><p>Java采用泛型擦除的机制来引入泛型，Java中泛型仅仅是给编辑器Java使用的，确保数据的安全性和免去强制类型转换问题，但是，一旦编译完成，所有和泛型有关的类型全部擦除<br>为了通过反射操作这些类型，Java新增了ParameterizedType , GenericArrayType , TypeVariable 和 WildcardType 几种类型来代表不能被归一到Class类中的类型但是又和原始类型齐名的类型<br>ParameterizedType : 表示一种参数化类型，比如Collection&lt; String &gt;<br>GenericArrayType：表示一种元素类型是参数化类型或者类型变量的数组类型<br>TypeVariable：是各种类型变量的公共父接口<br>WildcardType：代表一种通配符类型表达式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.ParameterizedType;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Type;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过反射获取泛型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test11</span> &#123;</span><br><span class="line">    <span class="comment">//传参泛型</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">(Map&lt;String,user&gt;map, List&lt;user&gt; list)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test01&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回值的泛型</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String,user&gt; <span class="title function_">test02</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test02&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException &#123;</span><br><span class="line">        <span class="comment">//传参泛型</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> Test11.class.getMethod(<span class="string">&quot;test01&quot;</span>, Map.class, List.class);</span><br><span class="line">        Type[] genericParameterTypes = method.getGenericParameterTypes();   <span class="comment">//获得泛型的参数类型</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Type genericParameterType : genericParameterTypes) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;#&quot;</span>+genericParameterType);       <span class="comment">//只能获得类信息</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (genericParameterType <span class="keyword">instanceof</span> ParameterizedType)&#123;     <span class="comment">//if这类型是否属于参数化类型（ParameterizedType）</span></span><br><span class="line">                Type[] actualTypeArguments = ((ParameterizedType) genericParameterType).getActualTypeArguments();</span><br><span class="line">                <span class="comment">//如果是，就强转为（ParameterizedType）</span></span><br><span class="line">                <span class="comment">//并获得一个真实的参数类型（getActualTypeArguments()）</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (Type actualTypeArgument : actualTypeArguments) &#123;</span><br><span class="line">                    System.out.println(actualTypeArgument);     <span class="comment">//获得了泛型的参数信息</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回值的泛型</span></span><br><span class="line">        method = Test11.class.getMethod(<span class="string">&quot;test02&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="type">Type</span> <span class="variable">genericReturnType</span> <span class="operator">=</span> method.getGenericReturnType();</span><br><span class="line">        <span class="keyword">if</span> (genericReturnType <span class="keyword">instanceof</span> ParameterizedType)&#123;     <span class="comment">//if这类型是否属于参数化类型（ParameterizedType）</span></span><br><span class="line">            Type[] actualTypeArguments = ((ParameterizedType) genericReturnType).getActualTypeArguments();</span><br><span class="line">            <span class="comment">//如果是，就强转为（ParameterizedType）,并使用（getActualTypeArguments()）</span></span><br><span class="line">            <span class="comment">//获得一个真实的参数类型（getActualTypeArguments()）</span></span><br><span class="line">            <span class="keyword">for</span> (Type actualTypeArgument : actualTypeArguments) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;$&quot;</span>+actualTypeArgument);     <span class="comment">//获得了泛型的参数信息</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="反射操作注解"><a href="#反射操作注解" class="headerlink" title="反射操作注解"></a>反射操作注解</h3><ul>
<li><code>getAnnotations</code></li>
<li><code>getAnnotation</code></li>
</ul>
<h4 id="练习：ORM"><a href="#练习：ORM" class="headerlink" title="练习：ORM"></a>练习：ORM</h4><ul>
<li><p>了解什么是</p>
<p>ORM</p>
<ul>
<li><strong>Object relationship Malling</strong> —&gt; 对象关系映射</li>
<li>类与表结构对应</li>
<li>属性和字段对应</li>
<li>对象和记录对应</li>
</ul>
</li>
<li><p>要求：利用注解和反射完成类和表结构的映射关系</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//练习反射操作注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test12</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchFieldException &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;Test.Student2&quot;</span>);</span><br><span class="line">        <span class="comment">//通过反射获得注解</span></span><br><span class="line">        Annotation[] annotations = c1.getAnnotations();</span><br><span class="line">        <span class="keyword">for</span> (Annotation annotation : annotations) &#123;</span><br><span class="line">            System.out.println(annotation);</span><br><span class="line">            <span class="comment">//只获得了类注解</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获得注解的value的值</span></span><br><span class="line">        <span class="type">Tablekuang</span> <span class="variable">annotation</span> <span class="operator">=</span> (Tablekuang)c1.getAnnotation(Tablekuang.class); <span class="comment">//获得指定注解，并生产注解信息</span></span><br><span class="line">        <span class="comment">//使用注解信息.value</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> annotation.value();</span><br><span class="line">        System.out.println(<span class="string">&quot;value:&quot;</span>+value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获得类指定的注解</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> c1.getDeclaredField(<span class="string">&quot;name&quot;</span>);      <span class="comment">//获得指定属性</span></span><br><span class="line">        <span class="type">Fieldkuang</span> <span class="variable">annotation1</span> <span class="operator">=</span> f.getAnnotation(Fieldkuang.class); <span class="comment">//指定属性类型</span></span><br><span class="line">        System.out.println(annotation1.columnName());</span><br><span class="line">        System.out.println(annotation1.type());</span><br><span class="line">        System.out.println(annotation1.length());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Tablekuang(&quot;db_student&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student2</span>&#123;</span><br><span class="line">    <span class="meta">@Fieldkuang(columnName = &quot;bd_id&quot;,type = &quot;int&quot;,length = 10)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="meta">@Fieldkuang(columnName = &quot;bd_age&quot;,type = &quot;int&quot;,length = 5)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="meta">@Fieldkuang(columnName = &quot;bd_name&quot;,type = &quot;varchar&quot;,length = 2)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student2</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student2</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> age, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student2&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类名的注解</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span>               <span class="comment">//可以在哪些地方使用</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span>     <span class="comment">//什么级别可以获取</span></span><br><span class="line"><span class="meta">@interface</span> Tablekuang&#123;      <span class="comment">//创建注解</span></span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//属性的注解</span></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span>               <span class="comment">//可以在哪些地方使用</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span>     <span class="comment">//什么级别可以获取</span></span><br><span class="line"><span class="meta">@interface</span> Fieldkuang&#123;</span><br><span class="line">    String <span class="title function_">columnName</span><span class="params">()</span>;</span><br><span class="line">    String <span class="title function_">type</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">length</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id><a href="#" class="headerlink" title=" "></a> </h4></li>
</ul>
]]></content>
      <tags>
        <tag>注解</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title>Juc</title>
    <url>/2023/03/29/Juc/</url>
    <content><![CDATA[<h3 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h3><p>进程是操作系统中的应用程序，是资源分配的基本单位，线程是用来执行具体的任务和功能，是CPU调度和分派的最小单位。</p>
<p>一个进程往往可以包含多个线程，至少包含一个。</p>
<p>对于Java而言：Thread、Runable、Callable进行开启线程的。</p>
<span id="more"></span>
<h3 id="什么是JUC"><a href="#什么是JUC" class="headerlink" title="什么是JUC"></a>什么是JUC</h3><p><img src="https://i.p04e.com/baid/i/2023/03/29/7k03x.png"></p>
<p>Runnable 没有返回值，企业中使用Callable</p>
<p>java默认有几个线程？</p>
<p>java默认有两个线程：main、GC</p>
<p>java真的可以开启线程吗？</p>
<p>不可以！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.guocl.demo0;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test0</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//查看线程启动，点击start查看</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//java源码：调用native方法(本地方法栈的C++方法)，java运行在虚拟机之上，无法直接操作硬件，由C++开启多线程。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> start0（）；</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>并发编程：并发、并行；</p>
<p>并发（多线程操作同一资源）</p>
<ul>
<li>CPU一核，模拟出来多条线程，快速交替。</li>
</ul>
<p>并行（多个人一起行走）</p>
<ul>
<li>CPU多核，多个线程可以同时执行；线程池。</li>
</ul>
<p><strong>并发编程的本质：充分利用cpu资源</strong></p>
<blockquote>
<p>使用代码查看cpu</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.guocl.demo0;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test0</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//获取cpu的核数</span></span><br><span class="line">        <span class="comment">//cpu密集型，io密集型</span></span><br><span class="line">        System.out.println(Runtime.getRuntime().availableProcessors());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果为 4</span></span><br></pre></td></tr></table></figure>
<h4 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.guocl.demo0;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test0</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//查看线程状态,恩住ctrl，点State</span></span><br><span class="line">        Thread.State</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//线程的状态：6个</span><br><span class="line">public enum State &#123;</span><br><span class="line">//就绪</span><br><span class="line">NEW,</span><br><span class="line">//运行</span><br><span class="line">RUNNABLE,</span><br><span class="line">//阻塞</span><br><span class="line">BLOCKED,</span><br><span class="line">//等待(死死的等)</span><br><span class="line">WAITING,</span><br><span class="line">//超时等待(超过一定时间，不再等待)</span><br><span class="line">TIMED_WAITING,</span><br><span class="line">//终止</span><br><span class="line">TERMINATED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="wait于sleep的区别"><a href="#wait于sleep的区别" class="headerlink" title="wait于sleep的区别"></a>wait于sleep的区别</h4><p>来自不同的类<br>wait=》Object<br>sleep=》Thread<br>wait释放锁，sleep不释放锁（sleep抱着锁睡觉）<br>wait必须在同步代码块中，sleep可以在任何地方（sleep可以在任何地方睡觉）<br>wait不需要捕获异常，sleep需要捕获异常（可能发生超时等待）</p>
<h3 id="Lock锁（重点）"><a href="#Lock锁（重点）" class="headerlink" title="Lock锁（重点）"></a>Lock锁（重点）</h3><h4 id="传统的Synchronized锁"><a href="#传统的Synchronized锁" class="headerlink" title="传统的Synchronized锁"></a>传统的Synchronized锁</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.guocl.demo0;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 不加Synchronized</span></span><br><span class="line"><span class="comment"> * 真正的多线程开发</span></span><br><span class="line"><span class="comment"> * 线程就是一个资源类，没有任何附属的操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SaleTicket</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//并发：多线程操作同一个资源类，把资源类丢入线程</span></span><br><span class="line">        <span class="type">Ticket</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket</span>();</span><br><span class="line">        <span class="comment">// Runnable方式 -- @FunctionalInterface函数式接口</span></span><br><span class="line"><span class="comment">//        new Thread(new Runnable() &#123;</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public void run() &#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;).start();</span></span><br><span class="line">        <span class="comment">// jdk1.8  使用lambda表达式</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//资源类OOP编程</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ticket</span>&#123;</span><br><span class="line">    <span class="comment">//属性，方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">    <span class="comment">//买票的方式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sale</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (number &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;卖出了第&quot;</span>+(number--)+<span class="string">&quot;票,剩余：&quot;</span>+number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A卖出了第30票,剩余：29</span><br><span class="line">B卖出了第29票,剩余：28</span><br><span class="line">A卖出了第28票,剩余：27</span><br><span class="line">B卖出了第27票,剩余：26</span><br><span class="line">A卖出了第26票,剩余：25</span><br><span class="line">B卖出了第25票,剩余：24</span><br><span class="line">B卖出了第23票,剩余：22</span><br><span class="line">B卖出了第22票,剩余：21</span><br><span class="line">B卖出了第21票,剩余：20</span><br><span class="line">B卖出了第20票,剩余：19</span><br><span class="line">B卖出了第19票,剩余：18</span><br><span class="line">B卖出了第18票,剩余：17</span><br><span class="line">B卖出了第17票,剩余：16</span><br><span class="line">B卖出了第16票,剩余：15</span><br><span class="line">B卖出了第15票,剩余：14</span><br><span class="line">B卖出了第14票,剩余：13</span><br><span class="line">B卖出了第13票,剩余：12</span><br><span class="line">B卖出了第12票,剩余：11</span><br><span class="line">B卖出了第11票,剩余：10</span><br><span class="line">B卖出了第10票,剩余：9</span><br><span class="line">B卖出了第9票,剩余：8</span><br><span class="line">B卖出了第8票,剩余：7</span><br><span class="line">B卖出了第7票,剩余：6</span><br><span class="line">B卖出了第6票,剩余：5</span><br><span class="line">B卖出了第5票,剩余：4</span><br><span class="line">B卖出了第4票,剩余：3</span><br><span class="line">B卖出了第3票,剩余：2</span><br><span class="line">B卖出了第2票,剩余：1</span><br><span class="line">B卖出了第1票,剩余：0</span><br><span class="line">A卖出了第24票,剩余：23</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br><span class="line">//结果是乱的</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.guocl.demo0;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 不加Synchronized</span></span><br><span class="line"><span class="comment"> * 真正的多线程开发</span></span><br><span class="line"><span class="comment"> * 线程就是一个资源类，没有任何附属的操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SaleTicket</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//并发：多线程操作同一个资源类，把资源类丢入线程</span></span><br><span class="line">        <span class="type">Ticket</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket</span>();</span><br><span class="line">        <span class="comment">// Runnable方式 -- @FunctionalInterface函数式接口</span></span><br><span class="line"><span class="comment">//        new Thread(new Runnable() &#123;</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public void run() &#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;).start();</span></span><br><span class="line">        <span class="comment">// jdk1.8  使用lambda表达式</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//资源类OOP编程</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ticket</span>&#123;</span><br><span class="line">    <span class="comment">//属性，方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">    <span class="comment">//买票的方式</span></span><br><span class="line">    <span class="comment">//synchronized  本质：队列，锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sale</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (number &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;卖出了第&quot;</span>+(number--)+<span class="string">&quot;票,剩余：&quot;</span>+number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A卖出了第30票,剩余：29</span><br><span class="line">A卖出了第29票,剩余：28</span><br><span class="line">A卖出了第28票,剩余：27</span><br><span class="line">A卖出了第27票,剩余：26</span><br><span class="line">A卖出了第26票,剩余：25</span><br><span class="line">A卖出了第25票,剩余：24</span><br><span class="line">A卖出了第24票,剩余：23</span><br><span class="line">A卖出了第23票,剩余：22</span><br><span class="line">A卖出了第22票,剩余：21</span><br><span class="line">A卖出了第21票,剩余：20</span><br><span class="line">A卖出了第20票,剩余：19</span><br><span class="line">A卖出了第19票,剩余：18</span><br><span class="line">A卖出了第18票,剩余：17</span><br><span class="line">A卖出了第17票,剩余：16</span><br><span class="line">A卖出了第16票,剩余：15</span><br><span class="line">A卖出了第15票,剩余：14</span><br><span class="line">A卖出了第14票,剩余：13</span><br><span class="line">A卖出了第13票,剩余：12</span><br><span class="line">A卖出了第12票,剩余：11</span><br><span class="line">A卖出了第11票,剩余：10</span><br><span class="line">A卖出了第10票,剩余：9</span><br><span class="line">A卖出了第9票,剩余：8</span><br><span class="line">A卖出了第8票,剩余：7</span><br><span class="line">A卖出了第7票,剩余：6</span><br><span class="line">A卖出了第6票,剩余：5</span><br><span class="line">A卖出了第5票,剩余：4</span><br><span class="line">A卖出了第4票,剩余：3</span><br><span class="line">A卖出了第3票,剩余：2</span><br><span class="line">A卖出了第2票,剩余：1</span><br><span class="line">A卖出了第1票,剩余：0</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="Lock锁（接口）"><a href="#Lock锁（接口）" class="headerlink" title="Lock锁（接口）"></a>Lock锁（接口）<img src="/C:/Users\Lenovo\AppData\Roaming\Typora\typora-user-images\1680096740590.png" alt="1680096740590"></h4><ul>
<li>公平锁：十分公平，必须先来后到；</li>
<li>非公平锁：十分不公平，可以插队； <strong>（默认为非公平锁）</strong></li>
</ul>
<blockquote>
<p>用lock锁实现买票实例</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.guocl.demo0;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockTicket</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//资源类</span></span><br><span class="line">        <span class="type">Ticket2</span> <span class="variable">ticket2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket2</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">                ticket2.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">                ticket2.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">                ticket2.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;C&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//lock三部曲</span></span><br><span class="line"><span class="comment">//1、    Lock lock=new ReentrantLock();</span></span><br><span class="line"><span class="comment">//2、    lock.lock() 加锁</span></span><br><span class="line"><span class="comment">//3、    finally=&gt; 解锁：lock.unlock();</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ticket2</span>&#123;</span><br><span class="line">    <span class="comment">//属性，方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">    <span class="comment">//创建锁</span></span><br><span class="line">    <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="comment">//买票的方式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sale</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//开启锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (number &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;卖出了第&quot;</span>+(number--)+<span class="string">&quot;票,剩余：&quot;</span>+number);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="Synchronized和Lock区别"><a href="#Synchronized和Lock区别" class="headerlink" title="Synchronized和Lock区别"></a>Synchronized和Lock区别</h4><p>1、Synchronized 是内置的java关键字，Lock是一个接口；</p>
<p>2、Synchronized 无法判断获取锁的状态，Lock可以判断；</p>
<p>3、Synchronized 会自动释放锁，Lock必须要手动加锁和手动释放锁！（若不释放锁，可能会造成死锁）；</p>
<p>4、Synchronized 线程1（获得锁-&gt;阻塞）、线程2（等待）（会一直等待下去）；Lock就不一定会一直等待下去，lock会有一个trylock去尝试获取锁，不会造成长久的等待；</p>
<p>5、Synchronized 是可重入锁，不可以中断的，非公平锁；Lock是可重入锁，可以中断锁，可以自己设置公平锁和非公平锁；</p>
<p>6、Synchronized 适合锁少量的代码同步问题，Lock适合锁大量同步代码问题；</p>
<p>深入研究Lock和Synchronized的区别于用法</p>
<p>参考文章：</p>
<p><a href="http://t.csdn.cn/Uouwa">http://t.csdn.cn/Uouwa</a></p>
<h5 id="1、synchronize和lock的用法区别"><a href="#1、synchronize和lock的用法区别" class="headerlink" title="1、synchronize和lock的用法区别"></a>1、synchronize和lock的用法区别</h5><p>synchronize：在需要同步的对象中加入此控制，synchronize可以加在方法上（同步方法），也可以加在特定代码块中（同步代码块），括号中表示需要锁的对象。</p>
<p>lock：需要显示指定起始位置和终止位置。一般使用ReentranLock类做为锁，多个线程中必须要使用一个ReentranLock类做为对象才能保证锁的生效。且在加锁和解锁处需要通过lock()和unlock()显示指出。所以一般会在finally块中写unlock()以防死锁。</p>
<h5 id="2、synchronized和lock性能区别"><a href="#2、synchronized和lock性能区别" class="headerlink" title="2、synchronized和lock性能区别"></a>2、synchronized和lock性能区别</h5><p>synchronized是托管给JVM执行的，而lock是java写的控制锁的代码。在Java1.5中，synchronized是性能很低效的。因为这是一个重量级操作。需要调用操作接口，导致有可能加锁消耗的系统时间比加锁以外的操作还多。相比之下使用java提供的lock对象，性能更高一些。但是到了JDK1.6，发生了变化。synchronize在语义上很清晰，可以进行很多优化，有适应自旋，锁消除，锁粗化，轻量级锁，偏向锁等等。导致在Java1.6上synchronize的性能并不比Lock差。官方也表示，他们也更支持synchronize，在未来的版本中还有优化余地。</p>
<p>说到这里，还是想提一下这两种机制的具体区别。据我所知，synchronized原始采用的是CPU悲观锁机制，即线程获得的是独占锁。独占锁意味着其他线程只能依靠阻塞来等待线程释放锁。而在CPU转换线程阻塞时会引起线程上下文切换，当有很多线程竞争锁的时候，会引起CPU频繁的上下文切换导致效率很低。</p>
<p>而lock用的是乐观锁方式，所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。乐观锁实现的机制就是CAS操作Compare and Swap）。我们可以进一步研究ReentrantLock的源代码，会发现其中比较重要的获得锁的一个方法是compareAndSetState。这里其实就是调用的CPU提供的特殊指令。</p>
<p>现代的CPU提供了指令，可以自动更新共享数据，而且能够检测其他线程的干扰，而 compareAndSet() 就用这些代替了锁定。这个算法称作非阻塞算法，意思是一个线程的失败或者挂起不应该影响其他线程的失败或挂起的算法。</p>
<h5 id="3、synchronized和lock用途区别"><a href="#3、synchronized和lock用途区别" class="headerlink" title="3、synchronized和lock用途区别"></a>3、synchronized和lock用途区别</h5><p>synchronized原语和ReentrantLock在一般情况下没有什么区别，但是在非常复杂的同步应用中，请考虑使用ReentrantLock，特别是遇到下面2种需求的时候。</p>
<p>某个线程在等待一个锁的控制权的这段时间需要中断。<br>需要分开处理一些wait（等待）-notify（唤醒），ReentrantLock里面的Condition应用（Condition定义了等待await/通知signal、signalAll两种类型的方法），能够控制notify哪个线程。<br>具有公平锁功能，每个到来的线程都将排队等候。<br>下面细细道来……</p>
<p>先说第一种情况，ReentrantLock的lock机制有2种，忽略中断锁和响应中断锁，这给我们带来了很大的灵活性。比如：如果A、B2个线程去竞争锁，A线程得到了锁，B线程等待，但是A线程这个时候实在有太多事情要处理，就是一直不返回，B线程可能就会等不及了，想中断自己，不再等待这个锁了，转而处理其他事情。这个时候ReentrantLock就提供了2种机制，第一，B线程中断自己（或者别的线程中断它），但是ReentrantLock不去响应，继续让B线程等待，你再怎么中断，我全当耳边风（synchronized原语就是如此）；第二，B线程中断自己（或者别的线程中断它），ReentrantLock处理了这个中断，并且不再等待这个锁的到来，完全放弃。（如果你没有了解java的中断机制，请参考下相关资料，再回头看这篇文章，80%的人根本没有真正理解什么是java的中断（下面有讲解），呵呵）</p>
<p>这里来做个试验，首先搞一个Buffer类，它有读操作和写操作，为了不读到脏数据，写和读都需要加锁，我们先用synchronized原语来加锁，如下：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.guocl.lockorsyn.syndemo;</span><br><span class="line"></span><br><span class="line">public class Buffer &#123;</span><br><span class="line">    private Object lock;</span><br><span class="line"></span><br><span class="line">    public Buffer()&#123;</span><br><span class="line">        lock = this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void write()&#123;</span><br><span class="line">        synchronized (lock)&#123;</span><br><span class="line">            long startTime = System.currentTimeMillis();</span><br><span class="line">            System.out.println(&quot;开始往这个buff写入数据…&quot;);</span><br><span class="line">            // 模拟要处理很长时间</span><br><span class="line">            for (;;)&#123;</span><br><span class="line">                if (System.currentTimeMillis() - startTime &gt; Integer.MAX_VALUE)</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;终于写完了&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void read()&#123;</span><br><span class="line">        synchronized (lock)&#123;</span><br><span class="line">            System.out.println(&quot;从这个buff读数据&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>读操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.guocl.lockorsyn.syndemo;</span><br><span class="line"></span><br><span class="line">public class Reader extends Thread&#123;</span><br><span class="line">    private Buffer buffer;</span><br><span class="line"></span><br><span class="line">    public Reader(Buffer buffer)&#123;</span><br><span class="line">        this.buffer = buffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        //这里估计会一直阻塞</span><br><span class="line">        buffer.read();</span><br><span class="line">        System.out.println(&quot;读结束&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.guocl.lockorsyn.syndemo;</span><br><span class="line"></span><br><span class="line">public class Writer extends Thread&#123;</span><br><span class="line">    private Buffer buffer;</span><br><span class="line"></span><br><span class="line">    public Writer(Buffer buffer)&#123;</span><br><span class="line">        this.buffer = buffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        buffer.write();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Main方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.guocl.lockorsyn.syndemo;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Buffer buffer = new Buffer();</span><br><span class="line"></span><br><span class="line">        final Writer writer = new Writer(buffer);</span><br><span class="line">        final Reader reader = new Reader(buffer);</span><br><span class="line"></span><br><span class="line">        writer.start();</span><br><span class="line">        reader.start();</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            long start = System.currentTimeMillis();</span><br><span class="line">            for (;;)&#123;</span><br><span class="line">                //等5秒钟去中断读</span><br><span class="line">                if (System.currentTimeMillis() - start &gt; 5000)&#123;</span><br><span class="line">                    System.out.println(&quot;不等了，尝试中断&quot;);</span><br><span class="line">                    reader.interrupt();</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">开始往这个buff写入数据…</span><br><span class="line">不等了，尝试中断</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们期待“读”这个线程能退出等待锁，可是事与愿违，一旦读这个线程发现自己得不到锁，就一直开始等待了，就算它等死，也得不到锁，因为写线程要21亿秒才能完成 T_T ，即使我们中断它，它都不来响应下，看来真的要等死了。</p>
<p>这个时候，ReentrantLock给了一种机制让我们来响应中断，让“读”能伸能屈，勇敢放弃对这个锁的等待。我们来改写Buffer这个类，就叫BufferInterruptibly吧，可中断缓存。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.guocl.lockorsyn.lockdemo;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">public class BufferInterruptibly&#123;</span><br><span class="line"></span><br><span class="line">    private Lock lock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">    public void write()&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            long startTime = System.currentTimeMillis();</span><br><span class="line">            System.out.println(&quot;开始往这个buff写入数据…&quot;);</span><br><span class="line">            for (;;)// 模拟要处理很长时间</span><br><span class="line">            &#123;</span><br><span class="line">                if (System.currentTimeMillis()</span><br><span class="line">                        - startTime &gt; Integer.MAX_VALUE)</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;终于写完了&quot;);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void read() throws InterruptedException &#123;</span><br><span class="line">        // 注意这里，可以响应中断</span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(&quot;从这个buff读数据&quot;);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>读</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.guocl.lockorsyn.lockdemo;</span><br><span class="line"></span><br><span class="line">public class Reader extends Thread&#123;</span><br><span class="line"></span><br><span class="line">    private BufferInterruptibly buff;</span><br><span class="line"></span><br><span class="line">    public Reader(BufferInterruptibly buff)&#123;</span><br><span class="line">        this.buff = buff;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            //可以收到中断的异常，从而有效退出</span><br><span class="line">            buff.read();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(&quot;我不读了&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;读结束&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>写</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.guocl.lockorsyn.lockdemo;</span><br><span class="line"></span><br><span class="line">public class Writer extends Thread&#123;</span><br><span class="line"></span><br><span class="line">    private BufferInterruptibly buff;</span><br><span class="line"></span><br><span class="line">    public Writer(BufferInterruptibly buff)&#123;</span><br><span class="line">        this.buff = buff;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        buff.write();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.guocl.lockorsyn.lockdemo;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        BufferInterruptibly buff = new BufferInterruptibly();</span><br><span class="line"></span><br><span class="line">        final Reader reader = new Reader(buff);</span><br><span class="line">        final Writer writer = new Writer(buff);</span><br><span class="line"></span><br><span class="line">        writer.start();</span><br><span class="line">        reader.start();</span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            long start = System.currentTimeMillis();</span><br><span class="line">                for (;;) &#123;</span><br><span class="line">                    if (System.currentTimeMillis()</span><br><span class="line">                            - start &gt; 5000) &#123;</span><br><span class="line">                        System.out.println(&quot;不等了，尝试中断&quot;);</span><br><span class="line">                        reader.interrupt();</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">开始往这个buff写入数据…</span><br><span class="line">不等了，尝试中断</span><br><span class="line">我不读了</span><br><span class="line">读结束</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这次“读”线程接收到了lock.lockInterruptibly()中断，并且有效处理了这个“异常”。</p>
<p>至于第二种情况，ReentrantLock可以与Condition的配合使用，Condition为ReentrantLock锁的等待和释放提供控制逻辑。<br>例如，使用ReentrantLock加锁之后，可以通过它自身的Condition.await()方法释放该锁，线程在此等待Condition.signal()方法，然后继续执行下去。await方法需要放在while循环中，因此，在不同线程之间实现并发控制，还需要一个volatile的变量，boolean是原子性的变量。因此，一般的并发控制的操作逻辑如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">volatile boolean isProcess = false;</span><br><span class="line">ReentrantLock lock  = new ReentrantLock();</span><br><span class="line">Condtion processReady = lock.newCondtion();</span><br><span class="line">thread: run() &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    isProcess = true;</span><br><span class="line">   try &#123;</span><br><span class="line">    while(!isProcessReady) &#123;  //isProcessReady 是另外一个线程的控制变量</span><br><span class="line">      processReady.await();//释放了lock，在此等待signal</span><br><span class="line">     &#125;catch (InterruptedException e) &#123;</span><br><span class="line">          Thread.currentThread().interrupt();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">          lock.unlock();</span><br><span class="line">          isProcess = false;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里只是代码使用的一段简化，下面我们看Hadoop的一段摘取的源码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	private class MapOutputBuffer&lt;K extends Object, V extends Object&gt;</span><br><span class="line">2</span><br><span class="line">      implements MapOutputCollector&lt;K, V&gt;, IndexedSortable &#123;</span><br><span class="line">3</span><br><span class="line">...</span><br><span class="line">4</span><br><span class="line">    boolean spillInProgress;</span><br><span class="line">5</span><br><span class="line">    final ReentrantLock spillLock = new ReentrantLock();</span><br><span class="line">6</span><br><span class="line">    final Condition spillDone = spillLock.newCondition();</span><br><span class="line">7</span><br><span class="line">    final Condition spillReady = spillLock.newCondition();</span><br><span class="line">8</span><br><span class="line">    volatile boolean spillThreadRunning = false;</span><br><span class="line">9</span><br><span class="line">    final SpillThread spillThread = new SpillThread();</span><br><span class="line">10</span><br><span class="line">...</span><br><span class="line">11</span><br><span class="line">    public MapOutputBuffer(TaskUmbilicalProtocol umbilical, JobConf job,</span><br><span class="line">12</span><br><span class="line">                           TaskReporter reporter</span><br><span class="line">13</span><br><span class="line">                           ) throws IOException, ClassNotFoundException &#123;</span><br><span class="line">14</span><br><span class="line">    ...</span><br><span class="line">15</span><br><span class="line">      spillInProgress = false;</span><br><span class="line">16</span><br><span class="line">      spillThread.setDaemon(true);</span><br><span class="line">17</span><br><span class="line">      spillThread.setName(&quot;SpillThread&quot;);</span><br><span class="line">18</span><br><span class="line">      spillLock.lock();</span><br><span class="line">19</span><br><span class="line">      try &#123;</span><br><span class="line">20</span><br><span class="line">        spillThread.start();</span><br><span class="line">21</span><br><span class="line">        while (!spillThreadRunning) &#123;</span><br><span class="line">22</span><br><span class="line">          spillDone.await();</span><br><span class="line">23</span><br><span class="line">        &#125;</span><br><span class="line">24</span><br><span class="line">      &#125; catch (InterruptedException e) &#123;</span><br><span class="line">25</span><br><span class="line">        throw new IOException(&quot;Spill thread failed to initialize&quot;, e);</span><br><span class="line">26</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">27</span><br><span class="line">        spillLock.unlock();</span><br><span class="line">28</span><br><span class="line">      &#125;</span><br><span class="line">29</span><br><span class="line">    &#125;</span><br><span class="line">30</span><br><span class="line"> </span><br><span class="line">31</span><br><span class="line">    protected class SpillThread extends Thread &#123;</span><br><span class="line">32</span><br><span class="line"> </span><br><span class="line">33</span><br><span class="line">      @Override</span><br><span class="line">34</span><br><span class="line">      public void run() &#123;</span><br><span class="line">35</span><br><span class="line">        spillLock.lock();</span><br><span class="line">36</span><br><span class="line">        spillThreadRunning = true;</span><br><span class="line">37</span><br><span class="line">        try &#123;</span><br><span class="line">38</span><br><span class="line">          while (true) &#123;</span><br><span class="line">39</span><br><span class="line">            spillDone.signal();</span><br><span class="line">40</span><br><span class="line">            while (!spillInProgress) &#123;</span><br><span class="line">41</span><br><span class="line">              spillReady.await();</span><br><span class="line">42</span><br><span class="line">            &#125;</span><br><span class="line">43</span><br><span class="line">            try &#123;</span><br><span class="line">44</span><br><span class="line">              spillLock.unlock();</span><br><span class="line">45</span><br><span class="line">              sortAndSpill();</span><br><span class="line">46</span><br><span class="line">            &#125; catch (Throwable t) &#123;</span><br><span class="line">47</span><br><span class="line">              sortSpillException = t;</span><br><span class="line">48</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">49</span><br><span class="line">              spillLock.lock();</span><br><span class="line">50</span><br><span class="line">              if (bufend &lt; bufstart) &#123;</span><br><span class="line">51</span><br><span class="line">                bufvoid = kvbuffer.length;</span><br><span class="line">52</span><br><span class="line">              &#125;</span><br><span class="line">53</span><br><span class="line">              kvstart = kvend;</span><br><span class="line">54</span><br><span class="line">              bufstart = bufend;</span><br><span class="line">55</span><br><span class="line">              spillInProgress = false;</span><br><span class="line">56</span><br><span class="line">            &#125;</span><br><span class="line">57</span><br><span class="line">          &#125;</span><br><span class="line">58</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">59</span><br><span class="line">          Thread.currentThread().interrupt();</span><br><span class="line">60</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">61</span><br><span class="line">          spillLock.unlock();</span><br><span class="line">62</span><br><span class="line">          spillThreadRunning = false;</span><br><span class="line">63</span><br><span class="line">        &#125;</span><br><span class="line">64</span><br><span class="line">      &#125;</span><br><span class="line">65</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>代码中spillDone 就是 spillLock的一个newCondition()。调用spillDone.await()时可以释放spillLock锁，线程进入阻塞状态，而等待其他线程的 spillDone.signal()操作时，就会唤醒线程，重新持有spillLock锁。</p>
<p>这里可以看出，利用lock可以使我们多线程交互变得方便，而使用synchronized则无法做到这点。</p>
<p>最后呢，ReentrantLock这个类还提供了2种竞争锁的机制：公平锁和非公平锁。这2种机制的意思从字面上也能了解个大概：即对于多线程来说，公平锁会依赖线程进来的顺序，后进来的线程后获得锁。而非公平锁的意思就是后进来的锁也可以和前边等待锁的线程同时竞争锁资源。对于效率来讲，当然是非公平锁效率更高，因为公平锁还要判断是不是线程队列的第一个才会让线程获得锁。</p>
<p>3.4、Java中断机制<br>参考文章：<a href="http://t.csdn.cn/sQxDN">http://t.csdn.cn/sQxDN</a></p>
<p>3.4.1、中断<br> 如果程序需要停止正在运行的线程，如果直接stop线程，则有可能导致程序运行不完整，因此Java提供了中断机制。中断（Interrupt）一个线程意味着在该线程完成任务之前停止其正在进行的一切，有效地终止其当前的操作。线程是死亡、还是等待新的任务或者是继续运行至下一步，就取决于这个程序。虽然初次看来它可能显得简单，但是，你必须进行一些预警以实现期望的结果。你最好还是牢记以下的几点告诫。</p>
<p>首先，忘掉Thread.stop方法。虽然它确实停止了一个正在运行的线程，然而，这种方法是不安全也是不受提倡的，这意味着，在未来的JAVA版本中，它将不复存在。<br>Java的中断是一种协作机制，也就是说通过中断并不能直接STOP另外一个线程，而需要被中断的线程自己处理中断，即仅给了另一个线程一个中断标识，由线程自行处理。<br>3.4.2、中断的原理<br> Java中断机制是一种协作机制，也就是说通过中断并不能直接终止另一个线程，而需要被中断的线程自己处理中断。这好比是家里的父母叮嘱在外的子女要注意身体，但子女是否注意身体，怎么注意身体则完全取决于自己。</p>
<p> Java中断模型也是这么简单，每个线程对象里都有一个boolean类型的标识（不一定就要是Thread类的字段，实际上也的确不是，这几个方法最终都是通过native方法来完成的），代表着是否有中断请求（该请求可以来自所有线程，包括被中断的线程本身）。例如，当线程t1想中断线程t2，只需要在线程t1中将线程t2对象的中断标识置为true，然后线程2可以选择在合适的时候处理该中断请求，甚至可以不理会该请求，就像这个线程没有被中断一样。</p>
<p> java.lang.Thread类提供了几个方法来操作这个中断状态，这些方法包括：</p>
<p>public static boolean interrupted<br>测试当前线程是否已经中断。线程的中断状态 由该方法清除。换句话说，如果连续两次调用该方法，则第二次调用将返回 false（在第一次调用已清除了其中断状态之后，且第二次调用检验完中断状态前，当前线程再次中断的情况除外）。</p>
<p>public boolean isInterrupted()<br>测试线程是否已经中断。线程的中断状态不受该方法的影响。</p>
<p>public void interrupt()<br>中断线程。</p>
<p>其中，interrupt方法是唯一能将中断状态设置为true的方法。静态方法interrupted会将当前线程的中断状态清除，但这个方法的命名极不直观，很容易造成误解，需要特别注意。</p>
<p>上面的例子中，线程t1通过调用interrupt方法将线程t2的中断状态置为true，t2可以在合适的时候调用interrupted或isInterrupted来检测状态并做相应的处理。</p>
<p>此外，类库中的有些类的方法也可能会调用中断，如FutureTask中的cancel方法，如果传入的参数为true，它将会在正在运行异步任务的线程上调用interrupt方法，如果正在执行的异步任务中的代码没有对中断做出响应，那么cancel方法中的参数将不会起到什么效果；又如ThreadPoolExecutor中的shutdownNow方法会遍历线程池中的工作线程并调用线程的interrupt方法来中断线程，所以如果工作线程中正在执行的任务没有对中断做出响应，任务将一直执行直到正常结束。</p>
<p>3.4.3、中断的处理<br>既然Java中断机制只是设置被中断线程的中断状态，那么被中断线程该做些什么？</p>
<p>3.4.3.1、处理时机<br> 显然，作为一种协作机制，不会强求被中断线程一定要在某个点进行处理。实际上，被中断线程只需在合适的时候处理即可，如果没有合适的时间点，甚至可以不处理，这时候在任务处理层面，就跟没有调用中断方法一样。“合适的时候”与线程正在处理的业务逻辑紧密相关，例如，每次迭代的时候，进入一个可能阻塞且无法中断的方法之前等，但多半不会出现在某个临界区更新另一个对象状态的时候，因为这可能会导致对象处于不一致状态。</p>
<p> 处理时机决定着程序的效率与中断响应的灵敏性。频繁的检查中断状态可能会使程序执行效率下降，相反，检查的较少可能使中断请求得不到及时响应。如果发出中断请求之后，被中断的线程继续执行一段时间不会给系统带来灾难，那么就可以将中断处理放到方便检查中断，同时又能从一定程度上保证响应灵敏度的地方。当程序的性能指标比较关键时，可能需要建立一个测试模型来分析最佳的中断检测点，以平衡性能和响应灵敏性。</p>
<p>3.4.3.2、处理方式<br>1、 中断状态的管理</p>
<p>一般说来，当可能阻塞的方法声明中有抛出InterruptedException则暗示该方法是可中断的，如BlockingQueue#put、BlockingQueue#take、Object#wait、Thread#sleep等，如果程序捕获到这些可中断的阻塞方法抛出的InterruptedException或检测到中断后，这些中断信息该如何处理？一般有以下两个通用原则：</p>
<p>如果遇到的是可中断的阻塞方法抛出InterruptedException，可以继续向方法调用栈的上层抛出该异常，如果是检测到中断，则可清除中断状态并抛出InterruptedException，使当前方法也成为一个可中断的方法。<br>若有时候不太方便在方法上抛出InterruptedException，比如要实现的某个接口中的方法签名上没有throws InterruptedException，这时就可以捕获可中断方法的InterruptedException并通过Thread.currentThread.interrupt()来重新设置中断状态。如果是检测并清除了中断状态，亦是如此。<br> 一般的代码中，尤其是作为一个基础类库时，绝不应当吞掉中断，即捕获到InterruptedException后在catch里什么也不做，清除中断状态后又不重设中断状态也不抛出InterruptedException等。因为吞掉中断状态会导致方法调用栈的上层得不到这些信息。</p>
<p> 当然，凡事总有例外的时候，当你完全清楚自己的方法会被谁调用，而调用者也不会因为中断被吞掉了而遇到麻烦，就可以这么做。</p>
<p>总得来说，就是要让方法调用栈的上层获知中断的发生。假设你写了一个类库，类库里有个方法amethod，在amethod中检测并清除了中断状态，而没有抛出InterruptedException，作为amethod的用户来说，他并不知道里面的细节，如果用户在调用amethod后也要使用中断来做些事情，那么在调用amethod之后他将永远也检测不到中断了，因为中断信息已经被amethod清除掉了。如果作为用户，遇到这样有问题的类库，又不能修改代码，那该怎么处理？只好在自己的类里设置一个自己的中断状态，在调用interrupt方法的时候，同时设置该状态，这实在是无路可走时才使用的方法。</p>
<p>2、中断的响应</p>
<p>程序里发现中断后该怎么响应？这就得视实际情况而定了。有些程序可能一检测到中断就立马将线程终止，有些可能是退出当前执行的任务，继续执行下一个任务……作为一种协作机制，这要与中断方协商好，当调用interrupt会发生些什么都是事先知道的，如做一些事务回滚操作，一些清理工作，一些补偿操作等。若不确定调用某个线程的interrupt后该线程会做出什么样的响应，那就不应当中断该线程。</p>
<p>3.4.3.3、线程在不同状态下对于中断所产生的反应<br>线程一共6种状态，分别是NEW，RUNNABLE，BLOCKED，WAITING，TIMED_WAITING，TERMINATED（Thread类中有一个State枚举类型列举了线程的所有状态）。</p>
<p>NEW和TERMINATED<br>线程的new状态表示还未调用start方法，还未真正启动。线程的terminated状态表示线程已经运行终止。这两个状态下调用中断方法来中断线程的时候，Java认为毫无意义，所以并不会设置线程的中断标识位，什么事也不会发生。</p>
<p>RUNNABLE<br>如果线程处于运行状态，那么该线程的状态就是RUNNABLE，但是不一定所有处于RUNNABLE状态的线程都能获得CPU运行，在某个时间段，只能由一个线程占用CPU，那么其余的线程虽然状态是RUNNABLE，但是都没有处于运行状态。而我们处于RUNNABLE状态的线程在遭遇中断操作的时候只会设置该线程的中断标志位，并不会让线程实际中断，想要发现本线程已经被要求中断了则需要用程序去判断。</p>
<p>BLOCKED<br>当线程处于BLOCKED状态说明该线程由于竞争某个对象的锁失败而被挂在了该对象的阻塞队列上了。那么此时发起中断操作不会对该线程产生任何影响，依然只是设置中断标志位。</p>
<p>WAITING/TIMED_WAITING<br>这两种状态本质上是同一种状态，只不过TIMED_WAITING在等待一段时间后会自动释放自己，而WAITING则是无限期等待，需要其他线程调用notify方法释放自己。但是他们都是线程在运行的过程中由于缺少某些条件（例如：调用wait()）而被挂起在某个对象的等待队列上。当这些线程遇到中断操作的时候，会抛出一个InterruptedException异常，并清空中断标志位。</p>
<p>Thread.interrupt VS Thread.stop</p>
<p>Thread.stop方法已经不推荐使用了。而在某些方面Thread.stop与中断机制有着相似之处。如当线程在等待内置锁或IO时，stop跟interrupt一样，不会中止这些操作；当catch住stop导致的异常时，程序也可以继续执行，虽然stop本意是要停止线程，这么做会让程序行为变得更加混乱。</p>
<p>那么它们的区别在哪里？最重要的就是中断需要程序自己去检测然后做相应的处理，而Thread.stop会直接在代码执行过程中抛出ThreadDeath错误，这是一个java.lang.Error的子类。</p>
<p>3.4.4、使用 interrupt 方法<br> Thread.interrupt()方法: 作用是中断线程。将会设置该线程的中断状态位，即设置为true，中断的结果线程是死亡、还是等待新的任务或是继续运行至下一步，就取决于这个程序本身。线程会不时地检测这个中断标示位，以判断线程是否应该被中断（中断标示值是否为true）。它并不像stop方法那样会中断一个正在运行的线程。</p>
<p> interrupt()方法只是改变中断状态，不会中断一个正在运行的线程。需要用户自己去监视线程的状态为并做处理。支持线程中断的方法（也就是线程中断后会抛出interruptedException的方法）就是在监视线程的中断状态，一旦线程的中断状态被置为“中断状态”，就会抛出中断异常。这一方法实际完成的是，给受阻塞的线程发出一个中断信号，这样受阻线程检查到中断标识，就得以退出阻塞的状态。</p>
<p> 更确切的说，如果线程被Object.wait, Thread.join和Thread.sleep三种方法之一阻塞，此时调用该线程的interrupt()方法，那么该线程将抛出一个 InterruptedException中断异常（该线程必须事先预备好处理此异常），从而提早地终结被阻塞状态。如果线程没有被阻塞，这时调用 interrupt()将不起作用，直到执行到wait(),sleep(),join()时,才马上会抛出 InterruptedException。</p>
<p>3.4.4.1、使用 interrupt() + InterruptedException来中断线程<br>线程处于阻塞状态，如Thread.sleep、wait、IO阻塞等情况时，调用interrupt方法后，sleep等方法将会抛出一个InterruptedException：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        Thread thread = new Thread() &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(&quot;线程启动了&quot;);</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(1000 * 100);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(&quot;线程结束了&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        thread.start();</span><br><span class="line"> </span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(1000 * 5);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        thread.interrupt();//作用是：在线程阻塞时抛出一个中断信号，这样线程就得以退出阻塞的状态</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://i.p04e.com/baid/i/2023/03/29/5la7.png"></p>
<p>使用 interrupt() + isInterrupted()来中断线程<br> <em>this.interrupted()😗</em>测试当前线程是否已经中断（静态方法）。如果连续调用该方法，则第二次调用将返回false。在api文档中说明interrupted()方法具有清除状态的功能。执行后具有将状态标识清除为false的功能。</p>
<p><em>this.isInterrupted()😗</em>测试线程是否已经中断，但是不能清除状态标识。</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        Thread thread = new Thread() &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(&quot;线程启动了&quot;);</span><br><span class="line">                while (!isInterrupted()) &#123;</span><br><span class="line">                    System.out.println(isInterrupted());//调用 interrupt 之后为true</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(&quot;线程结束了&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        thread.start();</span><br><span class="line"> </span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        thread.interrupt();</span><br><span class="line">        System.out.println(&quot;线程是否被中断：&quot; + thread.isInterrupted());//true</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://i.p04e.com/baid/i/2023/03/29/139pc.png"></p>
<p>来一个综合的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class test1 &#123;</span><br><span class="line"> </span><br><span class="line">    static volatile boolean flag = true;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Thread thread = new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(&quot;开始休眠&quot;);</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(100 * 1000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(&quot;结束休眠，开始死循环&quot;);</span><br><span class="line">                while (flag) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(&quot;------------------子线程结束------------------&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line"> </span><br><span class="line">        Scanner scanner = new Scanner(System.in);</span><br><span class="line">        System.out.println(&quot;输入1抛出一个中断异常，输入2修改循环标志位，输入3判断线程是否阻塞，输入其他结束Scanner\n&quot;);</span><br><span class="line">        while (scanner.hasNext()) &#123;</span><br><span class="line">            String text = scanner.next();</span><br><span class="line">            System.out.println(&quot;你输入了：&quot; + text + &quot;\n&quot;);</span><br><span class="line">            if (&quot;1&quot;.equals(text)) &#123;</span><br><span class="line">                thread.interrupt();</span><br><span class="line">            &#125; else if (&quot;2&quot;.equals(text)) &#123;</span><br><span class="line">                flag = false; //如果不设为false，主线程结束后子线程仍在运行</span><br><span class="line">            &#125; else if (&quot;3&quot;.equals(text)) &#123;</span><br><span class="line">                System.out.println(thread.isInterrupted());</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                scanner.close();</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;------------------主线程结束------------------&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://i.p04e.com/baid/i/2023/03/29/13bl4.png"></p>
<p>不能结束的情况</p>
<p>注意下面这种是根本不能结束的情况！</p>
<figure class="highlight plaintext"><figcaption><span>class Test &#123;</span></figcaption><table><tr><td class="code"><pre><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Thread thread = new Thread() &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(&quot;线程启动了&quot;);</span><br><span class="line">                while (true) &#123;//对于这种情况，即使线程调用了intentrupt()方法并且isInterrupted()，但线程还是会继续运行，根本停不下来！</span><br><span class="line">                    System.out.println(isInterrupted());//调用interrupt之后为true</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        thread.start();</span><br><span class="line">        thread.interrupt();//注意，此方法不会中断一个正在运行的线程，它的作用是：在线程受到阻塞时抛出一个中断信号，这样线程就得以退出阻塞的状态</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            System.out.println(&quot;是否isInterrupted：&quot; + thread.isInterrupted());//true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于interrupted()和isInterrupted()方法的注意事项说明</p>
<p><img src="https://i.p04e.com/baid/i/2023/03/29/7oeeh.png"></p>
<p><em>interrupted()是静态方法：*</em>内部实现是调用的当前线程的isInterrupted()，并且会重置当前线程的中断状态。</p>
<p>测试当前线程是否已经中断（静态方法）。返回的是上一次的中断状态，并且会清除该状态，所以连续调用两次，第一次返回true，第二次返回false。</p>
<p><strong>isInterrupted()是实例方法：</strong>是调用该方法的对象所表示的那个线程的isInterrupted()，不会重置当前线程的中断状态</p>
<p>测试线程当前是否已经中断，但是不能清除状态标识。</p>
<p>测试方法验证：</p>
<p><img src="https://i.p04e.com/baid/i/2023/03/29/5ng0.png"></p>
<p>第一个红框中断的线程是我们自己创建的thread线程，我调用的interrupted()，由上面源码可知是判断当前线程的中断状态，当前线程是main线程，我根本没有中断过main线程，所以2次调用均返回“false”。</p>
<p><img src="https://i.p04e.com/baid/i/2023/03/29/5nmo.png"></p>
<p>第一个红框中断的线程是当前线程（main线程），我调用的interrupted()，由上面源码可知是判断当前线程的中断状态，当前线程是main线程，所以第1次调用结果返回“true”，因为我确实中断了main线程。</p>
<p>由源码可知interrupted()调用的是isInterrupted()，并会重置中断状态，所以第一次调用之后把中断状态给重置了，从中断状态重置为非中断状态，所以第2次调用的结果返回“false” 。<br> <img src="https://i.p04e.com/baid/i/2023/03/29/13ekp.png"></p>
<p>个红框中断的线程是我们自己创建的thread线程，我调用的isInterrupted()，由上面源码可知是判断执行该方法的对象所表示线程的中断状态，也就是thread引用所表示的线程的中断状态，所以第1次调用结果返回“true”。</p>
<p>由源码可知isInterrupted()不会重置中断状态，所以第一次调用之后没有把中断状态给重置（从中断状态重置为非中断状态），所以第2次调用的结果还返回“true”。</p>
<h3 id="生产者和消费者的关系"><a href="#生产者和消费者的关系" class="headerlink" title="生产者和消费者的关系"></a>生产者和消费者的关系</h3><p>面试的：单例模式、排序算法、生产者和消费者、死锁。</p>
<p>Synchronized版本</p>
<figure class="highlight plaintext"><figcaption><span>com.guocl.pc;</span></figcaption><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 线程间的通信问题:生产者和消费者的问题!  等待唤醒 通知唤醒</span><br><span class="line"> * 线程交替执行  A B同时操作一个变量</span><br><span class="line"> * A num+1</span><br><span class="line"> * B num-1</span><br><span class="line"> */</span><br><span class="line">public class ConsumeAndProduct &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Data data = new Data();</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    data.increment();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,&quot;A&quot;).start();</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    data.increment();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,&quot;B&quot;).start();</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    data.decrement();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,&quot;C&quot;).start();</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    data.decrement();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,&quot;D&quot;).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//等待  业务  通知</span><br><span class="line">class Data&#123;</span><br><span class="line">    private int num = 0;</span><br><span class="line"></span><br><span class="line">    //生产者  +1</span><br><span class="line">    public synchronized void increment() throws InterruptedException &#123;</span><br><span class="line">        //判断等待</span><br><span class="line">        if (num != 0)&#123;</span><br><span class="line">            this.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        num++;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;=&gt;&quot; + num);</span><br><span class="line">        //通知其他线程 我执行完毕了</span><br><span class="line">        this.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //消费者 -1</span><br><span class="line">    public synchronized void decrement() throws InterruptedException &#123;</span><br><span class="line">        //判断等待</span><br><span class="line">        if (num == 0)&#123;</span><br><span class="line">            this.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        num--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;=&gt;&quot; + num);</span><br><span class="line">        // 通知其他线程 -1 执行完毕</span><br><span class="line">        this.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C=&gt;0</span><br><span class="line">B=&gt;1</span><br><span class="line">A=&gt;2</span><br><span class="line">D=&gt;1</span><br><span class="line">D=&gt;0</span><br><span class="line">A=&gt;1</span><br><span class="line">B=&gt;2</span><br><span class="line">C=&gt;1</span><br><span class="line">C=&gt;0</span><br><span class="line">B=&gt;1</span><br><span class="line">A=&gt;2</span><br><span class="line">D=&gt;1</span><br><span class="line">D=&gt;0</span><br><span class="line">A=&gt;1</span><br><span class="line">B=&gt;2</span><br><span class="line">C=&gt;1</span><br><span class="line">C=&gt;0</span><br><span class="line">B=&gt;1</span><br><span class="line">A=&gt;2</span><br><span class="line">D=&gt;1</span><br><span class="line">D=&gt;0</span><br><span class="line">A=&gt;1</span><br><span class="line">B=&gt;2</span><br><span class="line">C=&gt;1</span><br><span class="line">C=&gt;0</span><br><span class="line">B=&gt;1</span><br><span class="line">A=&gt;2</span><br><span class="line">D=&gt;1</span><br><span class="line">D=&gt;0</span><br><span class="line">A=&gt;1</span><br><span class="line">B=&gt;2</span><br><span class="line">C=&gt;1</span><br><span class="line">C=&gt;0</span><br><span class="line">B=&gt;1</span><br><span class="line">A=&gt;2</span><br><span class="line">D=&gt;1</span><br><span class="line">D=&gt;0</span><br><span class="line">B=&gt;1</span><br><span class="line">C=&gt;0</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>
<p><strong>存在问题（虚假唤醒）</strong></p>
<h4 id="虚假唤醒"><a href="#虚假唤醒" class="headerlink" title="虚假唤醒"></a>虚假唤醒</h4><p>参考文章：<a href="https://blog.csdn.net/weixin_45668482/article/details/117373700">https://blog.csdn.net/weixin_45668482/article/details/117373700</a><img src="https://i.p04e.com/baid/i/2023/03/29/5ne9.png"></p>
<p>解决方式： if改在while即可，防止虚假唤醒</p>
<p>结论：wait方法执行时，当前对应的线程会释放获取的当前对象锁，并被加入wait Set中，在被唤醒后，当前线程会重新进入就绪状态准备抢占CPU时间片，在重新获取该对象后，该线程将在wait方法返回后恢复原来挂起前的状态，继续向下执行 ， 我们等待的方法是在if判断内的，如下述代码：<br><figure class="highlight plaintext"><figcaption><span>-1</span></figcaption><table><tr><td class="code"><pre><span class="line">public synchronized void decrement() throws InterruptedException &#123;</span><br><span class="line">    //判断等待</span><br><span class="line">    if (num == 0)&#123;</span><br><span class="line">        this.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    num--;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + &quot;=&gt;&quot; + num);</span><br><span class="line">    // 通知其他线程 -1 执行完毕</span><br><span class="line">    this.notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们如果使用if判断的话，直接继续运行if代码块之后的代码，不会去重新判断if条件；而使用while的话，也会从wait之后的代码开始运行，但是唤醒后会重新判断循环条件（while语句会重新循环判断并执行），如果不成立才会执行while代码块之后的代码，成立的话继续执行wait。</p>
<p>while，如下述代码：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//消费者 -1</span><br><span class="line">    public synchronized void decrement() throws InterruptedException &#123;</span><br><span class="line">        //判断等待</span><br><span class="line">        while (num == 0)&#123;</span><br><span class="line">            this.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        num--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;=&gt;&quot; + num);</span><br><span class="line">        // 通知其他线程 -1 执行完毕</span><br><span class="line">        this.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="Lock版"><a href="#Lock版" class="headerlink" title="Lock版"></a>Lock版</h4><p><img src="https://i.p04e.com/baid/i/2023/03/29/7q0iz.png"></p>
<p>Condition</p>
<p><img src="/C:/Users\Lenovo\AppData\Roaming\Typora\typora-user-images\1680097974324.png" alt="1680097974324"></p>
<p>实现生产者和消费者代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.guocl.pc;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.locks.Condition;</span><br><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">public class LockCAP &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Data2 data2 = new Data2();</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">                data2.increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,&quot;A&quot;).start();</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">                data2.decrement();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;B&quot;).start();</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">                data2.increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;C&quot;).start();</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">                data2.decrement();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;D&quot;).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Data2&#123;</span><br><span class="line">    private int num = 0;</span><br><span class="line">    Lock lock = new ReentrantLock();</span><br><span class="line">    Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    public void increment()&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (num != 0) &#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            num++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;=&gt;&quot; + num);</span><br><span class="line">            // 通知其他线程 +1 执行完毕</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void decrement()&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (num == 0)&#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            num--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;=&gt;&quot; + num);</span><br><span class="line">            // 通知其他线程 +1 执行完毕</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="Condition的优势"><a href="#Condition的优势" class="headerlink" title="Condition的优势"></a>Condition的优势</h4><p><strong>精确的通知和唤醒线程</strong></p>
<p>如果我们要指定通知的下一个进行顺序怎么办呢？ 我们可以使用Condition来指定通知进程~</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.guocl.pc;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.locks.Condition;</span><br><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">public class ConditionDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Data3 data3 = new Data3();</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">                data3.printA();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,&quot;A&quot;).start();</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">                data3.printB();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,&quot;B&quot;).start();</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">                data3.printC();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,&quot;C&quot;).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Data3&#123;</span><br><span class="line">    private Lock lock = new ReentrantLock();</span><br><span class="line">    private Condition condition1 = lock.newCondition();</span><br><span class="line">    private Condition condition2 = lock.newCondition();</span><br><span class="line">    private Condition condition3 = lock.newCondition();</span><br><span class="line">    private int num = 1;// 1A 2B 3C</span><br><span class="line"></span><br><span class="line">    public void printA()&#123;</span><br><span class="line">        System.out.println(&quot;进入了A方法&quot;);</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (num != 1)&#123;</span><br><span class="line">                System.out.println(&quot;------A方法等待&quot;);</span><br><span class="line">                condition1.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;==&gt; AAAA&quot; );</span><br><span class="line">            num = 2;</span><br><span class="line">            condition2.signal();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void printB()&#123;</span><br><span class="line">        System.out.println(&quot;进入了B方法&quot;);</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (num != 2) &#123;</span><br><span class="line">                System.out.println(&quot;------B方法等待&quot;);</span><br><span class="line">                condition2.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;==&gt; BBBB&quot; );</span><br><span class="line">            num = 3;</span><br><span class="line">            condition3.signal();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void printC()&#123;</span><br><span class="line">        System.out.println(&quot;进入了C方法&quot;);</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            while(num != 3)&#123;</span><br><span class="line">                System.out.println(&quot;------C方法等待&quot;);</span><br><span class="line">                condition3.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;==&gt; CCCC&quot; );</span><br><span class="line">            num = 1;</span><br><span class="line">            condition1.signal();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="8锁现象"><a href="#8锁现象" class="headerlink" title="8锁现象"></a>8锁现象</h4><p>如何平判断锁的是谁？</p>
<p><strong>锁会锁住：对象、Class</strong></p>
<p>深刻理解我们的锁</p>
<blockquote>
<p>问题1：两个同步方法，先执行发短息还是打电话？</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.guocl.lock8;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 问题1：两个同步方法，先执行发短信还是打电话</span><br><span class="line"> */</span><br><span class="line">public class LockPro1 &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Phone phone = new Phone();</span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;&#123;phone.sendMs();&#125;).start();</span><br><span class="line"></span><br><span class="line">        //睡一秒</span><br><span class="line">        TimeUnit.SECONDS.sleep(1);</span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;&#123;phone.call();&#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Phone&#123;</span><br><span class="line">    public synchronized void sendMs()&#123;</span><br><span class="line">        System.out.println(&quot;发短信&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void call()&#123;</span><br><span class="line">        System.out.println(&quot;打电话&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">发短信</span><br><span class="line">打电话</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>为什么？ 如果你认为是顺序在前？ 这个答案是错误的！</strong></p>
<blockquote>
<p>问题2：我们再来看：我们让发短信延迟4S</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.guocl.lock8;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 问题1：两个同步方法，先执行发短信还是打电话</span><br><span class="line"> * 让短信延迟4S</span><br><span class="line"> */</span><br><span class="line">public class LockPro2 &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Phone2 phone2 = new Phone2();</span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                phone2.sendMs();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        //睡一秒</span><br><span class="line">        TimeUnit.SECONDS.sleep(1);</span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;&#123;phone2.call();&#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Phone2&#123;</span><br><span class="line">    public synchronized void sendMs() throws InterruptedException &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(4);</span><br><span class="line">        System.out.println(&quot;发短信&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void call()&#123;</span><br><span class="line">        System.out.println(&quot;打电话&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">发短信</span><br><span class="line">打电话</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">并不是顺序执行，而是synchronized锁住的对象是方法的调用！对于两个方法用的是同一个锁，谁先拿到谁先执行，另外一个等待。 ----》锁的new出来的对象。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>问题3：加一个普通方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.guocl.lock8;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line">/**</span><br><span class="line"> * 问题1：两个同步方法，先执行发短信还是打电话</span><br><span class="line"> * 让短信延迟4S</span><br><span class="line"> * 加一个普通方法</span><br><span class="line"> */</span><br><span class="line">public class LockPro3 &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Phone3 phone3 = new Phone3();</span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                phone3.sendMs();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        //睡一秒</span><br><span class="line">        TimeUnit.SECONDS.sleep(1);</span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;&#123;phone3.hello();&#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Phone3&#123;</span><br><span class="line">    public synchronized void sendMs() throws InterruptedException &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(4);</span><br><span class="line">        System.out.println(&quot;发短信&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void call()&#123;</span><br><span class="line">        System.out.println(&quot;打电话&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void hello()&#123;</span><br><span class="line">        System.out.println(&quot;hello&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello</span><br><span class="line">发短信</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello是一个普通方法，不受synchronized锁的影响，不用等待锁的释放。 ----》锁的new出来的对象。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>问题4：我们使用的是两个对象，一个调用发短信，一个调用打电话，顺序如何？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.guocl.lock8;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">public class LockPro4&#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Phone4 phone41 = new Phone4();</span><br><span class="line">        Phone4 phone42 = new Phone4();</span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                phone41.sendMs();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        //睡一秒</span><br><span class="line">        TimeUnit.SECONDS.sleep(1);</span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;&#123;phone42.call();&#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Phone4&#123;</span><br><span class="line">    public synchronized void sendMs() throws InterruptedException &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(4);</span><br><span class="line">        System.out.println(&quot;发短信&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void call()&#123;</span><br><span class="line">        System.out.println(&quot;打电话&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void hello()&#123;</span><br><span class="line">        System.out.println(&quot;hello&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">打电话</span><br><span class="line">发短信</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">两个对象两把锁，不会出现等待的情况，发短信睡了4秒，所以先执行打电话。 ----》锁的new出来的对象。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>两个对象两把锁，不会出现等待的情况，发短信睡了4秒，所以先执行打电话。 ——》锁的new出来的对象。</p>
<ul>
<li>一个对象</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.guocl.lock8;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line">/**</span><br><span class="line"> * 问题3：两个同步方法，先执行发短信还是打电话</span><br><span class="line"> * 让短信延迟4S</span><br><span class="line"> * 两个静态方法，一个对象</span><br><span class="line"> */</span><br><span class="line">public class LockPro5 &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Phone5 phone5 = new Phone5();</span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                phone5.sendMs();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        //睡一秒</span><br><span class="line">        TimeUnit.SECONDS.sleep(1);</span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;&#123;phone5.call();&#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Phone5&#123;</span><br><span class="line">    public static synchronized void sendMs() throws InterruptedException &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(4);</span><br><span class="line">        System.out.println(&quot;发短信&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static synchronized void call()&#123;</span><br><span class="line">        System.out.println(&quot;打电话&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">发短信</span><br><span class="line">打电话</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>两个对象</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.guocl.lock8;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line">/**</span><br><span class="line"> * 问题3：两个同步方法，先执行发短信还是打电话</span><br><span class="line"> * 让短信延迟4S</span><br><span class="line"> * 两个静态方法，两个对象</span><br><span class="line"> */</span><br><span class="line">public class LockPro6 &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Phone6 phone61 = new Phone6();</span><br><span class="line">        Phone6 phone62 = new Phone6();</span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                phone61.sendMs();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        //睡一秒</span><br><span class="line">        TimeUnit.SECONDS.sleep(1);</span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;&#123;phone62.call();&#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Phone6&#123;</span><br><span class="line">    public static synchronized void sendMs() throws InterruptedException &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(4);</span><br><span class="line">        System.out.println(&quot;发短信&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static synchronized void call()&#123;</span><br><span class="line">        System.out.println(&quot;打电话&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">发短信</span><br><span class="line">打电话</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>原因是什么呢？</p>
<p>为什么加了static就始终前面一个对象先执行呢！什么后面会等待呢？</p>
<p>原因：对象static静态方法来说，类在加载的时候就加载了静态方法，对整个类Class来说只有一份，对于不同的对象使用的是同一个Class模板，相当于这个方法是属于这个类的，如果静态static方法使用synchronized 锁定，那么这个synchronized 锁会锁住Class模板，不管多少对象，这个静态的锁都只有一把，谁先拿到谁先执行。</p>
<p>问题7：我们使用一个静态同步方法，一个对象调用的顺序是什么？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.guocl.lock8;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line">/**</span><br><span class="line"> * 问题3：两个同步方法，先执行发短信还是打电话</span><br><span class="line"> * 让短信延迟4S</span><br><span class="line"> * 一个静态方法，一个对象</span><br><span class="line"> */</span><br><span class="line">public class LockPro7 &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Phone7 phone7 = new Phone7();</span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                phone7.sendMs();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        //睡一秒</span><br><span class="line">        TimeUnit.SECONDS.sleep(1);</span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;&#123;phone7.call();&#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Phone7&#123;</span><br><span class="line">    public static synchronized void sendMs() throws InterruptedException &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(4);</span><br><span class="line">        System.out.println(&quot;发短信&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void call()&#123;</span><br><span class="line">        System.out.println(&quot;打电话&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">打电话</span><br><span class="line">发短信</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static锁的是Class模板，非静态方法锁的是new出来的对象，互不影响，不存在等待。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>问题8：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.guocl.lock8;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line">/**</span><br><span class="line"> * 问题3：两个同步方法，先执行发短信还是打电话</span><br><span class="line"> * 让短信延迟4S</span><br><span class="line"> * 一个静态方法，两个对象</span><br><span class="line"> */</span><br><span class="line">public class LockPro8 &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Phone8 phone81 = new Phone8();</span><br><span class="line">        Phone8 phone82 = new Phone8();</span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                phone81.sendMs();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        //睡一秒</span><br><span class="line">        TimeUnit.SECONDS.sleep(1);</span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;&#123;phone82.call();&#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Phone8&#123;</span><br><span class="line">    public static synchronized void sendMs() throws InterruptedException &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(4);</span><br><span class="line">        System.out.println(&quot;发短信&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void call()&#123;</span><br><span class="line">        System.out.println(&quot;打电话&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">打电话</span><br><span class="line">发短信</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">两个对象也是同理，static锁的是Class模板，非静态方法锁的是new出来的对象，互不影响，不存在等待。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结</p>
</blockquote>
<ul>
<li><p>非静态方法锁的是new出来的对象，互不影响；</p>
</li>
<li><p>静态方法锁的是Class模板，唯一；</p>
<h3 id="集合不安全"><a href="#集合不安全" class="headerlink" title="集合不安全"></a>集合不安全</h3><p>面试知识点：工作中遇到哪些异常，并发修改异常，OOM内存溢出异常</p>
<h4 id="List不安全"><a href="#List不安全" class="headerlink" title="List不安全"></a>List不安全</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.guocl.Collections;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.UUID;</span><br><span class="line"></span><br><span class="line">// ConcurrentModificationException并发修改异常！</span><br><span class="line">public class CollectionsTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;Object&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt;= 30 ; i++) &#123;</span><br><span class="line">            new Thread(()-&gt;&#123;</span><br><span class="line">                list.add(UUID.randomUUID().toString().substring(0, 5));</span><br><span class="line">                System.out.println(list);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>会导致ConcurrentModificationException并发修改异常！</p>
<p><strong>ArrayList在并发情况下是不安全的!</strong></p>
<p>解决方案：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.guocl.Collections;</span><br><span class="line"></span><br><span class="line">import java.util.*;</span><br><span class="line">import java.util.concurrent.CopyOnWriteArrayList;</span><br><span class="line"></span><br><span class="line">public class CollectionsTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">//        List&lt;Object&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         *  1、Vector&lt;String&gt; list = new Vector&lt;&gt;();</span><br><span class="line">         *  2、List&lt;String&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;());</span><br><span class="line">         *  3、List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">         */</span><br><span class="line">        List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt;= 30 ; i++) &#123;</span><br><span class="line">            new Thread(()-&gt;&#123;</span><br><span class="line">                list.add(UUID.randomUUID().toString().substring(0, 5));</span><br><span class="line">                System.out.println(list);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>CopyOnWriteArrayList：**写入时复制！ COW 计算机程序设计领域的一种优化策略</p>
<p>多个线程调用的时候，list是唯一的，读取的时候list是固定的，写入的时候给list复制一份给调用者，调用者写入副本，副本再添加到唯一的list中。避免在写入的时候被覆盖，造成数据问题！</p>
<p>核心思想：如果有多个调用者（Callers）同时要求相同的资源（如内存或者是磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源，直到某个调用者视图修改资源内容时，系统才会真正复制一份专用副本（private copy）给该调用者，而其他调用者所见到的最初的资源仍然保持不变。这过程对其他的调用者都是透明的（transparently）。此做法主要的优点是如果调用者没有修改资源，就不会有副本（private copy）被创建，因此多个调用者只是读取操作时可以共享同一份资源。</p>
<p>读的时候不需要加锁，如果读的时候有多个线程正向CopyOnWriteArrayList添加数据，读还是会读到旧数据，因为写的时候不会锁住旧的CopyOnWriteArrayList。</p>
<p>CopyOnWriteArrayList比Vector厉害在哪里？</p>
<p>Vector底层是使用synchronized 关键字来实现的：效率特别低下。<br><img src="https://i.p04e.com/baid/i/2023/03/29/7v0mi.png"></p>
<p><strong>CopyOnWriteArrayList</strong> 使用的是Lock锁，效率会更加高效！</p>
<p><img src="https://i.p04e.com/baid/i/2023/03/29/5s28.png"></p>
<h3 id="set不安全"><a href="#set不安全" class="headerlink" title="set不安全"></a>set不安全</h3><p>Set和List同理可得：多线程情况下，普通的Set集合是线程不安全的；</p>
<p>解决方案有两种：</p>
<ul>
<li>使用Collections工具类的<strong>synchronized</strong> 包装的Set类；</li>
<li>使用CopyOnWriteArraySet 写入复制的 <strong>JUC</strong>解决方案；</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.guocl.Collections;</span><br><span class="line"></span><br><span class="line">import java.util.Collections;</span><br><span class="line">import java.util.HashSet;</span><br><span class="line">import java.util.Set;</span><br><span class="line">import java.util.UUID;</span><br><span class="line">import java.util.concurrent.CopyOnWriteArraySet;</span><br><span class="line"></span><br><span class="line">public class SetTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        /**</span><br><span class="line">         * 1、Set&lt;String&gt; set = Collections.synchronizedSet(new HashSet&lt;&gt;());</span><br><span class="line">         * 2、Set&lt;String&gt; set = new CopyOnWriteArraySet&lt;&gt;();</span><br><span class="line">         */</span><br><span class="line">        Set&lt;String&gt; set = new CopyOnWriteArraySet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt;= 30; i++) &#123;</span><br><span class="line">            new Thread(() -&gt; &#123;</span><br><span class="line">                set.add(UUID.randomUUID().toString().substring(0, 5));</span><br><span class="line">                System.out.println(set);</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>HashSet底层是什么？</strong></p>
<p>hashSet底层就是一个<strong>HashMap</strong>；</p>
<p><img src="https://i.p04e.com/baid/i/2023/03/29/14m8l.png"></p>
<h4 id="Map不安全"><a href="#Map不安全" class="headerlink" title="Map不安全"></a>Map不安全</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//map 是这样用的吗？  不是，工作中不使用这个</span><br><span class="line">//默认等价什么？ new HashMap&lt;&gt;(16,0.75);</span><br><span class="line">Map&lt;String, String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">//加载因子、初始化容量</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>默认 <strong>加载因子是0.75</strong> 默认的 <strong>初始容量是16</strong></p>
<p><img src="https://i.p04e.com/baid/i/2023/03/29/14o7r.png"></p>
<p>同样的HashMap基础类也存在并发异常！</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.guocl.Collections;</span><br><span class="line"></span><br><span class="line">import java.util.Collections;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.UUID;</span><br><span class="line">import java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line">public class MapTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //map 是这样用的吗？  不是，工作中不使用这个</span><br><span class="line">        //默认等价什么？ new HashMap&lt;&gt;(16,0.75);</span><br><span class="line">        /**</span><br><span class="line">         *  Map&lt;String, String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">         * 解决方案</span><br><span class="line">         * 1、Map&lt;String, String&gt; map = Collections.synchronizedMap(new HashMap&lt;&gt;());</span><br><span class="line">         * 2、Map&lt;String, String&gt; map = new ConcurrentHashMap&lt;&gt;();</span><br><span class="line">         */</span><br><span class="line">        Map&lt;String, String&gt; map = new ConcurrentHashMap&lt;&gt;();</span><br><span class="line">        //加载因子、初始化容量</span><br><span class="line">        for (int i = 1; i &lt; 100; i++) &#123;</span><br><span class="line">            new Thread(() -&gt; &#123;</span><br><span class="line">                map.put(Thread.currentThread().getName(), UUID.randomUUID().toString().substring(0, 5));</span><br><span class="line">                System.out.println(map);</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>研究ConcurrentHashMap底层原理</p>
<h3 id="Callable（简单）"><a href="#Callable（简单）" class="headerlink" title="Callable（简单）"></a>Callable（简单）</h3><p><strong>1、callable的介绍</strong></p>
<p><img src="https://i.p04e.com/baid/i/2023/03/29/5ssz.png"></p>
<p><strong>callable和runnable的区别</strong></p>
<ul>
<li>callable可以有返回值</li>
<li>callable可以抛出异常</li>
<li>callable方法不同，run()/call()</li>
</ul>
<p><img src="https://i.p04e.com/baid/i/2023/03/29/5sae.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过源码分析：Callable接口的泛型就是call方法的返回值</span><br></pre></td></tr></table></figure>
<p><strong>3、分析Callable的启动</strong></p>
<p>我们通过Thread的源码分析Thread的参数只有Runnable，不能直接启动Callable</p>
<p>通过画图分析Callable怎么才能通过Thread启动呢？———》通过Runnable</p>
<p><img src="https://i.p04e.com/baid/i/2023/03/29/trr.png"><br><img src="https://i.p04e.com/baid/i/2023/03/29/14jgv.png"></p>
<p>Runnable接口中有一个FutureTask实现类</p>
<p><img src="https://i.p04e.com/baid/i/2023/03/29/5tgz.png"></p>
<p>FutureTask介绍</p>
<p><img src="https://i.p04e.com/baid/i/2023/03/29/14rsd.png"></p>
<p>FutureTask的构造方法中的参数中有Callable和Runnable</p>
<p><img src="https://i.p04e.com/baid/i/2023/03/29/tzw.png"></p>
<p>下面我们通过代码看一下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//我们通常使用Runnable的启动是</span><br><span class="line">new Thread(new Runnable()).start();</span><br><span class="line">//因为FutureTask是Runnable的实现类，所以上面的启动代码等价于下面的这行代码</span><br><span class="line">new Thread(new FutureTask&lt;V&gt;()).start();</span><br><span class="line">//Callable是FutureTask的参数，所以启动方式就为</span><br><span class="line">new Thread(new FutureTask&lt;V&gt;(Callable));</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>代码实例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.guocl.collable;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.Callable;</span><br><span class="line">import java.util.concurrent.ExecutionException;</span><br><span class="line">import java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line">public class CallableTest &#123;</span><br><span class="line">    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">        //我们通常使用Runnable的启动是</span><br><span class="line">        //new Thread(new Runnable()).start();</span><br><span class="line">        //因为FutureTask是Runnable的实现类，所以上面的启动代码等价于下面的这行代码</span><br><span class="line">        //new Thread(new FutureTask&lt;V&gt;()).start();</span><br><span class="line">        //Callable是FutureTask的参数，所以启动方式就为</span><br><span class="line">        //new Thread(new FutureTask&lt;V&gt;(Callable))</span><br><span class="line"></span><br><span class="line">        new Thread().start();//怎么启动Callable</span><br><span class="line">        // 步骤解析：</span><br><span class="line">        MyThread thread = new MyThread();</span><br><span class="line">        FutureTask futureTask = new FutureTask(thread);</span><br><span class="line"></span><br><span class="line">        //运行两个Thread，只会输出一次结果-------》  结果会被缓存，效率高</span><br><span class="line">        new Thread(futureTask, &quot;A&quot;).start();</span><br><span class="line">        new Thread(futureTask, &quot;B&quot;).start();</span><br><span class="line">        //返回值</span><br><span class="line">        //这个get方法很有可能会被阻塞，如果在call方法中是一个耗时的方法，就会等待很长时间。</span><br><span class="line">        //所以我们一般情况下回把这一行放到最后，或者使用异步通信</span><br><span class="line">        Integer o = (Integer) futureTask.get();</span><br><span class="line">        System.out.println(o);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyThread implements Callable&lt;Integer&gt;&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Integer call()&#123;</span><br><span class="line">        System.out.println(&quot;call()&quot;);</span><br><span class="line">        return 1024;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>结果会被缓存</li>
<li>输出线程返回值可能会被阻塞</li>
</ul>
<h3 id="常用的辅助类（必会）"><a href="#常用的辅助类（必会）" class="headerlink" title="常用的辅助类（必会）"></a>常用的辅助类（必会）</h3><h4 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h4><p>减法计数器</p>
<p>1、主要方法：</p>
<ul>
<li>countDown 减1操作；</li>
<li>await 等待计数器归零；</li>
</ul>
<p>await等待计数器归零，就唤醒，再继续向下运行。</p>
<p>2、代码实例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.guocl.threadUtil;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line">public class CountDownLatchDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        // 设置总数是6</span><br><span class="line">        CountDownLatch countDownLatch = new CountDownLatch(6);  </span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt;= 8 ; i++) &#123;</span><br><span class="line">            new Thread(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot;==&gt; Go Out&quot;);</span><br><span class="line">                countDownLatch.countDown();// 线程数量  -1</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        countDownLatch.await();// 等待计数器归零  然后向下执行</span><br><span class="line">        System.out.println(&quot;close door&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0==&gt; Go Out</span><br><span class="line">1==&gt; Go Out</span><br><span class="line">2==&gt; Go Out</span><br><span class="line">3==&gt; Go Out</span><br><span class="line">4==&gt; Go Out</span><br><span class="line">5==&gt; Go Out</span><br><span class="line">6==&gt; Go Out</span><br><span class="line">close door</span><br><span class="line">8==&gt; Go Out</span><br><span class="line">7==&gt; Go Out</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="CyclickBarrier"><a href="#CyclickBarrier" class="headerlink" title="CyclickBarrier"></a>CyclickBarrier</h4><p><img src="https://i.p04e.com/baid/i/2023/03/29/5ujl.png"></p>
<p><strong>简称：加法计数器</strong></p>
<blockquote>
<p>代码实例</p>
</blockquote>
<figure class="highlight plaintext"><figcaption><span>com.guocl.threadUtil;</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">import java.util.concurrent.BrokenBarrierException;</span><br><span class="line">import java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line">public class CyclickBarrierDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 主线程</span><br><span class="line">        CyclicBarrier cyclicBarrier = new CyclicBarrier(7, () -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;召唤神龙&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt;= 7; i++) &#123;</span><br><span class="line">            // 子线程</span><br><span class="line">            int i1 = i;</span><br><span class="line">            new Thread(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot;收集了第&quot; + i1 + &quot;颗龙珠&quot;);</span><br><span class="line">                try &#123;</span><br><span class="line">                    cyclicBarrier.await();// 加法计数  等待</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; catch (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Thread-0收集了第0颗龙珠</span><br><span class="line">Thread-3收集了第3颗龙珠</span><br><span class="line">Thread-2收集了第2颗龙珠</span><br><span class="line">Thread-1收集了第1颗龙珠</span><br><span class="line">Thread-4收集了第4颗龙珠</span><br><span class="line">Thread-5收集了第5颗龙珠</span><br><span class="line">Thread-6收集了第6颗龙珠</span><br><span class="line">召唤神龙</span><br><span class="line">Thread-7收集了第7颗龙珠</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h4><p>原理：</p>
<p>semaphore.acquire() 获得资源，如果资源已经使用完了，就等待资源释放后再进行使用！<br>semaphore.release()释放 ，会释放当前的信号量，然后唤醒等待的线程！<br>作用：</p>
<p>多个资源互斥时使用！并发限流，控制最大的线程数！</p>
<p>代码实例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.util.concurrent.Semaphore;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">public class SemaphoreDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        // 线程数量。停车位，限流</span><br><span class="line">        Semaphore semaphore = new Semaphore(3);</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; 6; i++) &#123;</span><br><span class="line">            new Thread(() -&gt; &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    semaphore.acquire(); // 得到</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot;抢到车位&quot;);</span><br><span class="line">                    TimeUnit.SECONDS.sleep(2);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot;离开车位&quot;);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    semaphore.release(); // 释放</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Thread-0抢到车位</span><br><span class="line">Thread-1抢到车位</span><br><span class="line">Thread-2抢到车位</span><br><span class="line">Thread-1离开车位</span><br><span class="line">Thread-2离开车位</span><br><span class="line">Thread-0离开车位</span><br><span class="line">Thread-3抢到车位</span><br><span class="line">Thread-5抢到车位</span><br><span class="line">Thread-4抢到车位</span><br><span class="line">Thread-3离开车位</span><br><span class="line">Thread-4离开车位</span><br><span class="line">Thread-5离开车位</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><h4 id="ReadWriteLock"><a href="#ReadWriteLock" class="headerlink" title="ReadWriteLock"></a>ReadWriteLock</h4><p>实现类:ReetrantReadWritelock</p>
<p>读可以被多个线程同时读，写的时候只能有一个线程去写。</p>
<p><img src="https://i.p04e.com/baid/i/2023/03/29/u5r.png"></p>
<ul>
<li>未加锁的代码实例</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ReadWriteLockDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyCache myCatch = new MyCache();</span><br><span class="line">        for (int i = 1; i &lt;= 5; i++) &#123;</span><br><span class="line">            final int temp = i;</span><br><span class="line">            new Thread(() -&gt; &#123;</span><br><span class="line">                myCatch.put(temp+&quot;&quot; , temp+&quot;&quot;);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt;= 5; i++) &#123;</span><br><span class="line">            final int temp = i;</span><br><span class="line">            new Thread(() -&gt; &#123;</span><br><span class="line">                myCatch.get(temp+&quot;&quot;);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyCache&#123;</span><br><span class="line">    private volatile Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    //存</span><br><span class="line">    public void put(String key, Object value)&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;写入&quot; + value);</span><br><span class="line">        map.put(key, value);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;写入成功！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //取</span><br><span class="line">    public void get(String key)&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+&quot;读取&quot;+key);</span><br><span class="line">        Object o = map.get(key);</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+&quot;读取成功&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2写入2</span><br><span class="line">1写入1</span><br><span class="line">1写入成功！</span><br><span class="line">2写入成功！</span><br><span class="line">3写入3</span><br><span class="line">5写入5</span><br><span class="line">5写入成功！</span><br><span class="line">3写入成功！</span><br><span class="line">4写入4</span><br><span class="line">4写入成功！</span><br><span class="line">1读取1</span><br><span class="line">2读取2</span><br><span class="line">1读取成功</span><br><span class="line">2读取成功</span><br><span class="line">3读取3</span><br><span class="line">3读取成功</span><br><span class="line">4读取4</span><br><span class="line">4读取成功</span><br><span class="line">5读取5</span><br><span class="line">5读取成功</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>结论：不加锁的情况下，多线程的读写会造成数据不可靠的问题。</p>
<p>我们也可以采用<strong>synchronized</strong>这种重量锁和轻量锁 <strong>lock</strong>去保证数据的可靠。</p>
<p>但是这次我们采用更细粒度的锁：<strong>ReadWriteLock</strong> 读写锁来保证</p>
<ul>
<li>加锁代码实例</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1写入1</span><br><span class="line">1写入成功！</span><br><span class="line">2写入2</span><br><span class="line">2写入成功！</span><br><span class="line">4写入4</span><br><span class="line">4写入成功！</span><br><span class="line">3写入3</span><br><span class="line">3写入成功！</span><br><span class="line">5写入5</span><br><span class="line">5写入成功！</span><br><span class="line">1读取1</span><br><span class="line">1读取成功</span><br><span class="line">2读取2</span><br><span class="line">2读取成功</span><br><span class="line">3读取3</span><br><span class="line">5读取5</span><br><span class="line">3读取成功</span><br><span class="line">5读取成功</span><br><span class="line">4读取4</span><br><span class="line">4读取成功</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><p><img src="https://i.p04e.com/baid/i/2023/03/29/7zyy4.png"><br><img src="https://i.p04e.com/baid/i/2023/03/29/15516.png"></p>
<p>BlockQueue<br>阻塞队列</p>
<p>是Collection的一个子类</p>
<p>什么情况下我们会用到阻塞队列</p>
<p>多线程并发处理、线程池</p>
<p>BlockingQueue有四组API</p>
<p>方式    抛出异常    不会抛出异常，有返回值    阻塞，等待    超时等待<br>添加    add()    offer()    put()    offer(timenum.timeUnit)<br>移出    remove()    poll()    take()    poll(timenum,timeUnit)<br>检测队首元素    element()    peek()<br>抛出异常</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 抛出异常</span><br><span class="line"> */</span><br><span class="line">public static void test1()&#123;</span><br><span class="line">    //需要初始化队列的大小</span><br><span class="line">    ArrayBlockingQueue blockingQueue = new ArrayBlockingQueue&lt;&gt;(3);</span><br><span class="line"></span><br><span class="line">    System.out.println(blockingQueue.add(&quot;a&quot;));</span><br><span class="line">    System.out.println(blockingQueue.add(&quot;b&quot;));</span><br><span class="line">    System.out.println(blockingQueue.add(&quot;c&quot;));</span><br><span class="line"></span><br><span class="line">    //抛出异常：java.lang.IllegalStateException: Queue full</span><br><span class="line">    //        System.out.println(blockingQueue.add(&quot;d&quot;));</span><br><span class="line"></span><br><span class="line">    System.out.println(blockingQueue.remove());</span><br><span class="line">    System.out.println(blockingQueue.remove());</span><br><span class="line">    System.out.println(blockingQueue.remove());</span><br><span class="line">    //如果多移除一个</span><br><span class="line">    //这也会造成 java.util.NoSuchElementException 抛出异常</span><br><span class="line">    System.out.println(blockingQueue.remove());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>不抛出异常，有返回值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 不抛出异常，有返回值</span><br><span class="line"> */</span><br><span class="line">public static void test2()&#123;</span><br><span class="line">    ArrayBlockingQueue&lt;Object&gt; blockingQueue = new ArrayBlockingQueue&lt;&gt;(3);</span><br><span class="line"></span><br><span class="line">    System.out.println(blockingQueue.offer(&quot;a&quot;));</span><br><span class="line">    System.out.println(blockingQueue.offer(&quot;b&quot;));</span><br><span class="line">    System.out.println(blockingQueue.offer(&quot;c&quot;));</span><br><span class="line">    //添加 一个不能添加的元素 使用offer只会返回false 不会抛出异常</span><br><span class="line">    System.out.println(blockingQueue.offer(&quot;d&quot;));</span><br><span class="line"></span><br><span class="line">    System.out.println(blockingQueue.poll());</span><br><span class="line">    System.out.println(blockingQueue.poll());</span><br><span class="line">    System.out.println(blockingQueue.poll());</span><br><span class="line">    //弹出 如果没有元素 只会返回null 不会抛出异常</span><br><span class="line">    System.out.println(blockingQueue.poll());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>阻塞，等待</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 等待 一直阻塞</span><br><span class="line"> */</span><br><span class="line">public static void test3() throws InterruptedException &#123;</span><br><span class="line">    ArrayBlockingQueue blockingQueue = new ArrayBlockingQueue&lt;&gt;(3);</span><br><span class="line"></span><br><span class="line">    //</span><br><span class="line">    blockingQueue.put(&quot;a&quot;);</span><br><span class="line">    blockingQueue.put(&quot;b&quot;);</span><br><span class="line">    blockingQueue.put(&quot;c&quot;);</span><br><span class="line">    //如果队列已经满了， 再进去一个元素  这种情况会一直等待这个队列 什么时候有了位置再进去，程序不会停止</span><br><span class="line">    //        blockingQueue.put(&quot;d&quot;);</span><br><span class="line"></span><br><span class="line">    System.out.println(blockingQueue.take());</span><br><span class="line">    System.out.println(blockingQueue.take());</span><br><span class="line">    System.out.println(blockingQueue.take());</span><br><span class="line">    //如果我们再来一个  这种情况也会等待，程序会一直运行 阻塞</span><br><span class="line">    System.out.println(blockingQueue.take());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>超时等待</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 等待 超时阻塞</span><br><span class="line"> * 这种情况也会等待队列有位置 或者有产品 但是会超时结束</span><br><span class="line"> */</span><br><span class="line">public static void test4() throws InterruptedException &#123;</span><br><span class="line">    ArrayBlockingQueue&lt;Object&gt; blockingQueue = new ArrayBlockingQueue&lt;&gt;(3);</span><br><span class="line"></span><br><span class="line">    blockingQueue.offer(&quot;a&quot;);</span><br><span class="line">    blockingQueue.offer(&quot;b&quot;);</span><br><span class="line">    blockingQueue.offer(&quot;c&quot;);</span><br><span class="line"></span><br><span class="line">    //超时时间2s 等待如果超过2s就结束等待</span><br><span class="line">    blockingQueue.offer(&quot;d&quot;, 2, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">    blockingQueue.poll();</span><br><span class="line">    blockingQueue.poll();</span><br><span class="line">    blockingQueue.poll();</span><br><span class="line">    //超过两秒 我们就不要等待了</span><br><span class="line">    blockingQueue.poll(2, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>SynchronousQueue<br>同步队列</p>
<p>特点：</p>
<p>同步队列没有容量，也可以视为容量为1的队列；<br>进去一个元素，必须等待取出来之后，才能再往里面放入一个元素；<br>put方法 和 take方法</p>
<p>SynchronousQueue和 其他的BlockingQueue 不一样 它不存储元素；</p>
<p>put了一个元素，就必须从里面先take出来，否则不能再put进去值！</p>
<p>并且SynchronousQueue 的take是使用了lock锁保证线程安全的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.marchsoft.queue;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.BlockingDeque;</span><br><span class="line">import java.util.concurrent.BlockingQueue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class SynchronousQueue &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        BlockingQueue&lt;String&gt; synchronousQueue = new java.util.concurrent.SynchronousQueue&lt;&gt;();</span><br><span class="line">        // 网queue中添加元素</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot;put 01&quot;);</span><br><span class="line">                synchronousQueue.put(&quot;1&quot;);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot;put 02&quot;);</span><br><span class="line">                synchronousQueue.put(&quot;2&quot;);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot;put 03&quot;);</span><br><span class="line">                synchronousQueue.put(&quot;3&quot;);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        // 取出元素</span><br><span class="line">        new Thread(()-&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot;take&quot; + synchronousQueue.take());</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot;take&quot; + synchronousQueue.take());</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot;take&quot; + synchronousQueue.take());</span><br><span class="line">            &#125;catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="线程池（重点）"><a href="#线程池（重点）" class="headerlink" title="线程池（重点）"></a>线程池（重点）</h3><p>线程池：三大创建方式、七大参数、四种拒绝策略</p>
<p>池化技术</p>
<p>程序的运行，本质：占用系统的资源！ 我们需要去优化资源的使用 ====&gt; 池化技术</p>
<p>例如：线程池、JDBC的连接池、内存池、对象池等等…</p>
<p>资源的创建、销毁十分消耗资源</p>
<p>池化技术：事先准备好一些资源，如果有人要用，就来我这里拿，用完之后还给我，以此来提高效率。</p>
<h4 id="线程池的好处："><a href="#线程池的好处：" class="headerlink" title="线程池的好处："></a>线程池的好处：</h4><p>1、降低资源的消耗；</p>
<p>2、提高响应的速度；</p>
<p>3、方便管理；</p>
<p>线程复用、可以控制最大并发、管理线程；</p>
<h4 id="线程池：三大方法、七大参数、四种策略"><a href="#线程池：三大方法、七大参数、四种策略" class="headerlink" title="线程池：三大方法、七大参数、四种策略"></a>线程池：三大方法、七大参数、四种策略</h4><p>三大方法</p>
<p>ExecutorService threadPool = Executors.newSingleThreadExecutor();//单个线程<br>ExecutorService threadPool2 = Executors.newFixedThreadPool(5); //创建一个固定的线程池的大小<br>ExecutorService threadPool3 = Executors.newCachedThreadPool(); //可伸缩的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.guocl.ThreadPool;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line">public class ThreadPoolDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ExecutorService threadPool = Executors.newSingleThreadExecutor();// 单个线程</span><br><span class="line">        ExecutorService threadPool = Executors.newFixedThreadPool(5);// 创建一个固定的线程池的大小</span><br><span class="line">        ExecutorService threadPool = Executors.newCachedThreadPool();// 单个线程</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            for (int i = 1; i &lt;= 10; i++) &#123;</span><br><span class="line">                threadPool.execute(() -&gt; &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot;：OK&quot;);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>七大参数</p>
</blockquote>
<p>创建线程时，不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式。</p>
<p><img src="https://i.p04e.com/baid/i/2023/03/29/81oa1.png"></p>
<p>阿里巴巴的Java操作手册中明确说明：对于Integer.MAX_VALUE初始值较大，所以一般情况我们要使用底层的 <strong>ThreadPoolExecutor</strong>来创建线程池。</p>
<p>使用 <strong>ThreadPoolExecutor</strong>创建线程池！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.guocl.ThreadPool;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line">public class ThreadPoolDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">//        ExecutorService threadPool = Executors.newSingleThreadExecutor();// 单个线程</span><br><span class="line">//        ExecutorService threadPool = Executors.newFixedThreadPool(5);// 创建一个固定的线程池的大小</span><br><span class="line">//        ExecutorService threadPool = Executors.newCachedThreadPool();// 单个线程</span><br><span class="line">        //获取cpu 的核数</span><br><span class="line">        int max = Runtime.getRuntime().availableProcessors();</span><br><span class="line">        //创建线程池</span><br><span class="line">        ExecutorService threadPool = new ThreadPoolExecutor(</span><br><span class="line">                2,</span><br><span class="line">                max,</span><br><span class="line">                3,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                new LinkedBlockingDeque&lt;&gt;(3),</span><br><span class="line">                Executors.defaultThreadFactory(),</span><br><span class="line">                new ThreadPoolExecutor.AbortPolicy()</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            for (int i = 1; i &lt;= 5; i++) &#123;</span><br><span class="line">                threadPool.execute(() -&gt; &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot;：OK&quot;);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们看了一下三种创建线程池方法的底层都是调用了<strong>ThreadPoolExecutor</strong>来创建的，<strong>ThreadPoolExecutor</strong>有七大参数，我们来看一下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public ThreadPoolExecutor(int corePoolSize,  //核心线程池大小</span><br><span class="line">                          int maximumPoolSize, //最大线程池的大小</span><br><span class="line">                          long keepAliveTime,  //超时时间，超过了就会释放线程</span><br><span class="line">                          TimeUnit unit, //超时单位</span><br><span class="line">                          BlockingQueue&lt;Runnable&gt; workQueue, //阻塞队列, 用来存储排队等待的线程</span><br><span class="line">                          ThreadFactory threadFactory, //线程工厂  创建线程的，我们一般不动</span><br><span class="line">                          RejectedExecutionHandler handler //拒绝策略，有四种</span><br><span class="line">                         ) &#123;</span><br><span class="line">    if (corePoolSize &lt; 0 ||</span><br><span class="line">        maximumPoolSize &lt;= 0 ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; 0)</span><br><span class="line">        throw new IllegalArgumentException();</span><br><span class="line">    if (workQueue == null || threadFactory == null || handler == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    this.corePoolSize = corePoolSize;</span><br><span class="line">    this.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    this.workQueue = workQueue;</span><br><span class="line">    this.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    this.threadFactory = threadFactory;</span><br><span class="line">    this.handler = handler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>四种拒绝策略</p>
<p>1.new ThreadPoolExecutor.AbortPolicy()： //该拒绝策略为：银行满了，还有人进来，不处理这个人的，并抛出异常</p>
<p>超出最大承载，就会抛出异常：队列容量大小+maxPoolSize。</p>
<p>new ThreadPoolExecutor.CallerRunsPolicy()： //该拒绝策略为：哪来的去哪里 main线程进行处理。</p>
<p>new ThreadPoolExecutor.DiscardPolicy(): //该拒绝策略为：队列满了,丢掉异常，不会抛出异常。</p>
<p>new ThreadPoolExecutor.DiscardOldestPolicy()： //该拒绝策略为：队列满了，尝试去和最早的进程竞争，不会抛出异常。</p>
<p>如果设置线程池的大小</p>
<p>1、CPU密集型：电脑的核数是几核就选择几；选择maximunPoolSiz 的大小</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 获取cpu 的核数</span><br><span class="line">int max = Runtime.getRuntime().availableProcessors();</span><br><span class="line">ExecutorService service =new ThreadPoolExecutor(</span><br><span class="line">    2,</span><br><span class="line">    max,</span><br><span class="line">    3,</span><br><span class="line">    TimeUnit.SECONDS,</span><br><span class="line">    new LinkedBlockingDeque&lt;&gt;(3),</span><br><span class="line">    Executors.defaultThreadFactory(),</span><br><span class="line">    new ThreadPoolExecutor.AbortPolicy()</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>2、I/O密集型：</p>
<p>在程序中有15个大型任务，IO十分占用资源；I/O密集型就是判断我们程序中十分耗I/O的线程数量，大约就是最大I/O的一倍到两倍之间。</p>
<h3 id="四大函数式接口"><a href="#四大函数式接口" class="headerlink" title="四大函数式接口"></a>四大函数式接口</h3><p>新时代的程序员： lambda表达式、链式编程、函数式接口、Stream流式计算</p>
<p>函数式接口：只有一个方法的接口<br><img src="https://i.p04e.com/baid/i/2023/03/29/80pou.png"></p>
<h4 id="Function函数型接口"><a href="#Function函数型接口" class="headerlink" title="Function函数型接口"></a>Function函数型接口</h4><p>Function函数型接口，有一个输入参数，有一个输出参数，只要是 函数型接口 可以用 lambda表达式简化。<img src="https://i.p04e.com/baid/i/2023/03/29/822tb.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.guocl.function;</span><br><span class="line"></span><br><span class="line">import java.util.function.Function;</span><br><span class="line"></span><br><span class="line">public class FunctionDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">//        Function function = new Function&lt;String, String&gt;() &#123;</span><br><span class="line">//            @Override</span><br><span class="line">//            public String apply(String str) &#123;</span><br><span class="line">//                System.out.println(str);</span><br><span class="line">//                return str;</span><br><span class="line">//            &#125;</span><br><span class="line">//        &#125;;</span><br><span class="line">        Function&lt;String, String&gt; function = (str)  -&gt; &#123;return str;&#125;;</span><br><span class="line">        System.out.println(function.apply(&quot;aaa&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="Predicate-断定型接口"><a href="#Predicate-断定型接口" class="headerlink" title="Predicate 断定型接口"></a>Predicate 断定型接口</h4><p><img src="https://i.p04e.com/baid/i/2023/03/29/5xhy.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">import com.sun.xml.internal.ws.util.StringUtils;</span><br><span class="line"></span><br><span class="line">import java.util.function.Predicate;</span><br><span class="line"></span><br><span class="line">public class PredicateDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">//        Predicate predicate = new Predicate&lt;String&gt;() &#123;</span><br><span class="line">//            @Override</span><br><span class="line">//            public boolean test(String o) &#123;</span><br><span class="line">//                if (o != null)&#123;</span><br><span class="line">//                    return true;</span><br><span class="line">//                &#125;</span><br><span class="line">//                return false;</span><br><span class="line">//            &#125;</span><br><span class="line">//        &#125;;</span><br><span class="line"></span><br><span class="line">        Predicate&lt;String&gt; predicate = (str) -&gt; &#123; return true;&#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(predicate.test(&quot;A&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="Consumer-消费型接口"><a href="#Consumer-消费型接口" class="headerlink" title="Consumer 消费型接口"></a>Consumer 消费型接口</h4><p><img src="https://i.p04e.com/baid/i/2023/03/29/15jn3.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.util.function.Consumer;</span><br><span class="line">import java.util.function.Predicate;</span><br><span class="line"></span><br><span class="line">public class PredicateDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">//        Consumer consumer = new Consumer&lt;String&gt;() &#123;</span><br><span class="line">//            @Override</span><br><span class="line">//            public void accept(String o) &#123;</span><br><span class="line">//                System.out.println(&quot;1111&quot;);</span><br><span class="line">//            &#125;</span><br><span class="line">//        &#125;;</span><br><span class="line"></span><br><span class="line">        Consumer&lt;String&gt; consumer = (str) -&gt; &#123; System.out.println(&quot;1111&quot;);&#125;;</span><br><span class="line"></span><br><span class="line">        consumer.accept(&quot;A&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="Suppier-供给型接口"><a href="#Suppier-供给型接口" class="headerlink" title="Suppier 供给型接口"></a>Suppier 供给型接口</h4><p><img src="https://i.p04e.com/baid/i/2023/03/29/15lxm.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.guocl.function;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import com.sun.xml.internal.ws.util.StringUtils;</span><br><span class="line"></span><br><span class="line">import java.util.function.Consumer;</span><br><span class="line">import java.util.function.Predicate;</span><br><span class="line">import java.util.function.Supplier;</span><br><span class="line"></span><br><span class="line">public class PredicateDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">//        Supplier supplier = new Supplier&lt;String&gt;() &#123;</span><br><span class="line">//            @Override</span><br><span class="line">//            public String get() &#123;</span><br><span class="line">//                return &quot;1&quot;;</span><br><span class="line">//            &#125;</span><br><span class="line">//        &#125;;</span><br><span class="line"></span><br><span class="line">        Supplier&lt;String&gt; supplier = () -&gt; &#123;  return &quot;1&quot;;&#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(supplier.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Stream流式计算"><a href="#Stream流式计算" class="headerlink" title="Stream流式计算"></a>Stream流式计算</h3><blockquote>
<p>什么是Stream流式计算</p>
</blockquote>
<p>大数据：存储 + 计算</p>
<p>集合、Mysql本质都是存储东西的；</p>
<p>计算都应该交给流来操作！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.guocl.stream;</span><br><span class="line"></span><br><span class="line">import com.guocl.stream.pojo.User;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Locale;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Description：</span><br><span class="line"> * 题目要求： 用一行代码实现</span><br><span class="line"> * 1. Id 必须是偶数</span><br><span class="line"> * 2.年龄必须大于23</span><br><span class="line"> * 3. 用户名转为大写</span><br><span class="line"> * 4. 用户名倒序</span><br><span class="line"> * 5. 只能输出一个用户</span><br><span class="line"> **/</span><br><span class="line">public class StreamDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        User u1 = new User(1, &quot;a&quot;, 23);</span><br><span class="line">        User u2 = new User(2, &quot;b&quot;, 23);</span><br><span class="line">        User u3 = new User(3, &quot;c&quot;, 23);</span><br><span class="line">        User u4 = new User(6, &quot;d&quot;, 24);</span><br><span class="line">        User u5 = new User(4, &quot;e&quot;, 25);</span><br><span class="line"></span><br><span class="line">        List&lt;User&gt; list = Arrays.asList(u1, u2, u3, u4, u5);</span><br><span class="line"></span><br><span class="line">        list.stream()</span><br><span class="line">                .filter(u -&gt; &#123;return u.getId() % 2 == 0;&#125;)</span><br><span class="line">                .filter(u -&gt; &#123;return u.getAge() &gt; 23;&#125;)</span><br><span class="line">                .map(u -&gt; &#123;return u.getName().toUpperCase();&#125;)</span><br><span class="line">                .sorted((uu1, uu2) -&gt; &#123;return uu2.compareTo(uu1);&#125;)</span><br><span class="line">                .limit(1)</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="ForkJoin"><a href="#ForkJoin" class="headerlink" title="ForkJoin"></a>ForkJoin</h3><p>ForkJoin 在JDK1.7中出现，并行执行任务！提高效率。在<strong>大数据量</strong>速率会更快！</p>
<p>大数据中： <strong>MapReduce 核心思想–&gt;把大任务拆分为小任务！</strong></p>
<p><img src="https://i.p04e.com/baid/i/2023/03/29/83mnx.png"></p>
<blockquote>
<p>ForkJoin特点：工作窃取</p>
</blockquote>
<p>实现原理： <strong>双端队列</strong> 从上面和下面都可以去拿到任务进行执行！</p>
<p><img src="https://i.p04e.com/baid/i/2023/03/29/15pcg.png"></p>
<blockquote>
<p>如何使用ForkJoin？</p>
</blockquote>
<p>1、通过<strong>ForkJoinPool</strong>来执行</p>
<p>2、计算任务 <strong>execute(ForkJoinTask&lt;?&gt; task)</strong></p>
<p>3、计算类要去继承 <strong>ForkJoinTask</strong></p>
<blockquote>
<p>ForkJoin的计算案例</p>
</blockquote>
<p>ForkJoin的计算类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.guocl.ff;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.RecursiveTask;</span><br><span class="line"></span><br><span class="line">public class ForkJoinDemo extends RecursiveTask&lt;Long&gt; &#123;</span><br><span class="line">    private long start;</span><br><span class="line">    private long end;</span><br><span class="line">    //临界值</span><br><span class="line">    private long temp = 1000000L;</span><br><span class="line"></span><br><span class="line">    public ForkJoinDemo(long start, long end)&#123;</span><br><span class="line">        this.start = start;</span><br><span class="line">        this.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 计算方法</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    protected Long compute() &#123;</span><br><span class="line">        if ((end - start) &lt; temp)&#123;</span><br><span class="line">            Long sum = 0L;</span><br><span class="line">            for (Long i = start; i &lt; end; i++) &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">            return sum;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            // 使用ForkJoin 分而治之  计算</span><br><span class="line">            // 1、计算平均值</span><br><span class="line">            long middle = (start + end) / 2;</span><br><span class="line">            // 拆分任务，把线程压入线程队列</span><br><span class="line">            ForkJoinDemo forkJoinDemo1 = new ForkJoinDemo(start, middle);</span><br><span class="line">            forkJoinDemo1.fork();</span><br><span class="line">            ForkJoinDemo forkJoinDemo2 = new ForkJoinDemo(middle, end);</span><br><span class="line">            forkJoinDemo2.fork();</span><br><span class="line"></span><br><span class="line">            long taskSum = forkJoinDemo1.join() + forkJoinDemo2.join();</span><br><span class="line">            return taskSum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>测试类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.guocl.ff;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.ExecutionException;</span><br><span class="line">import java.util.concurrent.ForkJoinPool;</span><br><span class="line">import java.util.concurrent.ForkJoinTask;</span><br><span class="line">import java.util.stream.LongStream;</span><br><span class="line"></span><br><span class="line">public class ForkJoinTest &#123;</span><br><span class="line">    private static final long SUM = 20_0000_0000;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">        //test1();</span><br><span class="line">        test2();</span><br><span class="line">        test3();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void test1()&#123;</span><br><span class="line">        long start = System.currentTimeMillis();</span><br><span class="line">        long sum = 0L;</span><br><span class="line">        for (int i = 0; i &lt; SUM; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        long end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">        System.out.println(&quot;时间：&quot; + (end - start));</span><br><span class="line">        System.out.println(&quot;----------------------&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void test2() throws ExecutionException, InterruptedException &#123;</span><br><span class="line">        long start = System.currentTimeMillis();</span><br><span class="line">        ForkJoinPool forkJoinPool = new ForkJoinPool();</span><br><span class="line">        ForkJoinTask&lt;Long&gt; task = new ForkJoinDemo(0L, SUM);</span><br><span class="line">        ForkJoinTask&lt;Long&gt; submit = forkJoinPool.submit(task);</span><br><span class="line">        Long along = submit.get();</span><br><span class="line"></span><br><span class="line">        System.out.println(along);</span><br><span class="line">        long end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;时间：&quot; + (end - start));</span><br><span class="line">        System.out.println(&quot;-----------&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void test3()&#123;</span><br><span class="line">        long start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        long sum = LongStream.range(0L, SUM).parallel().reduce(0, Long::sum);</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">        long end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;时间：&quot; + (end - start));</span><br><span class="line">        System.out.println(&quot;-----------&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1999999999000000000</span><br><span class="line">时间：20727</span><br><span class="line">-----------</span><br><span class="line">1999999999000000000</span><br><span class="line">时间：659</span><br><span class="line">-----------</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>.parallel().reduce(0, Long::sum)使用一个并行流去计算整个计算，提高效率。</strong></p>
<p><img src="https://i.p04e.com/baid/i/2023/03/29/b21dhd.png"></p>
<h3 id="异步回调"><a href="#异步回调" class="headerlink" title="异步回调"></a>异步回调</h3><blockquote>
<p>Future 设计的初衷：对将来的某个事件结果进行建模！</p>
</blockquote>
<p>其实就是前端 —》发送ajax异步请求给后端</p>
<p><img src="https://i.p04e.com/baid/i/2023/03/29/15m0t.png"></p>
<p>但是我们平时都使用<strong>CompletableFuture</strong></p>
<blockquote>
<p>没有返回值的runAsync异步回调</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.guocl.ff;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.CompletableFuture;</span><br><span class="line">import java.util.concurrent.ExecutionException;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">public class FutureDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">        // 发起 一个 请求</span><br><span class="line"></span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">        System.out.println(&quot;---------------------&quot;);</span><br><span class="line">        CompletableFuture&lt;Void&gt; future = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">            //发起一个异步任务</span><br><span class="line">            try &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(2);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;.....&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">        System.out.println(&quot;------------------------------&quot;);</span><br><span class="line">        //输出执行结果</span><br><span class="line">        System.out.println(future.get());  //获取执行结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1666602291181</span><br><span class="line">---------------------</span><br><span class="line">1666602291275</span><br><span class="line">------------------------------</span><br><span class="line">ForkJoinPool.commonPool-worker-1.....</span><br><span class="line">null</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>有返回值的supplyAsync异步回调</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.guocl.ff;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.CompletableFuture;</span><br><span class="line">import java.util.concurrent.ExecutionException;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">public class FutureDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">//        // 发起 一个 请求</span><br><span class="line">//		成功的</span><br><span class="line">//        System.out.println(System.currentTimeMillis());</span><br><span class="line">//        System.out.println(&quot;---------------------&quot;);</span><br><span class="line">//        CompletableFuture&lt;Void&gt; future = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">//            //发起一个异步任务</span><br><span class="line">//            try &#123;</span><br><span class="line">//                TimeUnit.SECONDS.sleep(2);</span><br><span class="line">//            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">//                e.printStackTrace();</span><br><span class="line">//            &#125;</span><br><span class="line">//            System.out.println(Thread.currentThread().getName()+&quot;.....&quot;);</span><br><span class="line">//        &#125;);</span><br><span class="line">//        System.out.println(System.currentTimeMillis());</span><br><span class="line">//        System.out.println(&quot;------------------------------&quot;);</span><br><span class="line">//        //输出执行结果</span><br><span class="line">//        System.out.println(future.get());  //获取执行结果</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //失败的</span><br><span class="line">        CompletableFuture&lt;Integer&gt; completableFuture = CompletableFuture.supplyAsync( () -&gt; &#123;</span><br><span class="line">           System.out.println(Thread.currentThread().getName());</span><br><span class="line">            try &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(2);</span><br><span class="line">                int i=1/0;</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            return 1024;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(completableFuture.whenComplete((t, u) -&gt; &#123;</span><br><span class="line">            // success 回调</span><br><span class="line">            System.out.println(&quot;t=&gt;&quot; + t); //正常的返回结果</span><br><span class="line">            System.out.println(&quot;u=&gt;&quot; + u); //抛出异常的 错误信息</span><br><span class="line">        &#125;).exceptionally((e) -&gt; &#123;</span><br><span class="line">            // error回调</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">            return 404;</span><br><span class="line">        &#125;).get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">失败时候的返回值：</span><br><span class="line"></span><br><span class="line">ForkJoinPool.commonPool-worker-1</span><br><span class="line">t=&gt;null</span><br><span class="line">u=&gt;java.util.concurrent.CompletionException: java.lang.ArithmeticException: / by zero</span><br><span class="line">java.lang.ArithmeticException: / by zero</span><br><span class="line">404</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">成功时候的返回值：</span><br><span class="line"></span><br><span class="line">ForkJoinPool.commonPool-worker-1</span><br><span class="line">t=&gt;1024</span><br><span class="line">u=&gt;null</span><br><span class="line">1024</span><br></pre></td></tr></table></figure>
<p>whenComplete: 有两个参数，一个是t 一个是u</p>
<p>T：是代表的 正常返回的结果；</p>
<p>U：是代表的 抛出异常的错误信息；</p>
<p>如果发生了异常，get可以获取到exceptionally返回的值；</p>
<p>16、JMM<br>16.1、对Volatile的理解<br>Volatile 是Java虚拟机提供 轻量级的同步机制</p>
<p>提到Volatile我们就会想到它的三个特点！</p>
<p>1、保证可见性</p>
<p>2、不保证原子性</p>
<p>3、禁止指令重排</p>
<p>如何实现可见性</p>
<p>volatile变量修饰的共享变量在进行写操作的时候会多出一行汇编：</p>
<p>0x01a3de1d:movb $0×0，0×1104800（%esi）;0x01a3de24<strong>:lock</strong> addl $0×0,(%esp);</p>
<p>Lock前缀的指令在多核处理器下回引发两件事：</p>
<p>将当前处理器缓存行的数据写回到系统内存。<br>这个写回内存的操作会使其他CPU里缓存了该内存地址的数据无效。<br>多处理器总线嗅探：</p>
<p>为了提高处理速度，处理器不直接和内存进行通信，而是先将系统内存的数据读到内部缓存后再进行操作，但操作不知道何时会写回到内存。如果对声明了volatile的变量进行写操作，JVM就会向处理器发送一条lock前缀的指令，将这个变量所在缓存行的数据写回到系统内存。但是在 多处理器下 ，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议， 每个处理器通过嗅探在总线上传播的数据来检查自己的缓存是不是过期了，如果处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置无效状态 ，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读取到处理器缓存中。</p>
<p>16.2、什么是JMM<br><strong>JMM：</strong>JAVA内存模型，不存在的东西，是一个概念也是一个约定！</p>
<p>关于JMM的一些同步的约定</p>
<p>1、线程解锁前，必须把共享变量立刻刷回主存；</p>
<p>2、线程加锁前，必须 读取主存中的最新值到工作内存中；</p>
<p>3、加锁和解锁是同一把锁；</p>
<p>线程中分为 工作内存、主内存。</p>
<p>8种操作</p>
<p>Read（读取）：作用于主内存变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用；</p>
<p>load（载入）：作用于工作内存的变量，它把read操作从主存中变量放入工作内存中；</p>
<p>Use（使用）：作用于工作内存中的变量，它把工作内存中的变量传输给执行引擎，每当虚拟机遇到一个需要使用到变量的值，就会使用到这个指令；</p>
<p>assign（赋值）：作用于工作内存中的变量，它把一个从执行引擎中接受到的值放入工作内存的变量副本中；</p>
<p>store（存储）：作用于主内存中的变量，它把一个从工作内存中一个变量的值传送到主内存中，以便后续的write使用；</p>
<p>write（写入）：作用于主内存中的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中；</p>
<p>lock（锁定）：作用于主内存的变量，把一个变量标识为线程独占状态；</p>
<p>unlock（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定；</p>
<p><img src="https://i.p04e.com/baid/i/2023/03/29/5y53.png"></p>
<p>JMM对这8种操作给了相应的规定：</p>
<p>不允许read和load、store和write操作之一单独出现。即使用了read必须load，使用了store必须write；<br>不允许线程丢弃他最近的assign操作，即工作变量的数据改变了之后，必须告知主存；<br>不允许一个线程将没有assign的数据从工作内存同步回主内存;<br>一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是对变量实施use、store操作之前，必须经过assign和load操作;<br>一个变量同一时间只有一个线程能对其进行lock。多次lock后，必须执行相同次数的unlock才能解锁;<br>如果对一个变量进行lock操作，会清空所有工作内存中此变量的值，在执行引擎使用这个变量前，必须重新load或assign操作初始化变量的值;<br>如果一个变量没有被lock，就不能对其进行unlock操作。也不能unlock一个被其他线程锁住的变量;<br>对一个变量进行unlock操作之前，必须把此变量同步回主内存<br>遇到问题</p>
<p>这时会出现一个问题，如线程A和线程B同时使用了主存的一个数据，线程B修改了值，但是线程A不能及时可见。</p>
<p><img src="https://i.p04e.com/baid/i/2023/03/29/15t7v.png"></p>
<p>遇到问题：<strong>程序不知道主存中的值已经被修改过了！ 下面解答</strong></p>
<h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><h4 id="保证可见性"><a href="#保证可见性" class="headerlink" title="保证可见性"></a>保证可见性</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.guocl.volatileDemo;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">public class volatiletest &#123;</span><br><span class="line"></span><br><span class="line">    //如果不加volatile，程序会一直跑，因为开启的线程不知道主存的num变成了1</span><br><span class="line">    private volatile static Integer num = 0;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        //子线程</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            while (num == 0)&#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(2);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        num = 1;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="不保证原子性"><a href="#不保证原子性" class="headerlink" title="不保证原子性"></a>不保证原子性</h4><p>原子性：不可分割；</p>
<p>线程A在执行任务的时候，不能被打扰，也不能被分割，要么同时成功，要么同时失败。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.guocl.volatileDemo;</span><br><span class="line"></span><br><span class="line">public class VolatileTest2 &#123;</span><br><span class="line">    private volatile static Integer num = 0;</span><br><span class="line"></span><br><span class="line">    public static void add()&#123;</span><br><span class="line">        //++ 不是一个原子性操作</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for (int i = 0; i &lt; 20; i++) &#123;</span><br><span class="line">            new Thread(() -&gt; &#123;</span><br><span class="line">                for (int j = 1; j &lt; 100; j++) &#123;</span><br><span class="line">                    add();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while (Thread.activeCount() &gt; 2)&#123;</span><br><span class="line">            //当线程数小于2的时候就停止，因为有两个默认线程：mian、GC</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;, num=&quot; + num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main, num=1980</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>如果不加lock和synchronized ，怎么样保证原子性？</strong></p>
<p><img src="https://i.p04e.com/baid/i/2023/03/29/5zg6.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.guocl.volatileDemo;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line">public class VolatileTest2 &#123;</span><br><span class="line">    private static volatile AtomicInteger num = new AtomicInteger();</span><br><span class="line"></span><br><span class="line">    public static void add()&#123;</span><br><span class="line">        //底层是CAS保证原子性，效率很高</span><br><span class="line">        num.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for (int i = 0; i &lt; 20; i++) &#123;</span><br><span class="line">            new Thread(() -&gt; &#123;</span><br><span class="line">                for (int j = 1; j &lt;= 1000; j++) &#123;</span><br><span class="line">                    add();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while (Thread.activeCount() &gt; 2)&#123;</span><br><span class="line">            //当线程数小于2的时候就停止，因为有两个默认线程：mian、GC</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;, num=&quot; + num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这些原子类的底层都是直接和操作系统挂钩，是在内存中修改值的。</p>
<p>Unsafe类是一个很特殊的存在；</p>
<h3 id="禁止指令重排"><a href="#禁止指令重排" class="headerlink" title="禁止指令重排"></a>禁止指令重排</h3><blockquote>
<p>什么是指令重排</p>
</blockquote>
<p>我们写程序时，计算机并不是按照我们自己写的那样去执行的。</p>
<p>源代码–&gt;编译器优化–&gt;指令并行也可能会重排–&gt;内存系统也会重排–&gt;执行</p>
<p><strong>处理器在进行指令重排的时候，会考虑数据之间的依赖性！</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int x=1; //1</span><br><span class="line">int y=2; //2</span><br><span class="line">x=x+5;   //3</span><br><span class="line">y=x*x;   //4</span><br><span class="line"></span><br><span class="line">//我们期望的执行顺序是 1_2_3_4  可能执行的顺序会变成2134 1324</span><br><span class="line">//可不可能是 4123？ 不可能的</span><br><span class="line">1234567</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可能造成的影响结果：前提：a b x y这四个值 默认都是0</p>
<p>线程A    线程B<br>x=a    y=b<br>b=1    a=2<br>正常的结果： x = 0; y =0;</p>
<p>线程A    线程B<br>b=1    a=2<br>x=a    y=b<br>可能在线程A中会出现，先执行b=1,然后再执行x=a；</p>
<p>在B线程中可能会出现，先执行a=2，然后执行y=b；</p>
<p>那么就有可能结果如下：x=2; y=1.</p>
<p>Volatile可以避免指令重排</p>
<p>Volatile中会加一道内存的屏障，这个内存屏障可以保证在这个屏障中的指令顺序。</p>
<p>内存屏障：CPU指令。</p>
<p>作用：</p>
<p>1、保证特定的操作的执行顺序；</p>
<p>2、可以保证某些变量的内存可见性（利用这些特性，就可以保证volatile实现的可见性）<br><img src="https://i.p04e.com/baid/i/2023/03/29/4em.png"></p>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><ul>
<li>volatile可以保证可见性；</li>
<li>不能保证原子性</li>
<li>由于内存屏障，可以保证避免指令重排的现象发生</li>
</ul>
<p>面试官：那么你知道在哪里用这个内存屏障用得最多呢？<strong>单例模式</strong></p>
<h3 id="玩转单例模式"><a href="#玩转单例模式" class="headerlink" title="玩转单例模式"></a>玩转单例模式</h3><p>饿汉式 、懒汉式（DCL懒汉式）</p>
<h4 id="18-1、饿汉式"><a href="#18-1、饿汉式" class="headerlink" title="18.1、饿汉式"></a>18.1、饿汉式</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.guocl.Singleton;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 饿汉式单例</span><br><span class="line"> */</span><br><span class="line">public class Hungry &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 可能会浪费空间</span><br><span class="line">     */</span><br><span class="line">    private byte[] data1 = new byte[1024*1024];</span><br><span class="line">    private byte[] data2 = new byte[1024*1024];</span><br><span class="line">    private byte[] data3 = new byte[1024*1024];</span><br><span class="line">    private byte[] data4 = new byte[1024*1024];</span><br><span class="line"></span><br><span class="line">    private Hungry()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private final static Hungry hungry = new Hungry();</span><br><span class="line"></span><br><span class="line">    public static Hungry getInstance()&#123;</span><br><span class="line">        return hungry;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="DCL懒汉式"><a href="#DCL懒汉式" class="headerlink" title="DCL懒汉式"></a>DCL懒汉式</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.guocl.Singleton;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Constructor;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line">public class LazyMan &#123;</span><br><span class="line"></span><br><span class="line">    private static boolean key = false;</span><br><span class="line"></span><br><span class="line">    private LazyMan()&#123;</span><br><span class="line">        //当用反射创建对象时，会破坏单例模式，这时我们需要在构造方法处 加锁</span><br><span class="line">        synchronized (LazyMan.class)&#123;</span><br><span class="line">            //当一个对象调用单例创建，其他对象用反射创建时，这时我们需要在构造方法处判断对象是否为空</span><br><span class="line">            //但是当两个对象都用反射创建时，此校验就没用了</span><br><span class="line">//            if (lazyMan != null)&#123;</span><br><span class="line">//                throw new RuntimeException(&quot;不要试图使用反射破坏异常&quot;);</span><br><span class="line">//            &#125;</span><br><span class="line">            //当两个对象都用反射创建时，我们使用红绿灯的方式来校验(标志位)</span><br><span class="line">            if (key==false)&#123;</span><br><span class="line">                key = true;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                throw new RuntimeException(&quot;不要试图使用反射破坏异常&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;OK&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private volatile static LazyMan lazyMan;</span><br><span class="line"></span><br><span class="line">    //双重检测模式的懒汉式单例， DCL单例</span><br><span class="line">    public static LazyMan getInstance()&#123;</span><br><span class="line">        if (lazyMan == null)&#123;</span><br><span class="line">            //当多线程调用时，会创建多个不同的对象，这时我们需要加锁</span><br><span class="line">            synchronized (LazyMan.class)&#123;</span><br><span class="line">                /**</span><br><span class="line">                 * new LazyMan();有三步</span><br><span class="line">                 * 1、分配内存空间</span><br><span class="line">                 * 2、执行构造方法，初始化对象</span><br><span class="line">                 * 3、把这个对象指向这个空间</span><br><span class="line">                 *</span><br><span class="line">                 * 这时有可能出现指令重排问题</span><br><span class="line">                 * 比如执行的顺序是1 3 2 等</span><br><span class="line">                 * 我们就可以添加volatile保证指令重排问题</span><br><span class="line">                 */</span><br><span class="line">                lazyMan = new LazyMan();//不是一个原子性操作</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return lazyMan;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        //多线程调用懒汉式单例模式，需要加锁</span><br><span class="line">//        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">//          new Thread(() -&gt; &#123;</span><br><span class="line">//              System.out.println(LazyMan.getInstance());</span><br><span class="line">//          &#125;).start();</span><br><span class="line">//        &#125;</span><br><span class="line"></span><br><span class="line">//        LazyMan lazyMan1 = LazyMan.getInstance();</span><br><span class="line">//        System.out.println(&quot;lazyMan1&quot; + lazyMan1);</span><br><span class="line"></span><br><span class="line">        //使用红绿灯的方式来校验单例，也是可以破解的。</span><br><span class="line">        //我们可以反编译这个类，看到红绿灯的变量名，无视标志位的私有化</span><br><span class="line">        Field key = LazyMan.class.getDeclaredField(&quot;key&quot;);</span><br><span class="line">        key.setAccessible(true);</span><br><span class="line">        // 使用反射来破解单例模式</span><br><span class="line">        // 反射私有的无参构造</span><br><span class="line">        Constructor&lt;LazyMan&gt; declaredConstructor = LazyMan.class.getDeclaredConstructor(null);</span><br><span class="line">        //无视私有的构造器</span><br><span class="line">        declaredConstructor.setAccessible(true);</span><br><span class="line">        LazyMan lazyMan1 = declaredConstructor.newInstance();</span><br><span class="line">        System.out.println(&quot;lazyMan1&quot; + lazyMan1);</span><br><span class="line">        //把key变量变成false</span><br><span class="line">        key.set(lazyMan1, false);</span><br><span class="line">        LazyMan lazyMan2 = declaredConstructor.newInstance();</span><br><span class="line">        System.out.println(&quot;lazyMan2&quot; + lazyMan2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>结论：懒汉式无论怎么检测都是不安全的，使用枚举才是安全的</p>
<h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.guocl.Singleton;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 静态内部类</span><br><span class="line"> */</span><br><span class="line">public class Holder &#123;</span><br><span class="line"></span><br><span class="line">    private Holder()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Holder getInstance()&#123;</span><br><span class="line">        return InnerClass.holder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class InnerClass&#123;</span><br><span class="line">        private static final Holder holder = new Holder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.guocl.Singleton;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Constructor;</span><br><span class="line">import java.lang.reflect.InvocationTargetException;</span><br><span class="line"></span><br><span class="line">//enum 是什么？  enum本身是一个Class类</span><br><span class="line">public enum EnumSingle &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    public EnumSingle getInstance()&#123;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Test&#123;</span><br><span class="line">    public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException &#123;</span><br><span class="line">        EnumSingle instance1 = EnumSingle.INSTANCE;</span><br><span class="line">        //开始我们看源码 枚举是一个无参构造，但是报的错不是我们 期望的。</span><br><span class="line">        //我们通过使用工具反编译，发现枚举默认的是一个两个参数的有参构造</span><br><span class="line">//        Constructor&lt;EnumSingle&gt; declaredConstructor = EnumSingle.class.getDeclaredConstructor(null);</span><br><span class="line">        Constructor&lt;EnumSingle&gt; declaredConstructor = EnumSingle.class.getDeclaredConstructor(String.class, int.class);</span><br><span class="line">        declaredConstructor.setAccessible(true);</span><br><span class="line"></span><br><span class="line">        EnumSingle instance2 = declaredConstructor.newInstance();</span><br><span class="line">        System.out.println(instance1);</span><br><span class="line">        System.out.println(instance2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用枚举，我们就可以防止反射破坏了.</p>
<p><img src="https://i.p04e.com/baid/i/2023/03/29/86swp.png"></p>
<p>枚举类型的最终反编译源码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final class EnumSingle extends Enum</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    public static EnumSingle[] values()</span><br><span class="line">    &#123;</span><br><span class="line">        return (EnumSingle[])$VALUES.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static EnumSingle valueOf(String name)</span><br><span class="line">    &#123;</span><br><span class="line">        return (EnumSingle)Enum.valueOf(com/ogj/single/EnumSingle, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private EnumSingle(String s, int i)</span><br><span class="line">    &#123;</span><br><span class="line">        super(s, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public EnumSingle getInstance()</span><br><span class="line">    &#123;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static final EnumSingle INSTANCE;</span><br><span class="line">    private static final EnumSingle $VALUES[];</span><br><span class="line"></span><br><span class="line">    static </span><br><span class="line">    &#123;</span><br><span class="line">        INSTANCE = new EnumSingle(&quot;INSTANCE&quot;, 0);</span><br><span class="line">        $VALUES = (new EnumSingle[] &#123;</span><br><span class="line">            INSTANCE</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="深入理解CAS"><a href="#深入理解CAS" class="headerlink" title="深入理解CAS"></a>深入理解CAS</h3><h4 id="什么是CAS"><a href="#什么是CAS" class="headerlink" title="什么是CAS"></a>什么是CAS</h4><p>大厂必须深入研究底层！！！！<strong>修内功！操作系统、计算机网络、组成原理、数据结构</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.guocl.cas;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line">public class CasDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        AtomicInteger atomicInteger = new AtomicInteger(2020);</span><br><span class="line"></span><br><span class="line">        // boolean compareAndSet(int expect, int update)</span><br><span class="line">        // 期望值、更新值</span><br><span class="line">        // 如果实际值 和 期望值相同，那么就会更新</span><br><span class="line">        // 如果实际值 和 期望值不相同，那么就不会更新</span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(2020, 2021));</span><br><span class="line">        System.out.println(atomicInteger.get());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        // ++操作  现在实际值为2021</span><br><span class="line">        atomicInteger.getAndIncrement();</span><br><span class="line">        // 因为期望值是2020  实际上是2021，所以修改失败</span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(2020, 2021));</span><br><span class="line">        System.out.println(atomicInteger.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>之前讲volatile的时候，谈到了Unsafe类。</p>
<blockquote>
<p>Unsafe类</p>
</blockquote>
<p><img src="https://i.p04e.com/baid/i/2023/03/29/15ttg.png"></p>
<p>java可以通过Unsafe 类来操作 内存</p>
<p><img src="https://i.p04e.com/baid/i/2023/03/29/860tj.png"></p>
<p>方法解释：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//该方法功能是Interger类型加1</span><br><span class="line">public final int getAndIncrement() &#123;</span><br><span class="line">    //主要看这个getAndAddInt方法</span><br><span class="line">    return unsafe.getAndAddInt(this, valueOffset, 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//var1 是this指针</span><br><span class="line">//var2 是地址偏移量</span><br><span class="line">//var4 是自增的数值，是自增1还是自增N</span><br><span class="line">public final int getAndAddInt(Object var1, long var2, int var4) &#123;</span><br><span class="line">    int var5;</span><br><span class="line">    do &#123;</span><br><span class="line">        //获取内存值，这是内存值已经是旧的，假设我们称作期望值E</span><br><span class="line">        var5 = this.getIntVolatile(var1, var2);</span><br><span class="line">        //compareAndSwapInt方法是重点，</span><br><span class="line">        //var5是期望值，var5 + var4是要更新的值</span><br><span class="line">        //这个操作就是调用CAS的JNI,每个线程将自己内存里的内存值M</span><br><span class="line">        //与var5期望值E作比较(其实就是var1和var5作比较)，如果相同将内存值M更新为var5 + var4,否则做自旋操作</span><br><span class="line">    &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    return var5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>CAS：比较当前工作内存中的值 和 主内存中的值，如果这个值时期望的，则执行操作！如果不是就一直循环，使用的就是自旋锁。</p>
<p><strong>缺点：</strong></p>
<ul>
<li>循环会耗时；</li>
<li>一次性只能保证一个共享变量的原子性；</li>
<li>它会存在ABA问题</li>
</ul>
<blockquote>
<p>CAS：ABA问题？(狸猫换太子)</p>
</blockquote>
<p><img src="https://i.p04e.com/baid/i/2023/03/29/60c2.png"></p>
<p>线程1：期望值是1，要变成2；</p>
<p>线程2：两个操作：</p>
<ul>
<li>1、期望值是1，变成3</li>
<li>2、期望是3，变成1</li>
</ul>
<p>所以对于线程1来说，A的值还是1，所以就出现了问题，骗过了线程1；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.guocl.cas;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line">public class AbaDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        AtomicInteger atomicInteger = new AtomicInteger(2020);</span><br><span class="line"></span><br><span class="line">        //捣乱线程</span><br><span class="line">        System.out.println(&quot;a1:&quot; + atomicInteger.compareAndSet(2020, 2021));</span><br><span class="line">        System.out.println(&quot;a2:&quot; + atomicInteger.compareAndSet(2021, 2020));</span><br><span class="line">        System.out.println(atomicInteger.get());</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;b1&quot; + atomicInteger.compareAndSet(2020, 2022));</span><br><span class="line">        System.out.println(atomicInteger.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a1:true</span><br><span class="line">a2:true</span><br><span class="line">2020</span><br><span class="line">b1true</span><br><span class="line">2022</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>解决CAS的ABA问题需要 原子引用，也就是乐观锁的思想</p>
<h3 id="原子引用"><a href="#原子引用" class="headerlink" title="原子引用"></a>原子引用</h3><p>解决ABA问题，对应的思想：就是使用乐观锁！！！</p>
<p>带版本号的原子操作！</p>
<p>当我们使用原子操作泛型为Integer时，注意一个大坑：</p>
<p>Integer 使用了对象缓存机制，默认范围是-128~127，推荐使用静态工厂方法valueOf获取对象实例，而不是new，因为valueOf使用缓存，而new一定会创建新的对象分配新的内存空间。</p>
<p><img src="https://i.p04e.com/baid/i/2023/03/29/87ipf.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.guocl.cas;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line">import java.util.concurrent.atomic.AtomicStampedReference;</span><br><span class="line"></span><br><span class="line">public class AtoRef &#123;</span><br><span class="line"></span><br><span class="line">    /**AtomicStampedReference 注意，如果泛型是一个包装类，注意对象的引用问题</span><br><span class="line">     * 正常在业务操作，这里面比较的都是一个个对象</span><br><span class="line">     */</span><br><span class="line">    static AtomicStampedReference&lt;Integer&gt; atomicStampedReference = new AtomicStampedReference&lt;&gt;(1, 1);</span><br><span class="line"></span><br><span class="line">    // CAS compareAndSet : 比较并交换！</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            // 获得新版本号</span><br><span class="line">            int stamp = atomicStampedReference.getStamp();</span><br><span class="line">            System.out.println(&quot;a1=&gt;&quot; + stamp);</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(2);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            // 修改操作时，版本号更新 + 1</span><br><span class="line">            System.out.println(atomicStampedReference.compareAndSet(1, 2, stamp, atomicStampedReference.getStamp() + 1));</span><br><span class="line">            System.out.println(&quot;a2=&gt;&quot; + atomicStampedReference.getStamp());</span><br><span class="line"></span><br><span class="line">            // 重新把值改回去， 版本号更新 + 1</span><br><span class="line">            System.out.println(atomicStampedReference.compareAndSet(2, 1, atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + 1));</span><br><span class="line">            System.out.println(&quot;a3=&gt;&quot; + atomicStampedReference.getStamp());</span><br><span class="line"></span><br><span class="line">        &#125;, &quot;a&quot;).start();</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            //获得版本号</span><br><span class="line">            int stamp = atomicStampedReference.getStamp();</span><br><span class="line">            System.out.println(&quot;b1=&gt;&quot; + stamp);</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(3);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(atomicStampedReference.compareAndSet(1, 6, stamp, atomicStampedReference.getStamp() + 1));</span><br><span class="line">            System.out.println(&quot;b2=&gt;&quot; + atomicStampedReference.getStamp());</span><br><span class="line">        &#125;, &quot;b&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a1=&gt;1</span><br><span class="line">b1=&gt;1</span><br><span class="line">true</span><br><span class="line">a2=&gt;2</span><br><span class="line">true</span><br><span class="line">a3=&gt;3</span><br><span class="line">false</span><br><span class="line">b2=&gt;3</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="各种锁的理解"><a href="#各种锁的理解" class="headerlink" title="各种锁的理解"></a>各种锁的理解</h3><h4 id="公平锁、非公平锁"><a href="#公平锁、非公平锁" class="headerlink" title="公平锁、非公平锁"></a>公平锁、非公平锁</h4><p><strong>公平锁：</strong> 非常公平，不能够插队，必须先来后到！</p>
<p><strong>非公平锁：</strong>非常不公平，可以插队！</p>
<p>Synchronized和Lock锁默认的都是非公平锁，看下面代码实例！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 默认非公平锁</span><br><span class="line">public ReentrantLock() &#123;</span><br><span class="line">	sync = new NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 公平锁</span><br><span class="line">public ReentrantLock(boolean fair) &#123;</span><br><span class="line">	sync = fair ? new FairSync() : new NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁`"></a>可重入锁`</h4><p>又叫递归锁</p>
<p><img src="https://i.p04e.com/baid/i/2023/03/29/16ay5.png"></p>
<p>手写可重入锁</p>
<blockquote>
<p>Synchronized</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.guocl.Lock;</span><br><span class="line"></span><br><span class="line">public class Demo1 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Phone phone = new Phone();</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt;&#123;</span><br><span class="line">            phone.sms();</span><br><span class="line">        &#125;, &quot;A&quot;).start();</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            phone.call();</span><br><span class="line">        &#125;, &quot;B&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Phone&#123;</span><br><span class="line">    public synchronized void sms()&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;sms&quot;);</span><br><span class="line">        call();// 这里也有锁</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void call()&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;call&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Lock</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.guocl.Lock;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">public class Demo2 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Phone2 phone2 = new Phone2();</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt;&#123;</span><br><span class="line">            phone2.sms();</span><br><span class="line">        &#125;, &quot;A&quot;).start();</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            phone2.call();</span><br><span class="line">        &#125;, &quot;B&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Phone2&#123;</span><br><span class="line">    Lock lock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">    public void sms()&#123;</span><br><span class="line">        lock.lock(); // 细节问题：lock.lock(); lock.unlock(); // lock 锁必须配对，否则就会死在里面</span><br><span class="line">        lock.lock();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;sms&quot;);</span><br><span class="line">            call();// 这里也有锁</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void call()&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;call&quot;);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Asms</span><br><span class="line">Acall</span><br><span class="line">Bcall</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>两个锁的执行结果相同，当A线程拿到第一个锁之后，就自动拿到下面的锁了，等这个线程的锁全部执行完才会释放锁。</p>
<h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><p>spinlock 自旋锁必须有CAS操作</p>
<p><img src="https://i.p04e.com/baid/i/2023/03/29/v54.png"></p>
<p>我们来自定义一个锁测试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.guocl.Lock;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 自旋锁</span><br><span class="line"> */</span><br><span class="line">public class SpinlockDemo &#123;</span><br><span class="line"></span><br><span class="line">    // int 0</span><br><span class="line">    // Thread null</span><br><span class="line">    AtomicReference&lt;Thread&gt; atomicReference = new AtomicReference&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    // 加锁</span><br><span class="line">    public void myLock()&#123;</span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;==&gt; mylock&quot;);</span><br><span class="line"></span><br><span class="line">        //自旋锁 必须有CAS操作</span><br><span class="line">        while (!atomicReference.compareAndSet(null, thread))&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 解锁</span><br><span class="line">    public void myUnLock()&#123;</span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;==&gt; myUnLock&quot;);</span><br><span class="line">        atomicReference.compareAndSet(thread, null);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.guocl.Lock;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">public class SpinlockTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        // ReentrantLock reentrantLock = new ReentrantLock();</span><br><span class="line">        // reentrantLock.lock();</span><br><span class="line">        // reentrantLock.unlock();</span><br><span class="line"></span><br><span class="line">        // 底层使用的自旋锁CAS</span><br><span class="line">        SpinlockDemo lock = new SpinlockDemo();</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            lock.myLock();</span><br><span class="line">            try &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(5);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                lock.myUnLock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;T1&quot;).start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(1);</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            lock.myLock();</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(1);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                lock.myUnLock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;T2&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">执行结果：</span><br><span class="line"></span><br><span class="line">T1==&gt; mylock</span><br><span class="line">T2==&gt; mylock</span><br><span class="line">T1==&gt; myUnLock</span><br><span class="line">T2==&gt; myUnLock</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><blockquote>
<p>死锁是什么</p>
</blockquote>
<p><img src="https://i.p04e.com/baid/i/2023/03/29/16gtz.png"></p>
<p>死锁测试，怎么排除死锁：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.guocl.Lock;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">public class DeadLockDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String lockA = &quot;lockA&quot;;</span><br><span class="line">        String lockB = &quot;lockB&quot;;</span><br><span class="line"></span><br><span class="line">        new Thread(new MyThread(lockA, lockB), &quot;T1&quot;).start();</span><br><span class="line">        new Thread(new MyThread(lockB, lockA), &quot;T1&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyThread implements Runnable&#123;</span><br><span class="line"></span><br><span class="line">    private String lockA;</span><br><span class="line">    private String lockB;</span><br><span class="line"></span><br><span class="line">    public MyThread(String lockA, String lockB)&#123;</span><br><span class="line">        this.lockA = lockA;</span><br><span class="line">        this.lockB = lockB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        synchronized (lockA)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;lock:&quot; + lockA + &quot;=&gt;get:&quot; + lockB);</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(2);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            synchronized (lockB)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot;lock:&quot; + lockB + &quot;=&gt;get:&quot; + lockA);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>解决死锁问题</p>
</blockquote>
<p>1、使用 <strong>jsp -l</strong> 定位进程号</p>
<p><img src="https://i.p04e.com/baid/i/2023/03/29/16c1z.png"></p>
<p>2、使用 <strong>jstack 进程号</strong> 找到死锁问题<img src="https://i.p04e.com/baid/i/2023/03/29/16b4l.png"></p>
]]></content>
      <tags>
        <tag>Juc</tag>
        <tag>生产者和消费者</tag>
        <tag>Lock</tag>
        <tag>Callable</tag>
        <tag>线程池</tag>
        <tag>volatile</tag>
        <tag>Stream</tag>
        <tag>CAS</tag>
      </tags>
  </entry>
  <entry>
    <title>Java数组扩容的三大方式</title>
    <url>/2023/04/25/Java%E6%95%B0%E7%BB%84%E6%89%A9%E5%AE%B9%E7%9A%84%E4%B8%89%E5%A4%A7%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="方案1：新建数组"><a href="#方案1：新建数组" class="headerlink" title="方案1：新建数组"></a>方案1：新建数组</h3><p>这种方法新建的数组必须要比原先的长度要长，然后将原来的数组内容移到新的数组中</p>
<span id="more"></span>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建新数组，长度为源数组的两倍</span></span><br><span class="line"><span class="type">int</span>[] b = <span class="keyword">new</span> <span class="title class_">int</span>[a.length * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将旧数组内容复制到新数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">    b[i] = a[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新数组内容赋值给源数组</span></span><br><span class="line">a = b;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line">System.out.println(Arrays.toString(a));</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[1, 2, 3, 4, 5, 0, 0, 0, 0, 0]</span><br></pre></td></tr></table></figure>
<h3 id="方案2：Arrays-copyOf"><a href="#方案2：Arrays-copyOf" class="headerlink" title="方案2：Arrays.copyOf"></a>方案2：Arrays.copyOf</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个参数是拷贝的数组，第二个参数是扩容长度，且返回一个新数组</span></span><br><span class="line">a = Arrays.copyOf(a, a.length * <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line">System.out.println(Arrays.toString(a));</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[1, 2, 3, 4, 5, 0, 0, 0, 0, 0]</span><br></pre></td></tr></table></figure>
<p>Arrays.copyof是用于数组进行复制时常使用的方法，本身在Arrays类里面，而之所以能这么使用而不用创建对象在于该方法本身由static修饰，被static修饰的方法可以在该类创建对象前载入jvm。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static long[] copyOf(long[] original, int newLength) &#123;</span><br><span class="line">    long[] copy = new long[newLength];</span><br><span class="line">    System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength));</span><br><span class="line">    return copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通过上面的代码可以看出，其本质是调用了System.arraycopy方法。</p>
<p>先产生一个新的数组然后调用arraycopy方法最后在返回产生的新数组。但是我们进行数组扩容的时候禅城了新数组，但是原数组依然存在，造成了内存的浪费。</p>
<h3 id="方案3：System-arraycopy"><a href="#方案3：System-arraycopy" class="headerlink" title="方案3：System.arraycopy"></a>方案3：System.arraycopy</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int[] a = &#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line"></span><br><span class="line">// 定义新数组，长度为源数组的两倍</span><br><span class="line">int[] b = new int[a.length * 2];</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * src      需要拷贝的源数组</span><br><span class="line"> * srcPos   源数组中的起始位置</span><br><span class="line"> * dest     目标数组</span><br><span class="line"> * destPos  目标数组中的起始位置</span><br><span class="line"> * length   要复制的数组元素数量</span><br><span class="line"> */</span><br><span class="line">System.arraycopy(a, 0, b, 0, a.length);</span><br><span class="line"></span><br><span class="line">// 新数组内容赋值给原数组</span><br><span class="line">a = b;</span><br><span class="line"></span><br><span class="line">// 打印结果</span><br><span class="line">System.out.println(Arrays.toString(a));</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[1, 2, 3, 4, 5, 0, 0, 0, 0, 0]</span><br></pre></td></tr></table></figure>
<h3 id="arraycopy源码"><a href="#arraycopy源码" class="headerlink" title="arraycopy源码"></a>arraycopy源码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> src     the source array.  源数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> srcPos  starting position in the source array. 要复制的源数组的起始位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dest    the destination array. 目标数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> destPos starting position in the destination data. 目标数组的起始位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length  the number of array elements to be copied. 要复制的长度</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IndexOutOfBoundsException if copying would cause</span></span><br><span class="line"><span class="comment">     *                                   access of data outside array bounds.</span></span><br><span class="line"><span class="comment">     *                                   如果复制会导致数据的访问超出数组边界。</span></span><br><span class="line"><span class="comment">     *                                   则会报IndexOutOfBoundsException索引越界异常</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ArrayStoreException       if an element in the &lt;code&gt;src&lt;/code&gt; array</span></span><br><span class="line"><span class="comment">     *                                   could not be stored into the </span></span><br><span class="line"><span class="comment">                                         &lt;code&gt;dest&lt;/code&gt; array</span></span><br><span class="line"><span class="comment">     *                                   because of a type mismatch.</span></span><br><span class="line"><span class="comment">     *                                   如果由于类型不匹配而无法将src数组中的元素存储到dest数组中。</span></span><br><span class="line"><span class="comment">     *                                   则会报 ArrayStoreException数组存储异常</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException      if either &lt;code&gt;src&lt;/code&gt; or</span></span><br><span class="line"><span class="comment">     *                                   &lt;code&gt;dest&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.</span></span><br><span class="line"><span class="comment">     *                                   如果src或dest为null。</span></span><br><span class="line"><span class="comment">     *                                   则会报NullPointerException空指针异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">arraycopy</span><span class="params">(Object src, <span class="type">int</span> srcPos, Object dest, <span class="type">int</span> destPos, <span class="type">int</span> length)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="System-arraycopy-的几种常用方法-普通for循环和arraycopy方法对比"><a href="#System-arraycopy-的几种常用方法-普通for循环和arraycopy方法对比" class="headerlink" title="System.arraycopy()的几种常用方法(普通for循环和arraycopy方法对比)"></a>System.arraycopy()的几种常用方法(普通for循环和arraycopy方法对比)</h3><h5 id="1-从旧数组拷贝到新数组"><a href="#1-从旧数组拷贝到新数组" class="headerlink" title="1. 从旧数组拷贝到新数组"></a>1. 从旧数组拷贝到新数组</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//从旧数组拷贝到新数组</span><br><span class="line">for (int i=0;i&lt;size;i++)&#123;</span><br><span class="line">	arrayNew[i]=array[i];</span><br><span class="line">&#125;</span><br><span class="line">System.arraycopy(array, 0, arrayNew, 0, array.length);</span><br></pre></td></tr></table></figure>
<h5 id="2-从左向右循环，逐个元素向左挪一位。"><a href="#2-从左向右循环，逐个元素向左挪一位。" class="headerlink" title="2. 从左向右循环，逐个元素向左挪一位。"></a>2. 从左向右循环，逐个元素向左挪一位。</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//从左向右循环，逐个元素向左挪一位。</span><br><span class="line">for (int i = index; i &lt; size - 1; i++) &#123;</span><br><span class="line">	array[i] = array[i + 1];</span><br><span class="line">&#125;</span><br><span class="line">System.arraycopy(array, index + 1, array, index, size - 1 - index);</span><br></pre></td></tr></table></figure>
<h5 id="3-从右向左循环，逐个元素向右挪一位。"><a href="#3-从右向左循环，逐个元素向右挪一位。" class="headerlink" title="3. 从右向左循环，逐个元素向右挪一位。"></a>3. 从右向左循环，逐个元素向右挪一位。</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//从右向左循环，逐个元素向右挪一位。</span><br><span class="line">for (int i = size - 1; i &gt;= index; i--) &#123;</span><br><span class="line">	array[i + 1] = array[i];</span><br><span class="line">&#125;</span><br><span class="line">System.arraycopy(array, index, array, index + 1, size - index);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="System-arraycopy-深层理解"><a href="#System-arraycopy-深层理解" class="headerlink" title="System.arraycopy()深层理解"></a>System.arraycopy()深层理解</h3><h4 id="深复制还是浅复制"><a href="#深复制还是浅复制" class="headerlink" title="深复制还是浅复制"></a>深复制还是浅复制</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">先说结论 ：</span><br><span class="line">当数组为一维数组，且元素为基本类型或String类型时，属于深拷贝，即原数组与新数组的元素不会相互影响。</span><br><span class="line"> 当数组为多维数组，或一维数组中的元素为引用类型时，属于浅拷贝，原数组与新数组的元素引用指向同一个对象。</span><br></pre></td></tr></table></figure>
<h5 id="引用对象"><a href="#引用对象" class="headerlink" title="引用对象"></a>引用对象</h5><p>构建一个User类型源数组，复制后至target数组，比较第一个元素的内存地址，判断结果是相同的，证明为<code>浅复制</code>；后修改target数组数组的随机元素，发现原来的值也变了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class SystemArrayCopyTestCase &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        User[] users = new User[] &#123; </span><br><span class="line">                new User(1), </span><br><span class="line">                new User(2),</span><br><span class="line">                new User(3) &#125;;// 初始化对象数组</span><br><span class="line">        </span><br><span class="line">        User[] target = new User[users.length];// 新建一个目标对象数组</span><br><span class="line">        </span><br><span class="line">        System.arraycopy(users, 0, target, 0, users.length);// 实现复制</span><br><span class="line">        </span><br><span class="line">        System.out.println(&quot;源对象与目标对象的物理地址是否一样：&quot; + (users[0] == target[0] ? &quot;浅复制&quot; : &quot;深复制&quot;));  //浅复制</span><br><span class="line">        </span><br><span class="line">        target[0].setId(5);</span><br><span class="line">        </span><br><span class="line">        System.out.println(&quot;修改目标对象的属性值后源对象users：&quot;);</span><br><span class="line">        for (User user : users) &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class User &#123;</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>System.arraycopy() 在拷贝数组的时候，采用的使用潜复制，复制结果是一维的引用变量传递给新数组的<a href="https://so.csdn.net/so/search?q=%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84&amp;spm=1001.2101.3001.7020">一维数组</a>，修改新数组时，会影响原来的数组。</p>
<h5 id="一维数组和多维数组"><a href="#一维数组和多维数组" class="headerlink" title="一维数组和多维数组"></a>一维数组和多维数组</h5><p>将一维数组作源数组，进行拷贝，产生target数组；然后修改target数组中的元素，新数组没变，证明是值拷贝，修改新数组不会影响原来的值。</p>
<p>将多维数组作源数组，进行拷贝至目标数组，修改至目标数组的元素，新数组也变了，说明是二者是相同的引用，而这时改变其中任何一个数组的元素的值，其实都修改了共同数组元素的值，所以原数组和新数组的元素值都一样了</p>
<h4 id="线程是否安全（摘自网络）"><a href="#线程是否安全（摘自网络）" class="headerlink" title="线程是否安全（摘自网络）"></a>线程是否安全（摘自网络）</h4><p>System.ayyaycopy是不安全的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ArrayCopyThreadSafe &#123;</span><br><span class="line">    private static int[] arrayOriginal = new int[1024 * 1024 * 10];</span><br><span class="line">    private static int[] arraySrc = new int[1024 * 1024 * 10];</span><br><span class="line">    private static int[] arrayDist = new int[1024 * 1024 * 10];</span><br><span class="line">    private static ReentrantLock lock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">    private static void modify() &#123;</span><br><span class="line">        for (int i = 0; i &lt; arraySrc.length; i++) &#123;</span><br><span class="line">            arraySrc[i] = i + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void copy() &#123;</span><br><span class="line">        System.arraycopy(arraySrc, 0, arrayDist, 0, arraySrc.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void init() &#123;</span><br><span class="line">        for (int i = 0; i &lt; arraySrc.length; i++) &#123;</span><br><span class="line">            arrayOriginal[i] = i;</span><br><span class="line">            arraySrc[i] = i;</span><br><span class="line">            arrayDist[i] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void doThreadSafeCheck() throws Exception &#123;</span><br><span class="line">        for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">            System.out.println(&quot;run count: &quot; + (i + 1));</span><br><span class="line">            init();</span><br><span class="line">            Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">            new Thread(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    lock.lock();</span><br><span class="line">                    condition.signalAll();</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                    copy();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            lock.lock();</span><br><span class="line">            // 这里使用 Condition 来保证拷贝线程先已经运行了.</span><br><span class="line">            condition.await();</span><br><span class="line">            lock.unlock();</span><br><span class="line"></span><br><span class="line">            Thread.sleep(2); // 休眠2毫秒, 确保拷贝操作已经执行了, 才执行修改操作.</span><br><span class="line">            modify();</span><br><span class="line"></span><br><span class="line">            if (!Arrays.equals(arrayOriginal, arrayDist)) &#123;</span><br><span class="line">                throw new RuntimeException(&quot;System.arraycopy is not thread safe&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        doThreadSafeCheck();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个例子的具体操作是:</p>
<p>arrayOriginal 和 arraySrc 初始化时是相同的, 而 arrayDist 是全为零的.</p>
<p>启动一个线程运行 copy() 方法来拷贝 arraySrc 到 arrayDist 中.</p>
<p>在主线程执行 modify() 操作, 修改 arraySrc 的内容. 为了确保 copy() 操作先于 modify() 操作, 我使用 Condition, 并且延时了两毫秒, 以此来保证执行拷贝操作(即System.arraycopy) 先于修改操作.</p>
<p>根据第三点, 如果 System.arraycopy 是线程安全的, 那么先执行拷贝操作, 再执行修改操作时, 不会影响复制结果, 因此 arrayOriginal 必然等于 arrayDist; 而如果 System.arraycopy 是线程不安全的, 那么 arrayOriginal 不等于 arrayDist.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">run count: 1</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.RuntimeException: System.arraycopy is not thread safe</span><br><span class="line">	at ArrayCopyThreadSafe.doThreadSafeCheck(ArrayCopyThreadSafe.java:54)</span><br><span class="line">	at ArrayCopyThreadSafe.main(ArrayCopyThreadSafe.java:60)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>结论 ：System.ayyaycopy是不安全的。</p>
</blockquote>
<h4 id="System-arraycopy-和for-相比谁更高效"><a href="#System-arraycopy-和for-相比谁更高效" class="headerlink" title="System.arraycopy()和for()相比谁更高效"></a>System.arraycopy()和for()相比谁更高效</h4><p>当测试数组的范围比较小的时候，两者相差的时间无几，当测试数组的长度达到百万级别，System.arraycopy的速度优势就开始体现了，根据对底层的理解，System.arraycopy是对内存直接进行复制，减少了for循环过程中的寻址时间，从而提高了效能。</p>
<h3 id="如果有帮助到你的话，请关注我的公众号叭"><a href="#如果有帮助到你的话，请关注我的公众号叭" class="headerlink" title="如果有帮助到你的话，请关注我的公众号叭"></a>如果有帮助到你的话，请关注我的公众号叭</h3><p><img src="https://i.p04e.com/baid/i/2023/04/25/5gyx.jpg"></p>
<h4 id="个人博客-白都-baidu2001-top"><a href="#个人博客-白都-baidu2001-top" class="headerlink" title="个人博客 白都 (baidu2001.top)"></a>个人博客 <a href="https://www.baidu2001.top/">白都 (baidu2001.top)</a></h4><h4 id="CSDN-白-都"><a href="#CSDN-白-都" class="headerlink" title="CSDN 白.都"></a>CSDN 白.都</h4>]]></content>
      <tags>
        <tag>数组</tag>
        <tag>Arrays.copyOf</tag>
        <tag>System.arraycopy</tag>
      </tags>
  </entry>
  <entry>
    <title>Java方法传参机制</title>
    <url>/2023/05/01/Java%E6%96%B9%E6%B3%95%E4%BC%A0%E5%8F%82%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>大家对java方法的传参机制了解有多少，现在我给大家用代码和画图来讲解一下吧，请耐心看下去，会有不少的收获</p>
<blockquote>
<h3 id="基本数据类型的传参机制"><a href="#基本数据类型的传参机制" class="headerlink" title="基本数据类型的传参机制"></a>基本数据类型的传参机制</h3></blockquote>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Method &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        int a = 10;</span><br><span class="line">        int b = 20;</span><br><span class="line"></span><br><span class="line">        A obj = new A();</span><br><span class="line">        obj.swap(a, b);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;\nmain方法\na=&quot; + a + &quot;\nb=&quot; + b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    class A &#123;</span><br><span class="line">        public void swap(int a, int b)&#123;</span><br><span class="line">            System.out.println(&quot;\na和b交换前的值\na=&quot; + a + &quot;\nb=&quot; + b);</span><br><span class="line"></span><br><span class="line">            int tmp = a;</span><br><span class="line">            a = b;</span><br><span class="line">            b = tmp;</span><br><span class="line">            System.out.println(&quot;\na和b交换后的值\na=&quot; + a + &quot;\nb=&quot; + b);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><u>运行结果</u></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a和b交换前的值</span><br><span class="line">a=10</span><br><span class="line">b=20</span><br><span class="line"></span><br><span class="line">a和b交换后的值</span><br><span class="line">a=20</span><br><span class="line">b=10</span><br><span class="line"></span><br><span class="line">main方法</span><br><span class="line">a=10</span><br><span class="line">b=20</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>同学们想一想为什么a与b在进行交换以后在main方法中依旧是原来的顺序。</p>
<p>这里给大家画个图</p>
<p><img src="https://i.p04e.com/baid/i/2023/05/01/7csqu.png"></p>
<p>在调用swap时就会开启swap栈，在swap使用结束后swap栈也会被销毁，而此时main方法中的a 和 b还是原先的ab，也就是说swap方法并没有影响到主方法的值。这也是很重要的一个知识点。</p>
<p><strong><em>基本数据类型，传递的时值拷贝，形参的任何改变不影响实参！！！</em></strong></p>
<blockquote>
<h3 id="引用数据类型的传参机制"><a href="#引用数据类型的传参机制" class="headerlink" title="引用数据类型的传参机制"></a>引用数据类型的传参机制</h3></blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Method2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">   B b = new B();</span><br><span class="line">   int[] arr = &#123;1, 2, 3&#125;;</span><br><span class="line">   b.test(arr);</span><br><span class="line">   System.out.println(&quot;main的 arr数组&quot;);</span><br><span class="line">   for(int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">       System.out.print(arr[i] + &quot;\t&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    class B &#123;</span><br><span class="line">        public void test(int[] arr)&#123;</span><br><span class="line">            arr[0] = 200;</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;test的arr数组&quot;);</span><br><span class="line"></span><br><span class="line">            for(int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">                System.out.print(arr[i] + &quot;\t&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><u>运行结果</u></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">test的arr数组</span><br><span class="line">200	2	3	</span><br><span class="line">main的 arr数组</span><br><span class="line">200	2	3	</span><br></pre></td></tr></table></figure>
<p>此时为什么在B方法中修改了数组，而main方法中也被修改呢</p>
<p><img src="https://i.p04e.com/baid/i/2023/05/01/5lkf.png"></p>
<p>因为此时使用的是数组引用类型传递，main方法和test方法中的arr都指向了同一个地址，也就是同一个值，所以test的修改也会影响导main方法中的arr数组值。</p>
<p><strong><em>引用类型传递的是地址（传递也是值，值是地址），可以通过形参影响到实参！</em></strong></p>
<blockquote>
<h3 id="继续思考"><a href="#继续思考" class="headerlink" title="继续思考"></a>继续思考</h3></blockquote>
<p>想来大家现在已经理解了基础数据类型和引用类型的区别，那么再出一道题大家是否能答出来，或者知道为什么吗？代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Method3 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        C c = new C();</span><br><span class="line"></span><br><span class="line">        Person p = new Person();</span><br><span class="line">        p.age = 10;</span><br><span class="line">        p.name = &quot;白都&quot;;</span><br><span class="line"></span><br><span class="line">        c.test(p);</span><br><span class="line">        System.out.println(&quot;main 的 p.age= &quot; + p.age);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    class Person &#123;</span><br><span class="line">        String name;</span><br><span class="line">        int age;</span><br><span class="line">    &#125;</span><br><span class="line">    class C &#123;</span><br><span class="line">        public void test(Person p) &#123;</span><br><span class="line">            p = null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>大家想想此时main输出的age应为多少？</p>
<p><u>运行结果</u></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main 的 p.age= 10</span><br></pre></td></tr></table></figure>
<p>大家有的人写错了这道题，很好奇为什么不是为null， C中不是执行了 p = null 吗，这里我给大家简单的画一下这张图。</p>
<p><img src="https://i.p04e.com/baid/i/2023/05/01/14oua.png"></p>
<p>和大家想象的不一样，p = null 不是将对象的值改为null，而是将连向对象的线给断掉，所以此时不会改变main方法中的值。</p>
<p>在出一道类似的题，加强以下大家的对引用的认知，代码如下。</p>
<p>大家先思考在看答案。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Method3 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        C c = new C();</span><br><span class="line"></span><br><span class="line">        Person p = new Person();</span><br><span class="line">        p.age = 10;</span><br><span class="line">        p.name = &quot;白都&quot;;</span><br><span class="line"></span><br><span class="line">        c.test(p);</span><br><span class="line">        System.out.println(&quot;main 的 p.age= &quot; + p.age);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    class Person &#123;</span><br><span class="line">        String name;</span><br><span class="line">        int age;</span><br><span class="line">    &#125;</span><br><span class="line">    class C &#123;</span><br><span class="line">        public void test(Person p) &#123;</span><br><span class="line">            p = new Person();</span><br><span class="line">            p.name = &quot;tom&quot;;</span><br><span class="line">            p.age = 99;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><u>运行结果</u></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main 的 p.age= 10</span><br></pre></td></tr></table></figure>
<p>为何值还是没有改变，并没有指向null，而是改变了值啊。其实此时是因为 在C中创建了一个新的p对象，C修改的p的值也指向了堆中新的对象，而原来main的对象没有受到改变，所以输出的值自然不会改变。</p>
<p>到现在想来大家对基础和引用类型区别已经分清，如果还有问题，可以关注并私信我的公众号，我会一一解答。</p>
<h3 id="如果有帮助到你的话，请关注我的公众号叭"><a href="#如果有帮助到你的话，请关注我的公众号叭" class="headerlink" title="如果有帮助到你的话，请关注我的公众号叭"></a>如果有帮助到你的话，请关注我的公众号叭</h3><p><img src="https://i.p04e.com/baid/i/2023/04/25/5gyx.jpg"></p>
<h4 id="个人博客-白都-baidu2001-top"><a href="#个人博客-白都-baidu2001-top" class="headerlink" title="个人博客 白都 (baidu2001.top)"></a>个人博客 <a href="https://www.baidu2001.top/">白都 (baidu2001.top)</a></h4><h4 id="CSDN-白-都"><a href="#CSDN-白-都" class="headerlink" title="CSDN 白.都"></a>CSDN 白.都</h4>]]></content>
      <tags>
        <tag>数据类型传参机制</tag>
      </tags>
  </entry>
</search>
