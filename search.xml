<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Linux命令学习和软件安装等</title>
    <url>/2022/09/22/Linux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E7%AD%89/</url>
    <content><![CDATA[<p>自主学习了一天很懒的打字了，大部分就用图片替代吧</p>
<h3 id="VMware安装"><a href="#VMware安装" class="headerlink" title="VMware安装"></a>VMware安装</h3><span id="more"></span>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/3bv.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/vq9g.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/4j8q.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/vq8s.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/3bv_1.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/nd1.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/ncf.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/4je9.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/nc7.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/4je7.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/nc2.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/vtp7.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/nd8.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/4jqh.png"></p>
<h3 id="Linux学习"><a href="#Linux学习" class="headerlink" title="Linux学习"></a>Linux学习</h3><h4 id="Linux目录介绍"><a href="#Linux目录介绍" class="headerlink" title="Linux目录介绍"></a>Linux目录介绍</h4><ul>
<li><code>bin 存放二进制可执行文件</code></li>
<li><code>boot存放系统引导时使用的各种文件</code></li>
<li>`dev存放设备文件</li>
<li><code>etc存放系统配置文件</code></li>
<li>`home存放系统用户的文件</li>
<li><code>lib存放程序运行所需的共享库和内核模块</code></li>
<li><code>opt额外安装的可选应用程序包所放置的位置</code></li>
<li>`root超级用户目录</li>
<li><code>sbin存放二进制可执行文件，只有root用户才能访问tmp存放临时文件</code></li>
<li><code>usr存放系统应用程序</code></li>
<li><code>var存放运行时需要改变数据的文件，例如日志文件</code></li>
</ul>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/4jro.png"></p>
<h4 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h4><p><img src="https://i.p04e.com/baid/i/2022/09/22/4jnd.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/54n6.png"></p>
<mg src="https://i.p04e.com/baid/i/2022/09/22/1cv9d5.png">

<p><img src="https://i.p04e.com/baid/i/2022/09/22/9i2le1.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/1cv9a2.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/1cv9ph.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/6zbte.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/54nf.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/9i2yg5.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/zwjj.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/zwjr.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/6zc0e.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/1cvct3.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/6zbyc.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/zwlb.png"><br><img src="https://i.p04e.com/baid/i/2022/09/22/6zc0z.png"><br><img src="https://i.p04e.com/baid/i/2022/09/22/1cvcwh.png"><br><img src="https://i.p04e.com/baid/i/2022/09/22/zwhl.png"><br><img src="https://i.p04e.com/baid/i/2022/09/22/54nj.png"></p>
<h3 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h3><p><img src="https://i.p04e.com/baid/i/2022/09/22/zwf7.png"><br><img src="https://i.p04e.com/baid/i/2022/09/22/54mm.png"></p>
<h3 id="安装Tomcat"><a href="#安装Tomcat" class="headerlink" title="安装Tomcat"></a>安装Tomcat</h3><p><img src="https://i.p04e.com/baid/i/2022/09/22/4ju0.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">防火墙操作:</span><br><span class="line">查看防火墙状态(systemctl status firewalld、 firewall-cmd --state)</span><br><span class="line"></span><br><span class="line">暂时关闭防火墙(systemctl stop firewalld)</span><br><span class="line"></span><br><span class="line">永久关闭防火墙(systemctl disable firewalld)</span><br><span class="line"></span><br><span class="line">开启防火墙(systemctl start firewalld)</span><br><span class="line"></span><br><span class="line">开放指定端口(firewall-cmd --zone=public --add-port=8080/tcp --permanent)</span><br><span class="line"></span><br><span class="line">关闭指定端口(firewall-cmd --zone=public --remove-port=8080/tcp --permanent)</span><br><span class="line"></span><br><span class="line">立即生效(firewall-cmd --reload)</span><br><span class="line"></span><br><span class="line">查看开放的端口(firewall-cmd --zone=public --list-ports)</span><br><span class="line"></span><br><span class="line">注意:</span><br><span class="line">1、 systemctl是管理Linux中服务的命令，可以对服务进行启动、停止、重启、查看状态等操作</span><br><span class="line"></span><br><span class="line">2、firewall-cmd是Linux中专门用于控制防火墙的命令</span><br><span class="line"></span><br><span class="line">3、为了保证系统安全，服务器的防火墙不建议关闭</span><br></pre></td></tr></table></figure>
<h3 id="安装Mysql"><a href="#安装Mysql" class="headerlink" title="安装Mysql"></a>安装Mysql</h3><p><img src="https://i.p04e.com/baid/i/2022/09/22/nez.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/nfg.png"><br><img src="https://i.p04e.com/baid/i/2022/09/22/vv1m.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/6zmgo.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/zy5i.png"></p>
<h3 id="安装lrzsz"><a href="#安装lrzsz" class="headerlink" title="安装lrzsz"></a>安装lrzsz</h3><p><img src="https://i.p04e.com/baid/i/2022/09/22/vxab.png"></p>
<h3 id="手动部署项目"><a href="#手动部署项目" class="headerlink" title="手动部署项目"></a>手动部署项目</h3><p><img src="https://i.p04e.com/baid/i/2022/09/22/ngn.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/4k8s.png"><br><img src="https://i.p04e.com/baid/i/2022/09/22/4kcp.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/4k7c.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/1d3qa3.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/w00d.png"></p>
<h3 id="通过shell脚本自动部署项目"><a href="#通过shell脚本自动部署项目" class="headerlink" title="通过shell脚本自动部署项目"></a>通过shell脚本自动部署项目</h3><p><img src="https://i.p04e.com/baid/i/2022/09/22/vyu0.png"><br><img src="https://i.p04e.com/baid/i/2022/09/22/nhj.png"><br><img src="https://i.p04e.com/baid/i/2022/09/22/nho.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/10453.png"><br><img src="https://i.p04e.com/baid/i/2022/09/22/70t09.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">echo =================================</span><br><span class="line">echo  自动化部署脚本启动</span><br><span class="line">echo =================================</span><br><span class="line"></span><br><span class="line">echo 停止原来运行中的工程</span><br><span class="line">APP_NAME=helloworld</span><br><span class="line"></span><br><span class="line">tpid=`ps -ef|grep $APP_NAME|grep -v grep|grep -v kill|awk &#x27;&#123;print $2&#125;&#x27;`</span><br><span class="line">if [ $&#123;tpid&#125; ]; then</span><br><span class="line">    echo &#x27;Stop Process...&#x27;</span><br><span class="line">    kill -15 $tpid</span><br><span class="line">fi</span><br><span class="line">sleep 2</span><br><span class="line">tpid=`ps -ef|grep $APP_NAME|grep -v grep|grep -v kill|awk &#x27;&#123;print $2&#125;&#x27;`</span><br><span class="line">if [ $&#123;tpid&#125; ]; then</span><br><span class="line">    echo &#x27;Kill Process!&#x27;</span><br><span class="line">    kill -9 $tpid</span><br><span class="line">else</span><br><span class="line">    echo &#x27;Stop Success!&#x27;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">echo 准备从Git仓库拉取最新代码</span><br><span class="line">cd /usr/local/helloworld</span><br><span class="line"></span><br><span class="line">echo 开始从Git仓库拉取最新代码</span><br><span class="line">git pull</span><br><span class="line">echo 代码拉取完成</span><br><span class="line"></span><br><span class="line">echo 开始打包</span><br><span class="line">output=`mvn clean package -Dmaven.test.skip=true`</span><br><span class="line"></span><br><span class="line">cd target</span><br><span class="line"></span><br><span class="line">echo 启动项目</span><br><span class="line">nohup java -jar helloworld-1.0-SNAPSHOT.jar &amp;&gt; helloworld.log &amp;</span><br><span class="line">echo 项目启动完成</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/vyxp.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/njj.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/njj_1.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/22/nj1.png"></p>
</mg>]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>防火墙命令</tag>
        <tag>Tomcat</tag>
        <tag>Mysql</tag>
        <tag>lrzsz</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux查看ip地址出错，ens33不显示inet解决</title>
    <url>/2022/09/20/Linux%E6%9F%A5%E7%9C%8Bip%E5%9C%B0%E5%9D%80%E5%87%BA%E9%94%99%EF%BC%8Cens33%E4%B8%8D%E6%98%BE%E7%A4%BAinet%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<p>问题：在 CentOS7中输入 ip addr 时，没有显示出局域网 IP</p>
<span id="more"></span>
<p>一下午尝试了网上各种的修改方法，还是不可以，这里就不一一赘述了。</p>
<h5 id="有两种解决办法"><a href="#有两种解决办法" class="headerlink" title="有两种解决办法"></a>有两种解决办法</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.暂时解决，重新启动虚拟机后ip地址还是会消失</span><br><span class="line"></span><br><span class="line">dhclient ens33  //ens33有时也是32，这里看自己具体的内容</span><br><span class="line"></span><br><span class="line">cd /etc/sysconfig/network-scripts/   </span><br><span class="line">ls</span><br><span class="line">进这个目录下可查看</span><br></pre></td></tr></table></figure>
<p>之后重启后发现ip地址继续隐藏</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi/etc/sysconfig/network-scripts/ifcfg-ens33</span><br><span class="line"></span><br><span class="line">改BOOTPROTO=static</span><br><span class="line">  ONBOOT=yes</span><br><span class="line">  </span><br><span class="line">  之后添加自己的网关掩码等等</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://i.p04e.com/baid/i/2022/09/20/7khnp.png"></p>
<h5 id="那怎么找到自己的DNS等等呢"><a href="#那怎么找到自己的DNS等等呢" class="headerlink" title="那怎么找到自己的DNS等等呢"></a>那怎么找到自己的DNS等等呢</h5><p><img src="https://i.p04e.com/baid/i/2022/09/20/5lp3.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/20/137wp.png"></p>
<p>以上为ip 掩码 网关</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查看文件</span><br><span class="line">/var/lib/dhclient/dhclient.leases</span><br></pre></td></tr></table></figure>
<p><img src="https://i.p04e.com/baid/i/2022/09/20/sqk.png"></p>
<p>即为DNS</p>
<p>此时填回ifcfg-ens33，再次 ip addr</p>
<p><img src="https://i.p04e.com/baid/i/2022/09/20/7nc56.png"></p>
<p>出现inet!</p>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>inet</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL主从同步故障：Slave_SQL_Running:NO</title>
    <url>/2022/10/03/MySQL%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E6%95%85%E9%9A%9C%EF%BC%9ASlave-SQL-Running-NO/</url>
    <content><![CDATA[<p><img src="https://i.p04e.com/baid/i/2022/10/03/3jdmr.png"></p>
<p>Slave_SQL_Running: No</p>
<span id="more"></span>
<p>1.程序可能在slave上进行了写操作</p>
<p>2.也可能是slave机器重起后，事务回滚造成的.</p>
<p>一般是事务回滚造成的：</p>
<p>解决办法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; stop slave ;</span><br><span class="line">mysql&gt; set GLOBAL SQL_SLAVE_SKIP_COUNTER=1;</span><br><span class="line">mysql&gt; start slave ;</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">change master to master_host=&#x27;------&#x27;,master_user=&#x27;xiaoming&#x27;,master_password=&#x27;Root@123456&#x27;,master_log_file=&#x27;mysql-bin.----&#x27;,master_log_pos=---;</span><br></pre></td></tr></table></figure>
<p>——都是自己的</p>
<p><img src="https://i.p04e.com/baid/i/2022/10/03/ifdz.png"></p>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>Mysql</tag>
        <tag>主从复制</tag>
        <tag>错误</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo+github做出一个属于自己的博客!</title>
    <url>/2022/08/26/hexo-github%E5%81%9A%E5%87%BA%E4%B8%80%E4%B8%AA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    博客是按照我自己的方式通过hexo+github搭建出来的，最后的域名是从华为云购买。我会一步步的从初学者的角度向大家讲解，也会解决一些我碰到的问题 ，如果有些问题是在解决不了可以通过我的邮箱联系。</p>
<p><code>这一篇为整体的搭建，问题的解决会在最后</code></p>
<span id="more"></span>
<h3 id="准备工具"><a href="#准备工具" class="headerlink" title="准备工具"></a>准备工具</h3><ul>
<li><p>下载<a href="http://nodejs.cn/download/">node.js</a>，node.js是使用和安装hexo。</p>
</li>
<li><p>下载<a href="https://npm.taobao.org/mirrors/git-for-windows/v2.22.0.windows.1/Git-2.22.0-64-bit.exe">Git</a>,此脚本所有测试都在都在git bash上运行。</p>
</li>
<li><p>并且需要一个github账号</p>
<p>下载的步骤和环境的搭建自行百度就可以，非常简单。</p>
</li>
</ul>
<h4 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h4><ol>
<li>装完之后打开终端 win+r，然后cmd。</li>
</ol>
<p>2.输入指令回车查看版本号(新版的Node.js已自带npm，安装Node.js时会一起安装)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br><span class="line">git --version</span><br></pre></td></tr></table></figure>
<p><img src="/images/01.png"></p>
<p>出现版本号，说明你的电脑上已经有nodejs，npm安装成功</p>
<h4 id="准备hexo"><a href="#准备hexo" class="headerlink" title="准备hexo"></a>准备hexo</h4><p>在命令框里输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line"></span><br><span class="line">////////////////</span><br><span class="line"></span><br><span class="line">hexo -v</span><br></pre></td></tr></table></figure>
<p><img src="/images/02.png"></p>
<p>出现版本号即为安装成功！</p>
<h3 id="登录github"><a href="#登录github" class="headerlink" title="登录github"></a>登录github</h3><p><code>我们要做的就是利用Github的仓库作为我们hexo的一个服务器，将hexo的内容都装进这个仓库里面,让所有的人都可以访问。</code></p>
<h4 id="建仓"><a href="#建仓" class="headerlink" title="建仓"></a>建仓</h4><p>打开github，点击new新建仓库</p>
<p><img src="/images/03.png"></p>
<p><img src="/images/04.png"></p>
<p><code>注意：仓库的名字是有规定的，为自己的名字+.github.io,从上图也可看出。</code></p>
<p><img src="/images/05.png"></p>
<p> <code>跟着我的点，最后创建</code></p>
<p><img src="/images/06.png"></p>
<p>此时就已经建成功了。</p>
<h3 id="将github与本地进行绑定"><a href="#将github与本地进行绑定" class="headerlink" title="将github与本地进行绑定"></a>将github与本地进行绑定</h3><h4 id="设置密钥"><a href="#设置密钥" class="headerlink" title="设置密钥"></a>设置密钥</h4><p>​    随意进入一个文件中，在空白区域右键，点出Git bash here,输入如下指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;邮件地址&quot;  //注意在git里面想要粘贴时，右键Paste,此时输入的邮件地址为绑定的github账号的邮件地址</span><br></pre></td></tr></table></figure>
<p><img src="/images/07.png"></p>
<p><code>此时输入命令后四次回车如图即可，如果出现overwrite时输入 y</code></p>
<p><img src="/images/08.png"></p>
<p>在电脑的这个位置找见.ssh里面以.pub为结尾的文件，以笔记本打开。打开后ctrl  + a  /c</p>
<p>打开github</p>
<p><img src="/images/09.png"></p>
<p>打开Setting</p>
<p><img src="/images/10.png"></p>
<p>打开SSH and GPG keys ，在点绿色的New SSH key</p>
<p><img src="/images/11.png"></p>
<p>可以随便起一个名字，然后将复制的钥匙粘贴进下面的大框。</p>
<p>最后在原来的git命令行输入一下代码，确定是否绑定成功。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>
<p> <img src="/images/12.png"></p>
<p>过程中有一次问答输入 yes ，最后出现 successfully即可。</p>
<h2 id="建立blog并且发布到Github"><a href="#建立blog并且发布到Github" class="headerlink" title="建立blog并且发布到Github"></a>建立blog并且发布到Github</h2><p>git在国外不稳定所以命令有时候还会有网络问题，多试两次或者选择换国内镜像源也可以。</p>
<p>创建一个自己的blog的空文件夹，进入后右键出git bush here；</p>
<p>输入一下命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo init       //初始化hexo  如果成功会发现自己的blog下面会多出很多的内容</span><br><span class="line"></span><br><span class="line">hexo s         //静态生成hexo本地的博客页面</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/images/13.png"></p>
<p>ctrl加点击<a href="http://localhost:4000">http://localhost:4000</a> 即可进入本地的hexo服务器</p>
<p>ctrl + c 即可停止服务器</p>
<p>进入你的blog文件找见下面的 _config.yml文件。打开后进入代码的最下面，将代码改为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: &#x27;git&#x27;</span><br><span class="line">  repository: </span><br><span class="line">  branch: main</span><br><span class="line">//注意冒号后面还有空格</span><br></pre></td></tr></table></figure>
<p><img src="/images/14.png"></p>
<p><img src="/images/15.png"></p>
<p>进入githun中的这个code，点击复制，然后粘贴在上面的 repository后 。</p>
<p>在你的博客文件夹下面点开git命令，输入以下命令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save  </span><br><span class="line"></span><br><span class="line">hexo g   //生成页面</span><br><span class="line"></span><br><span class="line">hexo d    //上传文件至仓库，需要输入账号密码，在此处可能会出现网络不稳定问题，多试几次</span><br></pre></td></tr></table></figure>
<p><img src="/images/16.png"></p>
<p>这个为github的用户名，输入之后会在让输密码。。。。。。。注意此时不能在输密码，进入上面提到过的github里的setting ,找到左侧的Developer settings,点击开发者设置。</p>
<p><img src="/images/17.png"></p>
<p>点击 Generate new token 创建一个新的令牌。</p>
<p><img src="/images/18.png"></p>
<p>随意取一个名字，并将所有选项选上，点击生成令牌。<img src="/images/19.png"></p>
<p>复制此处的序列号令牌到弹出的提示输入密码框内。</p>
<p><img src="/images/20.png"></p>
<p>即为上传成功！<img src="/images/20.png"></p>
<p>此时仓库的内容就发生了变化。此时通过 <a href="https://你的git名字.github.io/">https://你的git名字.github.io/</a>      即可从网址访问。</p>
<p><img src="/images/21.png"></p>
<p>此时博客的搭建已经差不多了，剩下的时博客的页面主题的更换和域名的绑定</p>
]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo主题的更换与优化和域名的配置</title>
    <url>/2022/08/28/hexo%E4%B8%BB%E9%A2%98%E7%9A%84%E6%9B%B4%E6%8D%A2%E4%B8%8E%E4%BC%98%E5%8C%96%E5%92%8C%E5%9F%9F%E5%90%8D%E7%9A%84%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="一、选择主题"><a href="#一、选择主题" class="headerlink" title="一、选择主题"></a>一、选择主题</h2><p>目前 Hexo 里面应用最多的主题基本就是 Next 主题了，我用的就是Next，另外它支持的插件和功能也极为丰富。</p>
<span id="more"></span>
<h2 id="二、下载主题"><a href="#二、下载主题" class="headerlink" title="二、下载主题"></a>二、下载主题</h2><p>我们可以直接到 Next 主题的 <a href="https://so.csdn.net/so/search?q=GitHub&amp;spm=1001.2101.3001.7020">GitHub</a> Repository 上把这个主题下载下来。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://github.com/theme-next/hexo-theme-next</span><br></pre></td></tr></table></figure>
<p>命令行进入到blog项目的根目录，执行如下命令即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>
<p>执行完毕之后 Next 主题的源码就会出现在项目的 themes/next 文件夹下。<br>然后需要修改下博客所用的主题名称，修改项目根目录下的 _config.yml 文件，找到 theme 字段，修改为 next 即可，修改如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure>
<p>然后本地重新开启服务，访问刷新下页面，就可以看到 next 主题就切换成功了</p>
<p>Next 主题内部也提供了一个配置文件，Next 主题里面所有的功能都可以通过这个配置文件来控制，下文所述的内容都是修改的 themes/next/_config.yml 文件。</p>
<h3 id="3-1-样式"><a href="#3-1-样式" class="headerlink" title="3.1 样式"></a>3.1 样式</h3><p>Next 主题还提供了多种样式，风格都是类似黑白的搭配，但整个布局位置不太一样，通过修改配置文件的 scheme 字段即可，我选了 Pisces 样式，修改 _config.yml （注意是 themes/next/_config.yml 文件）如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scheme: Pisces</span><br></pre></td></tr></table></figure>
<h3 id="3-2-favicon"><a href="#3-2-favicon" class="headerlink" title="3.2 favicon"></a>3.2 favicon</h3><p><code>https://realfavicongenerator.net/</code></p>
<p>avicon 就是站点标签栏的小图标，默认是用的 Hexo 的小图标，如果我们有站点 Logo 的图片的话，我们可以自己定制小图标。到这里上传一张图，便可以直接打包下载各种尺寸和适配不同设备的小图标。</p>
<p>图标下载下来之后把它放在 themes/next/source/images 目录下面。<br>然后在配置文件里面找到 favicon 配置项，把一些相关路径配置进去即可，示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">favicon:</span><br><span class="line">  small: /images/favicon-16x16.png</span><br><span class="line">  medium: /images/favicon-32x32.png</span><br><span class="line">  apple_touch_icon: /images/apple-touch-icon.png</span><br><span class="line">  safari_pinned_tab: /images/safari-pinned-tab.svg</span><br></pre></td></tr></table></figure>
<p>也可以将图标上传至网上通过链接获得</p>
<h4 id="3-2-1-将图片上传至网络"><a href="#3-2-1-将图片上传至网络" class="headerlink" title="3.2.1  将图片上传至网络"></a>3.2.1  将图片上传至网络</h4><p><code>[薄荷图床 首页 -图床外链生成器-亚马逊图片上传-无限流量-全球加速-无限数量-图片转链接-跨境电商图片空间-图片托管 (riyugo.com)](https://riyugo.com/)</code></p>
<p>上传后将路径改为地址即可</p>
<h3 id="3-3-avatar"><a href="#3-3-avatar" class="headerlink" title="3.3 avatar"></a>3.3 avatar</h3><p>将1.png 图片放置到 themes/next/source/images/1.png 路径，然后在主题 _config.yml 文件下编辑 avatar 的配置，修改为正确的路径即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Sidebar Avatar</span><br><span class="line">avatar:</span><br><span class="line">  # In theme directory (source/images): /images/avatar.gif</span><br><span class="line">  # In site directory (source/uploads): /uploads/avatar.gif</span><br><span class="line">  # You can also use other linking images.</span><br><span class="line">  url: /images/avatar.png</span><br><span class="line">  # If true, the avatar would be dispalyed in circle.</span><br><span class="line">  rounded: true</span><br><span class="line">  # If true, the avatar would be rotated with the cursor.</span><br><span class="line">  rotated: true</span><br></pre></td></tr></table></figure>
<h3 id="3-4-top"><a href="#3-4-top" class="headerlink" title="3.4 top"></a>3.4 top</h3><p>在浏览网页的时候，想快速返回到网站的上端，一般都是有一个按钮来辅助的，这里也支持它的配置，修改 _config.yml 的 back2top 字段即可，我的设置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">back2top:	</span><br><span class="line">  enable: true	</span><br><span class="line">  # Back to top in sidebar.	</span><br><span class="line">  sidebar: false	</span><br><span class="line">  # Scroll percent label in b2t button.	</span><br><span class="line">  scrollpercent: true</span><br></pre></td></tr></table></figure>
<h3 id="3-5-reading-process"><a href="#3-5-reading-process" class="headerlink" title="3.5 reading_process"></a>3.5 reading_process</h3><p>reading_process，阅读进度。大家可能注意到有些站点的最上侧会出现一个细细的进度条，代表页面加载进度和阅读进度 ，修改_config.yml 如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reading_progress:	</span><br><span class="line">  enable: true	</span><br><span class="line">  # Available values: top | bottom	</span><br><span class="line">  position: top	</span><br><span class="line">  color: &quot;#222&quot;	</span><br><span class="line">  height: 2px</span><br></pre></td></tr></table></figure>
<h3 id="3-6-pangu"><a href="#3-6-pangu" class="headerlink" title="3.6 pangu"></a>3.6 pangu</h3><p>希望写中文和英文的时候中间必须要留有间距，一个简单直接的方法就是中间加个空格。</p>
<p>pangu 就是来解决这个问题的，我们只需要在主题里面开启这个选项，在编译生成页面的时候，中英文之间就会自动添加空格，看起来更加美观。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pangu: true</span><br></pre></td></tr></table></figure>
<h3 id="3-7-pjax"><a href="#3-7-pjax" class="headerlink" title="3.7 pjax"></a>3.7 pjax</h3><p>pjax 这个技术实际上就是，利用 Ajax 技术实现了局部页面刷新，既可以实现 URL 的更换，有可以做到无刷新加载。</p>
<p>要开启这个功能需要先将 pjax 功能开启，然后安装对应的 pjax 依赖库，首先修改 _config.yml 修改如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pjax: true</span><br></pre></td></tr></table></figure>
<p>然后安装依赖库，切换到 next 主题下，然后安装依赖库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/theme-next/theme-next-pjax source/lib/pjax</span><br></pre></td></tr></table></figure>
<h2 id="四、发布文章"><a href="#四、发布文章" class="headerlink" title="四、发布文章"></a>四、发布文章</h2><h3 id="4-1、增加文章"><a href="#4-1、增加文章" class="headerlink" title="4.1、增加文章"></a>4.1、增加文章</h3><p>需要调用 Hexo 提供的命令即可，比如我们要新建一篇「HelloWorld」的文章，命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new hello-world</span><br></pre></td></tr></table></figure>
<h3 id="4-2、个性化设置"><a href="#4-2、个性化设置" class="headerlink" title="4.2、个性化设置"></a>4.2、个性化设置</h3><h4 id="4-2-1-标签页"><a href="#4-2-1-标签页" class="headerlink" title="4.2.1 标签页"></a>4.2.1 标签页</h4><p>按上路径创建 <strong>index.md</strong> </p>
<p><img src="https://s1.plumeta.com/i/2022/08/29/p5vqdl.jpg" alt></p>
<p>里面输入内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title: tags</span><br><span class="line">type: &quot;tags&quot;</span><br></pre></td></tr></table></figure>
<p>然后再在主题的 _config.yml 文件将这个页面的链接添加到主菜单里面，修改 menu 字段如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">menu:	</span><br><span class="line">  home: / || home	</span><br><span class="line">  #about: /about/ || user	</span><br><span class="line">  tags: /tags/ || tags	</span><br><span class="line">  #categories: /categories/ || th	</span><br><span class="line">  archives: /archives/ || archive	</span><br><span class="line">  #schedule: /schedule/ || calendar	</span><br><span class="line">  #sitemap: /sitemap.xml || sitemap	</span><br><span class="line">  #commonweal: /404/ || heartbeat</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>分类页和标签页是一样的。</p>
<h4 id="4-2-2-搜索页"><a href="#4-2-2-搜索页" class="headerlink" title="4.2.2 搜索页"></a>4.2.2 搜索页</h4><p>我们需要搜索全站的内容，所以一个搜索功能的支持也是很有必要的。</p>
<p>如果要添加搜索的支持，需要先安装一个插件，叫做 hexo-generator-searchdb，命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>
<p>然后在项目的 _config.yml 里面添加搜索设置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">search:	</span><br><span class="line">  path: search.xml	</span><br><span class="line">  field: post	</span><br><span class="line">  format: html	</span><br><span class="line">  limit: 10000</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在主题的 _config.yml 里面修改如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Local search	</span><br><span class="line"># Dependencies: https://github.com/wzpan/hexo-generator-search	</span><br><span class="line">local_search:	</span><br><span class="line">  enable: true	</span><br><span class="line">  # If auto, trigger search by changing input.	</span><br><span class="line">  # If manual, trigger search by pressing enter key or search button.	</span><br><span class="line">  trigger: auto	</span><br><span class="line">  # Show top n results per article, show all results by setting to -1	</span><br><span class="line">  top_n_per_article: 5	</span><br><span class="line">  # Unescape html strings to the readable one.	</span><br><span class="line">  unescape: false	</span><br><span class="line">  # Preload the search data when the page loads.	</span><br><span class="line">  preload: false</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="4-2-3-404页面"><a href="#4-2-3-404页面" class="headerlink" title="4.2.3 404页面"></a>4.2.3 404页面</h4><p>另外还需要添加一个 404 页面，直接在根目录 source 文件夹新建一个 404.md 文件即可，内容可以仿照如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---	</span><br><span class="line">title: 404 Not Found	</span><br><span class="line">date: 2019-09-22 10:41:27	</span><br><span class="line">---	</span><br><span class="line"> </span><br><span class="line">	</span><br><span class="line">&lt;center&gt;	</span><br><span class="line">对不起，您所访问的页面不存在或者已删除。	</span><br><span class="line">您可以&lt;a href=&quot;   &quot;&gt;点击此处&lt;/a&gt;返回首页。	</span><br><span class="line">&lt;/center&gt;	</span><br><span class="line"> </span><br><span class="line">	</span><br><span class="line">&lt;blockquote class=&quot;blockquote-center&quot;&gt;	</span><br><span class="line">    NightTeam	</span><br><span class="line">&lt;/blockquote&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里面的一些相关信息和链接可以替换成自己的。</p>
<h2 id="五、更新部署-amp-域名配置"><a href="#五、更新部署-amp-域名配置" class="headerlink" title="五、更新部署&amp;域名配置"></a>五、更新部署&amp;域名配置</h2><h3 id="5-1-Hexo更新"><a href="#5-1-Hexo更新" class="headerlink" title="5.1 Hexo更新"></a>5.1 Hexo更新</h3><p>通过博客上面的地址输入框进入  cmd</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean	</span><br><span class="line">hexo generate	</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>
<h3 id="5-2-自定义域名"><a href="#5-2-自定义域名" class="headerlink" title="5.2 自定义域名"></a>5.2 自定义域名</h3><p>我本人是在<a href="https://auth.huaweicloud.com/authui/login.html?service=https%3A%2F%2Fconsole.huaweicloud.com%2Fdns%2F%3FagencyId%3D1fb2d46c8a3e48dbbc4d41fb5b2cf34c%26region%3Dcn-east-3%26locale%3Dzh-cn%26cloud_route_state%3D%2Fdns%2Frecordset%2Fpublic%2Flist%3Fzoneid%3D8aace3b98282c2260182d8bd74236172%26zonename%3Dbaidu2001.top.%26zoneStatus%3DACTIVE#/login">华为云</a>下面买的域名</p>
<p>在 GitHub 的 Repository 里面设置域名，找到 Settings，拉到下面，可以看到有个 GitHub Pages 的配置项，如图所示</p>
<p><img src="https://i.p04e.com/baid/i/2022/09/02/74zzg.png"></p>
<p>下面有个 custom domain 的选项，输入想自定义的域名地址，然后添加 CNAME 解析就好了。</p>
<p>另外下面还有一个 Enforce HTTPS 的选项，GitHub Pages 会在我们配置自定义域名之后自动帮我们配置 HTTPS 服务。刚配置完自定义域名的时候可能这个选项是不可用的，一段时间后等到其可以勾选了，直接勾选即可，这样整个博客就会变成 HTTPS 的协议的了。</p>
<p>另外有一个值得注意的地方，如果配置了自定义域名，在目前的情况下，每次部署的时候这个自定义域名的设置是会被自动清除的。所以为了避免这个情况，我们需要在项目目录下面新建一个 CNAME 文件，路径为 source/CNAME，内容就是自定义域名。<br>我就在 source 目录下新建了一个 CNAME 文件，内容为自己的域名</p>
<p><img src="https://i.p04e.com/baid/i/2022/09/02/10q7p.png"></p>
<p>可以避免了每次部署的时候自定义域名被清除的情况了。</p>
]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>域名</tag>
        <tag>图片的免费上传</tag>
      </tags>
  </entry>
  <entry>
    <title>java.sql.SQLSyntaxErrorException: Unknown column &#39;is_deleted&#39; in &#39;field list&#39;</title>
    <url>/2022/09/02/java-sql-SQLSyntaxErrorException-Unknown-column-is-deleted-in-field-list/</url>
    <content><![CDATA[<p><img src="https://i.p04e.com/baid/i/2022/09/02/58a7.png"></p>
<p>今天做的是一个分页查询，结果无法显示，回到idea下面查找问题</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">: Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exceptison is org.springframework.jdbc.BadSqlGrammarException: </span><br><span class="line"></span><br><span class="line">### Error querying database.  Cause: java.sql.SQLSyntaxErrorException: Unknown column &#x27;is_deleted&#x27; in &#x27;field list&#x27;</span><br><span class="line">其实最重要的是后面这句，很明显是sql的问题 ，大概意思就是不知道 is_deleted 在表格中的什么什么</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">然后我在实体类中找到了这句</span><br><span class="line">    //是否删除</span><br><span class="line">    private Integer isDeleted;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我刚开始以为是驼峰命名法不对，结果改了后还是不对。</p>
<p>之后再数据库中发现这个表中并没有 is_deleted这个字段，是另一个表内的，由于实体类是找的网上资源自己懒的写就弄了一个大乌龙，删除掉以后就好了。</p>
]]></content>
      <tags>
        <tag>Mysql</tag>
        <tag>错误</tag>
      </tags>
  </entry>
  <entry>
    <title>redis软件安装和指令学习</title>
    <url>/2022/09/28/redis%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%92%8C%E6%8C%87%E4%BB%A4%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h3 id="Redis入门"><a href="#Redis入门" class="headerlink" title="Redis入门"></a>Redis入门</h3><h4 id="什么是-Redis"><a href="#什么是-Redis" class="headerlink" title="什么是 Redis ?"></a>什么是 Redis ?</h4><p>Redis是一个基于内存的key-value结构数据库。</p>
<p>基于内存存储，读写性能高</p>
<p>适合存储热点数据（热点商品、资讯、新闻)企业应用广泛</p>
<span id="more"></span>
<h4 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h4><p>Redis is an open source (BSD licensed), in-memory data structure store, used as a database, cache, andmessage broker，翻译为:Redis是一个开源的内存中的数据结构存储系统，它可以用作:数据库、缓存和消息中间件。官网: <a href="https://redis.io">https://redis.io</a><br>Redis是用C语言开发的一个开源的高性能键值对(key-value)数据库，官方提供的数据是可以达到100000+的QPS（(每秒内查询次数）。它存储的value类型比较丰富，也被称为结构化的NoSql数据库。<br>NoSql ( Not only sQL)，不仅仅是SQL，泛指非关系型数据库。NoSql数据库并不是要取代关系型数据库，而是关系型数据库的补充。</p>
<p>关系型数据库(RDBMS)</p>
<ul>
<li>Mysql</li>
<li>oracleDB2</li>
<li>sQLServer</li>
</ul>
<p>非关系型数据库(NoSql)</p>
<ul>
<li>Redis</li>
<li>Mongo </li>
<li>dbMemCached</li>
</ul>
<p>Redis应用场景</p>
<ul>
<li>缓存</li>
<li>任务队列</li>
<li>消息队列</li>
<li>分布式锁</li>
</ul>
<h4 id="Redis下载与安装"><a href="#Redis下载与安装" class="headerlink" title="Redis下载与安装"></a>Redis下载与安装</h4><p>Redis安装包分为windows版和Linux版:</p>
<p>Windows版下载地址:https:l/github.com/microsoftarchive/redis/releases</p>
<p>Linux版下载地址: <a href="https://download.redis.io/releasesl">https://download.redis.io/releasesl</a></p>
<p>在Linux系统安装Redis步骤:</p>
<p>1.将Redis安装包上传到Linux</p>
<p>⒉.解压安装包，命令: tar -zxvf redis-4.0.0.tar.gz-C /usr/local</p>
<p>3.安装Redis的依赖环境gcc，命令: yum install gcc-C++</p>
<p>4.进入/usr/local/redis-4.0.0，进行编译，命令: make</p>
<p>5.进入redis的src目录，进行安装，命令: make install</p>
<h4 id="Redis服务启动与停止"><a href="#Redis服务启动与停止" class="headerlink" title="Redis服务启动与停止"></a>Redis服务启动与停止</h4><p>Linux中redis服务启动，可以使用redis-server，默认端口号为6379</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">src/redis-server ./redis.conf</span><br><span class="line"></span><br><span class="line">src/redis-cli -p 6379 -a 123456</span><br><span class="line"></span><br><span class="line">//用本地服务器连接</span><br><span class="line">.\redis-cli.exe -h 192.168.81.128 -p 6379 -a 123456</span><br></pre></td></tr></table></figure>
<p>Ctrl+C停止Redis服务</p>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>介绍</p>
<p>Redis存储的是key-value结构的数据，其中key是字符串类型，value有5种常用的数据类型:</p>
<p>字符串string</p>
<p>哈希hash</p>
<p>列表list</p>
<p>集合set</p>
<p>有序集合sorted set</p>
<p><img src="https://i.p04e.com/baid/i/2022/09/28/12m8f.png"></p>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><h4 id="字符串string操作命令"><a href="#字符串string操作命令" class="headerlink" title="字符串string操作命令"></a>字符串string操作命令</h4><ul>
<li>SET key value    设置指定key的值</li>
<li>GET key    获取指定key的值</li>
<li>SETEX key seconds value    设置指定key的值，并将key 的过期时间设为seconds</li>
<li>SETNX key value    只有在key 不存在时设置key 的值</li>
</ul>
<h4 id="哈希hash操作命令"><a href="#哈希hash操作命令" class="headerlink" title="哈希hash操作命令"></a>哈希hash操作命令</h4><p>Redis hash 是一个string类型的field和value 的映射表，hash特别适合用于存储对象，常用命令:</p>
<ul>
<li>HSET key field value    将哈希表key 中的字段field的值设为value</li>
<li>HGET key field    获取存储在哈希表中指定字段的值</li>
<li>HDEL key field    删除存储在哈希表中的指定字段</li>
<li>HKEYS key    获取哈希表中所有字段</li>
<li>HVALS key    获取哈希表中所有值</li>
<li>HGETALL key    获取在哈希表中指定key的所有字段和值</li>
</ul>
<h4 id="列表list操作命令"><a href="#列表list操作命令" class="headerlink" title="列表list操作命令"></a>列表list操作命令</h4><ul>
<li><p>Redis列表是简单的字符串列表，按照插入顺序排序，常用命令:</p>
</li>
<li><p>LPUSH key value1 [value2]    将一个或多个值插入到列表头部</p>
</li>
<li><p>LRANGE key start stop    获取列表指定范围内的元素</p>
</li>
<li><p>RPOP key    移除并获取列表最后一个元素</p>
</li>
<li><p>LLEN key    获取列表长度</p>
</li>
<li><p>BRPOP key1 [key2 ] timeout    移出并获取列表的最后一个元素，如果列表没有元素会阻塞列表直到等待超</p>
<p>​                                   时或发现可弹出元素为止</p>
<p><img src="https://i.p04e.com/baid/i/2022/09/28/sl9.png"></p>
</li>
</ul>
<h4 id="集合set操作命令"><a href="#集合set操作命令" class="headerlink" title="集合set操作命令"></a>集合set操作命令</h4><p>Redis set 是string类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据，常用命令:</p>
<ul>
<li>SADD key member1 [member2]    向集合添加一个或多个成员</li>
<li>SMEMBERS key    返回集合中的所有成员</li>
<li>SCARD key    获取集合的成员数</li>
<li>SINTER key1 [key2]    返回给定所有集合的交集</li>
<li>SUNION key1 [key2]    返回所有给定集合的并集</li>
<li>SDIFF key1 [key2]    返回给定所有集合的差集</li>
<li>SREM key member1[member2]    移除集合中一个或多个成员</li>
</ul>
<p><img src="https://i.p04e.com/baid/i/2022/09/28/1h4x2d.png"></p>
<h4 id="有序集合sorted-set操作命令"><a href="#有序集合sorted-set操作命令" class="headerlink" title="有序集合sorted set操作命令"></a>有序集合sorted set操作命令</h4><p>Redis sorted set有序集合是string类型元素的集合，且不允许重复的成员。每个元素都会关联一个double类</p>
<p>型的分数(score)。redis正是通过分数来为集合中的成员进行从小到大排序。有序集合的成员是唯一的，但分</p>
<p>数却可以重复。常用命令:</p>
<ul>
<li>ZADD key score1 member1[score2 member2]    向有序集合添加一个或多个成员，或者更新已存在成员的分</li>
<li>数</li>
<li>ZRANGE key start stop [WITHSCORES]    通过索引区间返回有序集合中指定区间内的成员</li>
<li>zINCRBY key increment member    有序集合中对指定成员的分数加上增量increment</li>
<li>ZREM key member [member …]    移除有序集合中的一个或多个成员</li>
</ul>
<p><img src="https://i.p04e.com/baid/i/2022/09/28/7mbae.png"></p>
<h4 id="通用命令"><a href="#通用命令" class="headerlink" title="通用命令"></a>通用命令</h4><ul>
<li>KEYs pattern    查找所有符合给定模式( pattern)的 key</li>
<li>EXISTs key    检查给定key是否存在</li>
<li>TYPE key    返回key所储存的值的类型</li>
<li>TTL key    返回给定key的剩余生存时间(TTL, time to live)，以秒为单位</li>
<li>DEL key    该命令用于在key存在是删除key</li>
</ul>
<h3 id="在Java中操作Redis"><a href="#在Java中操作Redis" class="headerlink" title="在Java中操作Redis"></a>在Java中操作Redis</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>Redis 的Java客户端很多，官方推荐的有三种:</p>
<ul>
<li>Jedis</li>
<li>Lettuce</li>
<li>Redisson</li>
</ul>
<p>Spring对Redis客户端进行了整合，提供了Spring Data Redis，在Spring Boot项目中还提供了对应的</p>
<p>Starter，即spring-boot-starter-data-redis</p>
<h4 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h4><p>Jedis的maven坐标:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;groupld&gt;redis.clients&lt;/groupld&gt;</span><br><span class="line"></span><br><span class="line">&lt;artifactld&gt;jedis&lt;lartifactld&gt;</span><br><span class="line"></span><br><span class="line">&lt;version&gt;2.8.O&lt;/version&gt;</span><br><span class="line"></span><br><span class="line">&lt;/ dependency&gt;</span><br></pre></td></tr></table></figure>
<p>使用Jedis操作Redis的步骤:</p>
<ul>
<li>获取连接</li>
<li>执行操作</li>
<li>关闭连接</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.test;</span><br><span class="line"></span><br><span class="line">import org.junit.Test;</span><br><span class="line">import redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 使用Jedis操作Redis</span><br><span class="line"> */</span><br><span class="line">public class JedisTest &#123;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testRedis()&#123;</span><br><span class="line">        //1 获取连接</span><br><span class="line">        Jedis jedis = new Jedis(&quot;localhost&quot;,6379);</span><br><span class="line">        </span><br><span class="line">        //2 执行具体的操作</span><br><span class="line">        jedis.set(&quot;username&quot;,&quot;xiaoming&quot;);</span><br><span class="line"></span><br><span class="line">        String value = jedis.get(&quot;username&quot;);</span><br><span class="line">        System.out.println(value);</span><br><span class="line"></span><br><span class="line">        //jedis.del(&quot;username&quot;);</span><br><span class="line"></span><br><span class="line">        jedis.hset(&quot;myhash&quot;,&quot;addr&quot;,&quot;bj&quot;);</span><br><span class="line">        String hValue = jedis.hget(&quot;myhash&quot;, &quot;addr&quot;);</span><br><span class="line">        System.out.println(hValue);</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; keys = jedis.keys(&quot;*&quot;);</span><br><span class="line">        for (String key : keys) &#123;</span><br><span class="line">            System.out.println(key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //3 关闭连接</span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="Spring-Data-Redis"><a href="#Spring-Data-Redis" class="headerlink" title="Spring Data Redis"></a>Spring Data Redis</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在Spring Boot项目中，可以使用Spring Data Redis来简化Redis操作，maven坐标:</span><br><span class="line">	&lt;dependency&gt;</span><br><span class="line">&lt;groupld&gt;org.springframework.boot&lt;/groupld&gt;</span><br><span class="line">&lt;artifactld&gt;spring-boot-starter-data-redis&lt;/artifactld&gt;</span><br><span class="line">	&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>Spring Data Redis中提供了一个高度封装的类: RedisTemplate，针对jedis客户端中大量ap进行了归类封装,</p>
<p>将同一类型操作封装为operation接口，具体分类如下:</p>
<ul>
<li>valueOperations:简单K-V操作</li>
<li>SetOperations: set类型数据操作</li>
<li>ZSetOperations: zset类型数据操作</li>
<li>HashOperations:针对map类型的数据操作</li>
<li>Listoperations:针对list类型的数据操作</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: springdataredis_demo</span><br><span class="line">  #Redis相关配置</span><br><span class="line">  redis:</span><br><span class="line">    host: localhost</span><br><span class="line">    port: 6379</span><br><span class="line">    #password: 123456</span><br><span class="line">    database: 0 #操作的是0号数据库</span><br><span class="line">    jedis:</span><br><span class="line">      #Redis连接池配置</span><br><span class="line">      pool:</span><br><span class="line">        max-active: 8 #最大连接数</span><br><span class="line">        max-wait: 1ms #连接池最大阻塞等待时间</span><br><span class="line">        max-idle: 4 #连接池中的最大空闲连接</span><br><span class="line">        min-idle: 0 #连接池中的最小空闲连接</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.test;</span><br><span class="line"></span><br><span class="line">import org.junit.Test;</span><br><span class="line">import org.junit.runner.RunWith;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line">import org.springframework.data.redis.connection.DataType;</span><br><span class="line">import org.springframework.data.redis.core.*;</span><br><span class="line">import org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Set;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">@SpringBootTest</span><br><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">public class SpringDataRedisTest &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 操作String类型数据</span><br><span class="line">     */</span><br><span class="line">    @Test</span><br><span class="line">    public void testString()&#123;</span><br><span class="line">        redisTemplate.opsForValue().set(&quot;city123&quot;,&quot;beijing&quot;);</span><br><span class="line"></span><br><span class="line">        String value = (String) redisTemplate.opsForValue().get(&quot;city123&quot;);</span><br><span class="line">        System.out.println(value);</span><br><span class="line"></span><br><span class="line">        redisTemplate.opsForValue().set(&quot;key1&quot;,&quot;value1&quot;,10l, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        Boolean aBoolean = redisTemplate.opsForValue().setIfAbsent(&quot;city1234&quot;, &quot;nanjing&quot;);</span><br><span class="line">        System.out.println(aBoolean);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 操作Hash类型数据</span><br><span class="line">     */</span><br><span class="line">    @Test</span><br><span class="line">    public void testHash()&#123;</span><br><span class="line">        HashOperations hashOperations = redisTemplate.opsForHash();</span><br><span class="line"></span><br><span class="line">        //存值</span><br><span class="line">        hashOperations.put(&quot;002&quot;,&quot;name&quot;,&quot;xiaoming&quot;);</span><br><span class="line">        hashOperations.put(&quot;002&quot;,&quot;age&quot;,&quot;20&quot;);</span><br><span class="line">        hashOperations.put(&quot;002&quot;,&quot;address&quot;,&quot;bj&quot;);</span><br><span class="line"></span><br><span class="line">        //取值</span><br><span class="line">        String age = (String) hashOperations.get(&quot;002&quot;, &quot;age&quot;);</span><br><span class="line">        System.out.println(age);</span><br><span class="line"></span><br><span class="line">        //获得hash结构中的所有字段</span><br><span class="line">        Set keys = hashOperations.keys(&quot;002&quot;);</span><br><span class="line">        for (Object key : keys) &#123;</span><br><span class="line">            System.out.println(key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //获得hash结构中的所有值</span><br><span class="line">        List values = hashOperations.values(&quot;002&quot;);</span><br><span class="line">        for (Object value : values) &#123;</span><br><span class="line">            System.out.println(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 操作List类型的数据</span><br><span class="line">     */</span><br><span class="line">    @Test</span><br><span class="line">    public void testList()&#123;</span><br><span class="line">        ListOperations listOperations = redisTemplate.opsForList();</span><br><span class="line"></span><br><span class="line">        //存值</span><br><span class="line">        listOperations.leftPush(&quot;mylist&quot;,&quot;a&quot;);</span><br><span class="line">        listOperations.leftPushAll(&quot;mylist&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;);</span><br><span class="line"></span><br><span class="line">        //取值</span><br><span class="line">        List&lt;String&gt; mylist = listOperations.range(&quot;mylist&quot;, 0, -1);</span><br><span class="line">        for (String value : mylist) &#123;</span><br><span class="line">            System.out.println(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //获得列表长度 llen</span><br><span class="line">        Long size = listOperations.size(&quot;mylist&quot;);</span><br><span class="line">        int lSize = size.intValue();</span><br><span class="line">        for (int i = 0; i &lt; lSize; i++) &#123;</span><br><span class="line">            //出队列</span><br><span class="line">            String element = (String) listOperations.rightPop(&quot;mylist&quot;);</span><br><span class="line">            System.out.println(element);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 操作Set类型的数据</span><br><span class="line">     */</span><br><span class="line">    @Test</span><br><span class="line">    public void testSet()&#123;</span><br><span class="line">        SetOperations setOperations = redisTemplate.opsForSet();</span><br><span class="line"></span><br><span class="line">        //存值</span><br><span class="line">        setOperations.add(&quot;myset&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;a&quot;);</span><br><span class="line"></span><br><span class="line">        //取值</span><br><span class="line">        Set&lt;String&gt; myset = setOperations.members(&quot;myset&quot;);</span><br><span class="line">        for (String o : myset) &#123;</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //删除成员</span><br><span class="line">        setOperations.remove(&quot;myset&quot;,&quot;a&quot;,&quot;b&quot;);</span><br><span class="line"></span><br><span class="line">        //取值</span><br><span class="line">        myset = setOperations.members(&quot;myset&quot;);</span><br><span class="line">        for (String o : myset) &#123;</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 操作ZSet类型的数据</span><br><span class="line">     */</span><br><span class="line">    @Test</span><br><span class="line">    public void testZset()&#123;</span><br><span class="line">        ZSetOperations zSetOperations = redisTemplate.opsForZSet();</span><br><span class="line"></span><br><span class="line">        //存值</span><br><span class="line">        zSetOperations.add(&quot;myZset&quot;,&quot;a&quot;,10.0);</span><br><span class="line">        zSetOperations.add(&quot;myZset&quot;,&quot;b&quot;,11.0);</span><br><span class="line">        zSetOperations.add(&quot;myZset&quot;,&quot;c&quot;,12.0);</span><br><span class="line">        zSetOperations.add(&quot;myZset&quot;,&quot;a&quot;,13.0);</span><br><span class="line"></span><br><span class="line">        //取值</span><br><span class="line">        Set&lt;String&gt; myZset = zSetOperations.range(&quot;myZset&quot;, 0, -1);</span><br><span class="line">        for (String s : myZset) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //修改分数</span><br><span class="line">        zSetOperations.incrementScore(&quot;myZset&quot;,&quot;b&quot;,20.0);</span><br><span class="line"></span><br><span class="line">        //取值</span><br><span class="line">        myZset = zSetOperations.range(&quot;myZset&quot;, 0, -1);</span><br><span class="line">        for (String s : myZset) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //删除成员</span><br><span class="line">        zSetOperations.remove(&quot;myZset&quot;,&quot;a&quot;,&quot;b&quot;);</span><br><span class="line"></span><br><span class="line">        //取值</span><br><span class="line">        myZset = zSetOperations.range(&quot;myZset&quot;, 0, -1);</span><br><span class="line">        for (String s : myZset) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 通用操作，针对不同的数据类型都可以操作</span><br><span class="line">     */</span><br><span class="line">    @Test</span><br><span class="line">    public void testCommon()&#123;</span><br><span class="line">        //获取Redis中所有的key</span><br><span class="line">        Set&lt;String&gt; keys = redisTemplate.keys(&quot;*&quot;);</span><br><span class="line">        for (String key : keys) &#123;</span><br><span class="line">            System.out.println(key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //判断某个key是否存在</span><br><span class="line">        Boolean itcast = redisTemplate.hasKey(&quot;itcast&quot;);</span><br><span class="line">        System.out.println(itcast);</span><br><span class="line"></span><br><span class="line">        //删除指定key</span><br><span class="line">        redisTemplate.delete(&quot;myZset&quot;);</span><br><span class="line"></span><br><span class="line">        //获取指定key对应的value的数据类型</span><br><span class="line">        DataType dataType = redisTemplate.type(&quot;myset&quot;);</span><br><span class="line">        System.out.println(dataType.name());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>Reids</tag>
      </tags>
  </entry>
  <entry>
    <title>白都的一封信</title>
    <url>/2022/08/26/%E4%BF%A1/</url>
    <content><![CDATA[<p>已至凌晨却无论如何都睡不着了，心里藏着很多事情。</p>
<span id="more"></span>
<hr>
<p>​    可对于已经发生过的事情，我们无能为力，能做好的只有接下来的事情。</p>
<p>​    <code>小时候经常仰望着星空，渴望着自己成为逆转时空的飞人</code></p>
<p>​    </p>
<hr>
<p>​    <code>黑还是白并不重要</code></p>
<hr>
<p>​    在痛苦开心的过程中会慢慢的触摸到心中真正的所想所愿。那是一种奇妙的感觉，很像是悟道一样的感觉。</p>
<p>​    <code>每天每天每月每月，实现那个梦</code></p>
<hr>
<p>​    生命的所有，都来自于想象力。</p>
<p>所有的可能，所有的道都来自于想象力。</p>
]]></content>
      <tags>
        <tag>念想</tag>
      </tags>
  </entry>
  <entry>
    <title>个人博客网站问题解决</title>
    <url>/2022/08/29/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<h2 id="一、Hexo-Next-实现全局播放背景音乐"><a href="#一、Hexo-Next-实现全局播放背景音乐" class="headerlink" title="一、Hexo + Next 实现全局播放背景音乐"></a>一、Hexo + Next 实现全局播放背景音乐</h2><p>进入网页版的网易云，进入你想选的歌单，按F12键进入开发人员工具，在元素里面 按ctrl + F 进行搜索生成外链，</p>
<span id="more"></span>
<p>记住前面的那一行数字，新开一个网页输入</p>
<p><code>https://music.163.com/#/outchain/0/</code>733122887         并将那行数字加载在 / 的后面。</p>
<p>打开我们主题文件：<code>themes\next\layout\_macro\sidebar.swig</code>找到<code>sidebar-inner</code>，复制下面代码粘贴到此<code>&lt;div&gt;</code>标签后即可。</p>
<ul>
<li>打开<code>themes\next\layout</code>文件夹找到<code>_layout.swig</code></li>
<li>在<code>&lt;\head&gt;</code>标签前添加下面代码，并保存。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;head&gt;   //粘贴到这里</span><br><span class="line">    </span><br><span class="line">  &lt;!--pjax：防止跳转页面音乐暂停--&gt;</span><br><span class="line">  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.js&quot;&gt;&lt;/script&gt; </span><br><span class="line">&lt;/head&gt; </span><br></pre></td></tr></table></figure>
<ul>
<li>在主题的配置文件中找到<code>pajx</code>，将它设置为<code>true</code>，并保存。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Easily enable fast Ajax navigation on your website.</span><br><span class="line"># Dependencies: https://github.com/theme-next/theme-next-pjax</span><br><span class="line">pjax: true</span><br></pre></td></tr></table></figure>
<h2 id="二、部署hexo时遇到报错ERROR-Deployer-not-found-git"><a href="#二、部署hexo时遇到报错ERROR-Deployer-not-found-git" class="headerlink" title="二、部署hexo时遇到报错ERROR Deployer not found: git"></a>二、部署hexo时遇到报错ERROR Deployer not found: git</h2><p>这是因为没有安装<code>hexo-deployer-git</code>插件,在<strong>站点目录</strong>下输入下面的命令安装插件就好了。执行下面这行命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<h2 id="三、使用命令npm-install-g-hexo-cli-安装Hexo报错bash-hexo-command-not-found问题解决"><a href="#三、使用命令npm-install-g-hexo-cli-安装Hexo报错bash-hexo-command-not-found问题解决" class="headerlink" title="三、使用命令npm install -g hexo-cli 安装Hexo报错bash: hexo: command not found问题解决"></a>三、使用命令npm install -g hexo-cli 安装Hexo报错bash: hexo: command not found问题解决</h2><p>选择一个磁盘，简历一个文件夹，取名为blog</p>
<p>然后按照下面的指令一步步输入</p>
<p><strong>在命令的前面加上npx。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npx hexo init blog</span><br><span class="line">cd blog</span><br><span class="line">npm install</span><br><span class="line">npx hexo server</span><br></pre></td></tr></table></figure>
<p>最后解释一下，为啥要在前面加上npx。</p>
<p>在大牛<a href="http://www.ruanyifeng.com/blog/2019/02/npx.html">阮一峰的网络日志</a>中，他是这么描述的：“<strong>npx 想要解决的主要问题，就是调用项目内部安装的模块</strong>”，所以可以理解为在命令行下调用，可以让项目内部安装的模块用起来更方便，npx运行的时候，会到<code>node_modules/.bin</code>路径和环境变量<code>$PATH</code>里面，检查命令是否存在。</p>
<p>如果还是不可以就手动加载路径</p>
<p>注意你的博客目录下应该有两个 <code>node_modules</code> 文件夹，要添加到 Path 里面的是与 _config.yml 在同一个目录的 node_modules 文件夹！</p>
<p>环境变量添加好了之后重新打开 git 即可运行 hexo 命令，如果此时仍然无法执行 hexo 命令，那就只能拿出终极绝招了，运行命令 <code>npm install hexo-cli -g</code> 重新安装 hexo 即可！</p>
]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>外卖管理平台删除套餐</title>
    <url>/2022/09/14/%E5%A4%96%E5%8D%96%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0%E5%88%A0%E9%99%A4%E5%A5%97%E9%A4%90/</url>
    <content><![CDATA[<h3 id="一、需求分析"><a href="#一、需求分析" class="headerlink" title="一、需求分析"></a>一、需求分析</h3><p>在套餐管理列表页面点击删除按钮，可以删除对应的套餐信息。也可以通过复选框选择多个套餐，点击批量删除按钮一次删除多个套餐。注意，对于状态为售卖中的套餐不能删除，需要先停售，然后才能删除。</p>
<span id="more"></span>
<h3 id="二、代码开发-梳理交互过程"><a href="#二、代码开发-梳理交互过程" class="headerlink" title="二、代码开发-梳理交互过程"></a>二、代码开发-梳理交互过程</h3><p>在开发代码之前，需要梳理一下删除套餐时前端页面和服务端的交互过程:</p>
<p>1、删除单个套餐时，页面发送ajax请求，根据套餐id删除对应套餐</p>
<p><img src="https://i.p04e.com/baid/i/2022/09/15/2lii.png"></p>
<p>2、删除多个套餐时，页面发送ajax请求，根据提交的多个套餐id删除对应套餐</p>
<p><img src="https://i.p04e.com/baid/i/2022/09/15/i6q6.png"></p>
<p>开发删除套餐功能，其实就是在服务端编写代码去处理前端页面发送的这2次请求即可。</p>
<p>观察删除单个套餐和批量删除套餐的请求信息可以发现，两种请求的地址和请求方式都是相同的，不同的则是传递的id个数，所以在服务端可以提供一个方法来统一处理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.service;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.extension.service.IService;</span><br><span class="line">import com.itheima.reggie.dto.SetmealDto;</span><br><span class="line">import com.itheima.reggie.entity.Setmeal;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public interface SetmealService extends IService&lt;Setmeal&gt; &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 新增套餐，同时需要保存套餐和菜品的关系</span><br><span class="line">     * @param setmealDto</span><br><span class="line">     */</span><br><span class="line">    public void saveWithDish(SetmealDto setmealDto);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 删除套餐，同时需要删除套餐和菜品的关联数据</span><br><span class="line">     * @param ids</span><br><span class="line">     */</span><br><span class="line">    public void removeWithDish(List&lt;Long&gt; ids);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 删除套餐，同时需要删除套餐和菜品的关联数据</span><br><span class="line"> * @param ids</span><br><span class="line"> */</span><br><span class="line">@Transactional</span><br><span class="line">public void removeWithDish(List&lt;Long&gt; ids) &#123;</span><br><span class="line">    //select count(*) from setmeal where id in (1,2,3) and status = 1</span><br><span class="line">    //查询套餐状态，确定是否可用删除</span><br><span class="line">    LambdaQueryWrapper&lt;Setmeal&gt; queryWrapper = new LambdaQueryWrapper();</span><br><span class="line">    queryWrapper.in(Setmeal::getId,ids);</span><br><span class="line">    queryWrapper.eq(Setmeal::getStatus,1);</span><br><span class="line"></span><br><span class="line">    int count = this.count(queryWrapper);</span><br><span class="line">    if(count &gt; 0)&#123;</span><br><span class="line">        //如果不能删除，抛出一个业务异常</span><br><span class="line">        throw new CustomException(&quot;套餐正在售卖中，不能删除&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //如果可以删除，先删除套餐表中的数据---setmeal</span><br><span class="line">    this.removeByIds(ids);</span><br><span class="line"></span><br><span class="line">    //delete from setmeal_dish where setmeal_id in (1,2,3)</span><br><span class="line">    LambdaQueryWrapper&lt;SetmealDish&gt; lambdaQueryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">    lambdaQueryWrapper.in(SetmealDish::getSetmealId,ids);</span><br><span class="line">    //删除关系表中的数据----setmeal_dish</span><br><span class="line">    setmealDishService.remove(lambdaQueryWrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 删除套餐</span><br><span class="line"> * @param ids</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">@DeleteMapping</span><br><span class="line">public R&lt;String&gt; delete(@RequestParam List&lt;Long&gt; ids)&#123;</span><br><span class="line">    log.info(&quot;ids:&#123;&#125;&quot;,ids);</span><br><span class="line"></span><br><span class="line">    setmealService.removeWithDish(ids);</span><br><span class="line"></span><br><span class="line">    return R.success(&quot;套餐数据删除成功&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>springboot - 外卖平台</tag>
        <tag>项目开发</tag>
        <tag>删除套餐</tag>
        <tag>mybatis plus</tag>
      </tags>
  </entry>
  <entry>
    <title>外卖管理平台修改菜品</title>
    <url>/2022/09/12/%E5%A4%96%E5%8D%96%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0%E4%BF%AE%E6%94%B9%E8%8F%9C%E5%93%81/</url>
    <content><![CDATA[<h3 id="一、需求分析"><a href="#一、需求分析" class="headerlink" title="一、需求分析"></a>一、需求分析</h3><p>在菜品管理列表页面点击修改按钮，跳转到修改菜品页面，在修改页面回显菜品相关信息并进行修改，最后点击确定按钮完成修改操作</p>
<span id="more"></span>
<h3 id="二、修改菜品"><a href="#二、修改菜品" class="headerlink" title="二、修改菜品"></a>二、修改菜品</h3><h4 id="代码开发-梳理交互过程"><a href="#代码开发-梳理交互过程" class="headerlink" title="代码开发-梳理交互过程"></a>代码开发-梳理交互过程</h4><p>在开发代码之前，需要梳理一下修改菜品时前端页面( add.html)和服务端的交互过程:</p>
<p>1、页面发送ajax请求，请求服务端获取分类数据，用于菜品分类下拉框中数据展示</p>
<p>2、页面发送ajax请求，请求服务端，根据id查询当前菜品信息，用于菜品信息回显</p>
<p>3、页面发送请求，请求服务端进行图片下载，用于页图片回显</p>
<p>4、点击保存按钮，页面发送ajax请求，将修改后的菜品相关数据以json形式提交到服务端</p>
<p><code>开发修改菜品功能，其实就是在服务端编写代码去处理前端页面发送的这4次请求即可。</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.service;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.extension.service.IService;</span><br><span class="line">import com.itheima.reggie.dto.DishDto;</span><br><span class="line">import com.itheima.reggie.entity.Dish;</span><br><span class="line"></span><br><span class="line">public interface DishService extends IService&lt;Dish&gt; &#123;</span><br><span class="line"></span><br><span class="line">    //新增菜品，同时插入菜品对应的口味数据，需要同时操作两张表： dish,dish_flavor</span><br><span class="line">    public void saveWithFlavor(DishDto dishDto);</span><br><span class="line"></span><br><span class="line">    //根据id来查询菜品信息和对应的口味信息</span><br><span class="line">    public DishDto getByIdwithFlavor(Long id);</span><br><span class="line"></span><br><span class="line">    //更新菜品信息，同时更新对应的口味信息</span><br><span class="line">    public void updateWithFlaovr(DishDto dishDto);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.service.impl;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;</span><br><span class="line">import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;</span><br><span class="line">import com.itheima.reggie.dto.DishDto;</span><br><span class="line">import com.itheima.reggie.entity.Dish;</span><br><span class="line">import com.itheima.reggie.entity.DishFlavor;</span><br><span class="line">import com.itheima.reggie.mapper.DishMapper;</span><br><span class="line">import com.itheima.reggie.service.DishFlavorService;</span><br><span class="line">import com.itheima.reggie.service.DishService;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.beans.BeanUtils;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line">import org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line">import java.util.Collections;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">@Slf4j</span><br><span class="line">public class DishServiceImpl extends ServiceImpl&lt;DishMapper,Dish&gt; implements DishService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private DishFlavorService dishFlavorService;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 新增菜品，同时保存对应的口味数据</span><br><span class="line">     * @param dishDto</span><br><span class="line">     */</span><br><span class="line">    @Transactional</span><br><span class="line">    public void saveWithFlavor(DishDto dishDto) &#123;</span><br><span class="line">        //保存菜品的基本信息到菜品表dish</span><br><span class="line">        this.save(dishDto);</span><br><span class="line"></span><br><span class="line">        Long dishId = dishDto.getId();//菜品id</span><br><span class="line"></span><br><span class="line">        //菜品口味</span><br><span class="line">        List&lt;DishFlavor&gt; flavors = dishDto.getFlavors();</span><br><span class="line">        flavors = flavors.stream().map((item) -&gt; &#123;</span><br><span class="line">            item.setDishId(dishId);</span><br><span class="line">            return item;</span><br><span class="line">        &#125;).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        //保存菜品口味数据到菜品口味表dish_flavor</span><br><span class="line">        dishFlavorService.saveBatch(flavors);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据id查询菜品信息和对应的口味信息</span><br><span class="line">     * @param id</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    public DishDto getByIdwithFlavor(Long id) &#123;</span><br><span class="line">        //查询菜品基本信息，从dish表查询</span><br><span class="line">        Dish dish = this.getById(id);</span><br><span class="line"></span><br><span class="line">        DishDto dishDto = new DishDto();</span><br><span class="line">        BeanUtils.copyProperties(dish,dishDto);</span><br><span class="line"></span><br><span class="line">        //查询当前菜品对应的口味信息，从dish_flavor表查询</span><br><span class="line">        LambdaQueryWrapper&lt;DishFlavor&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">        queryWrapper.eq(DishFlavor::getDishId,dish.getId());</span><br><span class="line">        List&lt;DishFlavor&gt; flavors = dishFlavorService.list(queryWrapper);</span><br><span class="line">        dishDto.setFlavors(flavors);</span><br><span class="line"></span><br><span class="line">        return dishDto;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    @Transactional</span><br><span class="line">    public void updateWithFlaovr(DishDto dishDto) &#123;</span><br><span class="line">        //更新dish表基本信息</span><br><span class="line">        this.updateById(dishDto);</span><br><span class="line"></span><br><span class="line">        //清理当前菜品对应口味数据---dish_flavor表的delete操作</span><br><span class="line">        LambdaQueryWrapper&lt;DishFlavor&gt; queryWrapper = new LambdaQueryWrapper();</span><br><span class="line">        queryWrapper.eq(DishFlavor::getDishId,dishDto.getId());</span><br><span class="line"></span><br><span class="line">        dishFlavorService.remove(queryWrapper);</span><br><span class="line"></span><br><span class="line">        //添加当前提交过来的口味数据---dish_flavor表的insert操作</span><br><span class="line">        List&lt;DishFlavor&gt; flavors = dishDto.getFlavors();</span><br><span class="line"></span><br><span class="line">        flavors = flavors.stream().map((item) -&gt; &#123;</span><br><span class="line">            item.setDishId(dishDto.getId());</span><br><span class="line">            return item;</span><br><span class="line">        &#125;).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        dishFlavorService.saveBatch(flavors);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.controller;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;</span><br><span class="line">import com.baomidou.mybatisplus.extension.plugins.pagination.Page;</span><br><span class="line">import com.itheima.reggie.common.R;</span><br><span class="line">import com.itheima.reggie.dto.DishDto;</span><br><span class="line">import com.itheima.reggie.entity.Category;</span><br><span class="line">import com.itheima.reggie.entity.Dish;</span><br><span class="line">import com.itheima.reggie.service.CategoryService;</span><br><span class="line">import com.itheima.reggie.service.DishFlavorService;</span><br><span class="line">import com.itheima.reggie.service.DishService;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.beans.BeanUtils;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/dish&quot;)</span><br><span class="line">@Slf4j</span><br><span class="line">public class DishController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private DishService dishService;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private DishFlavorService dishFlavorService;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private CategoryService categoryService;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 新增菜品</span><br><span class="line">     * @param dishDto</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @PostMapping</span><br><span class="line">    public R&lt;String&gt; save(@RequestBody DishDto dishDto) &#123;</span><br><span class="line"></span><br><span class="line">        log.info(dishDto.toString());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        dishService.saveWithFlavor(dishDto);</span><br><span class="line">        return R.success(&quot;新增菜品成功&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 菜品信息分页</span><br><span class="line">     * @param page</span><br><span class="line">     * @param pageSize</span><br><span class="line">     * @param name</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @GetMapping(&quot;/page&quot;)</span><br><span class="line">    public R&lt;Page&gt; page(int page, int pageSize, String name) &#123;</span><br><span class="line"></span><br><span class="line">        //构造分页构造器</span><br><span class="line">        Page&lt;Dish&gt; pageInfo = new Page&lt;&gt;(page,pageSize);</span><br><span class="line">        Page&lt;DishDto&gt; dishDtoPage = new Page&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        //条件构造器</span><br><span class="line">        LambdaQueryWrapper&lt;Dish&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        //添加过滤条件</span><br><span class="line">        queryWrapper.like(name != null,Dish::getName, name);</span><br><span class="line"></span><br><span class="line">        //添加排序条件</span><br><span class="line">        queryWrapper.orderByDesc(Dish::getUpdateTime);</span><br><span class="line"></span><br><span class="line">        //执行分页查询</span><br><span class="line">        dishService.page(pageInfo, queryWrapper);</span><br><span class="line"></span><br><span class="line">        //对象拷贝</span><br><span class="line">        BeanUtils.copyProperties(pageInfo,dishDtoPage,&quot;records&quot;);</span><br><span class="line"></span><br><span class="line">        List&lt;Dish&gt; records = pageInfo.getRecords();</span><br><span class="line">        List&lt;DishDto&gt; list = records.stream().map((item) -&gt;  &#123;</span><br><span class="line">            DishDto dishDto = new DishDto();</span><br><span class="line"></span><br><span class="line">            BeanUtils.copyProperties(item, dishDto);</span><br><span class="line"></span><br><span class="line">            Long categoryId = item.getCategoryId();</span><br><span class="line"></span><br><span class="line">            //根据id查询分类对象</span><br><span class="line">            Category category = categoryService.getById(categoryId);</span><br><span class="line"></span><br><span class="line">            if (category != null) &#123;</span><br><span class="line">                String categoryName = category.getName();</span><br><span class="line">                dishDto.setCategoryName(categoryName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            return dishDto;</span><br><span class="line">        &#125;).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        dishDtoPage.setRecords(list);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        return R.success(dishDtoPage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">    public R&lt;DishDto&gt; get(@PathVariable Long id) &#123;</span><br><span class="line"></span><br><span class="line">        DishDto dishDto = dishService.getByIdwithFlavor(id);</span><br><span class="line"></span><br><span class="line">        return R.success(dishDto);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 修改菜品</span><br><span class="line">     * @param dishDto</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @PutMapping</span><br><span class="line">    public R&lt;String&gt; update(@RequestBody DishDto dishDto) &#123;</span><br><span class="line"></span><br><span class="line">        log.info(dishDto.toString());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        dishService.updateWithFlaovr(dishDto);</span><br><span class="line"></span><br><span class="line">        return R.success(&quot;修改菜品成功&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据条件查询对应的菜品数据</span><br><span class="line">     * @param dish</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @GetMapping(&quot;/list&quot;)</span><br><span class="line">    public R&lt;List&lt;Dish&gt;&gt; list(Dish dish) &#123;</span><br><span class="line"></span><br><span class="line">        //构造查询条件</span><br><span class="line">        LambdaQueryWrapper&lt;Dish&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">        queryWrapper.eq(dish.getCategoryId() != null , Dish::getCategoryId, dish.getCategoryId());</span><br><span class="line">        //查询状态为1</span><br><span class="line">        queryWrapper.eq(Dish::getStatus,1);</span><br><span class="line">        //添加一个排序条件</span><br><span class="line">        queryWrapper.orderByAsc(Dish::getSort).orderByDesc(Dish::getUpdateTime);</span><br><span class="line"></span><br><span class="line">        List&lt;Dish&gt; list = dishService.list(queryWrapper);</span><br><span class="line">        return R.success(list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>springboot - 外卖平台</tag>
        <tag>项目开发</tag>
        <tag>mybatis plus</tag>
        <tag>修改菜品</tag>
      </tags>
  </entry>
  <entry>
    <title>外卖管理平台套餐信息分页查询</title>
    <url>/2022/09/14/%E5%A4%96%E5%8D%96%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0%E5%A5%97%E9%A4%90%E4%BF%A1%E6%81%AF%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<h3 id="一、需求分析"><a href="#一、需求分析" class="headerlink" title="一、需求分析"></a>一、需求分析</h3><p>系统中的套餐数据很多的时候，如果在一个页面中全部展示出来会显得比较乱，不便于查看，所以一般的系统中都会以分页的方式来展示列表数据。</p>
<span id="more"></span>
<h3 id="二、代码开发-梳理交互过程"><a href="#二、代码开发-梳理交互过程" class="headerlink" title="二、代码开发-梳理交互过程"></a>二、代码开发-梳理交互过程</h3><p>在开发代码之前，需要梳理一下套餐分页查询时前端页面和服务端的交互过程:</p>
<p>1、页面(backend/page/combo/list.html)发送ajax请求，将分页查询参数(page. pageSize、</p>
<p>name)提交到服务端，获取分页数据</p>
<p>2、页面发送请求，请求服务端进行图片下载，用于页面图片展示</p>
<p>开发套餐信息分页查询功能，其实就是在服务端编写代码去处理前端页面发送的这2次请求即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.controller;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *套餐分页查询</span><br><span class="line">     * @param page</span><br><span class="line">     * @param pageSize</span><br><span class="line">     * @param name</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @GetMapping(&quot;/page&quot;)</span><br><span class="line">    public R&lt;Page&gt; page(int page, int pageSize, String name) &#123;</span><br><span class="line">        //分页构造器对象</span><br><span class="line">        Page&lt;Setmeal&gt; pageInfo = new Page&lt;&gt;(page, pageSize);</span><br><span class="line">        Page&lt;SetmealDto&gt; dtoPage = new Page&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        LambdaQueryWrapper&lt;Setmeal&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">        //添加查询条件，根据name进行like模糊查询</span><br><span class="line">        queryWrapper.like(name != null, Setmeal::getName, name);</span><br><span class="line">        //添加排序条件，根据更新时间降序排列</span><br><span class="line">        queryWrapper.orderByDesc(Setmeal::getUpdateTime);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        setmealService.page(pageInfo,queryWrapper);</span><br><span class="line"></span><br><span class="line">        //对象拷贝</span><br><span class="line">        BeanUtils.copyProperties(pageInfo, dtoPage,&quot;records&quot;);</span><br><span class="line">        List&lt;Setmeal&gt; records = pageInfo.getRecords();</span><br><span class="line"></span><br><span class="line">        List&lt;SetmealDto&gt; list = records.stream().map((item) -&gt; &#123;</span><br><span class="line">            SetmealDto setmealDto = new SetmealDto();</span><br><span class="line">            //对象拷贝</span><br><span class="line">            BeanUtils.copyProperties(item,setmealDto);</span><br><span class="line">            //分类id</span><br><span class="line">            Long categoryId = item.getCategoryId();</span><br><span class="line">            //根据分类id查询分类对象</span><br><span class="line">            Category category = categoryService.getById(categoryId);</span><br><span class="line">            if (category != null) &#123;</span><br><span class="line">                //分类名称</span><br><span class="line">                String categoryName = category.getName();</span><br><span class="line">                setmealDto.setCategoryName(categoryName);</span><br><span class="line">            &#125;</span><br><span class="line">            return setmealDto;</span><br><span class="line">        &#125;).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        dtoPage.setRecords(list);</span><br><span class="line">        return R.success(dtoPage);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>springboot - 外卖平台</tag>
        <tag>项目开发</tag>
        <tag>mybatis plus</tag>
        <tag>套餐信息分页查询</tag>
      </tags>
  </entry>
  <entry>
    <title>外卖管理平台文件上传下载</title>
    <url>/2022/09/09/%E5%A4%96%E5%8D%96%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD/</url>
    <content><![CDATA[<h3 id="一、文件上传介绍"><a href="#一、文件上传介绍" class="headerlink" title="一、文件上传介绍"></a>一、文件上传介绍</h3><p>文件上传，也称为upload，是指将本地图片、视频、音频等文件上传到服务器上，可以供其他用户浏览或下载的过程。文件上传在项目中应用非常广泛，我们经常发微博、发微信朋友圈都用到了文件上传功能。</p>
<span id="more"></span>
<p>文件上传时，对页面的form表单有如下要求:</p>
<ul>
<li><p>method=”post”              采用post方式提交数据</p>
</li>
<li><p>enctype=”multipart/form-data”            采用multipart格式上传文件</p>
</li>
<li><p>type=”file”        使用input的file控件上传</p>
</li>
</ul>
<p>  举例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;form method=&quot;post&quot;action=&quot; /common/upload&quot; enctype=&quot;multipart/form-data&quot;&gt;&lt;input name=&quot;myFile&quot; type=&quot;file&quot;/&gt;</span><br><span class="line">&lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;&lt;/form&gt;</span><br></pre></td></tr></table></figure>
<p>目前一些前端组件库也提供了相应的上传组件，但是底层原理还是基于form表单的文件上传。例如ElementUI中提供的upload上传组件:</p>
<p><img src="https://i.p04e.com/baid/i/2022/09/09/13n.png"></p>
<p>服务端要接收客户端页面上传的文件，通常都会使用Apache的两个组件:</p>
<ul>
<li>commons-fileupload</li>
<li>commons-io</li>
</ul>
<p>Spring框架在spring-web包中对文件上传进行了封装，大大简化了服务端代码，我们只需要在Controller的方法中声明一个MultipartFile类型的参数即可接收上传的文件，例如:</p>
<p><img src="https://i.p04e.com/baid/i/2022/09/09/1oku.png"></p>
<p>文件下载，也称为download，是指将文件从服务器传输到本地计算机的过程。</p>
<p>通过浏览器进行文件下载，通常有两种表现形式:</p>
<p>以附件形式下载，弹出保存对话框，将文件保存到指定磁盘目录直接在浏览器中打开</p>
<p>通过浏览器进行文件下载，本质上就是服务端将文件以流的形式写回浏览器的过程。</p>
<p>文件上传，页面端可以使用ElementUI提供的上传组件。</p>
<p>可以直接使用资料中提供的上传页面，位置:资料/文件上传下载页面/upload.html</p>
<p><img src="https://i.p04e.com/baid/i/2022/09/09/3h39j.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.controller;</span><br><span class="line"></span><br><span class="line">import com.itheima.reggie.common.R;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.beans.factory.annotation.Value;</span><br><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line">import org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line">import org.springframework.web.multipart.MultipartFile;</span><br><span class="line"></span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.UUID;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 文件上传和下载</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/common&quot;)</span><br><span class="line">@Slf4j</span><br><span class="line">public class CommonController &#123;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;reggie.path&#125;&quot;)</span><br><span class="line">    private String basePath;</span><br><span class="line">    /**</span><br><span class="line">     * 文件上传</span><br><span class="line">     * @param file</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @PostMapping(&quot;/upload&quot;)</span><br><span class="line">    public R&lt;String&gt; upload (MultipartFile file) &#123;</span><br><span class="line">        //file是一个临时文件，需要转存到指定位置，否则本次请求完成后临时文件将被删除</span><br><span class="line">        log.info(file.toString());</span><br><span class="line"></span><br><span class="line">        //获得原始文件名</span><br><span class="line">        String originalFilename = file.getOriginalFilename();</span><br><span class="line">        String suffix = originalFilename.substring((originalFilename.lastIndexOf(&quot;.&quot;)));</span><br><span class="line"></span><br><span class="line">        //使用UUID重新生成文件名，防止文件名称重复造成文件覆盖</span><br><span class="line">        String fileName = UUID.randomUUID().toString() + suffix;</span><br><span class="line"></span><br><span class="line">        //创建一个目录对象</span><br><span class="line">        File dir = new File(basePath);</span><br><span class="line">        //判断目录是否存在</span><br><span class="line">        if (!dir.exists()) &#123;</span><br><span class="line">            //目录不存在需要创建</span><br><span class="line">            dir.mkdir();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            file.transferTo(new File(basePath + fileName));</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return R.success(fileName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="二、文件上传下载"><a href="#二、文件上传下载" class="headerlink" title="二、文件上传下载"></a>二、文件上传下载</h3><p><code>文件下载代码实现</code></p>
<p>文件下载，页面端可以使用<img>标签展示下载的图片</p>
<p><img v-if="imageUrl" :src="imageUr1" class="avatar"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">handleAvatarSuccess (response，file，fileList) &#123;</span><br><span class="line">this. imageUrl =`/common/download?name=$ &#123;response.data&#125;`</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 文件下载</span><br><span class="line"> * @param name</span><br><span class="line"> * @param response</span><br><span class="line"> */</span><br><span class="line">@GetMapping(&quot;/download&quot;)</span><br><span class="line">public void downLoad(String name, HttpServletResponse response) &#123;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        //输入流，通过输入流读取文件内容</span><br><span class="line"></span><br><span class="line">        FileInputStream fileInputStream = new FileInputStream(new File(basePath + name));</span><br><span class="line"></span><br><span class="line">        //通过输出流将文件写回浏览器，在浏览器展示图片</span><br><span class="line"></span><br><span class="line">        ServletOutputStream outputStream = response.getOutputStream();</span><br><span class="line"></span><br><span class="line">        response.setContentType(&quot;image/jpeg&quot;);</span><br><span class="line"></span><br><span class="line">        int len = 0;</span><br><span class="line">        byte[] bytes = new byte[1024];</span><br><span class="line">        while ( (len = fileInputStream.read(bytes)) != -1) &#123;</span><br><span class="line">            outputStream.write(bytes,0,len);</span><br><span class="line">            outputStream.flush();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //关闭资源</span><br><span class="line">        outputStream.close();</span><br><span class="line">        fileInputStream.close();</span><br><span class="line"></span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>springboot - 外卖平台</tag>
        <tag>项目开发</tag>
        <tag>mybatis plus</tag>
        <tag>文件上传下载</tag>
      </tags>
  </entry>
  <entry>
    <title>外卖管理平台新增套餐</title>
    <url>/2022/09/13/%E5%A4%96%E5%8D%96%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0%E6%96%B0%E5%A2%9E%E5%A5%97%E9%A4%90/</url>
    <content><![CDATA[<h3 id="一、需求分析"><a href="#一、需求分析" class="headerlink" title="一、需求分析"></a>一、需求分析</h3><p>套餐就是菜品的集合。</p>
<p>后台系统中可以管理套餐信息，通过新增套餐功能来添加一个新的套餐，在添加套餐时需要选择当前套餐所属的套餐分类和包含的菜品，并且需要上传套餐对应的图片，在移动端会按照套餐分类来展示对应的套餐。</p>
<span id="more"></span>
<h4 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h4><p>新增套餐，其实就是将新增页面录入的套餐信息插入到setmeal表，还需要向setmeal_dish表插入套餐和菜品关联数据。</p>
<p>所以在新增套餐时，涉及到两个表:</p>
<p>setmeal    套餐表</p>
<p>setmeal_dish套餐菜品关系表</p>
<h3 id="二、代码开发-准备工作"><a href="#二、代码开发-准备工作" class="headerlink" title="二、代码开发 - 准备工作"></a>二、代码开发 - 准备工作</h3><p>在开发业务功能前,先将需要用到的类和接口基本结构创建好:</p>
<ul>
<li>实体类SetmealDish</li>
<li>DTO SetmealDto</li>
<li>Mapper接口SetmealDishMapper</li>
<li>业务层接口SetmealDishService</li>
<li>业务层实现类SetmealDishServicelmpl</li>
<li>控制层SetmealController</li>
</ul>
<h4 id="梳理交互过程"><a href="#梳理交互过程" class="headerlink" title="梳理交互过程"></a>梳理交互过程</h4><p>在开发代码之前，需要梳理一下新增套餐时前端页面和服务端的交互过程:</p>
<p>1、页面(backend/page/comboladd.html)发送ajax请求，请求服务端获取套餐分类数据并展示到下拉框中2、页面发送ajax请求，请求服务端获取菜品分类数据并展示到添加菜品窗口中</p>
<p>3、页面发送ajax请求，请求服务端，根据菜品分类查询对应的菜品数据并展示到添加菜品窗口中</p>
<p>4、页面发送请求进行图片上传，请求服务端将图片保存到服务器</p>
<p>5、页面发送请求进行图片下载，将上传的图片进行回显</p>
<p>6、点击保存按钮，发送ajax请求，将套餐相关数据以json形式提交到服务端</p>
<p>开发新增套餐功能，其实就是在服务端编写代码去处理前端页面发送的这6次请求即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 根据条件查询对应的菜品数据</span><br><span class="line"> * @param dish</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">@GetMapping(&quot;/list&quot;)</span><br><span class="line">public R&lt;List&lt;Dish&gt;&gt; list(Dish dish) &#123;</span><br><span class="line"></span><br><span class="line">    //构造查询条件</span><br><span class="line">    LambdaQueryWrapper&lt;Dish&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">    queryWrapper.eq(dish.getCategoryId() != null , Dish::getCategoryId, dish.getCategoryId());</span><br><span class="line">    //查询状态为1</span><br><span class="line">    queryWrapper.eq(Dish::getStatus,1);</span><br><span class="line">    //添加一个排序条件</span><br><span class="line">    queryWrapper.orderByAsc(Dish::getSort).orderByDesc(Dish::getUpdateTime);</span><br><span class="line"></span><br><span class="line">    List&lt;Dish&gt; list = dishService.list(queryWrapper);</span><br><span class="line">    return R.success(list);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.controller;</span><br><span class="line"></span><br><span class="line">import com.itheima.reggie.common.R;</span><br><span class="line">import com.itheima.reggie.dto.SetmealDto;</span><br><span class="line">import com.itheima.reggie.service.CategoryService;</span><br><span class="line">import com.itheima.reggie.service.SetmealDishService;</span><br><span class="line">import com.itheima.reggie.service.SetmealService;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestBody;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 套餐管理</span><br><span class="line"> */</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/setmeal&quot;)</span><br><span class="line">@Slf4j</span><br><span class="line">public class SetmealController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private SetmealService setmealService;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private CategoryService categoryService;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private SetmealDishService setmealDishService;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 新增套餐</span><br><span class="line">     * @param setmealDto</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @PostMapping</span><br><span class="line">    public R&lt;String&gt; save(@RequestBody SetmealDto setmealDto)&#123;</span><br><span class="line">        log.info(&quot;套餐信息：&#123;&#125;&quot;,setmealDto);</span><br><span class="line"></span><br><span class="line">        setmealService.saveWithDish(setmealDto);</span><br><span class="line"></span><br><span class="line">        return R.success(&quot;新增套餐成功&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.service;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.extension.service.IService;</span><br><span class="line">import com.itheima.reggie.dto.SetmealDto;</span><br><span class="line">import com.itheima.reggie.entity.Setmeal;</span><br><span class="line"></span><br><span class="line">public interface SetmealService extends IService&lt;Setmeal&gt; &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 新增套餐，同时需要保存套餐和菜品的关系</span><br><span class="line">     * @param setmealDto</span><br><span class="line">     */</span><br><span class="line">    public void saveWithDish(SetmealDto setmealDto);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.service.impl;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;</span><br><span class="line">import com.itheima.reggie.dto.SetmealDto;</span><br><span class="line">import com.itheima.reggie.entity.Setmeal;</span><br><span class="line">import com.itheima.reggie.entity.SetmealDish;</span><br><span class="line">import com.itheima.reggie.mapper.SetmealMapper;</span><br><span class="line">import com.itheima.reggie.service.SetmealDishService;</span><br><span class="line">import com.itheima.reggie.service.SetmealService;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line">import org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">@Slf4j</span><br><span class="line">public class SetmealServiceImpl extends ServiceImpl&lt;SetmealMapper, Setmeal&gt; implements SetmealService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private SetmealDishService setmealDishService;</span><br><span class="line">    /**</span><br><span class="line">     * 新增套餐，同时需要保存套餐和菜品的关系</span><br><span class="line">     * @param setmealDto</span><br><span class="line">     */</span><br><span class="line">    @Transactional</span><br><span class="line">    public void saveWithDish(SetmealDto setmealDto) &#123;</span><br><span class="line">        //保存套餐的基本信息，执行insert操作</span><br><span class="line">        this.save(setmealDto);</span><br><span class="line">        List&lt;SetmealDish&gt; setmealDishes = setmealDto.getSetmealDishes();</span><br><span class="line">        setmealDishes.stream().map((item) -&gt; &#123;</span><br><span class="line">            item.setSetmealId(setmealDto.getId());</span><br><span class="line">            return item;</span><br><span class="line">        &#125;).collect(Collectors.toList());</span><br><span class="line">        //保存套餐和菜品的关联信息，操作setmeal_dish,执行insert操作</span><br><span class="line">        setmealDishService.saveBatch(setmealDishes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>springboot - 外卖平台</tag>
        <tag>项目开发</tag>
        <tag>mybatis plus</tag>
        <tag>新增套餐</tag>
      </tags>
  </entry>
  <entry>
    <title>外卖管理平台新增菜品</title>
    <url>/2022/09/10/%E5%A4%96%E5%8D%96%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0%E6%96%B0%E5%A2%9E%E8%8F%9C%E5%93%81/</url>
    <content><![CDATA[<h3 id="一、需求分析"><a href="#一、需求分析" class="headerlink" title="一、需求分析"></a>一、需求分析</h3><p>后台系统中可以管理菜品信息，通过新增功能来添加一个新的菜品，在添加菜品时需要选择当前菜品所属的菜品分类，并且需要上传菜品图片，在移动端会按照菜品分类来展示对应的菜品信息。</p>
<span id="more"></span>
<h4 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h4><p>新增菜品，其实就是将新增页面录入的菜品信息插入到dish表，如果添加了口味做法，还需要向dish_flavor表插入数据.所以在新增菜品时，涉及到两个表:</p>
<ul>
<li>dish    菜品表</li>
<li>dish_flavor菜品口味表</li>
</ul>
<h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><p>在开发业务功能前，先将需要用到的类和接口基本结构创建好︰</p>
<ul>
<li>实体类DishFlavor</li>
<li>Mapper接口DishFlavorMapper</li>
<li>业务层接口DishFlavorService</li>
<li>业务层实现类DishFlavorServicelmpl控制层DishController</li>
</ul>
<h3 id="二、代码开发-梳理交互过程"><a href="#二、代码开发-梳理交互过程" class="headerlink" title="二、代码开发-梳理交互过程"></a>二、代码开发-梳理交互过程</h3><p>在开发代码之前，需要梳理一下新增菜品时前端页面和服务端的交互过程:</p>
<p>代码开发-梳理交互过程<br>在开发代码之前，需要梳理一下新增菜品时前端页面和服务端的交互过程:</p>
<p> 1、页面(backend/page/food/add.html)发送ajax请求，请求服务端获取菜品分类数据并展示到下拉框中</p>
<p>2、页面发送请求进行图片上传，请求服务端将图片保存到服务器<br>3、页面发送请求进行图片下载，将上传的图片进行回显<br>4、点击保存按钮，发送ajax请求，将菜品相关数据以json形式提交到服务端</p>
<p><code>开发新增菜品功能，其实就是在服务端编写代码去处理前端页面发送的这4次请求即可。</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据条件查询分类数据</span><br><span class="line">     * @param category</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @GetMapping(&quot;/list&quot;)</span><br><span class="line">    public R&lt;List&lt;Category&gt;&gt; list(Category category) &#123;</span><br><span class="line">        //条件构造器</span><br><span class="line">LambdaQueryWrapper&lt;Category&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">        //添加条件</span><br><span class="line">queryWrapper.eq(category.getType() != null, Category::getType, category.getType());</span><br><span class="line">        //添加排序条件</span><br><span class="line">        queryWrapper.orderByAsc(Category::getSort).orderByDesc(Category::getUpdateTime);</span><br><span class="line"></span><br><span class="line">        List&lt;Category&gt; list = categoryService.list(queryWrapper);</span><br><span class="line">        return R.success(list);</span><br></pre></td></tr></table></figure>
<h4 id="导入DTO"><a href="#导入DTO" class="headerlink" title="导入DTO"></a>导入DTO</h4><p>导入DishDto，用于封装页面提交的数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class DishDto extends Dish &#123;</span><br><span class="line">private List&lt;DishFlavor&gt; flavors = new ArrayList&lt;&gt; () ;</span><br><span class="line">private String categoryName;</span><br><span class="line">private Integer copies;</span><br></pre></td></tr></table></figure>
<p><code>注意事项</code><br><code>DTO，全称为Data Transfer Object，即数据传输对象，一般用于展示层与服务层之同的数据传输。</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.dto;</span><br><span class="line"></span><br><span class="line">import com.itheima.reggie.entity.Dish;</span><br><span class="line">import com.itheima.reggie.entity.DishFlavor;</span><br><span class="line">import lombok.Data;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">@Data</span><br><span class="line">public class DishDto extends Dish &#123;</span><br><span class="line"></span><br><span class="line">    private List&lt;DishFlavor&gt; flavors = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    private String categoryName;</span><br><span class="line"></span><br><span class="line">    private Integer copies;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.controller;</span><br><span class="line"></span><br><span class="line">import com.itheima.reggie.common.R;</span><br><span class="line">import com.itheima.reggie.dto.DishDto;</span><br><span class="line">import com.itheima.reggie.service.DishFlavorService;</span><br><span class="line">import com.itheima.reggie.service.DishService;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestBody;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/dish&quot;)</span><br><span class="line">@Slf4j</span><br><span class="line">public class DishController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private DishService dishService;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private DishFlavorService dishFlavorService;</span><br><span class="line"></span><br><span class="line">    @PostMapping</span><br><span class="line">    public R&lt;String&gt; save(@RequestBody DishDto dishDto) &#123;</span><br><span class="line"></span><br><span class="line">        log.info(dishDto.toString());</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.service.impl;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;</span><br><span class="line">import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;</span><br><span class="line">import com.itheima.reggie.dto.DishDto;</span><br><span class="line">import com.itheima.reggie.entity.Dish;</span><br><span class="line">import com.itheima.reggie.entity.DishFlavor;</span><br><span class="line">import com.itheima.reggie.mapper.DishMapper;</span><br><span class="line">import com.itheima.reggie.service.DishFlavorService;</span><br><span class="line">import com.itheima.reggie.service.DishService;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.beans.BeanUtils;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line">import org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line">import java.util.Collections;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">@Slf4j</span><br><span class="line">public class DishServiceImpl extends ServiceImpl&lt;DishMapper,Dish&gt; implements DishService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private DishFlavorService dishFlavorService;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 新增菜品，同时保存对应的口味数据</span><br><span class="line">     * @param dishDto</span><br><span class="line">     */</span><br><span class="line">    @Transactional</span><br><span class="line">    public void saveWithFlavor(DishDto dishDto) &#123;</span><br><span class="line">        //保存菜品的基本信息到菜品表dish</span><br><span class="line">        this.save(dishDto);</span><br><span class="line"></span><br><span class="line">        Long dishId = dishDto.getId();//菜品id</span><br><span class="line"></span><br><span class="line">        //菜品口味</span><br><span class="line">        List&lt;DishFlavor&gt; flavors = dishDto.getFlavors();</span><br><span class="line">        flavors = flavors.stream().map((item) -&gt; &#123;</span><br><span class="line">            item.setDishId(dishId);</span><br><span class="line">            return item;</span><br><span class="line">        &#125;).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        //保存菜品口味数据到菜品口味表dish_flavor</span><br><span class="line">        dishFlavorService.saveBatch(flavors);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据id查询菜品信息和对应的口味信息</span><br><span class="line">     * @param id</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public DishDto getByIdWithFlavor(Long id) &#123;</span><br><span class="line">        //查询菜品基本信息，从dish表查询</span><br><span class="line">        Dish dish = this.getById(id);</span><br><span class="line"></span><br><span class="line">        DishDto dishDto = new DishDto();</span><br><span class="line">        BeanUtils.copyProperties(dish,dishDto);</span><br><span class="line"></span><br><span class="line">        //查询当前菜品对应的口味信息，从dish_flavor表查询</span><br><span class="line">        LambdaQueryWrapper&lt;DishFlavor&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">        queryWrapper.eq(DishFlavor::getDishId,dish.getId());</span><br><span class="line">        List&lt;DishFlavor&gt; flavors = dishFlavorService.list(queryWrapper);</span><br><span class="line">        dishDto.setFlavors(flavors);</span><br><span class="line"></span><br><span class="line">        return dishDto;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Transactional</span><br><span class="line">    public void updateWithFlavor(DishDto dishDto) &#123;</span><br><span class="line">        //更新dish表基本信息</span><br><span class="line">        this.updateById(dishDto);</span><br><span class="line"></span><br><span class="line">        //清理当前菜品对应口味数据---dish_flavor表的delete操作</span><br><span class="line">        LambdaQueryWrapper&lt;DishFlavor&gt; queryWrapper = new LambdaQueryWrapper();</span><br><span class="line">        queryWrapper.eq(DishFlavor::getDishId,dishDto.getId());</span><br><span class="line"></span><br><span class="line">        dishFlavorService.remove(queryWrapper);</span><br><span class="line"></span><br><span class="line">        //添加当前提交过来的口味数据---dish_flavor表的insert操作</span><br><span class="line">        List&lt;DishFlavor&gt; flavors = dishDto.getFlavors();</span><br><span class="line"></span><br><span class="line">        flavors = flavors.stream().map((item) -&gt; &#123;</span><br><span class="line">            item.setDishId(dishDto.getId());</span><br><span class="line">            return item;</span><br><span class="line">        &#125;).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        dishFlavorService.saveBatch(flavors);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.controller;</span><br><span class="line"></span><br><span class="line">import com.itheima.reggie.common.R;</span><br><span class="line">import com.itheima.reggie.dto.DishDto;</span><br><span class="line">import com.itheima.reggie.service.DishFlavorService;</span><br><span class="line">import com.itheima.reggie.service.DishService;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestBody;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/dish&quot;)</span><br><span class="line">@Slf4j</span><br><span class="line">public class DishController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private DishService dishService;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private DishFlavorService dishFlavorService;</span><br><span class="line"></span><br><span class="line">    @PostMapping</span><br><span class="line">    public R&lt;String&gt; save(@RequestBody DishDto dishDto) &#123;</span><br><span class="line"></span><br><span class="line">        log.info(dishDto.toString());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        dishService.saveWithFlavor(dishDto);</span><br><span class="line">        return R.success(&quot;新增菜品成功&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line">import org.springframework.boot.web.servlet.ServletComponentScan;</span><br><span class="line">import org.springframework.transaction.annotation.EnableTransactionManagement;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Slf4j</span><br><span class="line">@SpringBootApplication</span><br><span class="line">@ServletComponentScan</span><br><span class="line">@EnableTransactionManagement</span><br><span class="line">public class ReggieApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(ReggieApplication.class,args);</span><br><span class="line">        log.info(&quot;项目启动成功...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>springboot - 外卖平台</tag>
        <tag>项目开发</tag>
        <tag>mybatis plus</tag>
        <tag>新增菜品</tag>
      </tags>
  </entry>
  <entry>
    <title>外卖管理平台短信发送</title>
    <url>/2022/09/14/%E5%A4%96%E5%8D%96%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0%E7%9F%AD%E4%BF%A1%E5%8F%91%E9%80%81/</url>
    <content><![CDATA[<h3 id="一、短信服务介绍"><a href="#一、短信服务介绍" class="headerlink" title="一、短信服务介绍"></a>一、短信服务介绍</h3><p>目前市面上有很多第三方提供的短信服务，这些第三方短信服务会和各个运营商（移动、联通、电信）对接，我们只需要注册成为会员并且按照提供的开发文档进行调用就可以发送短信。需要说明的是，这些短信服务一般都是收费服务。</p>
<span id="more"></span>
<p>常用短信服务:</p>
<ul>
<li>阿里云</li>
<li>华为云</li>
<li>腾讯云</li>
<li>京东</li>
<li>梦网</li>
<li>乐信</li>
</ul>
<h4 id="阿里云短信服务-介绍"><a href="#阿里云短信服务-介绍" class="headerlink" title="阿里云短信服务-介绍"></a>阿里云短信服务-介绍</h4><p>阿里云短信服务（Short Message Service)是广大企业客户快速触达手机用户所优选使用的通信能力。调用API或用群发助手，即可发送验证码、通知类和营销类短信;国内验证短信秒级触达，到达率最高可达99%;国际/港澳台短信覆盖200多个国家和地区，安全稳定，广受出海企业选用。</p>
<p>应用场景:</p>
<ul>
<li>验证码</li>
<li>短信通知</li>
<li>推广短信</li>
</ul>
<h4 id="阿里云短信服务-注册账号"><a href="#阿里云短信服务-注册账号" class="headerlink" title="阿里云短信服务-注册账号"></a>阿里云短信服务-注册账号</h4><p>阿里云官网: https:// www.aliyun.com/</p>
<p>点击官网首页注册按钮，跳转到如下注册页面:</p>
<p><img src="https://i.p04e.com/baid/i/2022/09/18/uub.png"></p>
<h4 id="阿里云短信服务-设置短信签名"><a href="#阿里云短信服务-设置短信签名" class="headerlink" title="阿里云短信服务-设置短信签名"></a>阿里云短信服务-设置短信签名</h4><p>注册成功后，点击登录按钮进行登录。登录后进入短信服务管理页面，选择国内消息菜单:</p>
<p><img src="https://i.p04e.com/baid/i/2022/09/18/n3tp.png"></p>
<p>短信签名是短信发送者的署名，表示发送方的身份。</p>
<h4 id="阿里云短信服务-设置短信模板"><a href="#阿里云短信服务-设置短信模板" class="headerlink" title="阿里云短信服务-设置短信模板"></a>阿里云短信服务-设置短信模板</h4><p>切换到【模板管理】标签页:</p>
<p><img src="https://i.p04e.com/baid/i/2022/09/18/y3t7.png"></p>
<h4 id="阿里云短信服务-设置AccessKey"><a href="#阿里云短信服务-设置AccessKey" class="headerlink" title="阿里云短信服务-设置AccessKey"></a>阿里云短信服务-设置AccessKey</h4><p>光标移动到用户头像上，在弹出的窗口中点击【AccessKey管理】∶</p>
<p><img src="https://i.p04e.com/baid/i/2022/09/18/2r.png"></p>
<p>选择子用户。</p>
<p>使用阿里云短信服务发送短信，可以参照官方提供的<a href="https://help.aliyun.com/product/44282.html?spm=5176.25163407.help.dexternal.51a7bb6e9O0uQU">文档</a>即可。</p>
<p>具体开发步骤:</p>
<p>1、导入maven坐标</p>
<p>2、调用API</p>
<p><img src="https://i.p04e.com/baid/i/2022/09/18/9m94.png"></p>
<h3 id="二、需求分析"><a href="#二、需求分析" class="headerlink" title="二、需求分析"></a>二、需求分析</h3><p>为了方便用户登录，移动端通常都会提供通过手机验证码登录的功能。<br>心</p>
<p>手机验证码登录的优点:</p>
<ul>
<li>方便快捷，无需注册，直接登录</li>
<li>使用短信验证码作为登录凭证，无需记忆密码</li>
<li>安全<br>登录流程:<br>输入手机号&gt;获取验证码&gt;输入验证码&gt;点击登录&gt;登录成功<br><code>注意:通过手机验证码登录，手机号是区分不同用户的标识。</code></li>
</ul>
<h4 id="三、代码开发-梳理交互过程"><a href="#三、代码开发-梳理交互过程" class="headerlink" title="三、代码开发-梳理交互过程"></a>三、代码开发-梳理交互过程</h4><p>在开发代码之前，需要梳理一下登录时前端页面和服务端的交互过程:</p>
<p>1、在登录页面(front/page/login.html)输入手机号，点击【获取验证码】按钮，页面发送ajax请求，在服务端调用短信服务API给指定手机号发送验证码短信</p>
<p>2、在登录页面输入验证码，点击【登录】按钮，发送ajax请求，在服务端处理登录请求</p>
<p>开发手机验证码登录功能，其实就是在服务端编写代码去处理前端页面发送的这2次请求即可。</p>
<h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><p>在开发业务功能前，先将需要用到的类和接口基本结构创建好:实体类User（</p>
<p>Mapper接口UserMapper</p>
<p>业务层接口UserService</p>
<p>业务层实现类UserServicelmpl控制层Usercontroller</p>
<p>工具类SMSutils、ValidateCodeutils</p>
<h4 id="代码开发-修改LoginCheckFilter"><a href="#代码开发-修改LoginCheckFilter" class="headerlink" title="代码开发-修改LoginCheckFilter"></a>代码开发-修改LoginCheckFilter</h4><p>前面我们已经完成了LoginCheckFilter过滤器的开发，此过滤器用于检查用户的登录状态。我们在进行手机验证码登录时，发送的请求需要在此过滤器处理时直接放行。</p>
<p><img src="https://i.p04e.com/baid/i/2022/09/18/d0i.png"></p>
<p>在LoginCheckFilter过滤器中扩展逻辑，判断移动端用户登录状态:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//4-1、判断登录状态，如果已登录，则直接放行</span><br><span class="line">        if(request.getSession().getAttribute(&quot;employee&quot;) != null)&#123;</span><br><span class="line">            log.info(&quot;用户已登录，用户id为：&#123;&#125;&quot;,request.getSession().getAttribute(&quot;employee&quot;));</span><br><span class="line"></span><br><span class="line">            Long empId = (Long) request.getSession().getAttribute(&quot;employee&quot;);</span><br><span class="line">            BaseContext.setCurrentId(empId);</span><br><span class="line"></span><br><span class="line">            filterChain.doFilter(request,response);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //4-2、判断登录状态，如果已登录，则直接放行</span><br><span class="line">        if(request.getSession().getAttribute(&quot;user&quot;) != null)&#123;</span><br><span class="line">            log.info(&quot;用户已登录，用户id为：&#123;&#125;&quot;,request.getSession().getAttribute(&quot;user&quot;));</span><br><span class="line"></span><br><span class="line">            Long userId = (Long) request.getSession().getAttribute(&quot;user&quot;);</span><br><span class="line">            BaseContext.setCurrentId(userId);</span><br><span class="line"></span><br><span class="line">            filterChain.doFilter(request,response);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        log.info(&quot;用户未登录&quot;);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.controller;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;</span><br><span class="line">import com.itheima.reggie.common.R;</span><br><span class="line">import com.itheima.reggie.entity.User;</span><br><span class="line">import com.itheima.reggie.service.UserService;</span><br><span class="line">import com.itheima.reggie.utils.ValidateCodeUtils;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.apache.commons.lang.StringUtils;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestBody;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">import javax.servlet.http.HttpSession;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/user&quot;)</span><br><span class="line">@Slf4j</span><br><span class="line">public class UserController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private UserService userService;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 发送手机短信验证码</span><br><span class="line">     * @param user</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @PostMapping(&quot;/sendMsg&quot;)</span><br><span class="line">    public R&lt;String&gt; sendMsg(@RequestBody User user, HttpSession session)&#123;</span><br><span class="line">        //获取手机号</span><br><span class="line">        String phone = user.getPhone();</span><br><span class="line"></span><br><span class="line">        if(StringUtils.isNotEmpty(phone))&#123;</span><br><span class="line">            //生成随机的4位验证码</span><br><span class="line">            String code = ValidateCodeUtils.generateValidateCode(4).toString();</span><br><span class="line">            log.info(&quot;code=&#123;&#125;&quot;,code);</span><br><span class="line"></span><br><span class="line">            //调用阿里云提供的短信服务API完成发送短信</span><br><span class="line">            //SMSUtils.sendMessage(&quot;瑞吉外卖&quot;,&quot;&quot;,phone,code);</span><br><span class="line"></span><br><span class="line">            //需要将生成的验证码保存到Session</span><br><span class="line">            session.setAttribute(phone,code);</span><br><span class="line"></span><br><span class="line">            return R.success(&quot;手机验证码短信发送成功&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return R.error(&quot;短信发送失败&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 移动端用户登录</span><br><span class="line">     * @param map</span><br><span class="line">     * @param session</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @PostMapping(&quot;/login&quot;)</span><br><span class="line">    public R&lt;User&gt; login(@RequestBody Map map, HttpSession session)&#123;</span><br><span class="line">        log.info(map.toString());</span><br><span class="line"></span><br><span class="line">        //获取手机号</span><br><span class="line">        String phone = map.get(&quot;phone&quot;).toString();</span><br><span class="line"></span><br><span class="line">        //获取验证码</span><br><span class="line">        String code = map.get(&quot;code&quot;).toString();</span><br><span class="line"></span><br><span class="line">        //从Session中获取保存的验证码</span><br><span class="line">        Object codeInSession = session.getAttribute(phone);</span><br><span class="line"></span><br><span class="line">        //进行验证码的比对（页面提交的验证码和Session中保存的验证码比对）</span><br><span class="line">        if(codeInSession != null &amp;&amp; codeInSession.equals(code))&#123;</span><br><span class="line">            //如果能够比对成功，说明登录成功</span><br><span class="line"></span><br><span class="line">            LambdaQueryWrapper&lt;User&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">            queryWrapper.eq(User::getPhone,phone);</span><br><span class="line"></span><br><span class="line">            User user = userService.getOne(queryWrapper);</span><br><span class="line">            if(user == null)&#123;</span><br><span class="line">                //判断当前手机号对应的用户是否为新用户，如果是新用户就自动完成注册</span><br><span class="line">                user = new User();</span><br><span class="line">                user.setPhone(phone);</span><br><span class="line">                user.setStatus(1);</span><br><span class="line">                userService.save(user);</span><br><span class="line">            &#125;</span><br><span class="line">            session.setAttribute(&quot;user&quot;,user.getId());</span><br><span class="line">            return R.success(user);</span><br><span class="line">        &#125;</span><br><span class="line">        return R.error(&quot;登录失败&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>springboot - 外卖平台</tag>
        <tag>项目开发</tag>
        <tag>mybatis plus</tag>
        <tag>短信发送</tag>
      </tags>
  </entry>
  <entry>
    <title>外卖管理平台用户下单</title>
    <url>/2022/09/19/%E5%A4%96%E5%8D%96%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0%E7%94%A8%E6%88%B7%E4%B8%8B%E5%8D%95/</url>
    <content><![CDATA[<h3 id="一、需求分析"><a href="#一、需求分析" class="headerlink" title="一、需求分析"></a>一、需求分析</h3><p>移动端用户将菜品或者套餐加入购物车后，可以点击购物车中的去结算按钮，页面跳转到订单确认页面，点<br>击去支付按钮则完成下单操作。</p>
<span id="more"></span>
<h4 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h4><p>用户下单业务对应的数据表为orders表和order_detail表:</p>
<ul>
<li>orders:订单表</li>
<li>order_detail:订单明细表</li>
</ul>
<h3 id="二、代码开发-梳理交互过程"><a href="#二、代码开发-梳理交互过程" class="headerlink" title="二、代码开发-梳理交互过程"></a>二、代码开发-梳理交互过程</h3><p>在开发代码之前，需要梳理一下用户下单操作时前端页面和服务端的交互过程:</p>
<p>1、在购物车中点击按钮，页面跳转到订单确认页面</p>
<p>2、在订单确认页面，发送ajax请求，请求服务端获取当前登录用户的默认地址</p>
<p>3、在订单确认页面，发送ajax请求，请求服务端获取当前登录用户的购物车数据</p>
<p>4、在订单确认页面点击去支付按钮，发送ajax请求，请求服务端完成下单操作</p>
<p>开发用户下单功能，其实就是在服务端编写代码去处理前端页面发送的请求即可。</p>
<h4 id="代码开发-准备工作"><a href="#代码开发-准备工作" class="headerlink" title="代码开发-准备工作"></a>代码开发-准备工作</h4><p>在开发业务功能前，先将需要用到的类和接口基本结构创建好:</p>
<ul>
<li>实体类Orders、OrderDetail </li>
<li>Mapper接口OrderMapper、OrderDetailMapper</li>
<li>业务层接口OrderService.OrderDetailService</li>
<li>业务层实现类QrderServicelmpl、OrderDetailServicelmpl</li>
<li>控制层OrderController、OrderDetailController</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.controller;</span><br><span class="line"></span><br><span class="line">import com.itheima.reggie.common.R;</span><br><span class="line">import com.itheima.reggie.entity.Orders;</span><br><span class="line">import com.itheima.reggie.service.OrderService;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestBody;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 订单</span><br><span class="line"> */</span><br><span class="line">@Slf4j</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/order&quot;)</span><br><span class="line">public class OrderController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private OrderService orderService;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 用户下单</span><br><span class="line">     * @param orders</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @PostMapping(&quot;/submit&quot;)</span><br><span class="line">    public R&lt;String&gt; submit(@RequestBody Orders orders)&#123;</span><br><span class="line">        log.info(&quot;订单数据：&#123;&#125;&quot;,orders);</span><br><span class="line">        orderService.submit(orders);</span><br><span class="line">        return R.success(&quot;下单成功&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.service;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.extension.service.IService;</span><br><span class="line">import com.itheima.reggie.entity.Orders;</span><br><span class="line"></span><br><span class="line">public interface OrderService extends IService&lt;Orders&gt; &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 用户下单</span><br><span class="line">     * @param orders</span><br><span class="line">     */</span><br><span class="line">    public void submit(Orders orders);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.service.impl;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;</span><br><span class="line">import com.baomidou.mybatisplus.core.toolkit.IdWorker;</span><br><span class="line">import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;</span><br><span class="line">import com.itheima.reggie.common.BaseContext;</span><br><span class="line">import com.itheima.reggie.common.CustomException;</span><br><span class="line">import com.itheima.reggie.entity.*;</span><br><span class="line">import com.itheima.reggie.mapper.OrderMapper;</span><br><span class="line">import com.itheima.reggie.service.*;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line">import org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line">import java.math.BigDecimal;</span><br><span class="line">import java.time.LocalDateTime;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line">import java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">@Slf4j</span><br><span class="line">public class OrderServiceImpl extends ServiceImpl&lt;OrderMapper, Orders&gt; implements OrderService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private ShoppingCartService shoppingCartService;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private UserService userService;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private AddressBookService addressBookService;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private OrderDetailService orderDetailService;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 用户下单</span><br><span class="line">     * @param orders</span><br><span class="line">     */</span><br><span class="line">    @Transactional</span><br><span class="line">    public void submit(Orders orders) &#123;</span><br><span class="line">        //获得当前用户id</span><br><span class="line">        Long userId = BaseContext.getCurrentId();</span><br><span class="line"></span><br><span class="line">        //查询当前用户的购物车数据</span><br><span class="line">        LambdaQueryWrapper&lt;ShoppingCart&gt; wrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">        wrapper.eq(ShoppingCart::getUserId,userId);</span><br><span class="line">        List&lt;ShoppingCart&gt; shoppingCarts = shoppingCartService.list(wrapper);</span><br><span class="line"></span><br><span class="line">        if(shoppingCarts == null || shoppingCarts.size() == 0)&#123;</span><br><span class="line">            throw new CustomException(&quot;购物车为空，不能下单&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //查询用户数据</span><br><span class="line">        User user = userService.getById(userId);</span><br><span class="line"></span><br><span class="line">        //查询地址数据</span><br><span class="line">        Long addressBookId = orders.getAddressBookId();</span><br><span class="line">        AddressBook addressBook = addressBookService.getById(addressBookId);</span><br><span class="line">        if(addressBook == null)&#123;</span><br><span class="line">            throw new CustomException(&quot;用户地址信息有误，不能下单&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        long orderId = IdWorker.getId();//订单号</span><br><span class="line"></span><br><span class="line">        AtomicInteger amount = new AtomicInteger(0);</span><br><span class="line"></span><br><span class="line">        List&lt;OrderDetail&gt; orderDetails = shoppingCarts.stream().map((item) -&gt; &#123;</span><br><span class="line">            OrderDetail orderDetail = new OrderDetail();</span><br><span class="line">            orderDetail.setOrderId(orderId);</span><br><span class="line">            orderDetail.setNumber(item.getNumber());</span><br><span class="line">            orderDetail.setDishFlavor(item.getDishFlavor());</span><br><span class="line">            orderDetail.setDishId(item.getDishId());</span><br><span class="line">            orderDetail.setSetmealId(item.getSetmealId());</span><br><span class="line">            orderDetail.setName(item.getName());</span><br><span class="line">            orderDetail.setImage(item.getImage());</span><br><span class="line">            orderDetail.setAmount(item.getAmount());</span><br><span class="line">            amount.addAndGet(item.getAmount().multiply(new BigDecimal(item.getNumber())).intValue());</span><br><span class="line">            return orderDetail;</span><br><span class="line">        &#125;).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        orders.setId(orderId);</span><br><span class="line">        orders.setOrderTime(LocalDateTime.now());</span><br><span class="line">        orders.setCheckoutTime(LocalDateTime.now());</span><br><span class="line">        orders.setStatus(2);</span><br><span class="line">        orders.setAmount(new BigDecimal(amount.get()));//总金额</span><br><span class="line">        orders.setUserId(userId);</span><br><span class="line">        orders.setNumber(String.valueOf(orderId));</span><br><span class="line">        orders.setUserName(user.getName());</span><br><span class="line">        orders.setConsignee(addressBook.getConsignee());</span><br><span class="line">        orders.setPhone(addressBook.getPhone());</span><br><span class="line">        orders.setAddress((addressBook.getProvinceName() == null ? &quot;&quot; : addressBook.getProvinceName())</span><br><span class="line">                + (addressBook.getCityName() == null ? &quot;&quot; : addressBook.getCityName())</span><br><span class="line">                + (addressBook.getDistrictName() == null ? &quot;&quot; : addressBook.getDistrictName())</span><br><span class="line">                + (addressBook.getDetail() == null ? &quot;&quot; : addressBook.getDetail()));</span><br><span class="line">        //向订单表插入数据，一条数据</span><br><span class="line">        this.save(orders);</span><br><span class="line"></span><br><span class="line">        //向订单明细表插入数据，多条数据</span><br><span class="line">        orderDetailService.saveBatch(orderDetails);</span><br><span class="line"></span><br><span class="line">        //清空购物车数据</span><br><span class="line">        shoppingCartService.remove(wrapper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>springboot - 外卖平台</tag>
        <tag>项目开发</tag>
        <tag>mybatis plus</tag>
        <tag>用户下单</tag>
      </tags>
  </entry>
  <entry>
    <title>外卖管理平台菜品信息分页查询</title>
    <url>/2022/09/11/%E5%A4%96%E5%8D%96%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0%E8%8F%9C%E5%93%81%E4%BF%A1%E6%81%AF%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><h3 id="一、需求分析"><a href="#一、需求分析" class="headerlink" title="一、需求分析"></a>一、需求分析</h3><p>系统中的菜品数据很多的时候，如果在一个页面中全部展示出来会显得比较乱，不便于查看，所以一般的系统中都会以分页的方式来展示列表数据。</p>
<span id="more"></span>
<h3 id="二、代码开发"><a href="#二、代码开发" class="headerlink" title="二、代码开发"></a>二、代码开发</h3><h4 id="梳理交互过程"><a href="#梳理交互过程" class="headerlink" title="梳理交互过程"></a>梳理交互过程</h4><p>在开发代码之前，需要梳理一下菜品分页查询时前端页面和服务端的交互过程:</p>
<p>1、页面(backend/page/food/list.html)发送ajax请求，将分页查询参数(page、pageSize、name)提交到服务端，获取分页数据</p>
<p>2、页面发送请求，请求服务端进行图片下载，用于页面图片展示</p>
<p>开发菜品信息分页查询功能，其实就是在服务端编写代码去处理前端页面发送的这2次请求即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.controller;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;</span><br><span class="line">import com.baomidou.mybatisplus.extension.plugins.pagination.Page;</span><br><span class="line">import com.itheima.reggie.common.R;</span><br><span class="line">import com.itheima.reggie.dto.DishDto;</span><br><span class="line">import com.itheima.reggie.entity.Category;</span><br><span class="line">import com.itheima.reggie.entity.Dish;</span><br><span class="line">import com.itheima.reggie.service.CategoryService;</span><br><span class="line">import com.itheima.reggie.service.DishFlavorService;</span><br><span class="line">import com.itheima.reggie.service.DishService;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.beans.BeanUtils;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/dish&quot;)</span><br><span class="line">@Slf4j</span><br><span class="line">public class DishController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private DishService dishService;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private DishFlavorService dishFlavorService;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private CategoryService categoryService;</span><br><span class="line"></span><br><span class="line">    @PostMapping</span><br><span class="line">    public R&lt;String&gt; save(@RequestBody DishDto dishDto) &#123;</span><br><span class="line"></span><br><span class="line">        log.info(dishDto.toString());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        dishService.saveWithFlavor(dishDto);</span><br><span class="line">        return R.success(&quot;新增菜品成功&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 菜品信息分页</span><br><span class="line">     * @param page</span><br><span class="line">     * @param pageSize</span><br><span class="line">     * @param name</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @GetMapping(&quot;/page&quot;)</span><br><span class="line">    public R&lt;Page&gt; page(int page, int pageSize, String name) &#123;</span><br><span class="line"></span><br><span class="line">        //构造分页构造器</span><br><span class="line">        Page&lt;Dish&gt; pageInfo = new Page&lt;&gt;(page,pageSize);</span><br><span class="line">        Page&lt;DishDto&gt; dishDtoPage = new Page&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        //条件构造器</span><br><span class="line">        LambdaQueryWrapper&lt;Dish&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        //添加过滤条件</span><br><span class="line">        queryWrapper.like(name != null,Dish::getName, name);</span><br><span class="line"></span><br><span class="line">        //添加排序条件</span><br><span class="line">        queryWrapper.orderByDesc(Dish::getUpdateTime);</span><br><span class="line"></span><br><span class="line">        //执行分页查询</span><br><span class="line">        dishService.page(pageInfo, queryWrapper);</span><br><span class="line"></span><br><span class="line">        //对象拷贝</span><br><span class="line">        BeanUtils.copyProperties(pageInfo,dishDtoPage,&quot;records&quot;);</span><br><span class="line"></span><br><span class="line">        List&lt;Dish&gt; records = pageInfo.getRecords();</span><br><span class="line">        List&lt;DishDto&gt; list = records.stream().map((item) -&gt;  &#123;</span><br><span class="line">            DishDto dishDto = new DishDto();</span><br><span class="line"></span><br><span class="line">            BeanUtils.copyProperties(item, dishDto);</span><br><span class="line"></span><br><span class="line">            Long categoryId = item.getCategoryId();</span><br><span class="line"></span><br><span class="line">            //根据id查询分类对象</span><br><span class="line">            Category category = categoryService.getById(categoryId);</span><br><span class="line"></span><br><span class="line">            if (category != null) &#123;</span><br><span class="line">                String categoryName = category.getName();</span><br><span class="line">                dishDto.setCategoryName(categoryName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            return dishDto;</span><br><span class="line">        &#125;).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        dishDtoPage.setRecords(list);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        return R.success(dishDtoPage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>springboot - 外卖平台</tag>
        <tag>项目开发</tag>
        <tag>mybatis plus</tag>
        <tag>菜品信息分页查询</tag>
      </tags>
  </entry>
  <entry>
    <title>外卖管理平台菜品展示</title>
    <url>/2022/09/19/%E5%A4%96%E5%8D%96%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0%E8%8F%9C%E5%93%81%E5%B1%95%E7%A4%BA/</url>
    <content><![CDATA[<h3 id="一、菜品展示"><a href="#一、菜品展示" class="headerlink" title="一、菜品展示"></a>一、菜品展示</h3><p>用户登录成功后跳转到系统首页，在首页需要根据分类来展示菜品和套餐。如果菜品设置了口味信息，需要展示<code>选择规格</code>按钮，否则显示<code>+</code>按钮。</p>
<span id="more"></span>
<h3 id="二、代码开发-梳理交互过程"><a href="#二、代码开发-梳理交互过程" class="headerlink" title="二、代码开发-梳理交互过程"></a>二、代码开发-梳理交互过程</h3><p>在开发代码之前，需要梳理一下前端页面和服务端的交互过程:</p>
<p>在开发代码之前，需要梳理一下前端页面和服务端的交互过程:<br>1、页面(front/index.html)发送ajax请求，获取分类数据（菜品分类和套餐分类)</p>
<p>2、页面发送ajax请求，获取第一个分类下的菜品或者套餐</p>
<p>开发菜品展示功能，其实就是在服务端编写代码去处理前端页面发送的这2次请求即可。</p>
<p>注意:首页加载完成后，还发送了一次ajax请求用于加载购物车数据，此处可以将这次请求的地址暂时修改一下，从静态json文件获取数据，等后续开发购物车功能时再修改回来，如下:</p>
<p><img src="https://i.p04e.com/baid/i/2022/09/19/3puk7.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 根据条件查询对应的菜品数据</span><br><span class="line">     * @param dish</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    /*@GetMapping(&quot;/list&quot;)</span><br><span class="line">    public R&lt;List&lt;Dish&gt;&gt; list(Dish dish)&#123;</span><br><span class="line">        //构造查询条件</span><br><span class="line">        LambdaQueryWrapper&lt;Dish&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">        queryWrapper.eq(dish.getCategoryId() != null ,Dish::getCategoryId,dish.getCategoryId());</span><br><span class="line">        //添加条件，查询状态为1（起售状态）的菜品</span><br><span class="line">        queryWrapper.eq(Dish::getStatus,1);</span><br><span class="line"></span><br><span class="line">        //添加排序条件</span><br><span class="line">        queryWrapper.orderByAsc(Dish::getSort).orderByDesc(Dish::getUpdateTime);</span><br><span class="line"></span><br><span class="line">        List&lt;Dish&gt; list = dishService.list(queryWrapper);</span><br><span class="line"></span><br><span class="line">        return R.success(list);</span><br><span class="line">    &#125;*/</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/list&quot;)</span><br><span class="line">    public R&lt;List&lt;DishDto&gt;&gt; list(Dish dish)&#123;</span><br><span class="line">        //构造查询条件</span><br><span class="line">        LambdaQueryWrapper&lt;Dish&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">        queryWrapper.eq(dish.getCategoryId() != null ,Dish::getCategoryId,dish.getCategoryId());</span><br><span class="line">        //添加条件，查询状态为1（起售状态）的菜品</span><br><span class="line">        queryWrapper.eq(Dish::getStatus,1);</span><br><span class="line"></span><br><span class="line">        //添加排序条件</span><br><span class="line">        queryWrapper.orderByAsc(Dish::getSort).orderByDesc(Dish::getUpdateTime);</span><br><span class="line"></span><br><span class="line">        List&lt;Dish&gt; list = dishService.list(queryWrapper);</span><br><span class="line"></span><br><span class="line">        List&lt;DishDto&gt; dishDtoList = list.stream().map((item) -&gt; &#123;</span><br><span class="line">            DishDto dishDto = new DishDto();</span><br><span class="line"></span><br><span class="line">            BeanUtils.copyProperties(item,dishDto);</span><br><span class="line"></span><br><span class="line">            Long categoryId = item.getCategoryId();//分类id</span><br><span class="line">            //根据id查询分类对象</span><br><span class="line">            Category category = categoryService.getById(categoryId);</span><br><span class="line"></span><br><span class="line">            if(category != null)&#123;</span><br><span class="line">                String categoryName = category.getName();</span><br><span class="line">                dishDto.setCategoryName(categoryName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //当前菜品的id</span><br><span class="line">            Long dishId = item.getId();</span><br><span class="line">            LambdaQueryWrapper&lt;DishFlavor&gt; lambdaQueryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">            lambdaQueryWrapper.eq(DishFlavor::getDishId,dishId);</span><br><span class="line">            //SQL:select * from dish_flavor where dish_id = ?</span><br><span class="line">            List&lt;DishFlavor&gt; dishFlavorList = dishFlavorService.list(lambdaQueryWrapper);</span><br><span class="line">            dishDto.setFlavors(dishFlavorList);</span><br><span class="line">            return dishDto;</span><br><span class="line">        &#125;).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        return R.success(dishDtoList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 根据条件查询分类数据</span><br><span class="line"> * @param category</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">@GetMapping(&quot;/list&quot;)</span><br><span class="line">public R&lt;List&lt;Category&gt;&gt; list(Category category) &#123;</span><br><span class="line">    //条件构造器</span><br><span class="line">    LambdaQueryWrapper&lt;Category&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">    //添加条件</span><br><span class="line">    queryWrapper.eq(category.getType() != null, Category::getType, category.getType());</span><br><span class="line">    //添加排序条件</span><br><span class="line">    queryWrapper.orderByAsc(Category::getSort).orderByDesc(Category::getUpdateTime);</span><br><span class="line"></span><br><span class="line">    List&lt;Category&gt; list = categoryService.list(queryWrapper);</span><br><span class="line">    return R.success(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据条件查询套餐数据</span><br><span class="line">     * @param setmeal</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @GetMapping(&quot;/list&quot;)</span><br><span class="line">    public R&lt;List&lt;Setmeal&gt;&gt; list(Setmeal setmeal)&#123;</span><br><span class="line">        LambdaQueryWrapper&lt;Setmeal&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">        queryWrapper.eq(setmeal.getCategoryId() != null,Setmeal::getCategoryId,setmeal.getCategoryId());</span><br><span class="line">        queryWrapper.eq(setmeal.getStatus() != null,Setmeal::getStatus,setmeal.getStatus());</span><br><span class="line">        queryWrapper.orderByDesc(Setmeal::getUpdateTime);</span><br><span class="line"></span><br><span class="line">        List&lt;Setmeal&gt; list = setmealService.list(queryWrapper);</span><br><span class="line"></span><br><span class="line">        return R.success(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>springboot - 外卖平台</tag>
        <tag>项目开发</tag>
        <tag>mybatis plus</tag>
        <tag>菜品展示</tag>
      </tags>
  </entry>
  <entry>
    <title>外卖管理平台购物车</title>
    <url>/2022/09/19/%E5%A4%96%E5%8D%96%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0%E8%B4%AD%E7%89%A9%E8%BD%A6/</url>
    <content><![CDATA[<h3 id="一、需求分析"><a href="#一、需求分析" class="headerlink" title="一、需求分析"></a>一、需求分析</h3><p>移动端用户可以将菜品或者套餐添加到购物车。对于菜品来说，如果设置了口味信息，则需要选择规格后才能加入购物车;对于套餐来说，可以直接点击将当前套餐加入购物车。在购物车中可以修改菜品和套餐的数量，也可以清空购物车。</p>
<span id="more"></span>
<h3 id="二、代码开发-梳理交互过程"><a href="#二、代码开发-梳理交互过程" class="headerlink" title="二、代码开发-梳理交互过程"></a>二、代码开发-梳理交互过程</h3><p>在开发代码之前，需要梳理一下购物车操作时前端页面和服务端的交互过程:</p>
<p>1、点击加入购物或者按钮+，页面发送ajax请求，请求服务端，将菜品或者套餐添加到购物车</p>
<p>2、点击购物车图标，页面发送ajax请求，请求服务端查询购物车中的菜品和套餐</p>
<p>3、点击清空购物车按钮，页面发送ajax请求，请求服务端来执行清空购物车操作</p>
<p>开发购物车功能，其实就是在服务端编写代码去处理前端页面发送的这3次请求即可。</p>
<h4 id="代码开发-准备工作"><a href="#代码开发-准备工作" class="headerlink" title="代码开发-准备工作"></a>代码开发-准备工作</h4><p>在开发业务功能前，先将需要用到的类和接口基本结构创建好:</p>
<ul>
<li>实体类ShoppingCart(直接从课程资料中导入即可)</li>
<li>Mapper接口ShoppingCartMapper</li>
<li>业务层接口ShoppingCartservice</li>
<li>业务层实现类ShoppingCartServicelmpl控制层 ShoppingcartController</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.controller;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;</span><br><span class="line">import com.itheima.reggie.common.BaseContext;</span><br><span class="line">import com.itheima.reggie.common.R;</span><br><span class="line">import com.itheima.reggie.entity.ShoppingCart;</span><br><span class="line">import com.itheima.reggie.service.ShoppingCartService;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line">import java.time.LocalDateTime;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 购物车</span><br><span class="line"> */</span><br><span class="line">@Slf4j</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/shoppingCart&quot;)</span><br><span class="line">public class ShoppingCartController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private ShoppingCartService shoppingCartService;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 添加购物车</span><br><span class="line">     * @param shoppingCart</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @PostMapping(&quot;/add&quot;)</span><br><span class="line">    public R&lt;ShoppingCart&gt; add(@RequestBody ShoppingCart shoppingCart)&#123;</span><br><span class="line">        log.info(&quot;购物车数据:&#123;&#125;&quot;,shoppingCart);</span><br><span class="line"></span><br><span class="line">        //设置用户id，指定当前是哪个用户的购物车数据</span><br><span class="line">        Long currentId = BaseContext.getCurrentId();</span><br><span class="line">        shoppingCart.setUserId(currentId);</span><br><span class="line"></span><br><span class="line">        Long dishId = shoppingCart.getDishId();</span><br><span class="line"></span><br><span class="line">        LambdaQueryWrapper&lt;ShoppingCart&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">        queryWrapper.eq(ShoppingCart::getUserId,currentId);</span><br><span class="line"></span><br><span class="line">        if(dishId != null)&#123;</span><br><span class="line">            //添加到购物车的是菜品</span><br><span class="line">            queryWrapper.eq(ShoppingCart::getDishId,dishId);</span><br><span class="line"></span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            //添加到购物车的是套餐</span><br><span class="line">            queryWrapper.eq(ShoppingCart::getSetmealId,shoppingCart.getSetmealId());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //查询当前菜品或者套餐是否在购物车中</span><br><span class="line">        //SQL:select * from shopping_cart where user_id = ? and dish_id/setmeal_id = ?</span><br><span class="line">        ShoppingCart cartServiceOne = shoppingCartService.getOne(queryWrapper);</span><br><span class="line"></span><br><span class="line">        if(cartServiceOne != null)&#123;</span><br><span class="line">            //如果已经存在，就在原来数量基础上加一</span><br><span class="line">            Integer number = cartServiceOne.getNumber();</span><br><span class="line">            cartServiceOne.setNumber(number + 1);</span><br><span class="line">            shoppingCartService.updateById(cartServiceOne);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            //如果不存在，则添加到购物车，数量默认就是一</span><br><span class="line">            shoppingCart.setNumber(1);</span><br><span class="line">            shoppingCart.setCreateTime(LocalDateTime.now());</span><br><span class="line">            shoppingCartService.save(shoppingCart);</span><br><span class="line">            cartServiceOne = shoppingCart;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return R.success(cartServiceOne);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 查看购物车</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @GetMapping(&quot;/list&quot;)</span><br><span class="line">    public R&lt;List&lt;ShoppingCart&gt;&gt; list()&#123;</span><br><span class="line">        log.info(&quot;查看购物车...&quot;);</span><br><span class="line"></span><br><span class="line">        LambdaQueryWrapper&lt;ShoppingCart&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">        queryWrapper.eq(ShoppingCart::getUserId,BaseContext.getCurrentId());</span><br><span class="line">        queryWrapper.orderByAsc(ShoppingCart::getCreateTime);</span><br><span class="line"></span><br><span class="line">        List&lt;ShoppingCart&gt; list = shoppingCartService.list(queryWrapper);</span><br><span class="line"></span><br><span class="line">        return R.success(list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 清空购物车</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @DeleteMapping(&quot;/clean&quot;)</span><br><span class="line">    public R&lt;String&gt; clean()&#123;</span><br><span class="line">        //SQL:delete from shopping_cart where user_id = ?</span><br><span class="line"></span><br><span class="line">        LambdaQueryWrapper&lt;ShoppingCart&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">        queryWrapper.eq(ShoppingCart::getUserId,BaseContext.getCurrentId());</span><br><span class="line"></span><br><span class="line">        shoppingCartService.remove(queryWrapper);</span><br><span class="line"></span><br><span class="line">        return R.success(&quot;清空购物车成功&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>springboot - 外卖平台</tag>
        <tag>项目开发</tag>
        <tag>mybatis plus</tag>
        <tag>购物车</tag>
      </tags>
  </entry>
  <entry>
    <title>外卖项目优化之使用git管理代码</title>
    <url>/2022/09/20/%E5%A4%96%E5%8D%96%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96%E4%B9%8B%E4%BD%BF%E7%94%A8git%E7%AE%A1%E7%90%86%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<h3 id="一、配置ssh公钥"><a href="#一、配置ssh公钥" class="headerlink" title="一、配置ssh公钥"></a>一、配置ssh公钥</h3><p>在原来项目的基础上做出优化，先将代码移至gitee好管理代码。</p>
<span id="more"></span>
<h4 id="先配置好ssh公钥"><a href="#先配置好ssh公钥" class="headerlink" title="先配置好ssh公钥"></a>先配置好ssh公钥</h4><ul>
<li>在GitBash界面按照如下命令生成公匙</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;xxxxx@xxxxx.com&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><p>按照提示完成三次回车，即可生成 ssh key。</p>
</li>
<li><p>通过查看 ~/.ssh/id_rsa.pub文件内容，获取到你的 public key。</p>
</li>
<li><p>复制id_rsa.pub文件中中生成的sshkey</p>
</li>
<li><p>在 [个人用户] -&gt; [设置] -&gt; [安全设置] -&gt; [ssh公匙] 页面添加sshkey</p>
</li>
<li><p>将复制的sshkey添加到公匙输入框中，设置标题，确定即可添加公匙</p>
<h4 id="验证ssh公匙"><a href="#验证ssh公匙" class="headerlink" title="验证ssh公匙"></a>验证ssh公匙</h4><p>输入<code>ssh -T git@gitee.com</code></p>
<p>首次使用需要确认并添加主机到本机SSH可信列表。<br> 若返回 Hi XXX! You’ve successfully authenticated, but Gitee.com does not provide shell access. 内容，则证明添加成功。</p>
</li>
</ul>
<h3 id="二、使用gitee管理代码"><a href="#二、使用gitee管理代码" class="headerlink" title="二、使用gitee管理代码"></a>二、使用gitee管理代码</h3><p><img src="https://i.p04e.com/baid/i/2022/09/20/l2.png"></p>
<p><img src="https://i.p04e.com/baid/i/2022/09/20/5kl7.png"><br><img src="https://i.p04e.com/baid/i/2022/09/20/sxj.png"><br><img src="https://i.p04e.com/baid/i/2022/09/20/t41.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在根目录下添加.gitgnore文件，因为不是所有的文件都需要上传到gitee</span><br><span class="line">.git</span><br><span class="line">logs</span><br><span class="line">rebel.xml</span><br><span class="line">target/</span><br><span class="line">!.mvn/wrapper/maven-wrapper.jar</span><br><span class="line">log.path_IS_UNDEFINED</span><br><span class="line">.DS_Store</span><br><span class="line">offline_user.md</span><br><span class="line"></span><br><span class="line">### STS ###</span><br><span class="line">.apt_generated</span><br><span class="line">.classpath</span><br><span class="line">.factorypath</span><br><span class="line">.project</span><br><span class="line">.settings</span><br><span class="line">.springBeans</span><br><span class="line"></span><br><span class="line">### IntelliJ IDEA ###</span><br><span class="line">.idea</span><br><span class="line">*.iws</span><br><span class="line">*.iml</span><br><span class="line">*.ipr</span><br><span class="line"></span><br><span class="line">### NetBeans ###</span><br><span class="line">nbproject/private/</span><br><span class="line">build/</span><br><span class="line">nbbuild/</span><br><span class="line">dist/</span><br><span class="line">nbdist/</span><br><span class="line">.nb-gradle/</span><br><span class="line">generatorConfig.xml</span><br><span class="line"></span><br><span class="line">### nacos ###</span><br><span class="line">third-party/nacos/derby.log</span><br><span class="line">third-party/nacos/data/</span><br><span class="line">third-party/nacos/work/</span><br><span class="line"></span><br><span class="line">file/</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://i.p04e.com/baid/i/2022/09/20/aqjg.png"><br><img src="https://i.p04e.com/baid/i/2022/09/20/7w1.png"><br><img src="https://i.p04e.com/baid/i/2022/09/20/1j7t.png"><br><img src="https://i.p04e.com/baid/i/2022/09/20/23809.png"><br><img src="https://i.p04e.com/baid/i/2022/09/20/7w9.png"><br><img src="https://i.p04e.com/baid/i/2022/09/20/1j9d.png"><br><img src="https://i.p04e.com/baid/i/2022/09/20/7w3.png"><br><img src="https://i.p04e.com/baid/i/2022/09/20/237q6.png"><br><img src="https://i.p04e.com/baid/i/2022/09/20/ar6a.png"><br><img src="https://i.p04e.com/baid/i/2022/09/20/1jaq.png"><br><img src="https://i.p04e.com/baid/i/2022/09/20/ar1g.png"></p>
]]></content>
      <tags>
        <tag>springboot - 外卖平台</tag>
        <tag>项目开发</tag>
        <tag>mybatis plus</tag>
        <tag>使用git管理代码</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>外卖项目优化之环境搭建</title>
    <url>/2022/09/20/%E5%A4%96%E5%8D%96%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96%E4%B9%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>外卖管理平台新增分类代码开发</title>
    <url>/2022/09/02/%E5%A4%96%E5%8D%96%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0%E6%96%B0%E5%A2%9E%E5%88%86%E7%B1%BB%E4%BB%A3%E7%A0%81%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h3 id="一、新增分类"><a href="#一、新增分类" class="headerlink" title="一、新增分类"></a>一、新增分类</h3><p>在开发代码之前，需要梳理一下整个程序的执行过程:</p>
<span id="more"></span>
<p>1、页面(backend/page/category/list.html)发送ajax请求，将新增分类窗口输入的数据以json形式提交到服务端</p>
<p>2、服务端Controller接收页面提交的数据并调用Service将数据进行保存</p>
<p>3、Service调用Mapper操作数据库，保存数据</p>
<p>可以先将大概的框架写出，后面在完善</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.entity;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.annotation.FieldFill;</span><br><span class="line">import com.baomidou.mybatisplus.annotation.IdType;</span><br><span class="line">import com.baomidou.mybatisplus.annotation.TableField;</span><br><span class="line">import com.baomidou.mybatisplus.annotation.TableId;</span><br><span class="line">import lombok.Data;</span><br><span class="line">import lombok.Getter;</span><br><span class="line">import lombok.Setter;</span><br><span class="line">import java.io.Serializable;</span><br><span class="line">import java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 分类</span><br><span class="line"> */</span><br><span class="line">@Data</span><br><span class="line">public class Category implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID = 1L;</span><br><span class="line"></span><br><span class="line">    private Long id;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //类型 1 菜品分类 2 套餐分类</span><br><span class="line">    private Integer type;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //分类名称</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //顺序</span><br><span class="line">    private Integer sort;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //创建时间</span><br><span class="line">    @TableField(fill = FieldFill.INSERT)</span><br><span class="line">    private LocalDateTime createTime;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //更新时间</span><br><span class="line">    @TableField(fill = FieldFill.INSERT_UPDATE)</span><br><span class="line">    private LocalDateTime updateTime;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //创建人</span><br><span class="line">    @TableField(fill = FieldFill.INSERT)</span><br><span class="line">    private Long createUser;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //修改人</span><br><span class="line">    @TableField(fill = FieldFill.INSERT_UPDATE)</span><br><span class="line">    private Long updateUser;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.mapper;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.core.mapper.BaseMapper;</span><br><span class="line">import com.itheima.reggie.entity.Category;</span><br><span class="line">import org.apache.ibatis.annotations.Mapper;</span><br><span class="line"></span><br><span class="line">@Mapper</span><br><span class="line">public interface CategoryMapper extends BaseMapper&lt;Category&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.service;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.extension.service.IService;</span><br><span class="line">import com.itheima.reggie.entity.Category;</span><br><span class="line"></span><br><span class="line">public interface CategoryService extends IService&lt;Category&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.service.impl;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;</span><br><span class="line">import com.itheima.reggie.entity.Category;</span><br><span class="line">import com.itheima.reggie.mapper.CategoryMapper;</span><br><span class="line">import com.itheima.reggie.service.CategoryService;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class CategoryServiceImpl extends ServiceImpl&lt;CategoryMapper, Category&gt; implements CategoryService &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.controller;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import com.itheima.reggie.service.CategoryService;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/category&quot;)</span><br><span class="line">public class CategoryController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private CategoryService categoryService;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到新增菜品分类和新增套餐分类请求的服务端地址和提交的json数据结构相同，所以服务端只需要提供一个方法统一处理即可：</p>
<p><img src="https://i.p04e.com/baid/i/2022/09/02/5955.png"></p>
<h3 id="二、分类信息分页查询"><a href="#二、分类信息分页查询" class="headerlink" title="二、分类信息分页查询"></a>二、分类信息分页查询</h3><h4 id="1、需求分析"><a href="#1、需求分析" class="headerlink" title="1、需求分析"></a>1、需求分析</h4><p>系统中的分类很多的时候，如果在一个页面中全部展示出来会显得比较乱，不便于查看，所以一般的系统中都会以分页的方式来展示列表数据。</p>
<h4 id="2、代码开发"><a href="#2、代码开发" class="headerlink" title="2、代码开发"></a>2、代码开发</h4><p>在开发代码之前，需要梳理一下整个程序的执行过程:</p>
<p>1、页面发送ajax请求，将分页查询参数(page.pageSize)提交到服务端</p>
<p>2、服务端Controller接收页面提交的数据并调用Service查询数据</p>
<p>3、Service调用Mapper操作数据库，查询分页数据</p>
<p>4、Controller将查询到的分页数据响应给页面</p>
<p>5、页面接收到分页数据并通过Elementul的Table组件展示到页面上</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.controller;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;</span><br><span class="line">import com.baomidou.mybatisplus.extension.plugins.pagination.Page;</span><br><span class="line">import com.itheima.reggie.common.R;</span><br><span class="line">import com.itheima.reggie.entity.Category;</span><br><span class="line">import com.itheima.reggie.service.CategoryService;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 分类管理</span><br><span class="line"> */</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/category&quot;)</span><br><span class="line">@Slf4j</span><br><span class="line">public class CategoryController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private CategoryService categoryService;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 新增分类</span><br><span class="line">     * @param category</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @PostMapping</span><br><span class="line">    public R&lt;String&gt; save(@RequestBody Category category)&#123;</span><br><span class="line">        log.info(&quot;category:&#123;&#125;&quot;,category);</span><br><span class="line">        categoryService.save(category);</span><br><span class="line">        return R.success(&quot;新增分类成功&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 分页查询</span><br><span class="line">     * @param page</span><br><span class="line">     * @param pageSize</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @GetMapping(&quot;/page&quot;)</span><br><span class="line">    public R&lt;Page&gt; page(int page,int pageSize)&#123;</span><br><span class="line">        //分页构造器</span><br><span class="line">        Page&lt;Category&gt; pageInfo = new Page&lt;&gt;(page,pageSize);</span><br><span class="line">        //条件构造器</span><br><span class="line">        LambdaQueryWrapper&lt;Category&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">        //添加排序条件，根据sort进行排序</span><br><span class="line">        queryWrapper.orderByAsc(Category::getSort);</span><br><span class="line"></span><br><span class="line">        //分页查询</span><br><span class="line">        categoryService.page(pageInfo,queryWrapper);</span><br><span class="line">        return R.success(pageInfo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最后就可以显示出来了。</p>
<p><img src="https://i.p04e.com/baid/i/2022/09/02/5cgu.png"></p>
<h3 id="三、删除分类"><a href="#三、删除分类" class="headerlink" title="三、删除分类"></a>三、删除分类</h3><h4 id="1、需求分析-1"><a href="#1、需求分析-1" class="headerlink" title="1、需求分析"></a>1、需求分析</h4><p>在分类管理列表页面，可以对某个分类进行删除操作。需要注意的是当分类关联了菜品或者套餐时，此分类不允许删除。</p>
<h4 id="2、代码开发-1"><a href="#2、代码开发-1" class="headerlink" title="2、代码开发"></a>2、代码开发</h4><p>在开发代码之前，需要梳理一下整个程序的执行过程:</p>
<p>1、页面发送ajax请求，将参数(id)提交到服务端</p>
<p>2、服务端Controller接收页面提交的数据并调用Service删除数据</p>
<p>3、Service调用Mapper操作数据库</p>
<p><img src="https://i.p04e.com/baid/i/2022/09/03/ycuv.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 根据id删除分类</span><br><span class="line"> * @param id</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">@DeleteMapping</span><br><span class="line">public R&lt;String&gt; delete(Long id) &#123;</span><br><span class="line">    log.info(&quot;删除分类，id为：&#123;&#125;&quot;,id);</span><br><span class="line"></span><br><span class="line">    categoryService.removeById(id);</span><br><span class="line">    return R.success(&quot;分类信息删除成功&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3、功能完善"><a href="#3、功能完善" class="headerlink" title="3、功能完善"></a>3、功能完善</h4><p>前面我们已经实现了根据id删除分类的功能，但是并没有检查删除的分类是否关联了菜品或者套餐，所以我们需要进行功能完善。</p>
<p>要完善分类删除功能，需要先准备基础的类和接口:1、实体类Dish和Setmeal (从课程资料中复制即可)</p>
<p>2、Mapper接口DishMapper和SetmealMapper</p>
<p>3、Service接口DishService和SetmealService</p>
<p>4、Service实现类DishServicelmpl和SetmealServicelmpl</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.entity;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.annotation.FieldFill;</span><br><span class="line">import com.baomidou.mybatisplus.annotation.IdType;</span><br><span class="line">import com.baomidou.mybatisplus.annotation.TableField;</span><br><span class="line">import com.baomidou.mybatisplus.annotation.TableId;</span><br><span class="line">import lombok.Data;</span><br><span class="line">import java.io.Serializable;</span><br><span class="line">import java.math.BigDecimal;</span><br><span class="line">import java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> 菜品</span><br><span class="line"> */</span><br><span class="line">@Data</span><br><span class="line">public class Dish implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID = 1L;</span><br><span class="line"></span><br><span class="line">    private Long id;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //菜品名称</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //菜品分类id</span><br><span class="line">    private Long categoryId;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //菜品价格</span><br><span class="line">    private BigDecimal price;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //商品码</span><br><span class="line">    private String code;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //图片</span><br><span class="line">    private String image;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //描述信息</span><br><span class="line">    private String description;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //0 停售 1 起售</span><br><span class="line">    private Integer status;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //顺序</span><br><span class="line">    private Integer sort;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @TableField(fill = FieldFill.INSERT)</span><br><span class="line">    private LocalDateTime createTime;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @TableField(fill = FieldFill.INSERT_UPDATE)</span><br><span class="line">    private LocalDateTime updateTime;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @TableField(fill = FieldFill.INSERT)</span><br><span class="line">    private Long createUser;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @TableField(fill = FieldFill.INSERT_UPDATE)</span><br><span class="line">    private Long updateUser;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //是否删除</span><br><span class="line">    private Integer isDeleted;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.entity;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.annotation.FieldFill;</span><br><span class="line">import com.baomidou.mybatisplus.annotation.IdType;</span><br><span class="line">import com.baomidou.mybatisplus.annotation.TableField;</span><br><span class="line">import com.baomidou.mybatisplus.annotation.TableId;</span><br><span class="line">import lombok.Data;</span><br><span class="line">import java.io.Serializable;</span><br><span class="line">import java.math.BigDecimal;</span><br><span class="line">import java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 套餐</span><br><span class="line"> */</span><br><span class="line">@Data</span><br><span class="line">public class Setmeal implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID = 1L;</span><br><span class="line"></span><br><span class="line">    private Long id;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //分类id</span><br><span class="line">    private Long categoryId;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //套餐名称</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //套餐价格</span><br><span class="line">    private BigDecimal price;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //状态 0:停用 1:启用</span><br><span class="line">    private Integer status;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //编码</span><br><span class="line">    private String code;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //描述信息</span><br><span class="line">    private String description;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //图片</span><br><span class="line">    private String image;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @TableField(fill = FieldFill.INSERT)</span><br><span class="line">    private LocalDateTime createTime;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @TableField(fill = FieldFill.INSERT_UPDATE)</span><br><span class="line">    private LocalDateTime updateTime;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @TableField(fill = FieldFill.INSERT)</span><br><span class="line">    private Long createUser;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @TableField(fill = FieldFill.INSERT_UPDATE)</span><br><span class="line">    private Long updateUser;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //是否删除</span><br><span class="line">    private Integer isDeleted;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.mapper;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.core.mapper.BaseMapper;</span><br><span class="line">import com.itheima.reggie.entity.Dish;</span><br><span class="line">import org.apache.ibatis.annotations.Mapper;</span><br><span class="line"></span><br><span class="line">@Mapper</span><br><span class="line">public interface DishMapper extends BaseMapper&lt;Dish&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.mapper;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.core.mapper.BaseMapper;</span><br><span class="line">import com.itheima.reggie.entity.Setmeal;</span><br><span class="line">import org.apache.ibatis.annotations.Mapper;</span><br><span class="line"></span><br><span class="line">@Mapper</span><br><span class="line">public interface SetmealMapper extends BaseMapper&lt;Setmeal&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.service;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.extension.service.IService;</span><br><span class="line">import com.itheima.reggie.entity.Dish;</span><br><span class="line"></span><br><span class="line">public interface DishService extends IService&lt;Dish&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.service;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.extension.service.IService;</span><br><span class="line">import com.itheima.reggie.entity.Setmeal;</span><br><span class="line"></span><br><span class="line">public interface SetmealService extends IService&lt;Setmeal&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.service.impl;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;</span><br><span class="line">import com.itheima.reggie.entity.Dish;</span><br><span class="line">import com.itheima.reggie.mapper.DishMapper;</span><br><span class="line">import com.itheima.reggie.service.DishService;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">@Slf4j</span><br><span class="line">public class DishServiceImpl extends ServiceImpl&lt;DishMapper, Dish&gt; implements DishService &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.service.impl;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;</span><br><span class="line">import com.itheima.reggie.entity.Setmeal;</span><br><span class="line">import com.itheima.reggie.mapper.SetmealMapper;</span><br><span class="line">import com.itheima.reggie.service.SetmealService;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">@Slf4j</span><br><span class="line">public class SetmealServiceImpl extends ServiceImpl&lt;SetmealMapper, Setmeal&gt; implements SetmealService &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.controller;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;</span><br><span class="line">import com.baomidou.mybatisplus.extension.plugins.pagination.Page;</span><br><span class="line">import com.itheima.reggie.common.R;</span><br><span class="line">import com.itheima.reggie.entity.Category;</span><br><span class="line">import com.itheima.reggie.service.CategoryService;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 分类管理</span><br><span class="line"> */</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/category&quot;)</span><br><span class="line">@Slf4j</span><br><span class="line">public class CategoryController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private CategoryService categoryService;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 新增分类</span><br><span class="line">     * @param category</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @PostMapping</span><br><span class="line">    public R&lt;String&gt; save(@RequestBody Category category)&#123;</span><br><span class="line">        log.info(&quot;category:&#123;&#125;&quot;,category);</span><br><span class="line">        categoryService.save(category);</span><br><span class="line">        return R.success(&quot;新增分类成功&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 分页查询</span><br><span class="line">     * @param page</span><br><span class="line">     * @param pageSize</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @GetMapping(&quot;/page&quot;)</span><br><span class="line">    public R&lt;Page&gt; page(int page,int pageSize)&#123;</span><br><span class="line">        //分页构造器</span><br><span class="line">        Page&lt;Category&gt; pageInfo = new Page&lt;&gt;(page,pageSize);</span><br><span class="line">        //条件构造器</span><br><span class="line">        LambdaQueryWrapper&lt;Category&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">        //添加排序条件，根据sort进行排序</span><br><span class="line">        queryWrapper.orderByAsc(Category::getSort);</span><br><span class="line"></span><br><span class="line">        //分页查询</span><br><span class="line">        categoryService.page(pageInfo,queryWrapper);</span><br><span class="line">        return R.success(pageInfo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据id删除分类</span><br><span class="line">     * @param id</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @DeleteMapping</span><br><span class="line">    public R&lt;String&gt; delete(Long id) &#123;</span><br><span class="line">        log.info(&quot;删除分类，id为：&#123;&#125;&quot;,id);</span><br><span class="line"></span><br><span class="line">        //categoryService.removeById(id);</span><br><span class="line">        categoryService.remove(id);</span><br><span class="line">        return R.success(&quot;分类信息删除成功&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.service.impl;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;</span><br><span class="line">import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;</span><br><span class="line">import com.itheima.reggie.common.CustomException;</span><br><span class="line">import com.itheima.reggie.entity.Category;</span><br><span class="line">import com.itheima.reggie.entity.Dish;</span><br><span class="line">import com.itheima.reggie.entity.Setmeal;</span><br><span class="line">import com.itheima.reggie.mapper.CategoryMapper;</span><br><span class="line">import com.itheima.reggie.service.CategoryService;</span><br><span class="line">import com.itheima.reggie.service.DishService;</span><br><span class="line">import com.itheima.reggie.service.SetmealService;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class CategoryServiceImpl extends ServiceImpl&lt;CategoryMapper, Category&gt; implements CategoryService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private DishService dishService;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private SetmealService setmealService;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据id删除分类,删除之前需要进行判断</span><br><span class="line">     * @param id</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void remove(Long id) &#123;</span><br><span class="line">        LambdaQueryWrapper&lt;Dish&gt; dishLambdaQueryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">        //添加查询条件，根据分类id进行查询</span><br><span class="line">        dishLambdaQueryWrapper.eq(Dish::getCategoryId, id);</span><br><span class="line">        int count1 = dishService.count(dishLambdaQueryWrapper);</span><br><span class="line">        //查询当前分类是否关联了菜品，如果已经关联，抛出一个业务异常</span><br><span class="line">        if (count1 &gt; 0) &#123;</span><br><span class="line">            //已经关联菜品，抛出一个业务异常</span><br><span class="line">            throw new CustomException(&quot;当前分类下关联了分类菜品，不能删除&quot;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //查询当前分类是否关联了套餐，如果已经关联，抛出一个业务异常</span><br><span class="line">        LambdaQueryWrapper&lt;Setmeal&gt; setmealLambdaQueryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">        int count2 = setmealService.count(setmealLambdaQueryWrapper);</span><br><span class="line">        if (count2 &gt; 0) &#123;</span><br><span class="line">            //已经关联套餐，抛出一个业务异常</span><br><span class="line">            throw new CustomException(&quot;当前分类下关联了套餐，不能删除&quot;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //正常删除分类</span><br><span class="line">        super.removeById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.common;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 自定义业务异常</span><br><span class="line"> */</span><br><span class="line">public class CustomException extends RuntimeException&#123;</span><br><span class="line">    public CustomException(String message) &#123;</span><br><span class="line">        super(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.common;</span><br><span class="line"></span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line">import org.springframework.web.bind.annotation.ControllerAdvice;</span><br><span class="line">import org.springframework.web.bind.annotation.ExceptionHandler;</span><br><span class="line">import org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">import java.sql.SQLIntegrityConstraintViolationException;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 全局异常处理</span><br><span class="line"> */</span><br><span class="line">@ControllerAdvice(annotations = &#123;RestController.class, Controller.class&#125;)</span><br><span class="line">@ResponseBody</span><br><span class="line">@Slf4j</span><br><span class="line">public class GlobalExceptionHandler &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 异常处理方法</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @ExceptionHandler(SQLIntegrityConstraintViolationException.class)</span><br><span class="line">    public R&lt;String&gt; exceptionHandler(SQLIntegrityConstraintViolationException ex)&#123;</span><br><span class="line">        log.error(ex.getMessage());</span><br><span class="line"></span><br><span class="line">        if(ex.getMessage().contains(&quot;Duplicate entry&quot;))&#123;</span><br><span class="line">            String[] split = ex.getMessage().split(&quot; &quot;);</span><br><span class="line">            String msg = split[2] + &quot;已存在&quot;;</span><br><span class="line">            return R.error(msg);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return R.error(&quot;未知错误&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 异常处理方法</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @ExceptionHandler(CustomException.class)</span><br><span class="line">    public R&lt;String&gt; exceptionHandler(CustomException ex)&#123;</span><br><span class="line">        log.error(ex.getMessage());</span><br><span class="line"></span><br><span class="line">        return R.error(ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="四、修改分类"><a href="#四、修改分类" class="headerlink" title="四、修改分类"></a>四、修改分类</h3><h4 id="1、需求分析-2"><a href="#1、需求分析-2" class="headerlink" title="1、需求分析"></a>1、需求分析</h4><p>在分类管理列表页面点击修改按钮，弹出修改窗口，在修改窗口回显分类信息并进行修改，最后点击确定按钮完成修改操作</p>
<h4 id="2、代码开发-2"><a href="#2、代码开发-2" class="headerlink" title="2、代码开发"></a>2、代码开发</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 根据id修改分类信息</span><br><span class="line"> * @param category</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">@PutMapping</span><br><span class="line">public R&lt;String&gt; update(@RequestBody Category category)&#123;</span><br><span class="line">    log.info(&quot;修改分类信息：&#123;&#125;&quot;,category);</span><br><span class="line"></span><br><span class="line">    categoryService.updateById(category);</span><br><span class="line"></span><br><span class="line">    return R.success(&quot;修改分类信息成功&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>springboot - 外卖平台</tag>
        <tag>项目开发</tag>
        <tag>mybatis plus</tag>
        <tag>新增分类</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker实用篇</title>
    <url>/2022/11/22/Docker%E5%AE%9E%E7%94%A8%E7%AF%87/</url>
    <content><![CDATA[<h1 id="Docker实用篇"><a href="#Docker实用篇" class="headerlink" title="Docker实用篇"></a>Docker实用篇</h1><span id="more"></span>
<h1 id="0-学习目标"><a href="#0-学习目标" class="headerlink" title="0.学习目标"></a>0.学习目标</h1><h1 id="1-初识Docker"><a href="#1-初识Docker" class="headerlink" title="1.初识Docker"></a>1.初识Docker</h1><h2 id="1-1-什么是Docker"><a href="#1-1-什么是Docker" class="headerlink" title="1.1.什么是Docker"></a>1.1.什么是Docker</h2><p>微服务虽然具备各种各样的优势，但服务的拆分通用给部署带来了很大的麻烦。</p>
<ul>
<li>分布式系统中，依赖的组件非常多，不同组件之间部署时往往会产生一些冲突。</li>
<li>在数百上千台服务中重复部署，环境不一定一致，会遇到各种问题</li>
</ul>
<h3 id="1-1-1-应用部署的环境问题"><a href="#1-1-1-应用部署的环境问题" class="headerlink" title="1.1.1.应用部署的环境问题"></a>1.1.1.应用部署的环境问题</h3><p>大型项目组件较多，运行环境也较为复杂，部署时会碰到一些问题：</p>
<ul>
<li>依赖关系复杂，容易出现兼容性问题</li>
<li>开发、测试、生产环境有差异</li>
</ul>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/voq.png"></p>
<p>例如一个项目中，部署时需要依赖于node.js、Redis、RabbitMQ、MySQL等，这些服务部署时所需要的函数库、依赖项各不相同，甚至会有冲突。给部署带来了极大的困难。</p>
<h3 id="1-1-2-Docker解决依赖兼容问题"><a href="#1-1-2-Docker解决依赖兼容问题" class="headerlink" title="1.1.2.Docker解决依赖兼容问题"></a>1.1.2.Docker解决依赖兼容问题</h3><p>而Docker确巧妙的解决了这些问题，Docker是如何实现的呢？</p>
<p>Docker为了解决依赖的兼容问题的，采用了两个手段：</p>
<ul>
<li>将应用的Libs（函数库）、Deps（依赖）、配置与应用一起打包</li>
<li>将每个应用放到一个隔离<strong>容器</strong>去运行，避免互相干扰</li>
</ul>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/vjp.png"></p>
<p>这样打包好的应用包中，既包含应用本身，也保护应用所需要的Libs、Deps，无需再操作系统上安装这些，自然就不存在不同应用之间的兼容问题了。</p>
<p>虽然解决了不同应用的兼容问题，但是开发、测试等环境会存在差异，操作系统版本也会有差异，怎么解决这些问题呢？</p>
<h3 id="1-1-3-Docker解决操作系统环境差异"><a href="#1-1-3-Docker解决操作系统环境差异" class="headerlink" title="1.1.3.Docker解决操作系统环境差异"></a>1.1.3.Docker解决操作系统环境差异</h3><p>要解决不同操作系统环境差异问题，必须先了解操作系统结构。以一个Ubuntu操作系统为例，结构如下：</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/66x0.png"></p>
<p>结构包括：</p>
<ul>
<li>计算机硬件：例如CPU、内存、磁盘等</li>
<li>系统内核：所有Linux发行版的内核都是Linux，例如CentOS、Ubuntu、Fedora等。内核可以与计算机硬件交互，对外提供<strong>内核指令</strong>，用于操作计算机硬件。</li>
<li>系统应用：操作系统本身提供的应用、函数库。这些函数库是对内核指令的封装，使用更加方便。</li>
</ul>
<p>应用于计算机交互的流程如下：</p>
<p>1）应用调用操作系统应用（函数库），实现各种功能</p>
<p>2）系统函数库是对内核指令集的封装，会调用内核指令</p>
<p>3）内核指令操作计算机硬件</p>
<p>Ubuntu和CentOSpringBoot都是基于Linux内核，无非是系统应用不同，提供的函数库有差异：</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/67g7.png"></p>
<p>此时，如果将一个Ubuntu版本的MySQL应用安装到CentOS系统，MySQL在调用Ubuntu函数库时，会发现找不到或者不匹配，就会报错了：</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/w0g.png"></p>
<p>Docker如何解决不同系统环境的问题？</p>
<ul>
<li>Docker将用户程序与所需要调用的系统(比如Ubuntu)函数库一起打包</li>
<li>Docker运行到不同操作系统时，直接基于打包的函数库，借助于操作系统的Linux内核来运行</li>
</ul>
<p>如图：</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/67vy.png"></p>
<h3 id="1-1-4-小结"><a href="#1-1-4-小结" class="headerlink" title="1.1.4.小结"></a>1.1.4.小结</h3><p>Docker如何解决大型项目依赖关系复杂，不同组件依赖的兼容性问题？</p>
<ul>
<li>Docker允许开发中将应用、依赖、函数库、配置一起<strong>打包</strong>，形成可移植镜像</li>
<li>Docker应用运行在容器中，使用沙箱机制，相互<strong>隔离</strong></li>
</ul>
<p>Docker如何解决开发、测试、生产环境有差异的问题？</p>
<ul>
<li>Docker镜像中包含完整运行环境，包括系统函数库，仅依赖系统的Linux内核，因此可以在任意Linux操作系统上运行</li>
</ul>
<p>Docker是一个快速交付应用、运行应用的技术，具备下列优势：</p>
<ul>
<li>可以将程序及其依赖、运行环境一起打包为一个镜像，可以迁移到任意Linux操作系统</li>
<li>运行时利用沙箱机制形成隔离容器，各个应用互不干扰</li>
<li>启动、移除都可以通过一行命令完成，方便快捷</li>
</ul>
<h2 id="1-2-Docker和虚拟机的区别"><a href="#1-2-Docker和虚拟机的区别" class="headerlink" title="1.2.Docker和虚拟机的区别"></a>1.2.Docker和虚拟机的区别</h2><p>Docker可以让一个应用在任何操作系统中非常方便的运行。而以前我们接触的虚拟机，也能在一个操作系统中，运行另外一个操作系统，保护系统中的任何应用。</p>
<p>两者有什么差异呢？</p>
<p><strong>虚拟机</strong>（virtual machine）是在操作系统中<strong>模拟</strong>硬件设备，然后运行另一个操作系统，比如在 Windows 系统里面运行 Ubuntu 系统，这样就可以运行任意的Ubuntu应用了。</p>
<p><strong>Docker</strong>仅仅是封装函数库，并没有模拟完整的操作系统，如图：</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/672v.png"></p>
<p>对比来看：</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/vvg.png"></p>
<p>小结：</p>
<p>Docker和虚拟机的差异：</p>
<ul>
<li>docker是一个系统进程；虚拟机是在操作系统中的操作系统</li>
<li>docker体积小、启动速度快、性能好；虚拟机体积大、启动速度慢、性能一般</li>
</ul>
<h2 id="1-3-Docker架构"><a href="#1-3-Docker架构" class="headerlink" title="1.3.Docker架构"></a>1.3.Docker架构</h2><h3 id="1-3-1-镜像和容器"><a href="#1-3-1-镜像和容器" class="headerlink" title="1.3.1.镜像和容器"></a>1.3.1.镜像和容器</h3><p>Docker中有几个重要的概念：</p>
<p><strong>镜像（Image）</strong>：Docker将应用程序及其所需的依赖、函数库、环境、配置等文件打包在一起，称为镜像。</p>
<p><strong>容器（Container）</strong>：镜像中的应用程序运行后形成的进程就是<strong>容器</strong>，只是Docker会给容器进程做隔离，对外不可见。</p>
<p>一切应用最终都是代码组成，都是硬盘中的一个个的字节形成的<strong>文件</strong>。只有运行时，才会加载到内存，形成进程。</p>
<p>而<strong>镜像</strong>，就是把一个应用在硬盘上的文件、及其运行环境、部分系统函数库文件一起打包形成的文件包。这个文件包是只读的。</p>
<p><strong>容器</strong>呢，就是将这些文件中编写的程序、函数加载到内存中允许，形成进程，只不过要隔离起来。因此一个镜像可以启动多次，形成多个容器进程。</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/8prb.png"></p>
<p>例如你下载了一个QQ，如果我们将QQ在磁盘上的运行<strong>文件</strong>及其运行的操作系统依赖打包，形成QQ镜像。然后你可以启动多次，双开、甚至三开QQ，跟多个妹子聊天。</p>
<h3 id="1-3-2-DockerHub"><a href="#1-3-2-DockerHub" class="headerlink" title="1.3.2.DockerHub"></a>1.3.2.DockerHub</h3><p>开源应用程序非常多，打包这些应用往往是重复的劳动。为了避免这些重复劳动，人们就会将自己打包的应用镜像，例如Redis、MySQL镜像放到网络上，共享使用，就像GitHub的代码共享一样。</p>
<ul>
<li>DockerHub：DockerHub是一个官方的Docker镜像的托管平台。这样的平台称为Docker Registry。</li>
<li>国内也有类似于DockerHub 的公开服务，比如 <a href="https://c.163yun.com/hub">网易云镜像服务</a>、<a href="https://cr.console.aliyun.com/">阿里云镜像库</a>等。</li>
</ul>
<p>我们一方面可以将自己的镜像共享到DockerHub，另一方面也可以从DockerHub拉取镜像：</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/18vy.png"></p>
<h3 id="1-3-3-Docker架构"><a href="#1-3-3-Docker架构" class="headerlink" title="1.3.3.Docker架构"></a>1.3.3.Docker架构</h3><p>我们要使用Docker来操作镜像、容器，就必须要安装Docker。</p>
<p>Docker是一个CS架构的程序，由两部分组成：</p>
<ul>
<li>服务端(server)：Docker守护进程，负责处理Docker指令，管理镜像、容器等</li>
<li>客户端(client)：通过命令或RestAPI向Docker服务端发送指令。可以在本地或远程向服务端发送指令。</li>
</ul>
<p>如图：</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/1p8x0.png"></p>
<h3 id="1-3-4-小结"><a href="#1-3-4-小结" class="headerlink" title="1.3.4.小结"></a>1.3.4.小结</h3><p>镜像：</p>
<ul>
<li>将应用程序及其依赖、环境、配置打包在一起</li>
</ul>
<p>容器：</p>
<ul>
<li>镜像运行起来就是容器，一个镜像可以运行多个容器</li>
</ul>
<p>Docker结构：</p>
<ul>
<li>服务端：接收命令或远程请求，操作镜像或容器</li>
<li>客户端：发送命令或者请求到Docker服务端</li>
</ul>
<p>DockerHub：</p>
<ul>
<li>一个镜像托管的服务器，类似的还有阿里云镜像服务，统称为DockerRegistry</li>
</ul>
<h2 id="1-4-安装Docker"><a href="#1-4-安装Docker" class="headerlink" title="1.4.安装Docker"></a>1.4.安装Docker</h2><p>企业部署一般都是采用Linux操作系统，而其中又数CentOS发行版占比最多，因此我们在CentOS下安装Docker。</p>
<h1 id="2-Docker的基本操作"><a href="#2-Docker的基本操作" class="headerlink" title="2.Docker的基本操作"></a>2.Docker的基本操作</h1><h2 id="2-1-镜像操作"><a href="#2-1-镜像操作" class="headerlink" title="2.1.镜像操作"></a>2.1.镜像操作</h2><h3 id="2-1-1-镜像名称"><a href="#2-1-1-镜像名称" class="headerlink" title="2.1.1.镜像名称"></a>2.1.1.镜像名称</h3><p>首先来看下镜像的名称组成：</p>
<ul>
<li>镜名称一般分两部分组成：[repository]:[tag]。</li>
<li>在没有指定tag时，默认是latest，代表最新版本的镜像</li>
</ul>
<p>如图：</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/8r3w.png"></p>
<p>这里的mysql就是repository，5.7就是tag，合一起就是镜像名称，代表5.7版本的MySQL镜像。</p>
<h3 id="2-1-2-镜像命令"><a href="#2-1-2-镜像命令" class="headerlink" title="2.1.2.镜像命令"></a>2.1.2.镜像命令</h3><p>常见的镜像操作命令如图：</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/190c.png"></p>
<h3 id="2-1-3-案例1-拉取、查看镜像"><a href="#2-1-3-案例1-拉取、查看镜像" class="headerlink" title="2.1.3.案例1-拉取、查看镜像"></a>2.1.3.案例1-拉取、查看镜像</h3><p>需求：从DockerHub中拉取一个nginx镜像并查看</p>
<p>1）首先去镜像仓库搜索nginx镜像，比如<a href="https://hub.docker.com/">DockerHub</a>:</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/6fi.png"></p>
<p>2）根据查看到的镜像名称，拉取自己需要的镜像，通过命令：docker pull nginx</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/191y.png"></p>
<p>3）通过命令：docker images 查看拉取到的镜像</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/1v2hq.png"></p>
<h3 id="2-1-4-案例2-保存、导入镜像"><a href="#2-1-4-案例2-保存、导入镜像" class="headerlink" title="2.1.4.案例2-保存、导入镜像"></a>2.1.4.案例2-保存、导入镜像</h3><p>需求：利用docker save将nginx镜像导出磁盘，然后再通过load加载回来</p>
<p>1）利用docker xx —help命令查看docker save和docker load的语法</p>
<p>例如，查看save命令用法，可以输入命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker save --<span class="built_in">help</span></span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/9l3f.png"></p>
<p>命令格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker save -o [保存的目标文件名称] [镜像名称]</span><br></pre></td></tr></table></figure>
<p>2）使用docker save导出镜像到磁盘 </p>
<p>运行命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker save -o nginx.tar nginx:latest</span><br></pre></td></tr></table></figure>
<p>结果如图：</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/9l58.png"></p>
<p>3）使用docker load加载镜像</p>
<p>先删除本地的nginx镜像：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker rmi nginx:latest</span><br></pre></td></tr></table></figure>
<p>然后运行命令，加载本地文件：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker load -i nginx.tar</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/9lam.png"></p>
<h3 id="2-1-5-练习"><a href="#2-1-5-练习" class="headerlink" title="2.1.5.练习"></a>2.1.5.练习</h3><p>需求：去DockerHub搜索并拉取一个Redis镜像</p>
<p>目标：</p>
<p>1）去DockerHub搜索Redis镜像</p>
<p>2）查看Redis镜像的名称和版本</p>
<p>3）利用docker pull命令拉取镜像</p>
<p>4）利用docker save命令将 redis:latest打包为一个redis.tar包</p>
<p>5）利用docker rmi 删除本地的redis:latest</p>
<p>6）利用docker load 重新加载 redis.tar文件</p>
<h2 id="2-2-容器操作"><a href="#2-2-容器操作" class="headerlink" title="2.2.容器操作"></a>2.2.容器操作</h2><h3 id="2-2-1-容器相关命令"><a href="#2-2-1-容器相关命令" class="headerlink" title="2.2.1.容器相关命令"></a>2.2.1.容器相关命令</h3><p>容器操作的命令如图：</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/9lcs.png"></p>
<p>容器保护三个状态：</p>
<ul>
<li>运行：进程正常运行</li>
<li>暂停：进程暂停，CPU不再运行，并不释放内存</li>
<li>停止：进程终止，回收进程占用的内存、CPU等资源</li>
</ul>
<p>其中：</p>
<ul>
<li>docker run：创建并运行一个容器，处于运行状态</li>
<li>docker pause：让一个运行的容器暂停</li>
<li>docker unpause：让一个容器从暂停状态恢复运行</li>
<li>docker stop：停止一个运行的容器</li>
<li>docker start：让一个停止的容器再次运行</li>
<li>docker rm：删除一个容器</li>
</ul>
<h3 id="2-2-2-案例-创建并运行一个容器"><a href="#2-2-2-案例-创建并运行一个容器" class="headerlink" title="2.2.2.案例-创建并运行一个容器"></a>2.2.2.案例-创建并运行一个容器</h3><p>创建并运行nginx容器的命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run --name containerName -p 80:80 -d nginx</span><br></pre></td></tr></table></figure>
<p>命令解读：</p>
<ul>
<li>docker run ：创建并运行一个容器</li>
<li>—name : 给容器起一个名字，比如叫做mn</li>
<li>-p ：将宿主机端口与容器端口映射，冒号左侧是宿主机端口，右侧是容器端口</li>
<li>-d：后台运行容器</li>
<li>nginx：镜像名称，例如nginx</li>
</ul>
<p>这里的<code>-p</code>参数，是将容器端口映射到宿主机端口。</p>
<p>默认情况下，容器是隔离环境，我们直接访问宿主机的80端口，肯定访问不到容器中的nginx。</p>
<p>现在，将容器的80与宿主机的80关联起来，当我们访问宿主机的80端口时，就会被映射到容器的80，这样就能访问到nginx了：</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/d25l1.png"></p>
<h3 id="2-2-3-案例-进入容器，修改文件"><a href="#2-2-3-案例-进入容器，修改文件" class="headerlink" title="2.2.3.案例-进入容器，修改文件"></a>2.2.3.案例-进入容器，修改文件</h3><p><strong>需求</strong>：进入Nginx容器，修改HTML文件内容，添加“传智教育欢迎您”</p>
<p><strong>提示</strong>：进入容器要用到docker exec命令。</p>
<p><strong>步骤</strong>：</p>
<p>1）进入容器。进入我们刚刚创建的nginx容器的命令为：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it mn bash</span><br></pre></td></tr></table></figure>
<p>命令解读：</p>
<ul>
<li>docker exec ：进入容器内部，执行一个命令</li>
<li>-it : 给当前进入的容器创建一个标准输入、输出终端，允许我们与容器交互</li>
<li>mn ：要进入的容器的名称</li>
<li>bash：进入容器后执行的命令，bash是一个linux终端交互命令</li>
</ul>
<p>2）进入nginx的HTML所在目录 /usr/share/nginx/html</p>
<p>容器内部会模拟一个独立的Linux文件系统，看起来如同一个linux服务器一样：</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/1v6lg.png"></p>
<p>nginx的环境、配置、运行文件全部都在这个文件系统中，包括我们要修改的html文件。</p>
<p>查看DockerHub网站中的nginx页面，可以知道nginx的html目录位置在<code>/usr/share/nginx/html</code></p>
<p>我们执行命令，进入该目录：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/share/nginx/html</span><br></pre></td></tr></table></figure>
<p> 查看目录下文件：</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/9llt.png"></p>
<p>3）修改index.html的内容</p>
<p>容器内没有vi命令，无法直接修改，我们用下面的命令来修改：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sed -i -e <span class="string">&#x27;s#Welcome to nginx#传智教育欢迎您#g&#x27;</span> -e <span class="string">&#x27;s#&lt;head&gt;#&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;#g&#x27;</span> index.html</span><br></pre></td></tr></table></figure>
<p>在浏览器访问自己的虚拟机地址即可看到结果：</p>
<h3 id="2-2-4-小结"><a href="#2-2-4-小结" class="headerlink" title="2.2.4.小结"></a>2.2.4.小结</h3><p>docker run命令的常见参数有哪些？</p>
<ul>
<li>—name：指定容器名称</li>
<li>-p：指定端口映射</li>
<li>-d：让容器后台运行</li>
</ul>
<p>查看容器日志的命令：</p>
<ul>
<li>docker logs</li>
<li>添加 -f 参数可以持续查看日志</li>
</ul>
<p>查看容器状态：</p>
<ul>
<li>docker ps</li>
<li>docker ps -a 查看所有容器，包括已经停止的</li>
</ul>
<h2 id="2-3-数据卷（容器数据管理）"><a href="#2-3-数据卷（容器数据管理）" class="headerlink" title="2.3.数据卷（容器数据管理）"></a>2.3.数据卷（容器数据管理）</h2><p>在之前的nginx案例中，修改nginx的html页面时，需要进入nginx内部。并且因为没有编辑器，修改文件也很麻烦。</p>
<p>这就是因为容器与数据（容器内文件）耦合带来的后果。</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/19hv.png"></p>
<p>要解决这个问题，必须将数据与容器解耦，这就要用到数据卷了。</p>
<h3 id="2-3-1-什么是数据卷"><a href="#2-3-1-什么是数据卷" class="headerlink" title="2.3.1.什么是数据卷"></a>2.3.1.什么是数据卷</h3><p><strong>数据卷（volume）</strong>是一个虚拟目录，指向宿主机文件系统中的某个目录。</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/6gy.png"></p>
<p>一旦完成数据卷挂载，对容器的一切操作都会作用在数据卷对应的宿主机目录了。</p>
<p>这样，我们操作宿主机的/var/lib/docker/volumes/html目录，就等于操作容器内的/usr/share/nginx/html目录了</p>
<h3 id="2-3-2-数据集操作命令"><a href="#2-3-2-数据集操作命令" class="headerlink" title="2.3.2.数据集操作命令"></a>2.3.2.数据集操作命令</h3><p>数据卷操作的基本语法如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker volume [COMMAND]</span><br></pre></td></tr></table></figure>
<p>docker volume命令是数据卷操作，根据命令后跟随的command来确定下一步的操作：</p>
<ul>
<li>create 创建一个volume</li>
<li>inspect 显示一个或多个volume的信息</li>
<li>ls 列出所有的volume</li>
<li>prune 删除未使用的volume</li>
<li>rm 删除一个或多个指定的volume</li>
</ul>
<h3 id="2-3-3-创建和查看数据卷"><a href="#2-3-3-创建和查看数据卷" class="headerlink" title="2.3.3.创建和查看数据卷"></a>2.3.3.创建和查看数据卷</h3><p><strong>需求</strong>：创建一个数据卷，并查看数据卷在宿主机的目录位置</p>
<p>① 创建数据卷</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker volume create html</span><br></pre></td></tr></table></figure>
<p>② 查看所有数据</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker volume <span class="built_in">ls</span></span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/6hz.png"></p>
<p>③ 查看数据卷详细信息卷</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker volume inspect html</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/8t97.png"></p>
<p>可以看到，我们创建的html这个数据卷关联的宿主机目录为<code>/var/lib/docker/volumes/html/_data</code>目录。</p>
<p><strong>小结</strong>：</p>
<p>数据卷的作用：</p>
<ul>
<li>将容器与数据分离，解耦合，方便操作容器内数据，保证数据安全</li>
</ul>
<p>数据卷操作：</p>
<ul>
<li>docker volume create：创建数据卷</li>
<li>docker volume ls：查看所有数据卷</li>
<li>docker volume inspect：查看数据卷详细信息，包括关联的宿主机目录位置</li>
<li>docker volume rm：删除指定数据卷</li>
<li>docker volume prune：删除所有未使用的数据卷</li>
</ul>
<h3 id="2-3-4-挂载数据卷"><a href="#2-3-4-挂载数据卷" class="headerlink" title="2.3.4.挂载数据卷"></a>2.3.4.挂载数据卷</h3><p>我们在创建容器时，可以通过 -v 参数来挂载一个数据卷到某个容器内目录，命令格式如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run \</span><br><span class="line">  --name mn \</span><br><span class="line">  -v html:/root/html \</span><br><span class="line">  -p 8080:80</span><br><span class="line">  nginx \</span><br></pre></td></tr></table></figure>
<p>这里的-v就是挂载数据卷的命令：</p>
<ul>
<li><code>-v html:/root/htm</code> ：把html数据卷挂载到容器内的/root/html这个目录中</li>
</ul>
<h3 id="2-3-5-案例-给nginx挂载数据卷"><a href="#2-3-5-案例-给nginx挂载数据卷" class="headerlink" title="2.3.5.案例-给nginx挂载数据卷"></a>2.3.5.案例-给nginx挂载数据卷</h3><p><strong>需求</strong>：创建一个nginx容器，修改容器内的html目录内的index.html内容</p>
<p><strong>分析</strong>：上个案例中，我们进入nginx容器内部，已经知道nginx的html目录所在位置/usr/share/nginx/html ，我们需要把这个目录挂载到html这个数据卷上，方便操作其中的内容。</p>
<p><strong>提示</strong>：运行容器时使用 -v 参数挂载数据卷</p>
<p>步骤：</p>
<p>① 创建容器并挂载数据卷到容器内的HTML目录</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run --name mn -v html:/usr/share/nginx/html -p 80:80 -d nginx</span><br></pre></td></tr></table></figure>
<p>② 进入html数据卷所在位置，并修改HTML内容</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看html数据卷的位置</span></span><br><span class="line">docker volume inspect html</span><br><span class="line"><span class="comment"># 进入该目录</span></span><br><span class="line"><span class="built_in">cd</span> /var/lib/docker/volumes/html/_data</span><br><span class="line"><span class="comment"># 修改文件</span></span><br><span class="line">vi index.html</span><br></pre></td></tr></table></figure>
<h3 id="2-3-6-案例-给MySQL挂载本地目录"><a href="#2-3-6-案例-给MySQL挂载本地目录" class="headerlink" title="2.3.6.案例-给MySQL挂载本地目录"></a>2.3.6.案例-给MySQL挂载本地目录</h3><p>容器不仅仅可以挂载数据卷，也可以直接挂载到宿主机目录上。关联关系如下：</p>
<ul>
<li>带数据卷模式：宿主机目录 —&gt; 数据卷 —-&gt; 容器内目录</li>
<li>直接挂载模式：宿主机目录 —-&gt; 容器内目录</li>
</ul>
<p>如图：</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/8uwz.png"></p>
<p><strong>语法</strong>：</p>
<p>目录挂载与数据卷挂载的语法是类似的：</p>
<ul>
<li>-v [宿主机目录]:[容器内目录]</li>
<li>-v [宿主机文件]:[容器内文件]</li>
</ul>
<p><strong>需求</strong>：创建并运行一个MySQL容器，将宿主机目录直接挂载到容器</p>
<p>实现思路如下：</p>
<p>1）在将课前资料中的mysql.tar文件上传到虚拟机，通过load命令加载为镜像</p>
<p>2）创建目录/tmp/mysql/data</p>
<p>3）创建目录/tmp/mysql/conf，将课前资料提供的hmy.cnf文件上传到/tmp/mysql/conf</p>
<p>4）去DockerHub查阅资料，创建并运行MySQL容器，要求：</p>
<p>① 挂载/tmp/mysql/data到mysql容器内数据存储目录</p>
<p>② 挂载/tmp/mysql/conf/hmy.cnf到mysql容器的配置文件</p>
<p>③ 设置MySQL密码</p>
<h3 id="2-3-7-小结"><a href="#2-3-7-小结" class="headerlink" title="2.3.7.小结"></a>2.3.7.小结</h3><p>docker run的命令中通过 -v 参数挂载文件或目录到容器中：</p>
<ul>
<li>-v volume名称:容器内目录</li>
<li>-v 宿主机文件:容器内文</li>
<li>-v 宿主机目录:容器内目录</li>
</ul>
<p>数据卷挂载与目录直接挂载的</p>
<ul>
<li>数据卷挂载耦合度低，由docker来管理目录，但是目录较深，不好找</li>
<li>目录挂载耦合度高，需要我们自己管理目录，不过目录容易寻找查看</li>
</ul>
<h1 id="3-Dockerfile自定义镜像"><a href="#3-Dockerfile自定义镜像" class="headerlink" title="3.Dockerfile自定义镜像"></a>3.Dockerfile自定义镜像</h1><p>常见的镜像在DockerHub就能找到，但是我们自己写的项目就必须自己构建镜像了。</p>
<p>而要自定义镜像，就必须先了解镜像的结构才行。</p>
<h2 id="3-1-镜像结构"><a href="#3-1-镜像结构" class="headerlink" title="3.1.镜像结构"></a>3.1.镜像结构</h2><p>镜像是将应用程序及其需要的系统函数库、环境、配置、依赖打包而成。</p>
<p>我们以MySQL为例，来看看镜像的组成结构：</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/6ik.png"></p>
<p>简单来说，镜像就是在系统函数库、运行环境基础上，添加应用程序文件、配置文件、依赖文件等组合，然后编写好启动脚本打包在一起形成的文件。</p>
<p>我们要构建镜像，其实就是实现上述打包的过程。</p>
<h2 id="3-2-Dockerfile语法"><a href="#3-2-Dockerfile语法" class="headerlink" title="3.2.Dockerfile语法"></a>3.2.Dockerfile语法</h2><p>构建自定义的镜像时，并不需要一个个文件去拷贝，打包。</p>
<p>我们只需要告诉Docker，我们的镜像的组成，需要哪些BaseImage、需要拷贝什么文件、需要安装什么依赖、启动脚本是什么，将来Docker会帮助我们构建镜像。</p>
<p>而描述上述信息的文件就是Dockerfile文件。</p>
<p><strong>Dockerfile</strong>就是一个文本文件，其中包含一个个的<strong>指令(Instruction)</strong>，用指令来说明要执行什么操作来构建镜像。每一个指令都会形成一层Layer。</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/19ok.png"></p>
<p>更新详细语法说明，请参考官网文档： <a href="https://docs.docker.com/engine/reference/builder">https://docs.docker.com/engine/reference/builder</a></p>
<h2 id="3-3-构建Java项目"><a href="#3-3-构建Java项目" class="headerlink" title="3.3.构建Java项目"></a>3.3.构建Java项目</h2><h3 id="3-3-1-基于Ubuntu构建Java项目"><a href="#3-3-1-基于Ubuntu构建Java项目" class="headerlink" title="3.3.1.基于Ubuntu构建Java项目"></a>3.3.1.基于Ubuntu构建Java项目</h3><p>需求：基于Ubuntu镜像构建一个新镜像，运行一个java项目</p>
<ul>
<li><p>步骤1：新建一个空文件夹docker-demo</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/1mhj.png"></p>
</li>
<li><p>步骤2：拷贝课前资料中的docker-demo.jar文件到docker-demo这个目录</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/bcq9.png"></p>
</li>
<li><p>步骤3：拷贝课前资料中的jdk8.tar.gz文件到docker-demo这个目录</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/bdf2.png"></p>
</li>
<li><p>步骤4：拷贝课前资料提供的Dockerfile到docker-demo这个目录</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/bdf2.png"></p>
<p>其中的内容如下：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">16.04</span></span><br><span class="line"><span class="comment"># 配置环境变量，JDK的安装目录</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_DIR=/usr/local</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝jdk和java项目的包</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./jdk8.tar.gz <span class="variable">$JAVA_DIR</span>/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./docker-demo.jar /tmp/app.jar</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装JDK</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">cd</span> <span class="variable">$JAVA_DIR</span> \</span></span><br><span class="line"><span class="language-bash"> &amp;&amp; tar -xf ./jdk8.tar.gz \</span></span><br><span class="line"><span class="language-bash"> &amp;&amp; <span class="built_in">mv</span> ./jdk1.8.0_144 ./java8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_HOME=$JAVA_DIR/java8</span><br><span class="line"><span class="keyword">ENV</span> PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 暴露端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8090</span></span><br><span class="line"><span class="comment"># 入口，java项目的启动命令</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> java -jar /tmp/app.jar</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>步骤5：进入docker-demo</p>
<p>将准备好的docker-demo上传到虚拟机任意目录，然后进入docker-demo目录下</p>
</li>
<li><p>步骤6：运行命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker build -t javaweb:1.0 .</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>最后访问 <a href="http://192.168.150.101:8090/hello/count，其中的ip改成你的虚拟机ip">http://192.168.150.101:8090/hello/count，其中的ip改成你的虚拟机ip</a></p>
<h3 id="3-3-2-基于java8构建Java项目"><a href="#3-3-2-基于java8构建Java项目" class="headerlink" title="3.3.2.基于java8构建Java项目"></a>3.3.2.基于java8构建Java项目</h3><p>虽然我们可以基于Ubuntu基础镜像，添加任意自己需要的安装包，构建镜像，但是却比较麻烦。所以大多数情况下，我们都可以在一些安装了部分软件的基础镜像上做改造。</p>
<p>例如，构建java项目的镜像，可以在已经准备了JDK的基础镜像基础上构建。</p>
<p>需求：基于java:8-alpine镜像，将一个Java项目构建为镜像</p>
<p>实现思路如下：</p>
<ul>
<li><p>① 新建一个空的目录，然后在目录中新建一个文件，命名为Dockerfile</p>
</li>
<li><p>② 拷贝课前资料提供的docker-demo.jar到这个目录中</p>
</li>
<li><p>③ 编写Dockerfile文件：</p>
<ul>
<li><p>a ）基于java:8-alpine作为基础镜像</p>
</li>
<li><p>b ）将app.jar拷贝到镜像中</p>
</li>
<li><p>c ）暴露端口</p>
</li>
<li><p>d ）编写入口ENTRYPOINT</p>
<p>内容如下：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> java:<span class="number">8</span>-alpine</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./app.jar /tmp/app.jar</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8090</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> java -jar /tmp/app.jar</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>④ 使用docker build命令构建镜像</p>
</li>
<li><p>⑤ 使用docker run创建容器并运行</p>
</li>
</ul>
<h2 id="3-4-小结"><a href="#3-4-小结" class="headerlink" title="3.4.小结"></a>3.4.小结</h2><p>小结：</p>
<ol>
<li>Dockerfile的本质是一个文件，通过指令描述镜像的构建过程</li>
<li>Dockerfile的第一行必须是FROM，从一个基础镜像来构建</li>
<li>基础镜像可以是基本操作系统，如Ubuntu。也可以是其他人制作好的镜像，例如：java:8-alpine</li>
</ol>
<h1 id="4-Docker-Compose"><a href="#4-Docker-Compose" class="headerlink" title="4.Docker-Compose"></a>4.Docker-Compose</h1><p>Docker Compose可以基于Compose文件帮我们快速的部署分布式应用，而无需手动一个个创建和运行容器！</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/8bp.png"></p>
<h2 id="4-1-初识DockerCompose"><a href="#4-1-初识DockerCompose" class="headerlink" title="4.1.初识DockerCompose"></a>4.1.初识DockerCompose</h2><p>Compose文件是一个文本文件，通过指令定义集群中的每个容器如何运行。格式如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">version<span class="punctuation">:</span> <span class="string">&quot;3.8&quot;</span></span><br><span class="line"> services<span class="punctuation">:</span></span><br><span class="line">  mysql<span class="punctuation">:</span></span><br><span class="line">    image<span class="punctuation">:</span> mysql<span class="punctuation">:</span><span class="number">5.7</span><span class="number">.25</span></span><br><span class="line">    environment<span class="punctuation">:</span></span><br><span class="line">     MYSQL_ROOT_PASSWORD<span class="punctuation">:</span> <span class="number">123</span> </span><br><span class="line">    volumes<span class="punctuation">:</span></span><br><span class="line">     - <span class="string">&quot;/tmp/mysql/data:/var/lib/mysql&quot;</span></span><br><span class="line">     - <span class="string">&quot;/tmp/mysql/conf/hmy.cnf:/etc/mysql/conf.d/hmy.cnf&quot;</span></span><br><span class="line">  web<span class="punctuation">:</span></span><br><span class="line">    build<span class="punctuation">:</span> .</span><br><span class="line">    ports<span class="punctuation">:</span></span><br><span class="line">     - <span class="string">&quot;8090:8090&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面的Compose文件就描述一个项目，其中包含两个容器：</p>
<ul>
<li>mysql：一个基于<code>mysql:5.7.25</code>镜像构建的容器，并且挂载了两个目录</li>
<li>web：一个基于<code>docker build</code>临时构建的镜像容器，映射端口时8090</li>
</ul>
<p>DockerCompose的详细语法参考官网：<a href="https://docs.docker.com/compose/compose-file/">https://docs.docker.com/compose/compose-file/</a></p>
<p>其实DockerCompose文件可以看做是将多个docker run命令写到一个文件，只是语法稍有差异。</p>
<h2 id="4-2-安装DockerCompose"><a href="#4-2-安装DockerCompose" class="headerlink" title="4.2.安装DockerCompose"></a>4.2.安装DockerCompose</h2><p>参考课前资料</p>
<h2 id="4-3-部署微服务集群"><a href="#4-3-部署微服务集群" class="headerlink" title="4.3.部署微服务集群"></a>4.3.部署微服务集群</h2><p><strong>需求</strong>：将之前学习的cloud-demo微服务集群利用DockerCompose部署</p>
<p><strong>实现思路</strong>：</p>
<p>① 查看课前资料提供的cloud-demo文件夹，里面已经编写好了docker-compose文件</p>
<p>② 修改自己的cloud-demo项目，将数据库、nacos地址都命名为docker-compose中的服务名</p>
<p>③ 使用maven打包工具，将项目中的每个微服务都打包为app.jar</p>
<p>④ 将打包好的app.jar拷贝到cloud-demo中的每一个对应的子目录中</p>
<p>⑤ 将cloud-demo上传至虚拟机，利用 docker-compose up -d 来部署</p>
<h3 id="4-3-1-compose文件"><a href="#4-3-1-compose文件" class="headerlink" title="4.3.1.compose文件"></a>4.3.1.compose文件</h3><p>查看课前资料提供的cloud-demo文件夹，里面已经编写好了docker-compose文件，而且每个微服务都准备了一个独立的目录：</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/bbur.png"></p>
<p>内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">nacos:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nacos/nacos-server</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MODE:</span> <span class="string">standalone</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8848:8848&quot;</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:5.7.25</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="number">123</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;$PWD/mysql/data:/var/lib/mysql&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;$PWD/mysql/conf:/etc/mysql/conf.d/&quot;</span></span><br><span class="line">  <span class="attr">userservice:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">./user-service</span></span><br><span class="line">  <span class="attr">orderservice:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">./order-service</span></span><br><span class="line">  <span class="attr">gateway:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">./gateway</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;10010:10010&quot;</span></span><br></pre></td></tr></table></figure>
<p>可以看到，其中包含5个service服务：</p>
<ul>
<li><code>nacos</code>：作为注册中心和配置中心<ul>
<li><code>image: nacos/nacos-server</code>： 基于nacos/nacos-server镜像构建</li>
<li><code>environment</code>：环境变量<ul>
<li><code>MODE: standalone</code>：单点模式启动</li>
</ul>
</li>
<li><code>ports</code>：端口映射，这里暴露了8848端口</li>
</ul>
</li>
<li><code>mysql</code>：数据库<ul>
<li><code>image: mysql:5.7.25</code>：镜像版本是mysql:5.7.25</li>
<li><code>environment</code>：环境变量<ul>
<li><code>MYSQL_ROOT_PASSWORD: 123</code>：设置数据库root账户的密码为123</li>
</ul>
</li>
<li><code>volumes</code>：数据卷挂载，这里挂载了mysql的data、conf目录，其中有我提前准备好的数据</li>
</ul>
</li>
<li><code>userservice</code>、<code>orderservice</code>、<code>gateway</code>：都是基于Dockerfile临时构建的</li>
</ul>
<p>查看mysql目录，可以看到其中已经准备好了cloud_order、cloud_user表：</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/bd7c.png"></p>
<p>查看微服务目录，可以看到都包含Dockerfile文件：</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/bd3h.png"></p>
<p>内容如下：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> java:<span class="number">8</span>-alpine</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./app.jar /tmp/app.jar</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> java -jar /tmp/app.jar</span></span><br></pre></td></tr></table></figure>
<h3 id="4-3-2-修改微服务配置"><a href="#4-3-2-修改微服务配置" class="headerlink" title="4.3.2.修改微服务配置"></a>4.3.2.修改微服务配置</h3><p>因为微服务将来要部署为docker容器，而容器之间互联不是通过IP地址，而是通过容器名。这里我们将order-service、user-service、gateway服务的mysql、nacos地址都修改为基于容器名的访问。</p>
<p>如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://mysql:3306/cloud_order?useSSL=false</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">orderservice</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">nacos:8848</span> <span class="comment"># nacos服务地址</span></span><br></pre></td></tr></table></figure>
<h3 id="4-3-3-打包"><a href="#4-3-3-打包" class="headerlink" title="4.3.3.打包"></a>4.3.3.打包</h3><p>接下来需要将我们的每个微服务都打包。因为之前查看到Dockerfile中的jar包名称都是app.jar，因此我们的每个微服务都需要用这个名称。</p>
<p>可以通过修改pom.xml中的打包名称来实现，每个微服务都需要修改：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 服务打包的最终名称 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>app<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>打包后：</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/bcbv.png"></p>
<h3 id="4-3-4-拷贝jar包到部署目录"><a href="#4-3-4-拷贝jar包到部署目录" class="headerlink" title="4.3.4.拷贝jar包到部署目录"></a>4.3.4.拷贝jar包到部署目录</h3><p>编译打包好的app.jar文件，需要放到Dockerfile的同级目录中。注意：每个微服务的app.jar放到与服务名称对应的目录，别搞错了。</p>
<p>user-service：</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/8bw.png"></p>
<p>order-service：</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/1mg8.png"></p>
<p>gateway：</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/bcuz.png"></p>
<h3 id="4-3-5-部署"><a href="#4-3-5-部署" class="headerlink" title="4.3.5.部署"></a>4.3.5.部署</h3><p>最后，我们需要将文件整个cloud-demo文件夹上传到虚拟机中，理由DockerCompose部署。</p>
<p>上传到任意目录：</p>
<p><img src="https://i.p04e.com/baid/i/2022/11/22/bdac.png"></p>
<p>部署：</p>
<p>进入cloud-demo目录，然后运行下面的命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>
<h1 id="5-Docker镜像仓库"><a href="#5-Docker镜像仓库" class="headerlink" title="5.Docker镜像仓库"></a>5.Docker镜像仓库</h1><h2 id="5-1-搭建私有镜像仓库"><a href="#5-1-搭建私有镜像仓库" class="headerlink" title="5.1.搭建私有镜像仓库"></a>5.1.搭建私有镜像仓库</h2><p>参考课前资料《CentOS7安装Docker.md》</p>
<h2 id="5-2-推送、拉取镜像"><a href="#5-2-推送、拉取镜像" class="headerlink" title="5.2.推送、拉取镜像"></a>5.2.推送、拉取镜像</h2><p>推送镜像到私有镜像服务必须先tag，步骤如下：</p>
<p>① 重新tag本地镜像，名称前缀为私有仓库的地址：192.168.150.101:8080/</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker tag nginx:latest 192.168.150.101:8080/nginx:1.0 </span><br></pre></td></tr></table></figure>
<p>② 推送镜像</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker push 192.168.150.101:8080/nginx:1.0 </span><br></pre></td></tr></table></figure>
<p>③ 拉取镜像</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker pull 192.168.150.101:8080/nginx:1.0 </span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Docker</tag>
        <tag>镜像仓库</tag>
        <tag>数据卷</tag>
      </tags>
  </entry>
  <entry>
    <title>Nacos-服务发现与配置管理v1.0</title>
    <url>/2023/01/06/Nacos-%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E4%B8%8E%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86v1-0/</url>
    <content><![CDATA[<h1 id="Nacos-服务发现和配置管理"><a href="#Nacos-服务发现和配置管理" class="headerlink" title="Nacos - 服务发现和配置管理"></a>Nacos - 服务发现和配置管理</h1><h2 id="1-理解服务发现"><a href="#1-理解服务发现" class="headerlink" title="1 理解服务发现"></a>1 <strong>理解服务发现</strong></h2><h3 id="1-1-微服务架构"><a href="#1-1-微服务架构" class="headerlink" title="1.1 微服务架构"></a>1.1 <strong>微服务架构</strong></h3><p>为适应企业的业务发展，提高软件研发的生产力，降低软件研发的成本，软件架构也作了升级和优化，将一个独立 的系统拆分成若干小的服务，每个小服务运行在不同的进程中，服务与服务之间采用RESTful、RPC等协议传输数    据，每个服务所拥有的功能具有独立性强的特点，这样的设计就实现了单个服务的高内聚，服务与服务之间的低耦 合效果，这些小服务就是微服务，基于这种方法设计的系统架构即微服务架构。</p>
<span id="more"></span>
<p>下图是基于微服务架构的电商系统：</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/06/5het.png"></p>
<p>特点：</p>
<p>1、服务层按业务拆分为一个一个的微服务。</p>
<p>2、微服务的职责单一。</p>
<p>3、微服务之间采用RESTful、RPC等轻量级协议传输。</p>
<p>4、有利于采用前后端分离架构。</p>
<h3 id="1-2理解服务发现"><a href="#1-2理解服务发现" class="headerlink" title="1.2理解服务发现"></a>1.2<strong>理解服务发现</strong></h3><h4 id="1-2-1-测试环境"><a href="#1-2-1-测试环境" class="headerlink" title="1.2.1 测试环境"></a>1.2.1 <strong>测试环境</strong></h4><p>在微服务架构中，整个系统会按职责能力划分为多个服务，通过服务之间协作来实现业务目标。这样在我们的代码 中免不了要进行服务间的远程调用，服务的消费方要调用服务的生产方，为了完成一次请求，消费方需要知道服务 生产方的网络位置(IP地址和端口号)。</p>
<p>我们的代码可以通过读取配置文件的方式读取服务生产方网络位置，如下：</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/06/62i4.png"></p>
<p>我们通过Spring boot技术很容易实现： </p>
<p><strong>1</strong>、创建nacos-discovery父工程</p>
<p>pom.xml如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF‐8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema‐instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0</span><br><span class="line">http://maven.apache.org/xsd/maven‐4.0.0.xsd&quot;&gt;</span><br><span class="line">&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">&lt;groupId&gt;com.itheima.nacos&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;nacos‐discovery&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.0‐SNAPSHOT&lt;/version&gt;</span><br><span class="line">&lt;packaging&gt;pom&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring‐boot‐dependencies&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;2.1.3.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">&lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line">&lt;/dependencyManagement&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>
<p>2、Service B（服务生产者）</p>
<p>创建服务提供者 nacos-restful-provider。</p>
<p>pom.xml如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF‐8&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema‐instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0</span><br><span class="line">http://maven.apache.org/xsd/maven‐4.0.0.xsd&quot;&gt;</span><br><span class="line">&lt;parent&gt;</span><br><span class="line">&lt;artifactId&gt;nacos‐discovery&lt;/artifactId&gt;</span><br><span class="line">&lt;groupId&gt;com.itheima.nacos&lt;/groupId&gt;</span><br><span class="line">&lt;version&gt;1.0‐SNAPSHOT&lt;/version&gt;</span><br><span class="line">&lt;/parent&gt;</span><br><span class="line">&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">&lt;artifactId&gt;nacos‐restful‐provider&lt;/artifactId&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring‐boot‐starter‐web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>
<p>1、创建Controller</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.nacos.provider.controller;</span><br><span class="line"></span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">public class RestProviderController &#123; @GetMapping(value = &quot;/service&quot;) //暴露服务public String service()&#123;</span><br><span class="line">System.out.println(&quot;provider invoke&quot;); return &quot;provider invoke&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、创建启动类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class SpringRestProviderBootstrap &#123; public static void main(String[] args) &#123;</span><br><span class="line">SpringApplication.run(SpringRestProviderBootstrap.class, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置文件：</p>
<p>创建application.yml，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server：</span><br><span class="line">port：56010</span><br></pre></td></tr></table></figure>
<p><strong>3</strong>、<strong>Service</strong> <strong>A</strong>（服务消费者）</p>
<p>创建nacos-restful-consumer 服务消费工程。</p>
<p>pom.xml如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF‐8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema‐instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0</span><br><span class="line">http://maven.apache.org/xsd/maven‐4.0.0.xsd&quot;&gt;</span><br><span class="line">&lt;parent&gt;</span><br><span class="line">&lt;artifactId&gt;nacos‐discovery&lt;/artifactId&gt;</span><br><span class="line">&lt;groupId&gt;com.itheima.nacos&lt;/groupId&gt;</span><br><span class="line">&lt;version&gt;1.0‐SNAPSHOT&lt;/version&gt;</span><br><span class="line">&lt;/parent&gt;</span><br><span class="line">&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">&lt;artifactId&gt;nacos‐restful‐consumer&lt;/artifactId&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring‐boot‐starter‐web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>
<p>实现代码：</p>
<p>1、创建controller</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.nacos.consumer.controller;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.annotation.Value; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; import org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">public class RestConsumerController &#123; @Value(&quot;$&#123;provider.address&#125;&quot;) private String providerAddress;</span><br><span class="line">@GetMapping(value = &quot;/service&quot;)</span><br><span class="line">public String service()&#123;</span><br><span class="line">RestTemplate restTemplate = new RestTemplate();</span><br><span class="line">//调用服务</span><br><span class="line">String providerResult = restTemplate.getForObject(&quot;http://&quot; + providerAddress + &quot;/service&quot;,String.class);</span><br><span class="line">return &quot;consumer invoke | &quot; + providerResult;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、创建启动类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class SpringRestConsumerBootstrap &#123; public static void main(String[] args) &#123;</span><br><span class="line">SpringApplication.run(SpringRestConsumerBootstrap.class, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置文件：</p>
<p>创建application.yml，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server.port = 56020 # 服务生产方地址</span><br><span class="line">provider.address = 127.0.0.1:56010</span><br></pre></td></tr></table></figure>
<p>访问<a href="http://127.0.0.1:56020/service，输出以下内容：">http://127.0.0.1:56020/service，输出以下内容：</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">consumer invoke | provider invoke</span><br></pre></td></tr></table></figure>
<h4 id="1-2-2-服务发现流程"><a href="#1-2-2-服务发现流程" class="headerlink" title="1.2.2 服务发现流程"></a>1.2.2 <strong>服务发现流程</strong></h4><p>上边的例子看上去很完美，但是，仔细考虑以下，此方案对于微服务应用而言行不通。首先，微服务可能是部署在 云环境的，服务实例的网络位置或许是动态分配的。另外，每一个服务一般会有多个实例来做负载均衡，由于宕机 或升级，服务实例网络地址会经常动态改变。再者，每一个服务也可能应对临时访问压力增加新的服务节点。正如 下图所示：</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/06/tib.png"></p>
<p>基于以上的问题，服务之间如何相互发现？服务如何管理？这就是服务发现的问题了。</p>
<p>服务发现就是服务消费方通过服务发现中心智能发现服务提供方，从而进行远程调用的过程。 如下图：</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/06/z5c.png"></p>
<p>上图中服务实例本身并不记录服务生产方的网络地址，所有服务实例内部都会包含<strong>服务发现客户端</strong>。</p>
<p>（1） 在每个服务启动时会向<strong>服务发现中心</strong>上报自己的网络位置。这样，在服务发现中心内部会形成一个<strong>服务注册</strong> <strong>表</strong>，<strong>服务注册表</strong>是服务发现的核心部分，是包含所有服务实例的网络地址的数据库。</p>
<p>（2） <strong>服务发现客户端</strong>会定期从<strong>服务发现中心</strong>同步<strong>服务注册表</strong>   ，并缓存在客户端。</p>
<p>（3） 当需要对某服务进行请求时，服务实例通过该注册表，定位目标服务网络地址。若目标服务存在多个网络地 址，则使用负载均衡算法从多个服务实例中选择出一个，然后发出请求。</p>
<p>总结，在微服务环境中，由于服务运行实例的网络地址是不断动态变化的，服务实例数量的动态变化   ，因此无法使用固定的配置文件来记录服务提供方的网络地址，必须使用动态的服务发现机制用于实现微服务间的<strong>相互感知</strong>。 各服务实例会上报自己的网络地址，这样服务中心就形成了一个完整的服务注册表，各服务实例会通过<strong>服务发现中</strong> <strong>心</strong>来获取访问目标服务的网络地址，从而实现<strong>服务发现</strong>的机制。</p>
<h2 id="2-Nacos-服务发现"><a href="#2-Nacos-服务发现" class="headerlink" title="2 Nacos 服务发现"></a>2 <strong>Nacos</strong> <strong>服务发现</strong></h2><h3 id="2-1-Nacos特性"><a href="#2-1-Nacos特性" class="headerlink" title="2.1. Nacos特性"></a>2.1. <strong>Nacos</strong>特性</h3><p>Nacos主要提供以下四大功能：</p>
<ol>
<li><strong>服务发现与服务健康检查</strong></li>
</ol>
<p>Nacos使服务更容易注册，并通过DNS或HTTP接口发现其他服务，Nacos还提供服务的实时健康检查，以防 止向不健康的主机或服务实例发送请求。</p>
<ol>
<li><strong>动态配置管理</strong></li>
</ol>
<p>动态配置服务允许您在所有环境中以集中和动态的方式管理所有服务的配置。Nacos消除了在更新配置时重新 部署应用程序，这使配置的更改更加高效和灵活。</p>
<ol>
<li><strong>动态DNS服务</strong></li>
</ol>
<p>Nacos提供基于DNS   协议的服务发现能力，旨在支持异构语言的服务发现，支持将注册在Nacos上的服务以域名的方式暴露端点，让三方应用方便的查阅及发现。</p>
<ol>
<li><strong>服务和元数据管理</strong></li>
</ol>
<p>Nacos 能让您从微服务平台建设的视角管理数据中心的所有服务及元数据，包括管理服务的描述、生命周期、服务的静态依赖分析、服务的健康状态、服务的流量管理、路由及安全策略。</p>
<h3 id="2-2-启动服务器"><a href="#2-2-启动服务器" class="headerlink" title="2.2 启动服务器"></a>2.2 <strong>启动服务器</strong></h3><p>nacos的默认端口是8848，需要保证8848默认端口没有被其他进程占用。 进入安装程序的bin目录：</p>
<p><strong>Windows</strong>启动方式： 启动命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmd startup.cmd</span><br></pre></td></tr></table></figure>
<p>或者双击startup.cmd运行文件。</p>
<p>启动成功，可通过浏览器访问   <a href="http://127.0.0.1:8848/nacos">http://127.0.0.1:8848/nacos</a>   ，打开如下nacos控制台登录页面：</p>
<p>启动成功，可通过浏览器访问   <a href="http://127.0.0.1:8848/nacos">http://127.0.0.1:8848/nacos</a>   ，打开如下nacos控制台登录页面：</p>
<h3 id="2-3外部mysql数据库支持"><a href="#2-3外部mysql数据库支持" class="headerlink" title="2.3外部mysql数据库支持"></a>2.3<strong>外部</strong>mysql<strong>数据库支持</strong></h3><p>单机模式时nacos默认使用嵌入式数据库实现数据的存储，若想使用外部mysql存储nacos数据，需要进行以下步 骤：</p>
<ol>
<li><p>安装数据库，版本要求：5.6.5+ ，mysql 8 以下</p>
</li>
<li><p>初始化mysql数据库，新建数据库nacos_conﬁg，数据库初始化文件：${nacoshome}/conf/nacos- mysql.sql</p>
</li>
<li><p>修改${nacoshome}/conf/application.properties文件，增加支持mysql数据源配置（目前只支持mysql），添加mysql数据源的url、用户名和密码。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring.datasource.platform=mysql</span><br><span class="line"></span><br><span class="line">db.num=1 db.url.0=jdbc:mysql://11.162.196.16:3306/nacos_config?</span><br><span class="line">characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true db.user=nacos_devtest</span><br><span class="line">db.password=youdontknow</span><br></pre></td></tr></table></figure>
<h3 id="2-4-服务注册"><a href="#2-4-服务注册" class="headerlink" title="2.4 服务注册"></a>2.4 <strong>服务注册</strong></h3><p>在服务提供工程中配置nacos服务发现相关的配置： </p>
<p>服务提供：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">application:</span><br><span class="line">name: nacos‐restful‐provider cloud:</span><br><span class="line">nacos:</span><br><span class="line">discovery:</span><br><span class="line">server‐addr: 127.0.0.1:8848</span><br></pre></td></tr></table></figure>
<p>启动nacos</p>
<p>启动服务提供</p>
<p>观察nacos服务列表，nacos-restful-provider注册成功</p>
<h2 id="3-服务发现数据模型"><a href="#3-服务发现数据模型" class="headerlink" title="3. 服务发现数据模型"></a>3. <strong>服务发现数据模型</strong></h2><h3 id="3-1-Namespace-隔离设计"><a href="#3-1-Namespace-隔离设计" class="headerlink" title="3.1 Namespace 隔离设计"></a>3.1 <strong>Namespace</strong> <strong>隔离设计</strong></h3><p><strong>命名空间**</strong>(Namespace)**用于进行租户粒度的隔离，Namespace    的常用场景之一是不同环境的隔离，例如开发测试环境和生产环境的资源（如配置、服务）隔离等。</p>
<p>从一个租户(用户)的角度来看，如果有多套不同的环境，那么这个时候可以根据指定的环境来创建不同的namespce，以此来实现多环境的隔离。例如，你可能有开发，测试和生产三个不同的环境，那么使用一套nacos 集群可以分别建以下三个不同的 namespace。如下图所示：</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/06/1lu2.png"></p>
<p>从多个租户(用户)的角度来看，每个租户(用户)可能会有自己的 namespace,每个租户(用户)的配置数据以及注册的服务数据都会归属到自己的 namespace 下，以此来实现多租户间的数据隔离。例如超级管理员分配了三个租户，分别为张三、李四和王五。分配好了之后，各租户用自己的账户名和密码登录后，创建自己的命名   空间。如下图所示：</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/06/1j07.png"></p>
<h3 id="3-2-命名空间管理"><a href="#3-2-命名空间管理" class="headerlink" title="3.2 命名空间管理"></a>3.2 <strong>命名空间管理</strong></h3><p>前面已经介绍过，命名空间(Namespace)是用于隔离多个环境的（如开发、测试、生产），而每个应用在不同环    境的同一个配置（如数据库数据源）的值是不一样的。因此，我们应针对企业项目实际研发流程、环境进行规划。 如某软件公司拥有开发、测试、生产三套环境，那么我们应该针对这三个环境分别建立三个namespace。</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/06/cpmx.png"></p>
<p>建立好所有namespace后，在<strong>配置管理</strong>与<strong>服务管理</strong>模块下所有页面，都会包含用于切换namespace(环境)的tab按   钮，如下图：</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/06/cwvj.png"></p>
<h2 id="4-Nacos配置管理"><a href="#4-Nacos配置管理" class="headerlink" title="4. Nacos配置管理"></a>4. <strong>Nacos</strong>配置管理</h2><p>首先在nacos发布配置，nacos-restful-consumer服务从nacos读取配置。</p>
<p>浏览器访问 <a href="http://127.0.0.1:8848/nacos">http://127.0.0.1:8848/nacos</a> ，打开nacos控制台，并点击菜单<strong>配置管理**</strong>-&gt;<strong>**配置列表</strong>： 在Nacos添加如下的配置：</p>
<p>nacos-restful-consumer:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Namespace: public</span><br><span class="line">Data ID:	nacos‐restful‐consumer.yaml Group :	DEFAULT_GROUP</span><br><span class="line">配置格式:	YAML</span><br><span class="line">配置内容：	common:</span><br><span class="line">name: application1 config</span><br></pre></td></tr></table></figure>
<p><img src="https://i.p04e.com/baid/i/2023/01/06/20rj.png"><br><img src="https://i.p04e.com/baid/i/2023/01/06/20rz.png"></p>
<p>要想从配置中心获取配置添加nacos-conﬁg的依赖：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring‐cloud‐starter‐alibaba‐nacos‐config&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>在bootstrap.yml添加配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">cloud:</span><br><span class="line">nacos:</span><br><span class="line">config:</span><br><span class="line">server‐addr: 127.0.0.1:8848 # 配置中心地址</span><br><span class="line">file‐extension: yaml group: DEFAULT_GROUP</span><br></pre></td></tr></table></figure>
<p>注意：要使用配置中心就要在bootstrap.yml中来配置，bootstrap.yml配置文件的加载顺序要比application.yml要优先。</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/06/et8n.png"></p>
<h2 id="5-定义扩展的-Data-Id-配置"><a href="#5-定义扩展的-Data-Id-配置" class="headerlink" title="5 定义扩展的 Data Id 配置"></a>5 <strong>定义扩展的</strong> <strong>Data</strong> <strong>Id</strong> <strong>配置</strong></h2><h3 id="5-1-ext-conﬁg扩展配置"><a href="#5-1-ext-conﬁg扩展配置" class="headerlink" title="5.1 ext-conﬁg扩展配置"></a>5.1 <strong>ext-conﬁg</strong>扩展配置</h3><p>Spring Cloud Alibaba Nacos Conﬁg可支持自定义 Data Id 的配置。 一个完整的配置案例如下所示：</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/06/1ynu.png"></p>
<p>扩展配置优先级是spring.cloud.nacos.config.ext-config[n].data-id中 n 的值越大，优先级越高。</p>
<p>通过内部相关规则(应用名、扩展名 )自动生成相关的 Data Id 配置的优先级最大。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h1><p>Nacos用来干什么？</p>
<p>Nacos是阿里巴巴公司开源的项目，它用来实现配置中心和服务注册中心。 什么是服务发现？</p>
<p>在微服务架构中一个业务流程需要多个微服务通过网络接口调用完成业务处理，服务消费方从服务注册中心获取服 务提供方的地址，从而进行远程调用，这个过程叫做服务发现。</p>
<p>服务发现的流程是什么？</p>
<p>1、服务发现的客户端从服务注册中心获取服务列表</p>
<p>2、服务消费方通过客户端负载均衡获取服务实例地址，进行远程调用。什么是配置中心？</p>
<p>在微服务架构中为了统一管理各各微服务的配置信息专门设置配置中心，配置中心就是一种统一管理各种应用配置 的基础服务组件。</p>
<p>配置中心的应用流程是什么？</p>
<p>1、发布配置，将配置信息发布到配置中心。</p>
<p>2、获取配置，配置中心客户端得到配置中心的通知，从配置中心获取配置。</p>
<p>Spring Cloud是什么？</p>
<p>Spring Cloud是一套微服务开发框架集合，包括微服务开发的方方页面，Spring   Cloud是一套微服务开发的标准， 集成了很多优秀的开源框架，比如有名的Netﬂix公司的众多项目。</p>
<p>Spring Cloud Alibaba是什么？</p>
<p>Spring Cloud Alibaba是阿里巴巴公司基于Spring Cloud标准实现一套微服务开发框架集合，它和Netﬂix一样都是Spring Cloud微服务开发实现方案。</p>
<p>Dubbo服务开发流程是什么？ 1、定义api工程。</p>
<p>方便其它服务原来api工程，远程调用dubbo服务。</p>
<p>2、定义api实现工程。</p>
<p>service实现类使用  @org.apache.dubbo.conﬁg.annotation.Service注解标记为dubbo服务。</p>
<p>3、服务消费方开发</p>
<p>引入api工程依赖</p>
<p>使用org.apache.dubbo.conﬁg.annotation.Reference注解注入service，发起远程调用</p>
]]></content>
      <tags>
        <tag>nacos</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis-Plus</title>
    <url>/2023/01/06/Mybatis-Plus/</url>
    <content><![CDATA[<h1 id="1-Mybatis-Plus介绍"><a href="#1-Mybatis-Plus介绍" class="headerlink" title="1 Mybatis-Plus介绍"></a>1 <strong>Mybatis-Plus</strong>介绍</h1><p>MyBatis-Plus（简称 MP）是一个 MyBatis 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发 提高效率而生。该框架由baomidou（苞米豆）组织开发并且开源的。我们的愿景是成为 MyBatis 最好的搭档，就像 魂斗罗 中的 1P 2P，基友搭配，效率翻倍。</p>
<span id="more"></span>
<h2 id="1-1-支持的数据库"><a href="#1-1-支持的数据库" class="headerlink" title="1.1 支持的数据库"></a>1.1 <strong>支持的数据库</strong></h2><p>MyBatisPlus支持如下数据库：</p>
<p>mysql mariadb  oracle  db2  h2  hsql  sqlite  postgresql  sqlserver</p>
<p>数据库 虚谷数据库 人大金仓数据库</p>
<h2 id="1-1-特性"><a href="#1-1-特性" class="headerlink" title="1.1 特性"></a>1.1 <strong>特性</strong></h2><p>无侵入<strong>：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑   </strong>损耗小**：启动即会自动注入基本 CRUD，性能基本无损耗，直接面向对象操作</p>
<p><strong>强大的</strong> <strong>CRUD</strong> <strong>操作</strong>：内置通用 Mapper 通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作， 更有强大的条件构造器，满足各类使用需求</p>
<p><strong>支持</strong> <strong>Lambda</strong> <strong>形式调用</strong>：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错</p>
<p><strong>支持多种数据库</strong>：支持 MySQL MariaDB Oracle DB2 H2 HSQL SQLite Postgre SQLServer2005 SQLServer</p>
<p>等多种数据库</p>
<p><strong>支持主键自动生成</strong>：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题1</p>
<p><strong>支持</strong> <strong>XML</strong> <strong>热加载</strong>：Mapper 对应的 XML 支持热加载，对于简单的 CRUD 操作，甚至可以无 XML 启动</p>
<p><strong>支持</strong> <strong>ActiveRecord</strong> <strong>模式</strong>：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD</p>
<p>操作</p>
<p><strong>支持自定义全局通用操作</strong>：支持全局通用方法注入（ Write once, use anywhere ）</p>
<p><strong>支持关键词自动转义</strong>：支持数据库关键词（order key    ）自动转义，还可自定义关键词</p>
<p><strong>内置代码生成器</strong>：采用代码或者 Maven 插件可快速生成 Mapper Model Service Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用</p>
<p><strong>内置分页插件</strong>：基于   MyBatis   物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通</p>
<p>List 查询</p>
<p><strong>内置性能分析插件</strong>：可输出 Sql 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询<strong>内置全局拦截插件</strong>：提供全表 delete     update 操作智能分析阻断，也可自定义拦截规则，预防误操作<strong>内置</strong> <strong>Sql</strong> <strong>注入剥离器</strong>：支持 Sql 注入剥离，有效预防 Sql 注入攻击</p>
<h2 id="1-1-架构"><a href="#1-1-架构" class="headerlink" title="1.1 架构"></a>1.1 <strong>架构</strong></h2><p><img src="https://i.p04e.com/baid/i/2023/01/06/2r80.png"></p>
<p>Mybatis主要包含以下模块：</p>
<p><strong>核心功能**</strong>(core)**，基于Mybatis的封装，提供了Mybatis Plus的基础配置类与核心功能，如内置通用 Mapper， Lambda 表达式查询等。</p>
<p><strong>注解**</strong>(annotation)**，提供了Mybatis Plus中注解的定义。</p>
<p><strong>扩展功能**</strong>(extension)**，提供扩展及插件功能，包括分页插件 通用 Service扩展 性能分析插件等。</p>
<p><strong>代码生成器**</strong>(generator)**：通过代码生成器可以快速生成 Mapper接口 Entity实体类 Mapper XML Service Controller 等各个模块的代码，极大的提升了开发效率。</p>
<p>执行流程：</p>
<p>（1） 扫描注解Entity，反射提取注解信息如：表名称   字段名称等信息。</p>
<p>（2） 分析注解信息并基于com.baomidou.mybatisplus.core.enums的SQL模板生成基本CRUD       SQL。</p>
<p>（3） 最后将这些SQL注入到Mybatis环境中。</p>
<p>因此Mybatis plus无需编写CRUD SQL语句，只需继承BaseMapper，就有了CRUD功能(通用CRUD)。</p>
<h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><h3 id="创建user表插入数据"><a href="#创建user表插入数据" class="headerlink" title="创建user表插入数据"></a>创建user表插入数据</h3><h3 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h3><p>新建一个<code>springboot</code>，<code>maven</code>项目</p>
<h3 id="引入对应依赖"><a href="#引入对应依赖" class="headerlink" title="引入对应依赖"></a>引入对应依赖</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 数据库驱动 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- lombok 简化set get toString --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- mybatis-plus --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.4.3.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="链接数据库-同mybatis"><a href="#链接数据库-同mybatis" class="headerlink" title="链接数据库(同mybatis)"></a>链接数据库(同mybatis)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    url: jdbc:mysql://localhost:3306/mybatis_plus?useUnicode=true&amp;useSSL=false&amp;characterEncoding=utf8&amp;serverTimezone=Asia/Shanghai</span><br><span class="line">    username: root</span><br><span class="line">    password: 123456</span><br><span class="line">#其中url中，数据库名称？是否使用安全链接，字符集编码，是否使用解码，设置时区</span><br><span class="line"></span><br><span class="line">#mysql数据库用的是gbk编码，而项目数据库用的是utf-8编码。这时候如果添加了useUnicode=true&amp;characterEncoding=UTF-8</span><br><span class="line">#存数据时：</span><br><span class="line">#数据库在存放项目数据的时候会先用UTF-8格式将数据解码成字节码，然后再将解码后的字节码重新使用GBK编码存放到数据库中。</span><br><span class="line">#取数据时：</span><br><span class="line">#在从数据库中取数据的时候，数据库会先将数据库中的数据按GBK格式解码成字节码，然后再将解码后的字节码重新按UTF-8格式编码数据，最后再将数据返回给客户端。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="使用mybatis-plus"><a href="#使用mybatis-plus" class="headerlink" title="使用mybatis-plus"></a>使用mybatis-plus</h3><p>创建pojo类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Data</span><br><span class="line">@AllArgsConstructor #有参构造器</span><br><span class="line">@NoArgsConstructor  #无参构造器</span><br><span class="line">public class User &#123;</span><br><span class="line">    //常见的数据库中主键自动设置方法有（uuid、自增id、雪花算法、redis生成、zookeeper生成）</span><br><span class="line">    private Long id;</span><br><span class="line">    private String name;</span><br><span class="line">    private Integer age;</span><br><span class="line">    private String email;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在启动类加上<code>@mapper</code>注解,扫描<code>mapper</code>文件夹</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@MapperScan(&quot;com.jdw.mapper&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>mapper接口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//在对应的Mapper 接口上 基础基本的 BaseMapper&lt;T&gt; T是对应的pojo类</span><br><span class="line">@Repository   //告诉容器你是持久层的 @Repository是spring提供的注释，能够将该类注册成Bean</span><br><span class="line">public interface UserMapper extends BaseMapper&lt;User&gt; &#123;</span><br><span class="line">    //所有的crud都编写完成了</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>支持，<code>mybatis-plus</code>已经配置完成，可以直接使用，<code>CRUD</code>。</li>
<li>使用测试类<code>@Test</code>测试</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//继承了BaseMapper ,所有方法来自父类，可扩展</span><br><span class="line">@Autowired</span><br><span class="line">private UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">void contextLoads() &#123;</span><br><span class="line">    System.out.println((&quot;----- selectAll method test 测试查询所有用户方法 ------&quot;));</span><br><span class="line">    //selectList 的参数wrapper 是条件构造器，可以先写null</span><br><span class="line">    List&lt;User&gt; userList = userMapper.selectList(null);</span><br><span class="line">    //forEach 的参数是 Consumer类型的 语法糖</span><br><span class="line">    userList.forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="日志配置"><a href="#日志配置" class="headerlink" title="日志配置"></a>日志配置</h1><p>使用yml添加日志配置项</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mybatis-plus:</span><br><span class="line">  configuration:</span><br><span class="line">    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行查询方法查看分析日志</p>
<p>执行上面的查询所有用户的方法查看日志</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/06/3xr0z.png"></p>
<p>插入测试</p>
<p>插入及日志分析</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//测试插入</span><br><span class="line">@Test</span><br><span class="line">public void testInsert()&#123;</span><br><span class="line">    User user = new User();</span><br><span class="line">    user.setName(&quot;小蒋&quot;);</span><br><span class="line">    user.setAge(3);</span><br><span class="line">    user.setEmail(&quot;24749559@qq.com&quot;);</span><br><span class="line">    //没有设置ID却自动生成的ID</span><br><span class="line">    int result = userMapper.insert(user);</span><br><span class="line">    System.out.println(&quot;result = &quot; + result);</span><br><span class="line">    System.out.println(&quot;user = &quot; + user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>日志分析</strong></p>
<p>我们可以看到，并没有给user设置id，数据库自动插入了id=1453311479846608897，</p>
<h3 id="主键生成策略"><a href="#主键生成策略" class="headerlink" title="主键生成策略"></a>主键生成策略</h3><p>因为在最开始建表的sql语句中就指明了，id是数据库的主键，主键不能唯空，</p>
<p>常见的数据库中主键自动设置方法有（uuid、自增id、雪花算法、redis生成、zookeeper生成）</p>
<h4 id="雪花算法"><a href="#雪花算法" class="headerlink" title="雪花算法"></a>雪花算法</h4><p>这里生成的id默认采用的是<strong>雪花算法</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">snowflake是Twitter开源的分布式ID生成算法，结果是一个long型的ID。其核心思想是：使用41bit作为毫秒数，10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID），12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 ID），最后还有一个符号位，永远是0。具体实现的代码可以参看https://github.com/twitter/snowflake。雪花算法支持的TPS可以达到419万左右（2^22*1000）,几乎保证全球唯一。</span><br><span class="line"></span><br><span class="line">雪花算法在工程实现上有单机版本和分布式版本。单机版本如下，分布式版本可以参看美团leaf算法：https://github.com/Meituan-Dianping/Leaf</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以在User类的id属性上加入注解TableId更改和查看策略</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type = IdType.ASSIGN_ID，全局唯一id，雪花算法</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line">    @TableId(type = IdType.ASSIGN_ID,value = &quot;id&quot;)//枚举注解,使用ID_WORKER策略,全局唯一ID，数据库设置自增也没用</span><br><span class="line">    private Long id;</span><br><span class="line">    private String name;</span><br><span class="line">    private Integer age;</span><br><span class="line">    private String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进入这个注解</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Documented</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(&#123;ElementType.FIELD&#125;)  //枚举注解</span><br><span class="line">public @interface TableId &#123;</span><br><span class="line">    //可以设置以下两个参数</span><br><span class="line">    String value() default &quot;&quot;;</span><br><span class="line">    IdType type() default IdType.NONE; //ID策略</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="主键自增策略"><a href="#主键自增策略" class="headerlink" title="主键自增策略"></a>主键自增策略</h4><p>要是自增策略，在id上加入下列代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@TableId(type = IdType.AUTO)</span><br><span class="line">private Long id;</span><br></pre></td></tr></table></figure>
<p>同时数据库设计时，一定要将id设计为自增，这样自增id会设置在最大值上加1</p>
<h1 id="更新测试"><a href="#更新测试" class="headerlink" title="更新测试"></a>更新测试</h1><h3 id="更新及日志分析"><a href="#更新及日志分析" class="headerlink" title="更新及日志分析"></a>更新及日志分析</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//更新测试</span><br><span class="line">@Test</span><br><span class="line">   public void testUpdateByID() &#123;</span><br><span class="line">       User user = new User();</span><br><span class="line">       user.setId(7L);</span><br><span class="line">       user.setName(&quot;小小&quot;);</span><br><span class="line">       user.setAge(18);//这一行后加</span><br><span class="line">       int i = userMapper.updateById(user);//受影响的行数,参数是一个user不是id,点击看源码</span><br><span class="line">       System.out.println(&quot;i = &quot; + i);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我可以发现，先只更新了名字，后面更新名字和年龄。mybatis-plus通过条件自动把我们进行了动态sql拼接</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/06/41dx0.png"></p>
<p>自动填充<br>创建时间、更新时间！这个操作是自动化完成的，不要手动更新！</p>
<p>gmt_create、gmt_modified几乎在所有表都要配置上，而且自动化填充。gmt是时间时间的意思</p>
<h4 id="方式一、数据库级别（不建议）"><a href="#方式一、数据库级别（不建议）" class="headerlink" title="方式一、数据库级别（不建议）"></a>方式一、数据库级别（不建议）</h4><p>在数据库种添加字段gmt_create、gmt_modified，然后在pojo类中添加这两个属性，下次就可以查看了.(博主使用的是Navigat)<br><img src="https://i.p04e.com/baid/i/2023/01/06/kxnm.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private Data gmtCreate;</span><br><span class="line">private Data gmtModified;</span><br></pre></td></tr></table></figure>
<h4 id="方式二、代码级别"><a href="#方式二、代码级别" class="headerlink" title="方式二、代码级别"></a>方式二、代码级别</h4><p>1、在数据库中删除掉根据当前时间戳更新的选项</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/06/438ai.png"></p>
<p>2、在实体类的成员变量上添加注解<code>@TableField</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//字段添加填充内容</span><br><span class="line">@TableField(fill = FieldFill.INSERT ,value = &quot;create_time&quot;)</span><br><span class="line">private LocalDateTime createTime;</span><br><span class="line">@TableField(fill = FieldFill.INSERT_UPDATE ,value = &quot;update_time&quot;)</span><br><span class="line">private LocalDateTime updateTime;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>3、编写处理器来处理这个注解</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Slf4j //日志</span><br><span class="line">@Component//以组件的形式把这个处理器注册到IOC容器中</span><br><span class="line">public class MyMetaObjectHandler implements MetaObjectHandler &#123;</span><br><span class="line"></span><br><span class="line">    //插入时启动  第三个参数 LocalDateTime 一定要和 createTime成员变量的值的类型一致，不然是null 如果是date就都设置date</span><br><span class="line">    @Override</span><br><span class="line">    public void insertFill(MetaObject metaObject) &#123;</span><br><span class="line">        log.info(&quot;start insert fill ....&quot;);</span><br><span class="line">        this.strictInsertFill(metaObject, &quot;createTime&quot;, LocalDateTime.class, LocalDateTime.now()); // 起始版本 3.3.0(推荐使用)</span><br><span class="line">        this.strictUpdateFill(metaObject, &quot;updateTime&quot;, LocalDateTime.class, LocalDateTime.now()); // 起始版本 3.3.0(推荐)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //更新时候启动</span><br><span class="line">    @Override</span><br><span class="line">    public void updateFill(MetaObject metaObject) &#123;</span><br><span class="line">        log.info(&quot;start update fill ....&quot;);</span><br><span class="line">        this.strictUpdateFill(metaObject, &quot;updateTime&quot;, LocalDateTime.class, LocalDateTime.now()); // 起始版本 3.3.0(推荐)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>接下来的代码执行插入、更新时都会自动设置时间了</p>
<h1 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h1><h3 id="乐观锁原理"><a href="#乐观锁原理" class="headerlink" title="乐观锁原理"></a>乐观锁原理</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当要更新一条记录的时候，希望这条记录没有被别人更新</span><br><span class="line"></span><br><span class="line">乐观锁实现方式：</span><br><span class="line"></span><br><span class="line">取出记录时，获取当前version</span><br><span class="line">更新时，带上这个version</span><br><span class="line">执行更新时， set version = newVersion where version = oldVersion</span><br><span class="line">如果version不对，就更新失败</span><br></pre></td></tr></table></figure>
<p>相当于给每一个记录都加一个version字段。当我们要改记录时，把version字段拿出来看一看，对比一下这个version 有没有在你操作数据时被其他线程更改，如果依然等于oldVersion，你就对数据进行操作同时把 version = newVersion 更新（比如+1），以此你在改数据的途中告诉其他线程不要读了脏数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--A 线程</span><br><span class="line">update user set name = &quot;jdw&quot; ,version = version + 1   --version = newVersion  version有默认值比如1 </span><br><span class="line">where id = 2 and version = 1  -- version = oldVersion</span><br><span class="line">--B 线程 抢先完成，此时version=2,导致A线程的  version = oldVersion 不匹配A的oldVersion A将会修改失败,防止数据库产生脏数据</span><br><span class="line">update user set name = &quot;jdw&quot; ,version = version + 1   --version = newVersion  version有默认值比如1 </span><br><span class="line">where id = 2 and version = 1  -- version = oldVersion</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="乐观锁的应用"><a href="#乐观锁的应用" class="headerlink" title="乐观锁的应用"></a>乐观锁的应用</h3><h4 id="测试更新"><a href="#测试更新" class="headerlink" title="测试更新"></a>测试更新</h4><p>1、在数据库添加version字段，int型,默认0,长度10,不自增</p>
<p>2、在User类中添加对应属性：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Version //乐观锁注解</span><br><span class="line">private int version;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">说明: Version</span><br><span class="line"></span><br><span class="line">支持的数据类型只有:int,Integer,long,Long,Date,Timestamp,LocalDateTime</span><br><span class="line">整数类型下 newVersion = oldVersion + 1</span><br><span class="line">newVersion 会回写到 entity 中</span><br><span class="line">仅支持 updateById(id) 与 update(entity, wrapper) 方法</span><br><span class="line">在 update(entity, wrapper) 方法下, wrapper 不能复用!!!</span><br></pre></td></tr></table></figure>
<p>3、在config下注册组件，开启乐观锁拦截器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@EnableTransactionManagement  //开启事务</span><br><span class="line">@Configuration  //配置类注解</span><br><span class="line">public class MybatisPlusConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public MybatisPlusInterceptor mybatisPlusInterceptor() &#123;</span><br><span class="line">        MybatisPlusInterceptor mybatisPlusInterceptor = new MybatisPlusInterceptor();</span><br><span class="line">        mybatisPlusInterceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor());//乐观锁插件拦截器OptimisticLockerInnerInterceptor</span><br><span class="line">        return mybatisPlusInterceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>4.测试乐观锁</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testOptimisticLocker()&#123;</span><br><span class="line">    //1、查询用户信息</span><br><span class="line">    User user = userMapper.selectById(1L);</span><br><span class="line">    //2、修改用户信息</span><br><span class="line">    user.setEmail(&quot;123@qq.com&quot;);</span><br><span class="line">    user.setName(&quot;小&quot;);</span><br><span class="line">    //3、更新操作</span><br><span class="line">    userMapper.updateById(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在测试代码中我们并没有更新version数据库的version已经变成2了</p>
<p>5.模拟多线程下乐观锁失败案例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">   public void testOptimisticLocker2()&#123;</span><br><span class="line">       //模拟多线程</span><br><span class="line">       User user = userMapper.selectById(3L);</span><br><span class="line">       user.setEmail(&quot;123jdw@qq.com&quot;);</span><br><span class="line">       user.setName(&quot;帅小伙111&quot;);//我们在这里对线程1修改值</span><br><span class="line"></span><br><span class="line">       //线程2插队</span><br><span class="line">       User user2 = userMapper.selectById(3L);</span><br><span class="line">       user2.setEmail(&quot;321jdw@qq.com&quot;);</span><br><span class="line">       user2.setName(&quot;帅小伙222&quot;);</span><br><span class="line">       userMapper.updateById(user2); //线程2抢先提交</span><br><span class="line"></span><br><span class="line">       userMapper.updateById(user);//线程1失败，乐观锁在这种情况下防止了脏数据存在，没有乐观锁就会有覆盖掉线程2的操作</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="测试查询"><a href="#测试查询" class="headerlink" title="测试查询"></a>测试查询</h4><p>1、查询单用户</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//查询单用户</span><br><span class="line">@Test</span><br><span class="line">public void testSelectBatchId()&#123;</span><br><span class="line">    User user = userMapper.selectById(1L);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>2、多用户查询</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//查询指定多用户</span><br><span class="line">@Test</span><br><span class="line">public void testSelectBatchIds() &#123;</span><br><span class="line">    //Arrays.asList()创建了一个固定大小的集合   </span><br><span class="line">    List&lt;User&gt; users = userMapper.selectBatchIds(Arrays.asList(1, 2, 3));//参数Collection的集合</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//  selectBatchIds 源码</span><br><span class="line">/**</span><br><span class="line"> * 查询（根据ID 批量查询）</span><br><span class="line"> *</span><br><span class="line"> * @param idList 主键ID列表(不能为 null 以及 empty)</span><br><span class="line"> */</span><br><span class="line">List&lt;T&gt; selectBatchIds(@Param(Constants.COLLECTION) Collection&lt;? extends Serializable&gt; idList);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>日志分析：内部解析的是一个 IN 条件</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/06/tfyee.png"></p>
<p>3、条件查询</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//条件查询，-- HashMap</span><br><span class="line">@Test</span><br><span class="line">public void testSelectByMap() &#123;</span><br><span class="line">    HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">    //定义查询条件</span><br><span class="line">    map.put(&quot;name&quot;, &quot;小蒋&quot;); //where k = v</span><br><span class="line">    map.put(&quot;age&quot;,3);</span><br><span class="line">    List&lt;User&gt; users = userMapper.selectByMap(map);</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>日志分析</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/06/tl57e.png"></p>
<h1 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h1><p>1、配置拦截器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MybatisPlusConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public MybatisPlusInterceptor mybatisPlusInterceptor() &#123;</span><br><span class="line">        MybatisPlusInterceptor mybatisPlusInterceptor = new MybatisPlusInterceptor();</span><br><span class="line">        mybatisPlusInterceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor());//创建乐观锁拦截器 OptimisticLockerInnerInterceptor</span><br><span class="line">        mybatisPlusInterceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL)); //插件分页拦截器，我的是mysql</span><br><span class="line">        return mybatisPlusInterceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>2、使用page对象即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//测试分页查询</span><br><span class="line">@Test</span><br><span class="line">public void testPage() &#123;</span><br><span class="line">    Page&lt;User&gt; page = new Page&lt;&gt;(1,5); //开启拦截器后，会注册一个page对象  当前页，每页条数</span><br><span class="line">    //方法源码：   &lt;P extends IPage&lt;T&gt;&gt; P selectPage(P page, @Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);</span><br><span class="line">    userMapper.selectPage(page,null); //分页查询</span><br><span class="line">    page.getRecords().forEach(System.out::println); //获取分页后的数据 打印</span><br><span class="line">    System.out.println(page.getTotal()); //获取记录总数</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**源码</span><br><span class="line"> * 分页构造函数</span><br><span class="line"> *</span><br><span class="line"> * @param current 当前页</span><br><span class="line"> * @param size    每页显示条数</span><br><span class="line"> */</span><br><span class="line">public Page(long current, long size) &#123;</span><br><span class="line">    this(current, size, 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="删除测试"><a href="#删除测试" class="headerlink" title="删除测试"></a>删除测试</h1><h3 id="常见删除"><a href="#常见删除" class="headerlink" title="常见删除"></a>常见删除</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//删除测试</span><br><span class="line">@Test</span><br><span class="line">public void testDeleteById()&#123;</span><br><span class="line">    userMapper.deleteById(1453324799370616833L);</span><br><span class="line">	// userMapper.delete(null); //全部删除</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从上往下分别是：根据id删除，根据 entity 条件删除记录，通过多个id批量删除，根据map条件删除</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/06/491ek.png"></p>
<h3 id="逻辑删除"><a href="#逻辑删除" class="headerlink" title="逻辑删除"></a>逻辑删除</h3><p>物理删除：在数据库中移除</p>
<p>逻辑删除：数据库中没有移除，而是在代码中使用一个变量来使他失效！(如：delete = 0 =&gt; delete = 1; )</p>
<p>就比如，管理员可以查看被删除的记录！防止数据丢失。类似于回收站。用户就没法查看删除记录。</p>
<p>1、在数据库添加deleted字段</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/06/49poj.png"></p>
<p>2、同步实体类中，同时添加<code>@TableLogic//逻辑删除</code>注解</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@TableLogic//逻辑删除</span><br><span class="line">private Integer deleted;</span><br></pre></td></tr></table></figure>
<p>3、在配置文件yml中配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mybatis-plus:</span><br><span class="line">  global-config:</span><br><span class="line">    db-config:</span><br><span class="line">      logic-delete-field: flag  # 全局逻辑删除的实体字段名(since 3.3.0,配置后可以不加步骤2的注解)</span><br><span class="line">      logic-delete-value: 1 # 逻辑已删除值(默认为 1)</span><br><span class="line">      logic-not-delete-value: 0 # 逻辑未删除值(默认为 0)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>4、测试删除</p>
<p>执行删除操作，实际上是执行更新操作，把deleted字段改为1了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    @Test</span><br><span class="line">public void testDeleteById()&#123;</span><br><span class="line">    userMapper.deleteById(1L);</span><br><span class="line">	// userMapper.delete(null); //全部删除</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://i.p04e.com/baid/i/2023/01/06/48zas.png"></p>
<p>数据库中也是没被删，改了值而已</p>
<p>如果我们再去查询这个id=1的用户发现，查不到，mybatis-plus 自动拼接了deleted字段在where中判断。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testSelectBatchId() &#123;</span><br><span class="line">    User user = userMapper.selectById(1L);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://i.p04e.com/baid/i/2023/01/06/twyz6.png"></p>
<p>性能分析插件<br>官方使用的p6spy性能有损耗，推荐使用其他第三方性能分析插件，比如阿里巴巴的Druid。</p>
<p>条件构造器Wrapper（重点）<br>之前我们写crud时候经常碰到一个参数叫做wrapper，我们写的都是null，他到底是什么。</p>
<p>官方链接，条件构造器</p>
<p>我们之前一直是增删改查，没有一个是带条件的，而这个条件构造器就相当于sql中加了一个where,</p>
<p>QueryWrapper和 UpdateWrapper,分别是用于生成查和改 的 sql 的 where 条件</p>
<p>例如, 查询多条记录与单条记录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   @Test</span><br><span class="line">   void contextLoads() &#123;</span><br><span class="line">       //----------查询多个</span><br><span class="line">       //查询一个复杂的，比如查询用户name、邮箱不为空，年龄大于20的用户</span><br><span class="line">       QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;(); //首先新建一个 QueryWrapper</span><br><span class="line">       //链式编程 添加查询条件</span><br><span class="line">       wrapper.isNotNull(&quot;name&quot;)</span><br><span class="line">               .eq(&quot;email&quot;,&quot;2455555659@qq.com&quot;)</span><br><span class="line">               .ge(&quot;age&quot;,12);  </span><br><span class="line">       userMapper.selectList(wrapper).forEach(System.out::println); </span><br><span class="line">	//----------查询单个</span><br><span class="line">       User user = userMapper.selectOne(wrapper); //出现多个结果会报错，查询一个</span><br><span class="line">       System.out.println(&quot;user = &quot; + user);</span><br><span class="line">   &#125;</span><br><span class="line">//        eq相等   ne不相等，   gt大于，    lt小于         ge大于等于       le 小于等于</span><br><span class="line">//        equal/ not equal/ greater than/ less than/ less than or equal/ great than or equal/</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>日志分析，就是在where中添加了多个条件</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/06/m1z7.png"></p>
<p>区间查询与计数，between()，selectCount()</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">void test2() &#123;</span><br><span class="line">    //查询区间内的记录</span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;();</span><br><span class="line">    wrapper.between(&quot;age&quot;,20,30);</span><br><span class="line">    Integer count = userMapper.selectCount(wrapper);</span><br><span class="line">    System.out.println(&quot;count = &quot; + count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">void test3() &#123;</span><br><span class="line">    //模糊查询</span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;();</span><br><span class="line">    wrapper.like(&quot;name&quot;,99)         //  名字中 存在 99</span><br><span class="line">            .notLike(&quot;name&quot;,6)      //  名字中 不存在 6</span><br><span class="line">            .likeRight(&quot;email&quot;,2)   //  邮箱 最右边是m  %m</span><br><span class="line">            .likeLeft(&quot;email&quot;,&quot;m&quot;); //  邮箱 最左边是2  2%</span><br><span class="line">    userMapper.selectMaps(wrapper);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://i.p04e.com/baid/i/2023/01/06/u3nbr.png"></p>
<p>子查询（多表查询）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void test4() &#123;</span><br><span class="line">    //子查询</span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;();</span><br><span class="line">    wrapper.inSql(&quot;id&quot;,&quot;select id from table where id &lt;2&quot;);</span><br><span class="line">    userMapper.selectObjs(wrapper).forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://i.p04e.com/baid/i/2023/01/06/m70o.png"></p>
<p>排序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">void test5() &#123;</span><br><span class="line">    //排序 </span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;();</span><br><span class="line">    wrapper.orderByAsc(&quot;id&quot;);  //根据id升序排列   降序orderByDesc()略</span><br><span class="line">    userMapper.selectList(wrapper).forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://i.p04e.com/baid/i/2023/01/06/4bnd9.png"></p>
<p>分组，条件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">void test7() &#123;</span><br><span class="line">    //分组排序</span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;();</span><br><span class="line">    wrapper.groupBy(&quot;version&quot;).having(&quot;version = 1&quot;);</span><br><span class="line">    userMapper.selectList(wrapper).forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://i.p04e.com/baid/i/2023/01/06/4c1xj.png"></p>
<h1 id="代码自动生成器（重点）"><a href="#代码自动生成器（重点）" class="headerlink" title="代码自动生成器（重点）"></a>代码自动生成器（重点）</h1><p>AutoGenerator 是 MyBatis-Plus 的代码生成器，通过 AutoGenerator 可以快速生成 Entity、Mapper、Mapper XML、Service、Controller 等各个模块的代码，极大的提升了开发效率。</p>
<p><strong>使用步骤</strong></p>
<p><strong>配置依赖，添加如下依赖</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- mp 代码生成器 依赖 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;com.baomidou&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;3.4.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- 导入swagger --&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;io.swagger&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;swagger-annotations&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;1.5.20&lt;/version&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">&lt;!-- 添加模板引擎，thymeleaf 还有freemarker都是模板引擎 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在任意文件夹新建立一个类进行配置</p>
<p>类的代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.jdw;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.annotation.DbType;</span><br><span class="line">import com.baomidou.mybatisplus.annotation.FieldFill;</span><br><span class="line">import com.baomidou.mybatisplus.annotation.IdType;</span><br><span class="line">import com.baomidou.mybatisplus.core.exceptions.MybatisPlusException;</span><br><span class="line">import com.baomidou.mybatisplus.core.toolkit.StringPool;</span><br><span class="line">import com.baomidou.mybatisplus.core.toolkit.StringUtils;</span><br><span class="line">import com.baomidou.mybatisplus.generator.AutoGenerator;</span><br><span class="line">import com.baomidou.mybatisplus.generator.InjectionConfig;</span><br><span class="line">import com.baomidou.mybatisplus.generator.config.*;</span><br><span class="line">import com.baomidou.mybatisplus.generator.config.po.TableFill;</span><br><span class="line">import com.baomidou.mybatisplus.generator.config.po.TableInfo;</span><br><span class="line">import com.baomidou.mybatisplus.generator.config.rules.DateType;</span><br><span class="line">import com.baomidou.mybatisplus.generator.config.rules.NamingStrategy;</span><br><span class="line">import com.baomidou.mybatisplus.generator.engine.FreemarkerTemplateEngine;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">// 演示例子，执行 main 方法控制台输入模块表名回车自动生成对应项目目录中</span><br><span class="line">public class CodeGenerator &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * 读取控制台内容</span><br><span class="line">     * &lt;/p&gt;</span><br><span class="line">     */</span><br><span class="line">    public static String scanner(String tip) &#123;</span><br><span class="line">        Scanner scanner = new Scanner(System.in);</span><br><span class="line">        StringBuilder help = new StringBuilder();</span><br><span class="line">        help.append(&quot;请输入&quot; + tip + &quot;：&quot;);</span><br><span class="line">        System.out.println(help.toString());</span><br><span class="line">        if (scanner.hasNext()) &#123;</span><br><span class="line">            String ipt = scanner.next();</span><br><span class="line">            if (StringUtils.isNotBlank(ipt)) &#123;</span><br><span class="line">                return ipt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        throw new MybatisPlusException(&quot;请输入正确的&quot; + tip + &quot;！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 代码生成器</span><br><span class="line">        //构建一个代码自动生成器对象</span><br><span class="line">        AutoGenerator mpg = new AutoGenerator();</span><br><span class="line"></span><br><span class="line">        // 1、创建全局配置类的对象</span><br><span class="line">        GlobalConfig gc = new GlobalConfig();</span><br><span class="line">        //获取当前项目路径</span><br><span class="line">        String projectPath = System.getProperty(&quot;user.dir&quot;);</span><br><span class="line">        System.out.println(&quot;projectPath = &quot; + projectPath);</span><br><span class="line">        //自动生成代码存放的路径</span><br><span class="line">        gc.setOutputDir(projectPath + &quot;/src/main/java&quot;);</span><br><span class="line">        //设置 --作者注释</span><br><span class="line">        gc.setAuthor(&quot;jdw&quot;);</span><br><span class="line">        //是否打开文件夹</span><br><span class="line">        gc.setOpen(false);</span><br><span class="line">        //是否覆盖已有文件</span><br><span class="line">        gc.setFileOverride(false);</span><br><span class="line">        //各层文件名称方式，例如： %sAction 生成 UserAction  %s占位符</span><br><span class="line">        gc.setServiceName(&quot;%sService&quot;);</span><br><span class="line">        //设置日期策略  date类型</span><br><span class="line">        gc.setDateType(DateType.ONLY_DATE);</span><br><span class="line">        //设置主键策略 雪花算法</span><br><span class="line">        gc.setIdType(IdType.ASSIGN_ID);</span><br><span class="line">        //设置开启 swagger2 模式</span><br><span class="line">        gc.setSwagger2(true);</span><br><span class="line">        //把全局配置放入代码生成器</span><br><span class="line">        mpg.setGlobalConfig(gc);</span><br><span class="line"></span><br><span class="line">        // 2、数据源配置</span><br><span class="line">        DataSourceConfig dsc = new DataSourceConfig();</span><br><span class="line">        dsc.setUrl(&quot;jdbc:mysql://localhost:3306/vueblog?useUnicode=true&amp;useSSL=false&amp;characterEncoding=utf8&amp;serverTimezone=Asia/Shanghai&quot;);</span><br><span class="line">        dsc.setDriverName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><span class="line">        dsc.setUsername(&quot;root&quot;);</span><br><span class="line">        dsc.setPassword(&quot;123456&quot;);</span><br><span class="line">        dsc.setDbType(DbType.MYSQL);</span><br><span class="line">        mpg.setDataSource(dsc); //把数据源配置加入到代码生成器</span><br><span class="line"></span><br><span class="line">        // 3、包配置</span><br><span class="line">        PackageConfig pc = new PackageConfig();</span><br><span class="line">        pc.setParent(&quot;com.jdw&quot;);</span><br><span class="line">        pc.setEntity(&quot;entity&quot;);</span><br><span class="line">        pc.setMapper(&quot;mapper&quot;);</span><br><span class="line">        pc.setService(&quot;service&quot;);</span><br><span class="line">        pc.setController(&quot;controller&quot;);</span><br><span class="line">        // ...  有默认值，点击查看源码</span><br><span class="line">        mpg.setPackageInfo(pc);//包加入代码生成器</span><br><span class="line"></span><br><span class="line">        // 4、策略配置</span><br><span class="line">        StrategyConfig strategy = new StrategyConfig();</span><br><span class="line">        //下划线转驼峰命名  表</span><br><span class="line">        strategy.setNaming(NamingStrategy.underline_to_camel);</span><br><span class="line">        // 下划线转驼峰命名字段</span><br><span class="line">        strategy.setColumnNaming(NamingStrategy.underline_to_camel);</span><br><span class="line">        //实体类是否加上lombok注解</span><br><span class="line">        strategy.setEntityLombokModel(true);</span><br><span class="line">        //控制层采用RestControllerStyle注解</span><br><span class="line">        strategy.setRestControllerStyle(true);</span><br><span class="line">        // RequestMapping中 驼峰转连字符 -</span><br><span class="line">        strategy.setControllerMappingHyphenStyle(true);</span><br><span class="line">        //要映射的数据库表名  （重点）</span><br><span class="line">        strategy.setInclude(scanner(&quot;表名，多个英文逗号分割&quot;).split(&quot;,&quot;));</span><br><span class="line">        //添加表名前缀</span><br><span class="line">        //strategy.setTablePrefix(&quot;m_&quot;); //自动拼接上m_</span><br><span class="line">        //逻辑删除字段名</span><br><span class="line">        strategy.setLogicDeleteFieldName(&quot;deleted&quot;);</span><br><span class="line">        //乐观锁字段名</span><br><span class="line">        strategy.setVersionFieldName(&quot;version&quot;);</span><br><span class="line">        // -------自动填充策略</span><br><span class="line">        ArrayList&lt;TableFill&gt; fillList = new ArrayList&lt;&gt;();</span><br><span class="line">        fillList.add(new TableFill(&quot;createTime&quot;, FieldFill.INSERT));</span><br><span class="line">        fillList.add(new TableFill(&quot;updateTime&quot;,FieldFill.INSERT_UPDATE));</span><br><span class="line">        // 参数是 List&lt;TableFill&gt; 的链表</span><br><span class="line">        strategy.setTableFillList(fillList);</span><br><span class="line">        mpg.setStrategy(strategy);</span><br><span class="line"></span><br><span class="line">        //---------------------------------</span><br><span class="line">        // 自定义配置</span><br><span class="line">        InjectionConfig cfg = new InjectionConfig() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void initMap() &#123;</span><br><span class="line">                // to do nothing</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        // 如果模板引擎是 freemarker</span><br><span class="line">        String templatePath = &quot;/templates/mapper.xml.ftl&quot;;</span><br><span class="line">        // 如果模板引擎是 velocity</span><br><span class="line">        // String templatePath = &quot;/templates/mapper.xml.vm&quot;;</span><br><span class="line"></span><br><span class="line">        // 自定义输出配置</span><br><span class="line">        List&lt;FileOutConfig&gt; focList = new ArrayList&lt;&gt;();</span><br><span class="line">        // 自定义配置会被优先输出</span><br><span class="line">        focList.add(new FileOutConfig(templatePath) &#123;</span><br><span class="line">            @Override </span><br><span class="line">            //输出了 静态资源下的 Mapper</span><br><span class="line">            public String outputFile(TableInfo tableInfo) &#123;</span><br><span class="line">                // 自定义输出文件名 ， 如果你 Entity 设置了前后缀、此处注意 xml 的名称会跟着发生变化！！</span><br><span class="line">                return projectPath + &quot;/src/main/resources/mapper/&quot; + pc.getModuleName()</span><br><span class="line">                        + &quot;/&quot; + tableInfo.getEntityName() + &quot;Mapper&quot; + StringPool.DOT_XML;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        cfg.setFileOutConfigList(focList);</span><br><span class="line">        mpg.setCfg(cfg);</span><br><span class="line"></span><br><span class="line">        //        FreemarkerTemplateEngine模板引擎</span><br><span class="line">        mpg.setTemplateEngine(new FreemarkerTemplateEngine());</span><br><span class="line">        mpg.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Mybatis-Plus</tag>
        <tag>乐观锁</tag>
        <tag>CRUD</tag>
        <tag>代码生成器</tag>
      </tags>
  </entry>
  <entry>
    <title>API接口文档利器：Swagger,Postman</title>
    <url>/2023/01/06/API%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3%E5%88%A9%E5%99%A8%EF%BC%9ASwagger-Postman/</url>
    <content><![CDATA[<h2 id="API接口文档利器：Swagger"><a href="#API接口文档利器：Swagger" class="headerlink" title="API接口文档利器：Swagger"></a><strong>API</strong>接口文档利器：Swagger</h2><h3 id="Swagger介绍"><a href="#Swagger介绍" class="headerlink" title="Swagger介绍"></a><strong>Swagger</strong>介绍</h3><p>Swagger 是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务</p>
<p>(<a href="https://swagger.io/">https://swagger.io/</a>)。 它的主要作用是：<span id="more"></span></p>
<ol>
<li><p>使得前后端分离开发更加方便，有利于团队协作</p>
</li>
<li><p>接口的文档在线自动生成，降低后端开发人员编写接口文档的负担</p>
</li>
<li><p>功能测试</p>
</li>
</ol>
<p>Spring已经将Swagger纳入自身的标准，建立了Spring-swagger项目，现在叫Springfox。通过在项目中引入Springfox ，即可非常简单快捷的使用Swagger。</p>
<h3 id="SpringBoot集成Swagger"><a href="#SpringBoot集成Swagger" class="headerlink" title="SpringBoot集成Swagger"></a><strong>SpringBoot</strong>集成Swagger</h3><p>项目中添加依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!‐‐ Swagger依赖 ‐‐&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;springfox‐swagger2&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;springfox‐swagger‐ui&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>工程的conﬁg包中添加一个Swagger配置类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.shanjupay.merchant.config;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty; import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration; import springfox.documentation.builders.ApiInfoBuilder; import springfox.documentation.builders.PathSelectors;</span><br><span class="line">import springfox.documentation.builders.RequestHandlerSelectors; import springfox.documentation.service.ApiInfo;</span><br><span class="line">import springfox.documentation.service.Contact; import springfox.documentation.spi.DocumentationType;</span><br><span class="line">import springfox.documentation.spring.web.plugins.Docket;</span><br><span class="line">import springfox.documentation.swagger2.annotations.EnableSwagger2;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">@ConditionalOnProperty(prefix = &quot;swagger&quot;,value = &#123;&quot;enable&quot;&#125;,havingValue = &quot;true&quot;) @EnableSwagger2</span><br><span class="line">public class SwaggerConfiguration &#123;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public Docket buildDocket() &#123;</span><br><span class="line">return new Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">.apiInfo(buildApiInfo())</span><br><span class="line">.select()</span><br><span class="line">// 要扫描的API(Controller)基础包</span><br><span class="line"></span><br><span class="line">.apis(RequestHandlerSelectors.basePackage(&quot;com.shanjupay.merchant.controller&quot;))</span><br><span class="line">.paths(PathSelectors.any())</span><br><span class="line">.build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">*@param</span><br><span class="line"></span><br><span class="line">*@return springfox.documentation.service.ApiInfo</span><br><span class="line">*@Title: 构建API基本信息</span><br><span class="line">*@methodName: buildApiInfo</span><br><span class="line">*/</span><br><span class="line">private ApiInfo buildApiInfo() &#123;</span><br><span class="line">Contact contact = new Contact(&quot;开发者&quot;,&quot;&quot;,&quot;&quot;); return new ApiInfoBuilder()</span><br><span class="line">.title(&quot;闪聚支付‐商户应用API文档&quot;)</span><br><span class="line">.description(&quot;&quot;)</span><br><span class="line">.contact(contact)</span><br><span class="line">.version(&quot;1.0.0&quot;).build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加SpringMVC配置类：WebMvcConﬁg，让外部可直接访问Swagger文档</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.shanjupay.merchant.config;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line">import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry; import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">public class WebMvcConfig implements WebMvcConfigurer &#123;</span><br><span class="line">/**</span><br><span class="line">*添加静态资源文件，外部可以直接访问地址</span><br><span class="line">*</span><br><span class="line">*@param registry</span><br><span class="line">*/ @Override</span><br><span class="line">public void addResourceHandlers(ResourceHandlerRegistry registry) &#123; registry.addResourceHandler(&quot;/**&quot;).addResourceLocations(&quot;classpath:/static/&quot;);</span><br><span class="line"></span><br><span class="line">registry.addResourceHandler(&quot;swagger‐ui.html&quot;)</span><br><span class="line">.addResourceLocations(&quot;classpath:/META‐INF/resources/&quot;);</span><br><span class="line"></span><br><span class="line">registry.addResourceHandler(&quot;/webjars/**&quot;)</span><br><span class="line">.addResourceLocations(&quot;classpath:/META‐INF/resources/webjars/&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Swagger常用注解"><a href="#Swagger常用注解" class="headerlink" title="Swagger常用注解"></a><strong>Swagger</strong>常用注解</h3><p>在Java类中添加Swagger的注解即可生成Swagger接口文档，常用Swagger注解如下：</p>
<p>@Api：修饰整个类，描述Controller的作用 @ApiOperation：描述一个类的一个方法，或者说一个接口@ApiParam：单个参数的描述信息</p>
<p>@ApiModel：用对象来接收参数</p>
<p>@ApiModelProperty：用对象接收参数时，描述对象的一个字段@ApiResponse：HTTP响应其中1个描述</p>
<p>在Java类中添加Swagger的注解即可生成Swagger接口文档，常用Swagger注解如下：</p>
<p>@Api：修饰整个类，描述Controller的作用 @ApiOperation：描述一个类的一个方法，或者说一个接口@ApiParam：单个参数的描述信息</p>
<p>@ApiModel：用对象来接收参数</p>
<p>@ApiModelProperty：用对象接收参数时，描述对象的一个字段@ApiResponse：HTTP响应其中1个描述</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>属性</strong></th>
<th><strong>取值</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>paramType</td>
<td></td>
<td>查询参数类型</td>
</tr>
<tr>
<td></td>
<td>path</td>
<td>以地址的形式提交数据</td>
</tr>
<tr>
<td></td>
<td>query</td>
<td>直接跟参数完成自动映射赋值</td>
</tr>
<tr>
<td></td>
<td>body</td>
<td>以流的形式提交 仅支持POST</td>
</tr>
<tr>
<td></td>
<td>header</td>
<td>参数在request headers 里边提交</td>
</tr>
<tr>
<td></td>
<td>form</td>
<td>以form表单的形式提交 仅支持POST</td>
</tr>
<tr>
<td>dataType</td>
<td></td>
<td>参数的数据类型 只作为标志说明，并没有实际验证</td>
</tr>
<tr>
<td></td>
<td>Long</td>
<td></td>
</tr>
<tr>
<td></td>
<td>String</td>
<td></td>
</tr>
<tr>
<td>name</td>
<td></td>
<td>接收参数名</td>
</tr>
<tr>
<td>value</td>
<td></td>
<td>接收参数的意义描述</td>
</tr>
<tr>
<td>required</td>
<td></td>
<td>参数是否必填</td>
</tr>
<tr>
<td></td>
<td>true</td>
<td>必填</td>
</tr>
<tr>
<td></td>
<td>false</td>
<td>非必填</td>
</tr>
<tr>
<td>defaultValue</td>
<td></td>
<td>默认值</td>
</tr>
</tbody>
</table>
</div>
<p>上边的属性后边编写程序时用到哪个我再详细讲解，下边写一个swagger的简单例子，我们在MerchantController   中添加Swagger注解，代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Api(value = &quot;商户平台‐商户相关&quot;, tags = &quot;商户平台‐商户相关&quot;, description = &quot;商户平台‐商户相关&quot;) @RestController</span><br><span class="line">public class MerchantController &#123;</span><br><span class="line"></span><br><span class="line">@Reference</span><br><span class="line">private MerchantService merchantService;</span><br></pre></td></tr></table></figure>
<p>Swagger生成API文档的工作原理：</p>
<p>1、shanjupay-merchant-application启动时会扫描到SwaggerConﬁguration类</p>
<p>2、在此类中指定了扫描包路径com.shanjupay.merchant.controller，会找到在此包下及子包下标记有@RestController注解的controller类</p>
<p>3、根据controller类中的Swagger注解生成API文档</p>
<h2 id="接口调试利器Postman"><a href="#接口调试利器Postman" class="headerlink" title="接口调试利器Postman"></a><strong>接口调试利器</strong>Postman</h2><p>Postman是一款功能强大的http接口测试工具，使用Postman可以完成http各种请求的功能测试。作为服务器端   开发人员，当一个业务功能开发完毕后，应该用Postman进行功能测试。</p>
<p>1、请自行在本机安装Postman</p>
<p>2、新建集合(建议一个微服务新建一个对应的集合)：商户应用</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/06/4nrlz.png"><br><img src="https://i.p04e.com/baid/i/2023/01/06/nysy.png"></p>
<p>填写新建商户接口地址和请求类型后，点击Send发送请求</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/06/6cromn.png"></p>
]]></content>
      <tags>
        <tag>Swagger</tag>
        <tag>Postman</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot系列：运行原理</title>
    <url>/2023/01/09/SpringBoot%E7%B3%BB%E5%88%97%EF%BC%9A%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>《SpringBoot系列部分摘于网络，仅供个人笔记学习使用》</p>
<h2 id="运行原理："><a href="#运行原理：" class="headerlink" title="运行原理："></a>运行原理：</h2><p>一个普通的HelloSpringBoot，是怎么运行的呢？</p>
<span id="more"></span>
<h3 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h3><p>父依赖</p>
<p>依赖于父项目，管理项目的资源过滤及插件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.2.5.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">&lt;/parent&gt;</span><br></pre></td></tr></table></figure>
<p>点进去，发现还有一个父依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.2.5.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;relativePath&gt;../../spring-boot-dependencies&lt;/relativePath&gt;</span><br><span class="line">&lt;/parent&gt;</span><br></pre></td></tr></table></figure>
<p>这是真正管理SpringBoot应用里面所有依赖版本的地方，SpringBoot的版本控制中心；</p>
<p><strong>以后我们导入依赖默认是不需要写版本；</strong></p>
<p><strong>但如果导入的包没有在依赖中管理着就需要手动配置版本了；</strong></p>
<h2 id="启动器-spring-boot-starter"><a href="#启动器-spring-boot-starter" class="headerlink" title="启动器 spring-boot-starter"></a>启动器 spring-boot-starter</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p><strong>springboot-boot-starter-xxx</strong>：就是spring-boot的场景启动器</p>
<p><strong>spring-boot-starter-web</strong>：帮我们导入了web模块正常运行所依赖的组件；</p>
<p>SpringBoot将所有的功能场景都抽取出来，做成一个个的starter （启动器），只需要在项目中引入这些starter即可，所有相关的依赖都会导入进来 ， 我们要用什么功能就导入什么样的场景启动器即可 ；我们未来也可以自己自定义 starter；</p>
<h2 id="主启动类"><a href="#主启动类" class="headerlink" title="主启动类"></a><strong>主启动类</strong></h2><p>分析完了 pom.xml 来看看这个启动类</p>
<h3 id="默认的主启动类"><a href="#默认的主启动类" class="headerlink" title="默认的主启动类"></a>默认的主启动类</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/@SpringBootApplication 来标注一个主程序类</span><br><span class="line">//说明这是一个Spring Boot应用</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class SpringbootApplication &#123;</span><br><span class="line"></span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">     //以为是启动了一个方法，没想到启动了一个服务</span><br><span class="line">      SpringApplication.run(SpringbootApplication.class, args);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是<strong>一个简单的启动类并不简单！</strong>我们来分析一下这些注解都干了什么</p>
<h3 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h3><p>作用：标注在某个类上说明这个类是SpringBoot的主配置类 ， SpringBoot就应该运行这个类的main方法来启动SpringBoot应用；</p>
<p>进入这个注解：可以看到上面还有很多其他注解！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SpringBootConfiguration</span><br><span class="line">@EnableAutoConfiguration</span><br><span class="line">@ComponentScan(</span><br><span class="line">    excludeFilters = &#123;@Filter(</span><br><span class="line">    type = FilterType.CUSTOM,</span><br><span class="line">    classes = &#123;TypeExcludeFilter.class&#125;</span><br><span class="line">), @Filter(</span><br><span class="line">    type = FilterType.CUSTOM,</span><br><span class="line">    classes = &#123;AutoConfigurationExcludeFilter.class&#125;</span><br><span class="line">)&#125;</span><br><span class="line">)</span><br><span class="line">public @interface SpringBootApplication &#123;</span><br><span class="line">    // ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h3><p>这个注解在Spring中很重要 ,它对应XML配置中的元素。</p>
<p>作用：自动扫描并加载符合条件的组件或者bean ， 将这个bean定义加载到IOC容器中</p>
<h3 id="SpringBootConfiguration"><a href="#SpringBootConfiguration" class="headerlink" title="@SpringBootConfiguration"></a>@SpringBootConfiguration</h3><p>作用：SpringBoot的配置类 ，标注在某个类上 ， 表示这是一个SpringBoot的配置类；</p>
<p>我们继续进去这个注解查看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">// 点进去得到下面的 @Component</span><br><span class="line">@Configuration</span><br><span class="line">public @interface SpringBootConfiguration &#123;&#125;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">public @interface Configuration &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 @Configuration，说明这是一个配置类 ，配置类就是对应Spring的xml 配置文件；</p>
<p>里面的 @Component 这就说明，启动类本身也是Spring中的一个组件而已，负责启动应用！</p>
<p>我们回到 SpringBootApplication 注解中继续看。</p>
<h3 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h3><p><strong>@EnableAutoConfiguration ：开启自动配置功能</strong></p>
<p>以前我们需要自己配置的东西，而现在SpringBoot可以自动帮我们配置 ；@EnableAutoConfiguration告诉SpringBoot开启自动配置功能，这样自动配置才能生效；</p>
<p>点进注解接续查看：</p>
<p><strong>@AutoConfigurationPackage ：自动配置包</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@Import(&#123;Registrar.class&#125;)</span><br><span class="line">public @interface AutoConfigurationPackage &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>@import</strong> ：Spring底层注解@import ， 给容器中导入一个组件</p>
<p>Registrar.class 作用：将主启动类的所在包及包下面所有子包里面的所有组件扫描到Spring容器 ；</p>
<p>这个分析完了，退到上一步，继续看</p>
<p><strong>@Import({AutoConfigurationImportSelector.class}) ：给容器导入组件 ；</strong></p>
<p>AutoConfigurationImportSelector ：自动配置导入选择器，那么它会导入哪些组件的选择器呢？我们点击去这个类看源码：</p>
<p>1、这个类中有一个这样的方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">// 获得候选的配置</span><br><span class="line">protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) &#123;</span><br><span class="line">    //这里的getSpringFactoriesLoaderFactoryClass（）方法</span><br><span class="line">    //返回的就是我们最开始看的启动自动导入配置文件的注解类；EnableAutoConfiguration</span><br><span class="line">    List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader());</span><br><span class="line">    Assert.notEmpty(configurations, &quot;No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.&quot;);</span><br><span class="line">    return configurations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、这个方法又调用了  SpringFactoriesLoader 类的静态方法！我们进入SpringFactoriesLoader类loadFactoryNames() 方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryClass, @Nullable ClassLoader classLoader) &#123;</span><br><span class="line">    String factoryClassName = factoryClass.getName();</span><br><span class="line">    //这里它又调用了 loadSpringFactories 方法</span><br><span class="line">    return (List)loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、我们继续点击查看 loadSpringFactories 方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">private static Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(@Nullable ClassLoader classLoader) &#123;</span><br><span class="line">    //获得classLoader ， 我们返回可以看到这里得到的就是EnableAutoConfiguration标注的类本身</span><br><span class="line">    MultiValueMap&lt;String, String&gt; result = (MultiValueMap)cache.get(classLoader);</span><br><span class="line">    if (result != null) &#123;</span><br><span class="line">        return result;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            //去获取一个资源 &quot;META-INF/spring.factories&quot;</span><br><span class="line">            Enumeration&lt;URL&gt; urls = classLoader != null ? classLoader.getResources(&quot;META-INF/spring.factories&quot;) : ClassLoader.getSystemResources(&quot;META-INF/spring.factories&quot;);</span><br><span class="line">            LinkedMultiValueMap result = new LinkedMultiValueMap();</span><br><span class="line"></span><br><span class="line">            //将读取到的资源遍历，封装成为一个Properties</span><br><span class="line">            while(urls.hasMoreElements()) &#123;</span><br><span class="line">                URL url = (URL)urls.nextElement();</span><br><span class="line">                UrlResource resource = new UrlResource(url);</span><br><span class="line">                Properties properties = PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line">                Iterator var6 = properties.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">                while(var6.hasNext()) &#123;</span><br><span class="line">                    Entry&lt;?, ?&gt; entry = (Entry)var6.next();</span><br><span class="line">                    String factoryClassName = ((String)entry.getKey()).trim();</span><br><span class="line">                    String[] var9 = StringUtils.commaDelimitedListToStringArray((String)entry.getValue());</span><br><span class="line">                    int var10 = var9.length;</span><br><span class="line"></span><br><span class="line">                    for(int var11 = 0; var11 &lt; var10; ++var11) &#123;</span><br><span class="line">                        String factoryName = var9[var11];</span><br><span class="line">                        result.add(factoryClassName, factoryName.trim());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            cache.put(classLoader, result);</span><br><span class="line">            return result;</span><br><span class="line">        &#125; catch (IOException var13) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;Unable to load factories from location [META-INF/spring.factories]&quot;, var13);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4、发现一个多次出现的文件：spring.factories，全局搜索它</p>
<h2 id="spring-factories"><a href="#spring-factories" class="headerlink" title="spring.factories"></a>spring.factories</h2><p>我们根据源头打开spring.factories ， 看到了很多自动配置的文件；这就是自动配置根源所在！</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/09/4309.png"></p>
<p><strong>WebMvcAutoConfiguration</strong></p>
<p>我们在上面的自动配置类随便找一个打开看看，比如 ：WebMvcAutoConfiguration</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/09/ucko.png"></p>
<p>可以看到这些一个个的都是JavaConfig配置类，而且都注入了一些Bean，可以找一些自己认识的类，看着熟悉一下！</p>
<p>所以，自动配置真正实现是从classpath中搜寻所有的META-INF/spring.factories配置文件 ，并将其中对应的 org.springframework.boot.autoconfigure. 包下的配置项，通过反射实例化为对应标注了 @Configuration的JavaConfig形式的IOC容器配置类 ， 然后将这些都汇总成为一个实例并加载到IOC容器中。</p>
<p><strong>结论：</strong></p>
<ol>
<li>SpringBoot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值</li>
<li>将这些值作为自动配置类导入容器 ， 自动配置类就生效 ， 帮我们进行自动配置工作；</li>
<li>整个J2EE的整体解决方案和自动配置都在springboot-autoconfigure的jar包中；</li>
<li>它会给容器中导入非常多的自动配置类 （xxxAutoConfiguration）, 就是给容器中导入这个场景需要的所有组件 ， 并配置好这些组件 ；</li>
<li>有了自动配置类 ， 免去了我们手动编写配置注入功能组件等的工作；</li>
</ol>
<h2 id="SpringApplication"><a href="#SpringApplication" class="headerlink" title="SpringApplication"></a><strong>SpringApplication</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class SpringbootApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(SpringbootApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>SpringApplication.run分析</strong></p>
<p>分析该方法主要分两部分，一部分是SpringApplication的实例化，二是run方法的执行；</p>
<p>SpringApplication这个类主要做了以下四件事情：</p>
<p>1、推断应用的类型是普通的项目还是Web项目</p>
<p>2、查找并加载所有可用初始化器 ， 设置到initializers属性中</p>
<p>3、找出所有的应用程序监听器，设置到listeners属性中</p>
<p>4、推断并设置main方法的定义类，找到运行的主类</p>
<p>查看构造器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public SpringApplication(ResourceLoader resourceLoader, Class... primarySources) &#123;</span><br><span class="line">    // ......</span><br><span class="line">    this.webApplicationType = WebApplicationType.deduceFromClasspath();</span><br><span class="line">    this.setInitializers(this.getSpringFactoriesInstances();</span><br><span class="line">    this.setListeners(this.getSpringFactoriesInstances(ApplicationListener.class));</span><br><span class="line">    this.mainApplicationClass = this.deduceMainApplicationClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot系列：yaml配置注入</title>
    <url>/2023/01/10/SpringBoot%E7%B3%BB%E5%88%97%EF%BC%9Ayaml%E9%85%8D%E7%BD%AE%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>SpringBoot使用一个全局的配置文件 ， 配置文件名称是固定的</p>
<span id="more"></span>
<ul>
<li><p>application.properties</p>
</li>
<li><ul>
<li>语法结构 ：key=value</li>
</ul>
</li>
<li><p>application.yml</p>
</li>
<li><ul>
<li>语法结构 ：key：空格 value</li>
</ul>
</li>
</ul>
<p><strong>配置文件的作用 ：</strong>修改SpringBoot自动配置的默认值，因为SpringBoot在底层都给我们自动配置好了；</p>
<p>比如我们可以在配置文件中修改Tomcat 默认启动的端口号！测试一下！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server.port=8081</span><br></pre></td></tr></table></figure>
<h2 id="yaml概述"><a href="#yaml概述" class="headerlink" title="yaml概述"></a>yaml概述</h2><p>YAML是 “YAML Ain’t a Markup Language” （YAML不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：”Yet Another Markup Language”（仍是一种标记语言）</p>
<p><strong>这种语言以数据作为中心，而不是以标记语言为重点！</strong></p>
<p>以前的配置文件，大多数都是使用xml来配置；比如一个简单的端口配置，我们来对比下yaml和xml</p>
<p>传统xml配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;server&gt;    &lt;port&gt;8081&lt;port&gt;&lt;/server&gt;</span><br></pre></td></tr></table></figure>
<p>yaml配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server：  prot: 8080</span><br></pre></td></tr></table></figure>
<h2 id="yaml基础语法"><a href="#yaml基础语法" class="headerlink" title="yaml基础语法"></a>yaml基础语法</h2><p>说明：语法要求严格！</p>
<p>1、空格不能省略</p>
<p>2、以缩进来控制层级关系，只要是左边对齐的一列数据都是同一个层级的。</p>
<p>3、属性和值的大小写都是十分敏感的。</p>
<p><strong>字面量：普通的值  [ 数字，布尔值，字符串  ]</strong></p>
<p>字面量直接写在后面就可以 ， 字符串默认不用加上双引号或者单引号；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">k: v</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li><p>“ ” 双引号，不会转义字符串里面的特殊字符 ， 特殊字符会作为本身想表示的意思；</p>
<p>比如 ：name: “bai \n du”   输出 ：bai  换行   du</p>
</li>
<li><p>‘’ 单引号，会转义特殊字符 ， 特殊字符最终会变成和普通字符一样输出</p>
<p>比如 ：name: ‘bai \n du’   输出 ：bai   \n   du</p>
</li>
</ul>
<p><strong>对象、Map（键值对）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#对象、Map格式</span><br><span class="line">k: </span><br><span class="line">    v1:</span><br><span class="line">    v2:</span><br></pre></td></tr></table></figure>
<p>在下一行来写对象的属性和值得关系，注意缩进；比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">student:</span><br><span class="line">    name: qinjiang</span><br><span class="line">    age: 3</span><br></pre></td></tr></table></figure>
<p>行内写法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">student: &#123;name: qinjiang,age: 3&#125;</span><br></pre></td></tr></table></figure>
<p><strong>数组（ List、set ）</strong></p>
<p>用 - 值表示数组中的一个元素,比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pets:</span><br><span class="line"> - cat</span><br><span class="line"> - dog</span><br><span class="line"> - pig</span><br></pre></td></tr></table></figure>
<p>行内写法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pets: [cat,dog,pig]</span><br></pre></td></tr></table></figure>
<p><strong>修改SpringBoot的默认端口号</strong></p>
<p>配置文件中添加，端口号的参数，就可以切换端口；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">server:</span><br><span class="line">  port: 8082</span><br></pre></td></tr></table></figure>
<p>注入配置文件</p>
<p>yaml文件更强大的地方在于，他可以给我们的实体类直接注入匹配值！</p>
<h2 id="yaml注入配置文件"><a href="#yaml注入配置文件" class="headerlink" title="yaml注入配置文件"></a>yaml注入配置文件</h2><p>1、在springboot项目中的resources目录下新建一个文件 application.yml</p>
<p>2、编写一个实体类 Dog；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">package com.kuang.springboot.pojo;</span><br><span class="line"></span><br><span class="line">@Component  //注册bean到容器中</span><br><span class="line">public class Dog &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private Integer age;</span><br><span class="line">    </span><br><span class="line">    //有参无参构造、get、set方法、toString()方法  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、思考，我们原来是如何给bean注入属性值的！@Value，给狗狗类测试一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span> <span class="comment">//注册bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;大黄&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Value(&quot;8&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4、在SpringBoot的测试类下注入狗狗输出一下；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SpringBootTest</span><br><span class="line">class DemoApplicationTests &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired //将狗狗自动注入进来</span><br><span class="line">    Dog dog;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void contextLoads() &#123;</span><br><span class="line">        System.out.println(dog); //打印看下狗狗对象</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果成功输出，@Value注入成功，这是我们原来的办法对吧。</p>
<p>5、我们在编写一个复杂一点的实体类：Person 类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component //注册bean到容器中</span><br><span class="line">public class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private Integer age;</span><br><span class="line">    private Boolean happy;</span><br><span class="line">    private Date birth;</span><br><span class="line">    private Map&lt;String,Object&gt; maps;</span><br><span class="line">    private List&lt;Object&gt; lists;</span><br><span class="line">    private Dog dog;</span><br><span class="line">    </span><br><span class="line">    //有参无参构造、get、set方法、toString()方法  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>6、我们来使用yaml配置的方式进行注入，大家写的时候注意区别和优势，我们编写一个yaml配置！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">person:</span><br><span class="line">  name: baidu</span><br><span class="line">  age: 3</span><br><span class="line">  happy: false</span><br><span class="line">  birth: 2000/01/01</span><br><span class="line">  maps: &#123;k1: v1,k2: v2&#125;</span><br><span class="line">  lists:</span><br><span class="line">   - code</span><br><span class="line">   - girl</span><br><span class="line">   - music</span><br><span class="line">  dog:</span><br><span class="line">    name: 旺财</span><br><span class="line">    age: 1</span><br></pre></td></tr></table></figure>
<p>7、我们刚才已经把person这个对象的所有值都写好了，我们现在来注入到我们的类中！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">@ConfigurationProperties作用：</span><br><span class="line">将配置文件中配置的每一个属性的值，映射到这个组件中；</span><br><span class="line">告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定</span><br><span class="line">参数 prefix = “person” : 将配置文件中的person下面的所有属性一一对应</span><br><span class="line">*/</span><br><span class="line">@Component //注册bean</span><br><span class="line">@ConfigurationProperties(prefix = &quot;person&quot;)</span><br><span class="line">public class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private Integer age;</span><br><span class="line">    private Boolean happy;</span><br><span class="line">    private Date birth;</span><br><span class="line">    private Map&lt;String,Object&gt; maps;</span><br><span class="line">    private List&lt;Object&gt; lists;</span><br><span class="line">    private Dog dog;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>8、IDEA 提示，springboot配置注解处理器没有找到，让我们看文档，我们可以查看文档，找到一个依赖！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 导入配置文件处理器，配置文件进行绑定就会有提示，需要重启 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;</span><br><span class="line">  &lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>9、确认以上配置都OK之后，我们去测试类中测试一下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@SpringBootTest</span><br><span class="line">class DemoApplicationTests &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    Person person; //将person自动注入进来</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void contextLoads() &#123;</span><br><span class="line">        System.out.println(person); //打印person信息</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：所有值全部注入成功</p>
<p><strong>yaml配置注入到实体类完全OK！</strong></p>
<p>课堂测试：</p>
<p>1、将配置文件的key 值 和 属性的值设置为不一样，则结果输出为null，注入失败</p>
<p>2、在配置一个person2，然后将 @ConfigurationProperties(prefix = “person2”) 指向我们的person2；</p>
<h2 id="加载指定的配置文件"><a href="#加载指定的配置文件" class="headerlink" title="加载指定的配置文件"></a>加载指定的配置文件</h2><p><strong>@PropertySource ：</strong>加载指定的配置文件；</p>
<p><strong>@configurationProperties</strong>：默认从全局配置文件中获取值；</p>
<p>1、我们去在resources目录下新建一个<strong>person.properties</strong>文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">name=kuangshen</span><br></pre></td></tr></table></figure>
<p>2、然后在我们的代码中指定加载person.properties文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@PropertySource(value = &quot;classpath:person.properties&quot;)</span><br><span class="line">@Component //注册bean</span><br><span class="line">public class Person &#123;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;name&#125;&quot;)</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    ......  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、再次输出测试一下：指定配置文件绑定成功！</p>
<h2 id="配置文件占位符"><a href="#配置文件占位符" class="headerlink" title="配置文件占位符"></a>配置文件占位符</h2><p>配置文件还可以编写占位符生成随机数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">person:</span><br><span class="line">    name: qinjiang$&#123;random.uuid&#125; # 随机uuid</span><br><span class="line">    age: $&#123;random.int&#125;  # 随机int</span><br><span class="line">    happy: false</span><br><span class="line">    birth: 2000/01/01</span><br><span class="line">    maps: &#123;k1: v1,k2: v2&#125;</span><br><span class="line">    lists:</span><br><span class="line">      - code</span><br><span class="line">      - girl</span><br><span class="line">      - music</span><br><span class="line">    dog:</span><br><span class="line">      name: $&#123;person.hello:other&#125;_旺财</span><br><span class="line">      age: 1</span><br></pre></td></tr></table></figure>
<h2 id="回顾properties配置"><a href="#回顾properties配置" class="headerlink" title="回顾properties配置"></a>回顾properties配置</h2><p>我们上面采用的yaml方法都是最简单的方式，开发中最常用的；也是springboot所推荐的！那我们来唠唠其他的实现方式，道理都是相同的；写还是那样写；配置文件除了yml还有我们之前常用的properties ， 我们没有讲，我们来唠唠！</p>
<p>【注意】properties配置文件在写中文的时候，会有乱码 ， 我们需要去IDEA中设置编码格式为UTF-8；</p>
<p>settings—&gt;FileEncodings 中配置；</p>
<p><strong>测试步骤：</strong></p>
<p>1、新建一个实体类User</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component //注册bean</span><br><span class="line">public class User &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    private String sex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、编辑配置文件 user.properties</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">user1.name=kuangshen</span><br><span class="line">user1.age=18</span><br><span class="line">user1.sex=男</span><br></pre></td></tr></table></figure>
<p>3、我们在User类上使用@Value来进行注入！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component //注册bean</span><br><span class="line">@PropertySource(value = &quot;classpath:user.properties&quot;)</span><br><span class="line">public class User &#123;</span><br><span class="line">    //直接使用@value</span><br><span class="line">    @Value(&quot;$&#123;user.name&#125;&quot;) //从配置文件中取值</span><br><span class="line">    private String name;</span><br><span class="line">    @Value(&quot;#&#123;9*2&#125;&quot;)  // #&#123;SPEL&#125; Spring表达式</span><br><span class="line">    private int age;</span><br><span class="line">    @Value(&quot;男&quot;)  // 字面量</span><br><span class="line">    private String sex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4、Springboot测试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SpringBootTest</span><br><span class="line">class DemoApplicationTests &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    User user;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void contextLoads() &#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果正常输出：</p>
<h2 id="对比小结"><a href="#对比小结" class="headerlink" title="对比小结"></a>对比小结</h2><p>@Value这个使用起来并不友好！我们需要为每个属性单独注解赋值，比较麻烦；我们来看个功能对比图</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7KtjyIb9NEaYlz0tCWSiboOYjMibiaov73iaTsiaWEPoArDcAB1Ooibx9uR5JxtacIuicHblEtUI9SrySX2A/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p>
<p>1、@ConfigurationProperties只需要写一次即可 ， @Value则需要每个字段都添加</p>
<p>2、松散绑定：这个什么意思呢? 比如我的yml中写的last-name，这个和lastName是一样的， - 后面跟着的字母默认是大写的。这就是松散绑定。可以测试一下</p>
<p>3、JSR303数据校验 ， 这个就是我们可以在字段是增加一层过滤器验证 ， 可以保证数据的合法性</p>
<p>4、复杂类型封装，yml中可以封装对象 ， 使用value就不支持</p>
<p><strong>结论：</strong></p>
<p>配置yml和配置properties都可以获取到值 ， 强烈推荐 yml；</p>
<p>如果我们在某个业务中，只需要获取配置文件中的某个值，可以使用一下 @value；</p>
<p>如果说，我们专门编写了一个JavaBean来和配置文件进行一一映射，就直接@configurationProperties，不要犹豫！</p>
]]></content>
      <tags>
        <tag>SpringBoot</tag>
        <tag>yaml</tag>
        <tag>properties</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot系列：JSR303数据校验及多环境切换</title>
    <url>/2023/01/10/SpringBoot%E7%B3%BB%E5%88%97%EF%BC%9AJSR303%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C%E5%8F%8A%E5%A4%9A%E7%8E%AF%E5%A2%83%E5%88%87%E6%8D%A2/</url>
    <content><![CDATA[<p>Springboot中可以用@validated来校验数据，如果数据异常则会统一抛出异常，方便异常中心统一处理。我们这里来写个注解让我们的name只能支持Email格式；</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component //注册bean@ConfigurationProperties(prefix = &quot;person&quot;)@Validated  //数据校验public class Person &#123;</span><br><span class="line">    @Email(message=&quot;邮箱格式错误&quot;) //name必须是邮箱格式    private String name;&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果 ：default message [不是一个合法的电子邮件地址];</p>
<p><strong>使用数据校验，可以保证数据的正确性；</strong> </p>
<h2 id="常见参数"><a href="#常见参数" class="headerlink" title="常见参数"></a>常见参数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@NotNull(message=&quot;名字不能为空&quot;)</span><br><span class="line">private String userName;</span><br><span class="line">@Max(value=120,message=&quot;年龄最大不能查过120&quot;)</span><br><span class="line">private int age;</span><br><span class="line">@Email(message=&quot;邮箱格式错误&quot;)</span><br><span class="line">private String email;</span><br><span class="line"></span><br><span class="line">空检查</span><br><span class="line">@Null       验证对象是否为null</span><br><span class="line">@NotNull    验证对象是否不为null, 无法查检长度为0的字符串</span><br><span class="line">@NotBlank   检查约束字符串是不是Null还有被Trim的长度是否大于0,只对字符串,且会去掉前后空格.</span><br><span class="line">@NotEmpty   检查约束元素是否为NULL或者是EMPTY.</span><br><span class="line">    </span><br><span class="line">Booelan检查</span><br><span class="line">@AssertTrue     验证 Boolean 对象是否为 true  </span><br><span class="line">@AssertFalse    验证 Boolean 对象是否为 false  </span><br><span class="line">    </span><br><span class="line">长度检查</span><br><span class="line">@Size(min=, max=) 验证对象（Array,Collection,Map,String）长度是否在给定的范围之内  </span><br><span class="line">@Length(min=, max=) string is between min and max included.</span><br><span class="line"></span><br><span class="line">日期检查</span><br><span class="line">@Past       验证 Date 和 Calendar 对象是否在当前时间之前  </span><br><span class="line">@Future     验证 Date 和 Calendar 对象是否在当前时间之后  </span><br><span class="line">@Pattern    验证 String 对象是否符合正则表达式的规则</span><br><span class="line"></span><br><span class="line">.......等等</span><br><span class="line">除此以外，我们还可以自定义一些数据校验规则</span><br></pre></td></tr></table></figure>
<h2 id="多环境切换"><a href="#多环境切换" class="headerlink" title="多环境切换"></a>多环境切换</h2><p>profile是Spring对不同环境提供不同配置功能的支持，可以通过激活不同的环境版本，实现快速切换环境；</p>
<h3 id="多配置文件"><a href="#多配置文件" class="headerlink" title="多配置文件"></a>多配置文件</h3><p>我们在主配置文件编写的时候，文件名可以是 application-{profile}.properties/yml , 用来指定多个环境版本；</p>
<p><strong>例如：</strong></p>
<p>application-test.properties 代表测试环境配置</p>
<p>application-dev.properties 代表开发环境配置</p>
<p>但是Springboot并不会直接启动这些配置文件，它<strong>默认使用application.properties主配置文件</strong>；</p>
<p>我们需要通过一个配置来选择需要激活的环境：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#比如在配置文件中指定使用dev环境，我们可以通过设置不同的端口号进行测试；</span><br><span class="line">#我们启动SpringBoot，就可以看到已经切换到dev下的配置了；</span><br><span class="line">spring.profiles.active=dev</span><br></pre></td></tr></table></figure>
<h3 id="yaml的多文档块"><a href="#yaml的多文档块" class="headerlink" title="yaml的多文档块"></a>yaml的多文档块</h3><p>和properties配置文件中一样，但是使用yml去实现不需要创建多个配置文件，更加方便了 !</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8081</span><br><span class="line">#选择要激活那个环境块</span><br><span class="line">spring:</span><br><span class="line">  profiles:</span><br><span class="line">    active: prod</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">server:</span><br><span class="line">  port: 8083</span><br><span class="line">spring:</span><br><span class="line">  profiles: dev #配置环境的名称</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">server:</span><br><span class="line">  port: 8084</span><br><span class="line">spring:</span><br><span class="line">  profiles: prod  #配置环境的名称</span><br></pre></td></tr></table></figure>
<p><strong>注意：如果yml和properties同时都配置了端口，并且没有激活其他环境 ， 默认会使用properties配置文件的！</strong></p>
<h3 id="配置文件加载位置"><a href="#配置文件加载位置" class="headerlink" title="配置文件加载位置"></a>配置文件加载位置</h3><p><strong>外部加载配置文件的方式十分多，我们选择最常用的即可，在开发的资源文件中进行配置！</strong></p>
<p>springboot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">优先级1：项目路径下的config文件夹配置文件</span><br><span class="line">优先级2：项目路径下配置文件</span><br><span class="line">优先级3：资源路径下的config文件夹配置文件</span><br><span class="line">优先级4：资源路径下配置文件</span><br></pre></td></tr></table></figure>
<p>优先级由高到底，高优先级的配置会覆盖低优先级的配置；</p>
<p><strong>SpringBoot会从这四个位置全部加载主配置文件；互补配置；</strong></p>
<p>我们在最低级的配置文件中设置一个项目访问路径的配置来测试互补问题；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#配置项目的访问路径</span><br><span class="line">server.servlet.context-path=/baidu</span><br></pre></td></tr></table></figure>
<h2 id="拓展，运维小技巧"><a href="#拓展，运维小技巧" class="headerlink" title="拓展，运维小技巧"></a>拓展，运维小技巧</h2><p>指定位置加载配置文件</p>
<p>我们还可以通过spring.config.location来改变默认的配置文件位置</p>
<p>项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；这种情况，一般是后期运维做的多，相同配置，外部指定的配置文件优先级最高</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -jar spring-boot-config.jar --spring.config.location=F:/application.properties</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>SpringBoot</tag>
        <tag>yaml</tag>
        <tag>多环境切换</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot整理：Web开发静态资源处理</title>
    <url>/2023/01/13/SpringBoot%E6%95%B4%E7%90%86%EF%BC%9AWeb%E5%BC%80%E5%8F%91%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>开始学习SpringBoot与Web开发;</p>
<p>其实SpringBoot的东西用起来非常简单，因为SpringBoot最大的特点就是自动装配。</p>
<span id="more"></span>
<p><strong>使用SpringBoot的步骤：</strong></p>
<p>1、创建一个SpringBoot应用，选择我们需要的模块，SpringBoot就会默认将我们的需要的模块自动配置好</p>
<p>2、手动在配置文件中配置部分配置项目就可以运行起来了</p>
<p>3、专注编写业务代码，不需要考虑以前那样一大堆的配置了。</p>
<p>要熟悉掌握开发，之前学习的自动配置的原理一定要搞明白！</p>
<p>比如SpringBoot到底帮我们配置了什么？我们能不能修改？我们能修改哪些配置？我们能不能扩展？</p>
<ul>
<li>向容器中自动配置组件 ： Autoconfiguration</li>
<li>自动配置类，封装配置文件的内容：Poperties</li>
</ul>
<p>没事就找找类，看看自动装配原理！</p>
<p>我们之后来进行一个单体项目的小项目测试，让大家能够快速上手开发！</p>
<p>静态资源处理</p>
<h2 id="静态资源映射规则"><a href="#静态资源映射规则" class="headerlink" title="静态资源映射规则"></a>静态资源映射规则</h2><p><strong>首先，我们搭建一个普通的SpringBoot项目，回顾一下HelloWorld程序！</strong></p>
<p>写请求非常简单，那我们要引入我们前端资源，我们项目中有许多的静态资源，比如css，js等文件，这个SpringBoot怎么处理呢？</p>
<p>如果我们是一个web应用，我们的main下会有一个webapp，我们以前都是将所有的页面导在这里面的，对吧！但是我们现在的pom呢，打包方式是为jar的方式，那么这种方式SpringBoot能不能来给我们写页面呢？当然是可以的，但是SpringBoot对于静态资源放置的位置，是有规定的！</p>
<p><strong>我们先来聊聊这个静态资源映射规则：</strong></p>
<p>SpringBoot中，SpringMVC的web配置都在 WebMvcAutoConfiguration 这个配置类里面；</p>
<p>我们可以去看看 WebMvcAutoConfigurationAdapter 中有很多配置方法；</p>
<p>有一个方法：addResourceHandlers 添加资源处理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void addResourceHandlers(ResourceHandlerRegistry registry) &#123;</span><br><span class="line">    if (!this.resourceProperties.isAddMappings()) &#123;</span><br><span class="line">        // 已禁用默认资源处理</span><br><span class="line">        logger.debug(&quot;Default resource handling disabled&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 缓存控制</span><br><span class="line">    Duration cachePeriod = this.resourceProperties.getCache().getPeriod();</span><br><span class="line">    CacheControl cacheControl = this.resourceProperties.getCache().getCachecontrol().toHttpCacheControl();</span><br><span class="line">    // webjars 配置</span><br><span class="line">    if (!registry.hasMappingForPattern(&quot;/webjars/**&quot;)) &#123;</span><br><span class="line">        customizeResourceHandlerRegistration(registry.addResourceHandler(&quot;/webjars/**&quot;)</span><br><span class="line">                                             .addResourceLocations(&quot;classpath:/META-INF/resources/webjars/&quot;)</span><br><span class="line">                                             .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl));</span><br><span class="line">    &#125;</span><br><span class="line">    // 静态资源配置</span><br><span class="line">    String staticPathPattern = this.mvcProperties.getStaticPathPattern();</span><br><span class="line">    if (!registry.hasMappingForPattern(staticPathPattern)) &#123;</span><br><span class="line">        customizeResourceHandlerRegistration(registry.addResourceHandler(staticPathPattern)</span><br><span class="line">                                             .addResourceLocations(getResourceLocations(this.resourceProperties.getStaticLocations()))</span><br><span class="line">                                             .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读一下源代码：比如所有的 /webjars/** ， 都需要去 classpath:/META-INF/resources/webjars/ 找对应的资源；</p>
<h2 id="什么是webjars-呢？"><a href="#什么是webjars-呢？" class="headerlink" title="什么是webjars 呢？"></a>什么是webjars 呢？</h2><p>Webjars本质就是以jar包的方式引入我们的静态资源 ， 我们以前要导入一个静态资源文件，直接导入即可。</p>
<p>使用SpringBoot需要使用Webjars，我们可以去搜索一下：</p>
<p>网站：<a href="https://www.webjars.org">https://www.webjars.org</a> </p>
<p>要使用jQuery，我们只要要引入jQuery对应版本的pom依赖即可！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.webjars&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jquery&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.4.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>导入完毕，查看webjars目录结构，并访问Jquery.js文件！</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/13/6iqs9.png"></p>
<p>访问：只要是静态资源，SpringBoot就会去对应的路径寻找资源，我们这里访问：<a href="http://localhost:8080/webjars/jquery/3.4.1/jquery.js">http://localhost:8080/webjars/jquery/3.4.1/jquery.js</a></p>
<p><img src="https://i.p04e.com/baid/i/2023/01/13/4slo.png"></p>
<h2 id="第二种静态资源映射规则"><a href="#第二种静态资源映射规则" class="headerlink" title="第二种静态资源映射规则"></a>第二种静态资源映射规则</h2><p>那我们项目中要是使用自己的静态资源该怎么导入呢？我们看下一行代码；</p>
<p>我们去找staticPathPattern发现第二种映射规则 ：/** , 访问当前的项目任意资源，它会去找 resourceProperties 这个类，我们可以点进去看一下分析：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 进入方法</span><br><span class="line">public String[] getStaticLocations() &#123;</span><br><span class="line">    return this.staticLocations;</span><br><span class="line">&#125;</span><br><span class="line">// 找到对应的值</span><br><span class="line">private String[] staticLocations = CLASSPATH_RESOURCE_LOCATIONS;</span><br><span class="line">// 找到路径</span><br><span class="line">private static final String[] CLASSPATH_RESOURCE_LOCATIONS = &#123; </span><br><span class="line">    &quot;classpath:/META-INF/resources/&quot;,</span><br><span class="line">  &quot;classpath:/resources/&quot;, </span><br><span class="line">    &quot;classpath:/static/&quot;, </span><br><span class="line">    &quot;classpath:/public/&quot; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>ResourceProperties 可以设置和我们静态资源有关的参数；这里面指向了它会去寻找资源的文件夹，即上面数组的内容。</p>
<p>所以得出结论，以下四个目录存放的静态资源可以被我们识别：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;classpath:/META-INF/resources/&quot;</span><br><span class="line">&quot;classpath:/resources/&quot;</span><br><span class="line">&quot;classpath:/static/&quot;</span><br><span class="line">&quot;classpath:/public/&quot;</span><br></pre></td></tr></table></figure>
<p>我们可以在resources根目录下新建对应的文件夹，都可以存放我们的静态文件；</p>
<p>比如我们访问 <a href="http://localhost:8080/1.js">http://localhost:8080/1.js</a> , 他就会去这些文件夹中寻找对应的静态资源文件；</p>
<h2 id="自定义静态资源路径"><a href="#自定义静态资源路径" class="headerlink" title="自定义静态资源路径"></a>自定义静态资源路径</h2><p>我们也可以自己通过配置文件来指定一下，哪些文件夹是需要我们放静态资源文件的，在application.properties中配置；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring.resources.static-locations=classpath:/coding/,classpath:/bai/</span><br></pre></td></tr></table></figure>
<p>一旦自己定义了静态文件夹的路径，原来的自动配置就都会失效了！</p>
<p>首页处理</p>
<p>静态资源文件夹说完后，我们继续向下看源码！可以看到一个欢迎页的映射，就是我们的首页！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public WelcomePageHandlerMapping welcomePageHandlerMapping(ApplicationContext applicationContext,</span><br><span class="line">                                                           FormattingConversionService mvcConversionService,</span><br><span class="line">                                                           ResourceUrlProvider mvcResourceUrlProvider) &#123;</span><br><span class="line">    WelcomePageHandlerMapping welcomePageHandlerMapping = new WelcomePageHandlerMapping(</span><br><span class="line">        new TemplateAvailabilityProviders(applicationContext), applicationContext, getWelcomePage(), // getWelcomePage 获得欢迎页</span><br><span class="line">        this.mvcProperties.getStaticPathPattern());</span><br><span class="line">    welcomePageHandlerMapping.setInterceptors(getInterceptors(mvcConversionService, mvcResourceUrlProvider));</span><br><span class="line">    return welcomePageHandlerMapping;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>点进去继续看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private Optional&lt;Resource&gt; getWelcomePage() &#123;</span><br><span class="line">    String[] locations = getResourceLocations(this.resourceProperties.getStaticLocations());</span><br><span class="line">    // ::是java8 中新引入的运算符</span><br><span class="line">    // Class::function的时候function是属于Class的，应该是静态方法。</span><br><span class="line">    // this::function的funtion是属于这个对象的。</span><br><span class="line">    // 简而言之，就是一种语法糖而已，是一种简写</span><br><span class="line">    return Arrays.stream(locations).map(this::getIndexHtml).filter(this::isReadable).findFirst();</span><br><span class="line">&#125;</span><br><span class="line">// 欢迎页就是一个location下的的 index.html 而已</span><br><span class="line">private Resource getIndexHtml(String location) &#123;</span><br><span class="line">    return this.resourceLoader.getResource(location + &quot;index.html&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>欢迎页，静态资源文件夹下的所有 index.html 页面；被 /** 映射。</p>
<p>比如我访问  <a href="http://localhost:8080/">http://localhost:8080/</a> ，就会找静态资源文件夹下的 index.html</p>
<p>新建一个 index.html ，在我们上面的3个目录中任意一个；然后访问测试  <a href="http://localhost:8080/">http://localhost:8080/</a>  看结果！</p>
<p><strong>关于网站图标说明</strong>：</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/13/6j0z6.png"></p>
<p>与其他静态资源一样，Spring Boot在配置的静态内容位置中查找 favicon.ico。如果存在这样的文件，它将自动用作应用程序的favicon。</p>
<p>1、关闭SpringBoot默认图标</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#关闭默认图标</span><br><span class="line">spring.mvc.favicon.enabled=false</span><br></pre></td></tr></table></figure>
<p>2、自己放一个图标在静态资源目录下，我放在 public 目录下</p>
<p>3、清除浏览器缓存！刷新网页，发现图标已经变成自己的了！</p>
]]></content>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot系列：整合Druid</title>
    <url>/2023/01/13/SpringBoot%E7%B3%BB%E5%88%97%EF%BC%9A%E6%95%B4%E5%90%88Druid/</url>
    <content><![CDATA[<h2 id="Druid简介"><a href="#Druid简介" class="headerlink" title="Druid简介"></a>Druid简介</h2><p>Java程序很大一部分要操作数据库，为了提高性能操作数据库的时候，又不得不使用数据库连接池。</p>
<p>Druid 是阿里巴巴开源平台上一个数据库连接池实现，结合了 C3P0、DBCP 等 DB 池的优点，同时加入了日志监控。<span id="more"></span></p>
<p>Druid 可以很好的监控 DB 池连接和 SQL 的执行情况，天生就是针对监控而生的 DB 连接池。</p>
<p>Druid已经在阿里巴巴部署了超过600个应用，经过一年多生产环境大规模部署的严苛考验。</p>
<p>Spring Boot 2.0 以上默认使用 Hikari 数据源，可以说 Hikari 与 Driud 都是当前 Java Web 上最优秀的数据源，我们来重点介绍 Spring Boot 如何集成 Druid 数据源，如何实现数据库监控。</p>
<p>Github地址：<a href="https://github.com/alibaba/druid/">https://github.com/alibaba/druid/</a></p>
<p><strong>com.alibaba.druid.pool.DruidDataSource 基本配置参数如下：</strong></p>
<p><img src="https://i.p04e.com/baid/i/2023/01/13/5ix23.png"></p>
<h2 id="配置数据源"><a href="#配置数据源" class="headerlink" title="配置数据源"></a>配置数据源</h2><p>1、添加上 Druid 数据源依赖。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;druid&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.1.21&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>2、切换数据源；之前已经说过 Spring Boot 2.0 以上默认使用 com.zaxxer.hikari.HikariDataSource 数据源，但可以 通过 spring.datasource.type 指定数据源。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    username: root</span><br><span class="line">    password: 123456</span><br><span class="line">    url: jdbc:mysql://localhost:3306/springboot?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    type: com.alibaba.druid.pool.DruidDataSource # 自定义数据源</span><br></pre></td></tr></table></figure>
<p>3、数据源切换之后，在测试类中注入 DataSource，然后获取到它，输出一看便知是否成功切换；</p>
<p>4、切换成功！既然切换成功，就可以设置数据源连接初始化大小、最大连接数、等待时间、最小连接数 等设置项；可以查看源码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    username: root</span><br><span class="line">    password: root</span><br><span class="line">    #?serverTimezone=UTC解决时区的报错</span><br><span class="line">    url: jdbc:mysql://localhost:3306/springboot?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    type: com.alibaba.druid.pool.DruidDataSource</span><br><span class="line"></span><br><span class="line">    #Spring Boot 默认是不注入这些属性值的，需要自己绑定</span><br><span class="line">    #druid 数据源专有配置</span><br><span class="line">    initialSize: 5</span><br><span class="line">    minIdle: 5</span><br><span class="line">    maxActive: 20</span><br><span class="line">    maxWait: 60000</span><br><span class="line">    timeBetweenEvictionRunsMillis: 60000</span><br><span class="line">    minEvictableIdleTimeMillis: 300000</span><br><span class="line">    validationQuery: SELECT 1 FROM DUAL</span><br><span class="line">    testWhileIdle: true</span><br><span class="line">    testOnBorrow: false</span><br><span class="line">    testOnReturn: false</span><br><span class="line">    poolPreparedStatements: true</span><br><span class="line"></span><br><span class="line">    #配置监控统计拦截的filters，stat:监控统计、log4j：日志记录、wall：防御sql注入</span><br><span class="line">    #如果允许时报错  java.lang.ClassNotFoundException: org.apache.log4j.Priority</span><br><span class="line">    #则导入 log4j 依赖即可，Maven 地址：https://mvnrepository.com/artifact/log4j/log4j</span><br><span class="line">    filters: stat,wall,log4j</span><br><span class="line">    maxPoolPreparedStatementPerConnectionSize: 20</span><br><span class="line">    useGlobalDataSourceStat: true</span><br><span class="line">    connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500</span><br></pre></td></tr></table></figure>
<p>5、导入Log4j 的依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/log4j/log4j --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;log4j&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;log4j&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2.17&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>6、现在需要程序员自己为 DruidDataSource 绑定全局配置文件中的参数，再添加到容器中，而不再使用 Spring Boot 的自动生成了；我们需要 自己添加 DruidDataSource 组件到容器中，并绑定属性；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">package com.kuang.config;</span><br><span class="line"></span><br><span class="line">import com.alibaba.druid.pool.DruidDataSource;</span><br><span class="line">import org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line">import javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class DruidConfig &#123;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">       将自定义的 Druid数据源添加到容器中，不再让 Spring Boot 自动创建</span><br><span class="line">       绑定全局配置文件中的 druid 数据源属性到 com.alibaba.druid.pool.DruidDataSource从而让它们生效</span><br><span class="line">       @ConfigurationProperties(prefix = &quot;spring.datasource&quot;)：作用就是将 全局配置文件中</span><br><span class="line">       前缀为 spring.datasource的属性值注入到 com.alibaba.druid.pool.DruidDataSource 的同名参数中</span><br><span class="line">     */</span><br><span class="line">    @ConfigurationProperties(prefix = &quot;spring.datasource&quot;)</span><br><span class="line">    @Bean</span><br><span class="line">    public DataSource druidDataSource() &#123;</span><br><span class="line">        return new DruidDataSource();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>7、去测试类中测试一下；看是否成功！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SpringBootTest</span><br><span class="line">class SpringbootDataJdbcApplicationTests &#123;</span><br><span class="line"></span><br><span class="line">    //DI注入数据源</span><br><span class="line">    @Autowired</span><br><span class="line">    DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void contextLoads() throws SQLException &#123;</span><br><span class="line">        //看一下默认数据源</span><br><span class="line">        System.out.println(dataSource.getClass());</span><br><span class="line">        //获得连接</span><br><span class="line">        Connection connection =   dataSource.getConnection();</span><br><span class="line">        System.out.println(connection);</span><br><span class="line"></span><br><span class="line">        DruidDataSource druidDataSource = (DruidDataSource) dataSource;</span><br><span class="line">        System.out.println(&quot;druidDataSource 数据源最大连接数：&quot; + druidDataSource.getMaxActive());</span><br><span class="line">        System.out.println(&quot;druidDataSource 数据源初始化连接数：&quot; + druidDataSource.getInitialSize());</span><br><span class="line"></span><br><span class="line">        //关闭连接</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果 ：可见配置参数已经生效！</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/13/5jglr.png"></p>
<h2 id="配置Druid数据源监控"><a href="#配置Druid数据源监控" class="headerlink" title="配置Druid数据源监控"></a>配置Druid数据源监控</h2><p>Druid 数据源具有监控的功能，并提供了一个 web 界面方便用户查看，类似安装 路由器 时，人家也提供了一个默认的 web 页面。</p>
<p>所以第一步需要设置 Druid 的后台管理页面，比如 登录账号、密码 等；配置后台管理；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//配置 Druid 监控管理后台的Servlet；</span><br><span class="line">//内置 Servlet 容器时没有web.xml文件，所以使用 Spring Boot 的注册 Servlet 方式</span><br><span class="line">@Bean</span><br><span class="line">public ServletRegistrationBean statViewServlet() &#123;</span><br><span class="line">    ServletRegistrationBean bean = new ServletRegistrationBean(new StatViewServlet(), &quot;/druid/*&quot;);</span><br><span class="line"></span><br><span class="line">    // 这些参数可以在 com.alibaba.druid.support.http.StatViewServlet </span><br><span class="line">    // 的父类 com.alibaba.druid.support.http.ResourceServlet 中找到</span><br><span class="line">    Map&lt;String, String&gt; initParams = new HashMap&lt;&gt;();</span><br><span class="line">    initParams.put(&quot;loginUsername&quot;, &quot;admin&quot;); //后台管理界面的登录账号</span><br><span class="line">    initParams.put(&quot;loginPassword&quot;, &quot;root&quot;); //后台管理界面的登录密码</span><br><span class="line"></span><br><span class="line">    //后台允许谁可以访问</span><br><span class="line">    //initParams.put(&quot;allow&quot;, &quot;localhost&quot;)：表示只有本机可以访问</span><br><span class="line">    //initParams.put(&quot;allow&quot;, &quot;&quot;)：为空或者为null时，表示允许所有访问</span><br><span class="line">    initParams.put(&quot;allow&quot;, &quot;&quot;);</span><br><span class="line">    //deny：Druid 后台拒绝谁访问</span><br><span class="line">    //initParams.put(&quot;baidu&quot;, &quot;192.168.1.0.1&quot;);表示禁止此ip访问</span><br><span class="line"></span><br><span class="line">    //设置初始化参数</span><br><span class="line">    bean.setInitParameters(initParams);</span><br><span class="line">    return bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置完毕后，我们可以选择访问 ：<a href="http://localhost:8080/druid/login.html">http://localhost:8080/druid/login.html</a></p>
<p><img src="https://i.p04e.com/baid/i/2023/01/13/42sp.png"></p>
<p><strong>配置 Druid web 监控 filter 过滤器</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">//配置 Druid 监控 之  web 监控的 filter</span><br><span class="line">//WebStatFilter：用于配置Web和Druid数据源之间的管理关联监控统计</span><br><span class="line">@Bean</span><br><span class="line">public FilterRegistrationBean webStatFilter() &#123;</span><br><span class="line">    FilterRegistrationBean bean = new FilterRegistrationBean();</span><br><span class="line">    bean.setFilter(new WebStatFilter());</span><br><span class="line"></span><br><span class="line">    //exclusions：设置哪些请求进行过滤排除掉，从而不进行统计</span><br><span class="line">    Map&lt;String, String&gt; initParams = new HashMap&lt;&gt;();</span><br><span class="line">    initParams.put(&quot;exclusions&quot;, &quot;*.js,*.css,/druid/*,/jdbc/*&quot;);</span><br><span class="line">    bean.setInitParameters(initParams);</span><br><span class="line"></span><br><span class="line">    //&quot;/*&quot; 表示过滤所有请求</span><br><span class="line">    bean.setUrlPatterns(Arrays.asList(&quot;/*&quot;));</span><br><span class="line">    return bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>平时在工作中，按需求进行配置即可，主要用作监控！</p>
]]></content>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Druid</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot系列：整合JDBC</title>
    <url>/2023/01/12/SpringBoot%E7%B3%BB%E5%88%97%EF%BC%9A%E6%95%B4%E5%90%88JDBC/</url>
    <content><![CDATA[<p>对于数据访问层，无论是 SQL(关系型数据库) 还是 NOSQL(非关系型数据库)，Spring Boot 底层都是采用 Spring Data 的方式进行统一处理。</p>
<p>Spring Boot 底层都是采用 Spring Data 的方式进行统一处理各种数据库，Spring Data 也是 Spring 中与 Spring Boot、Spring Cloud 等齐名的知名项目。</p>
<span id="more"></span>
<h2 id="创建测试项目测试数据源"><a href="#创建测试项目测试数据源" class="headerlink" title="创建测试项目测试数据源"></a>创建测试项目测试数据源</h2><p>1、我去新建一个项目测试：springboot-data-jdbc ; 引入相应的模块！基础模块</p>
<p>2、项目建好之后，发现自动帮我们导入了如下的启动器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">    &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>3、编写yaml配置文件连接数据库；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    username: root</span><br><span class="line">    password: root</span><br><span class="line">    url: jdbc:mysql://localhost:3306/springboot?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br></pre></td></tr></table></figure>
<p>4、配置完这一些东西后，我们就可以直接去使用了，因为SpringBoot已经默认帮我们进行了自动配置；去测试类测试一下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@SpringBootTest</span><br><span class="line">class SpringbootDataJdbcApplicationTests &#123;</span><br><span class="line"></span><br><span class="line">    //DI注入数据源</span><br><span class="line">    @Autowired</span><br><span class="line">    DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void contextLoads() throws SQLException &#123;</span><br><span class="line">        //看一下默认数据源</span><br><span class="line">        System.out.println(dataSource.getClass());</span><br><span class="line">        //获得连接</span><br><span class="line">        Connection connection =   dataSource.getConnection();</span><br><span class="line">        System.out.println(connection);</span><br><span class="line">        //关闭连接</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：我们可以看到他默认给我们配置的数据源为 : class com.zaxxer.hikari.HikariDataSource ， 我们并没有手动配置</p>
<p>我们来全局搜索一下，找到数据源的所有自动配置都在 ：DataSourceAutoConfiguration文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Import(</span><br><span class="line">    &#123;Hikari.class, Tomcat.class, Dbcp2.class, Generic.class, DataSourceJmxConfiguration.class&#125;</span><br><span class="line">)</span><br><span class="line">protected static class PooledDataSourceConfiguration &#123;</span><br><span class="line">    protected PooledDataSourceConfiguration() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里导入的类都在 DataSourceConfiguration 配置类下，可以看出 Spring Boot 2.2.5 默认使用HikariDataSource 数据源，而以前版本，如 Spring Boot 1.5 默认使用 org.apache.tomcat.jdbc.pool.DataSource 作为数据源；</p>
<p><strong>HikariDataSource 号称 Java WEB 当前速度最快的数据源，相比于传统的 C3P0 、DBCP、Tomcat jdbc 等连接池更加优秀；</strong></p>
<p><strong>可以使用 spring.datasource.type 指定自定义的数据源类型，值为 要使用的连接池实现的完全限定名。</strong></p>
<p>关于数据源我们并不做介绍，有了数据库连接，显然就可以 CRUD 操作数据库了。但是我们需要先了解一个对象 JdbcTemplate</p>
<h2 id="JDBCTemplate"><a href="#JDBCTemplate" class="headerlink" title="JDBCTemplate"></a>JDBCTemplate</h2><p>1、有了数据源(com.zaxxer.hikari.HikariDataSource)，然后可以拿到数据库连接(java.sql.Connection)，有了连接，就可以使用原生的 JDBC 语句来操作数据库；</p>
<p>2、即使不使用第三方第数据库操作框架，如 MyBatis等，Spring 本身也对原生的JDBC 做了轻量级的封装，即JdbcTemplate。</p>
<p>3、数据库操作的所有 CRUD 方法都在 JdbcTemplate 中。</p>
<p>4、Spring Boot 不仅提供了默认的数据源，同时默认已经配置好了 JdbcTemplate 放在了容器中，程序员只需自己注入即可使用</p>
<p>5、JdbcTemplate 的自动配置是依赖 org.springframework.boot.autoconfigure.jdbc 包下的 JdbcTemplateConfiguration 类</p>
<p><strong>JdbcTemplate主要提供以下几类方法：</strong></p>
<ul>
<li>execute方法：可以用于执行任何SQL语句，一般用于执行DDL语句；</li>
<li>update方法及batchUpdate方法：update方法用于执行新增、修改、删除等语句；batchUpdate方法用于执行批处理相关语句；</li>
<li>query方法及queryForXXX方法：用于执行查询相关语句；</li>
<li>call方法：用于执行存储过程、函数相关语句。</li>
</ul>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>编写一个Controller，注入 jdbcTemplate，编写测试方法进行访问测试；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">package com.kuang.controller;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">import java.util.Date;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/jdbc&quot;)</span><br><span class="line">public class JdbcController &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Spring Boot 默认提供了数据源，默认提供了 org.springframework.jdbc.core.JdbcTemplate</span><br><span class="line">     * JdbcTemplate 中会自己注入数据源，用于简化 JDBC操作</span><br><span class="line">     * 还能避免一些常见的错误,使用起来也不用再自己来关闭数据库连接</span><br><span class="line">     */</span><br><span class="line">    @Autowired</span><br><span class="line">    JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    //查询employee表中所有数据</span><br><span class="line">    //List 中的1个 Map 对应数据库的 1行数据</span><br><span class="line">    //Map 中的 key 对应数据库的字段名，value 对应数据库的字段值</span><br><span class="line">    @GetMapping(&quot;/list&quot;)</span><br><span class="line">    public List&lt;Map&lt;String, Object&gt;&gt; userList()&#123;</span><br><span class="line">        String sql = &quot;select * from employee&quot;;</span><br><span class="line">        List&lt;Map&lt;String, Object&gt;&gt; maps = jdbcTemplate.queryForList(sql);</span><br><span class="line">        return maps;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //新增一个用户</span><br><span class="line">    @GetMapping(&quot;/add&quot;)</span><br><span class="line">    public String addUser()&#123;</span><br><span class="line">        //插入语句，注意时间问题</span><br><span class="line">        String sql = &quot;insert into employee(last_name, email,gender,department,birth)&quot; +</span><br><span class="line">                &quot; values (&#x27;bai&#x27;,&#x27;25453@qq.com&#x27;,1,101,&#x27;&quot;+ new Date().toLocaleString() +&quot;&#x27;)&quot;;</span><br><span class="line">        jdbcTemplate.update(sql);</span><br><span class="line">        //查询</span><br><span class="line">        return &quot;addOk&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //修改用户信息</span><br><span class="line">    @GetMapping(&quot;/update/&#123;id&#125;&quot;)</span><br><span class="line">    public String updateUser(@PathVariable(&quot;id&quot;) int id)&#123;</span><br><span class="line">        //插入语句</span><br><span class="line">        String sql = &quot;update employee set last_name=?,email=? where id=&quot;+id;</span><br><span class="line">        //数据</span><br><span class="line">        Object[] objects = new Object[2];</span><br><span class="line">        objects[0] = &quot;秦&quot;;</span><br><span class="line">        objects[1] = &quot;25445465@qq.com&quot;;</span><br><span class="line">        jdbcTemplate.update(sql,objects);</span><br><span class="line">        //查询</span><br><span class="line">        return &quot;updateOk&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //删除用户</span><br><span class="line">    @GetMapping(&quot;/delete/&#123;id&#125;&quot;)</span><br><span class="line">    public String delUser(@PathVariable(&quot;id&quot;) int id)&#123;</span><br><span class="line">        //插入语句</span><br><span class="line">        String sql = &quot;delete from employee where id=?&quot;;</span><br><span class="line">        jdbcTemplate.update(sql,id);</span><br><span class="line">        //查询</span><br><span class="line">        return &quot;deleteOk&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>测试请求，结果正常；</p>
<p>到此，CURD的基本操作，使用 JDBC 就搞定了。</p>
]]></content>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot系列：自动配置原理</title>
    <url>/2023/01/12/SpringBoot%E7%B3%BB%E5%88%97%EF%BC%9A%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="分析自动配置原理"><a href="#分析自动配置原理" class="headerlink" title="分析自动配置原理"></a>分析自动配置原理</h2><p>我们以<strong>HttpEncodingAutoConfiguration（Http编码自动配置）</strong>为例解释自动配置原理；</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">//表示这是一个配置类，和以前编写的配置文件一样，也可以给容器中添加组件；</span><br><span class="line">@Configuration </span><br><span class="line"></span><br><span class="line">//启动指定类的ConfigurationProperties功能；</span><br><span class="line">  //进入这个HttpProperties查看，将配置文件中对应的值和HttpProperties绑定起来；</span><br><span class="line">  //并把HttpProperties加入到ioc容器中</span><br><span class="line">@EnableConfigurationProperties(&#123;HttpProperties.class&#125;) </span><br><span class="line"></span><br><span class="line">//Spring底层@Conditional注解</span><br><span class="line">  //根据不同的条件判断，如果满足指定的条件，整个配置类里面的配置就会生效；</span><br><span class="line">  //这里的意思就是判断当前应用是否是web应用，如果是，当前配置类生效</span><br><span class="line">@ConditionalOnWebApplication(</span><br><span class="line">    type = Type.SERVLET</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">//判断当前项目有没有这个类CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器；</span><br><span class="line">@ConditionalOnClass(&#123;CharacterEncodingFilter.class&#125;)</span><br><span class="line"></span><br><span class="line">//判断配置文件中是否存在某个配置：spring.http.encoding.enabled；</span><br><span class="line">  //如果不存在，判断也是成立的</span><br><span class="line">  //即使我们配置文件中不配置pring.http.encoding.enabled=true，也是默认生效的；</span><br><span class="line">@ConditionalOnProperty(</span><br><span class="line">    prefix = &quot;spring.http.encoding&quot;,</span><br><span class="line">    value = &#123;&quot;enabled&quot;&#125;,</span><br><span class="line">    matchIfMissing = true</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">public class HttpEncodingAutoConfiguration &#123;</span><br><span class="line">    //他已经和SpringBoot的配置文件映射了</span><br><span class="line">    private final Encoding properties;</span><br><span class="line">    //只有一个有参构造器的情况下，参数的值就会从容器中拿</span><br><span class="line">    public HttpEncodingAutoConfiguration(HttpProperties properties) &#123;</span><br><span class="line">        this.properties = properties.getEncoding();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //给容器中添加一个组件，这个组件的某些值需要从properties中获取</span><br><span class="line">    @Bean</span><br><span class="line">    @ConditionalOnMissingBean //判断容器没有这个组件？</span><br><span class="line">    public CharacterEncodingFilter characterEncodingFilter() &#123;</span><br><span class="line">        CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter();</span><br><span class="line">        filter.setEncoding(this.properties.getCharset().name());</span><br><span class="line">        filter.setForceRequestEncoding(this.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.REQUEST));</span><br><span class="line">        filter.setForceResponseEncoding(this.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.RESPONSE));</span><br><span class="line">        return filter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>一句话总结 ：根据当前不同的条件判断，决定这个配置类是否生效！</strong></p>
<ul>
<li>一但这个配置类生效；这个配置类就会给容器中添加各种组件；</li>
<li>这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的；</li>
<li>所有在配置文件中能配置的属性都是在xxxxProperties类中封装着；</li>
<li>配置文件能配置什么就可以参照某个功能对应的这个属性类</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//从配置文件中获取指定的值和bean的属性进行绑定</span><br><span class="line">@ConfigurationProperties(prefix = &quot;spring.http&quot;) </span><br><span class="line">public class HttpProperties &#123;</span><br><span class="line">    // .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们去配置文件里面试试前缀，看提示！</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/12/4lfo.png"></p>
<p><strong>这就是自动装配的原理！</strong></p>
<h2 id="精髓"><a href="#精髓" class="headerlink" title="精髓"></a>精髓</h2><p>1、SpringBoot启动会加载大量的自动配置类</p>
<p>2、我们看我们需要的功能有没有在SpringBoot默认写好的自动配置类当中；</p>
<p>3、我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件存在在其中，我们就不需要再手动配置了）</p>
<p>4、给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们只需要在配置文件中指定这些属性的值即可；</p>
<p><strong>xxxxAutoConfigurartion：自动配置类；</strong>给容器中添加组件</p>
<p><strong>xxxxProperties:封装配置文件中相关属性；</strong></p>
<h2 id="了解：-Conditional"><a href="#了解：-Conditional" class="headerlink" title="了解：@Conditional"></a>了解：@Conditional</h2><p>了解完自动装配的原理后，我们来关注一个细节问题，<strong>自动配置类必须在一定的条件下才能生效；</strong></p>
<p><strong>@Conditional派生注解（Spring注解版原生的@Conditional作用）</strong></p>
<p>作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效；</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/12/w76n.png"></p>
<p><strong>那么多的自动配置类，必须在一定的条件下才能生效；也就是说，我们加载了这么多的配置类，但不是所有的都生效了。</strong></p>
<p>我们怎么知道哪些自动配置类生效？</p>
<p><strong>我们可以通过启用 debug=true属性；来让控制台打印自动配置报告，这样我们就可以很方便的知道哪些自动配置类生效；</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#开启springboot的调试类debug=true</span><br></pre></td></tr></table></figure>
<p><strong>Positive matches:（自动配置类启用的：正匹配）</strong></p>
<p><strong>Negative matches:（没有启动，没有匹配成功的自动配置类：负匹配）</strong></p>
<p><strong>Unconditional classes: （没有条件的类）</strong></p>
]]></content>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot系列：Thymeleaf模板引擎</title>
    <url>/2023/01/14/SpringBoot%E7%B3%BB%E5%88%97%EF%BC%9AThymeleaf%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/</url>
    <content><![CDATA[<h2 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h2><p>前端交给我们的页面，是html页面。如果是我们以前开发，我们需要把他们转成jsp页面，jsp好处就是当我们查出一些数据转发到JSP页面以后，我们可以用jsp轻松实现数据的显示，及交互等。</p>
<span id="more"></span>
<p>jsp支持非常强大的功能，包括能写Java代码，但是呢，我们现在的这种情况，SpringBoot这个项目首先是以jar的方式，不是war，像第二，我们用的还是嵌入式的Tomcat，所以呢，<strong>他现在默认是不支持jsp的</strong>。</p>
<p>那不支持jsp，如果我们直接用纯静态页面的方式，那给我们开发会带来非常大的麻烦，那怎么办呢？</p>
<p><strong>SpringBoot推荐你可以来使用模板引擎：</strong></p>
<p>模板引擎，我们其实大家听到很多，其实jsp就是一个模板引擎，还有用的比较多的freemarker，包括SpringBoot给我们推荐的Thymeleaf，模板引擎有非常多，但再多的模板引擎，他们的思想都是一样的，什么样一个思想呢我们来看一下这张图：</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/14/87cb5m.png"></p>
<p>模板引擎的作用就是我们来写一个页面模板，比如有些值呢，是动态的，我们写一些表达式。而这些值，从哪来呢，就是我们在后台封装一些数据。然后把这个模板和这个数据交给我们模板引擎，模板引擎按照我们这个数据帮你把这表达式解析、填充到我们指定的位置，然后把这个数据最终生成一个我们想要的内容给我们写出去，这就是我们这个模板引擎，不管是jsp还是其他模板引擎，都是这个思想。只不过呢，就是说不同模板引擎之间，他们可能这个语法有点不一样。其他的我就不介绍了，我主要来介绍一下SpringBoot给我们推荐的Thymeleaf模板引擎，这模板引擎呢，是一个高级语言的模板引擎，他的这个语法更简单。而且呢，功能更强大。</p>
<p>我们呢，就来看一下这个模板引擎，那既然要看这个模板引擎。首先，我们来看SpringBoot里边怎么用。</p>
<h2 id="引入Thymeleaf"><a href="#引入Thymeleaf" class="headerlink" title="引入Thymeleaf"></a>引入Thymeleaf</h2><p>怎么引入呢，对于springboot来说，什么事情不都是一个start的事情嘛，我们去在项目中引入一下。给大家三个网址：</p>
<p>Thymeleaf 官网：<a href="https://www.thymeleaf.org/">https://www.thymeleaf.org/</a></p>
<p>Thymeleaf 在Github 的主页：<a href="https://github.com/thymeleaf/thymeleaf">https://github.com/thymeleaf/thymeleaf</a></p>
<p>Spring官方文档：找到我们对应的版本</p>
<p><a href="https://docs.spring.io/spring-boot/docs/2.2.5.RELEASE/reference/htmlsingle/#using-boot-starter">https://docs.spring.io/spring-boot/docs/2.2.5.RELEASE/reference/htmlsingle/#using-boot-starter</a> </p>
<p>找到对应的pom依赖：可以适当点进源码看下本来的包！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--thymeleaf--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>Maven会自动下载jar包，我们可以去看下下载的东西；</p>
<p>!<img src="https://i.p04e.com/baid/i/2023/01/14/61cxh.png"></p>
<h2 id="Thymeleaf分析"><a href="#Thymeleaf分析" class="headerlink" title="Thymeleaf分析"></a>Thymeleaf分析</h2><p>前面呢，我们已经引入了Thymeleaf，那这个要怎么使用呢？</p>
<p>我们首先得按照SpringBoot的自动配置原理看一下我们这个Thymeleaf的自动配置规则，在按照那个规则，我们进行使用。</p>
<p>我们去找一下Thymeleaf的自动配置类：ThymeleafProperties</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ConfigurationProperties(</span><br><span class="line">    prefix = &quot;spring.thymeleaf&quot;</span><br><span class="line">)</span><br><span class="line">public class ThymeleafProperties &#123;</span><br><span class="line">    private static final Charset DEFAULT_ENCODING;</span><br><span class="line">    public static final String DEFAULT_PREFIX = &quot;classpath:/templates/&quot;;</span><br><span class="line">    public static final String DEFAULT_SUFFIX = &quot;.html&quot;;</span><br><span class="line">    private boolean checkTemplate = true;</span><br><span class="line">    private boolean checkTemplateLocation = true;</span><br><span class="line">    private String prefix = &quot;classpath:/templates/&quot;;</span><br><span class="line">    private String suffix = &quot;.html&quot;;</span><br><span class="line">    private String mode = &quot;HTML&quot;;</span><br><span class="line">    private Charset encoding;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以在其中看到默认的前缀和后缀！</p>
<p>我们只需要把我们的html页面放在类路径下的templates下，thymeleaf就可以帮我们自动渲染了。</p>
<p>使用thymeleaf什么都不需要配置，只需要将他放在指定的文件夹下即可！</p>
<p><strong>测试</strong></p>
<p>1、编写一个TestController</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class TestController &#123;</span><br><span class="line">    </span><br><span class="line">    @RequestMapping(&quot;/t1&quot;)</span><br><span class="line">    public String test1()&#123;</span><br><span class="line">        //classpath:/templates/test.html</span><br><span class="line">        return &quot;test&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、编写一个测试页面  test.html 放在 templates 目录下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;测试页面&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>3、启动项目请求测试</p>
<h2 id="Thymeleaf-语法学习"><a href="#Thymeleaf-语法学习" class="headerlink" title="Thymeleaf 语法学习"></a>Thymeleaf 语法学习</h2><p>要学习语法，还是参考官网文档最为准确，我们找到对应的版本看一下；</p>
<p>Thymeleaf 官网：<a href="https://www.thymeleaf.org/">https://www.thymeleaf.org/</a> ， 简单看一下官网！我们去下载Thymeleaf的官方文档！</p>
<p><strong>我们做个最简单的练习 ：我们需要查出一些数据，在页面中展示</strong></p>
<p>1、修改测试请求，增加数据传输；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequestMapping(&quot;/t1&quot;)</span><br><span class="line">public String test1(Model model)&#123;</span><br><span class="line">    //存入数据</span><br><span class="line">    model.addAttribute(&quot;msg&quot;,&quot;Hello,Thymeleaf&quot;);</span><br><span class="line">    //classpath:/templates/test.html</span><br><span class="line">    return &quot;test&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、我们要使用thymeleaf，需要在html文件中导入命名空间的约束，方便提示。</p>
<p>我们可以去官方文档的#3中看一下命名空间拿来过来：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xmlns:th=&quot;http://www.thymeleaf.org&quot;</span><br></pre></td></tr></table></figure>
<p>3、我们去编写下前端页面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;测试页面&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--th:text就是将div中的内容设置为它指定的值，和之前学习的Vue一样--&gt;</span><br><span class="line">&lt;div th:text=&quot;$&#123;msg&#125;&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>4、启动测试！</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Idia351qHgmH2vbzurk1Pp6ia0fYFrNsXdHekjLfPlq4ZMpF0rtPzFRBTWsw6K8zic3ywna1LgcM6Gw/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p>
<p><strong>OK，入门搞定，我们来认真研习一下Thymeleaf的使用语法！</strong></p>
<p><strong>1、我们可以使用任意的 th:attr 来替换Html中原生属性的值！</strong></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Idia351qHgmH2vbzurk1Pp6fGYIwv043icVDYuybRJDCGTSNTMEibFzzMdlKS4t07TQoicQJKQAe0slQ/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p>
<p>1、 我们编写一个Controller，放一些数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequestMapping(&quot;/t2&quot;)</span><br><span class="line">public String test2(Map&lt;String,Object&gt; map)&#123;</span><br><span class="line">    //存入数据</span><br><span class="line">    map.put(&quot;msg&quot;,&quot;&lt;h1&gt;Hello&lt;/h1&gt;&quot;);</span><br><span class="line">    map.put(&quot;users&quot;, Arrays.asList(&quot;qinjiang&quot;,&quot;kuangshen&quot;));</span><br><span class="line">    //classpath:/templates/test.html</span><br><span class="line">    return &quot;test&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、测试页面取出数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;div th:text=&quot;$&#123;msg&#125;&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;!--不转义--&gt;</span><br><span class="line">&lt;div th:utext=&quot;$&#123;msg&#125;&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--遍历数据--&gt;</span><br><span class="line">&lt;!--th:each每次遍历都会生成当前这个标签：官网#9--&gt;</span><br><span class="line">&lt;h4 th:each=&quot;user :$&#123;users&#125;&quot; th:text=&quot;$&#123;user&#125;&quot;&gt;&lt;/h4&gt;</span><br><span class="line"></span><br><span class="line">&lt;h4&gt;</span><br><span class="line">    &lt;!--行内写法：官网#12--&gt;</span><br><span class="line">    &lt;span th:each=&quot;user:$&#123;users&#125;&quot;&gt;[[$&#123;user&#125;]]&lt;/span&gt;</span><br><span class="line">&lt;/h4&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>3、启动项目测试！</p>
<p><strong>我们看完语法，很多样式，我们即使现在学习了，也会忘记，所以我们在学习过程中，需要使用什么，根据官方文档来查询，才是最重要的，要熟练使用官方文档！</strong></p>
]]></content>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Thymeleaf</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot系列：MVC自动配置原理</title>
    <url>/2023/01/14/SpringBoot%E7%B3%BB%E5%88%97%EF%BC%9AMVC%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>官网阅读</p>
<p>在进行项目编写前，我们还需要知道一个东西，就是SpringBoot对我们的SpringMVC还做了哪些配置，包括如何扩展，如何定制。</p>
<span id="more"></span>
<p>只有把这些都搞清楚了，我们在之后使用才会更加得心应手。途径一：源码分析，途径二：官方文档！</p>
<p>地址 ：<a href="https://docs.spring.io/spring-boot/docs/2.2.5.RELEASE/reference/htmlsingle/#boot-features-spring-mvc-auto-configuration">https://docs.spring.io/spring-boot/docs/2.2.5.RELEASE/reference/htmlsingle/#boot-features-spring-mvc-auto-configuration</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Spring MVC Auto-configuration</span><br><span class="line">// Spring Boot为Spring MVC提供了自动配置，它可以很好地与大多数应用程序一起工作。</span><br><span class="line">Spring Boot provides auto-configuration for Spring MVC that works well with most applications.</span><br><span class="line">// 自动配置在Spring默认设置的基础上添加了以下功能：</span><br><span class="line">The auto-configuration adds the following features on top of Spring’s defaults:</span><br><span class="line">// 包含视图解析器</span><br><span class="line">Inclusion of ContentNegotiatingViewResolver and BeanNameViewResolver beans.</span><br><span class="line">// 支持静态资源文件夹的路径，以及webjars</span><br><span class="line">Support for serving static resources, including support for WebJars </span><br><span class="line">// 自动注册了Converter：</span><br><span class="line">// 转换器，这就是我们网页提交数据到后台自动封装成为对象的东西，比如把&quot;1&quot;字符串自动转换为int类型</span><br><span class="line">// Formatter：【格式化器，比如页面给我们了一个2019-8-10，它会给我们自动格式化为Date对象】</span><br><span class="line">Automatic registration of Converter, GenericConverter, and Formatter beans.</span><br><span class="line">// HttpMessageConverters</span><br><span class="line">// SpringMVC用来转换Http请求和响应的的，比如我们要把一个User对象转换为JSON字符串，可以去看官网文档解释；</span><br><span class="line">Support for HttpMessageConverters (covered later in this document).</span><br><span class="line">// 定义错误代码生成规则的</span><br><span class="line">Automatic registration of MessageCodesResolver (covered later in this document).</span><br><span class="line">// 首页定制</span><br><span class="line">Static index.html support.</span><br><span class="line">// 图标定制</span><br><span class="line">Custom Favicon support (covered later in this document).</span><br><span class="line">// 初始化数据绑定器：帮我们把请求数据绑定到JavaBean中！</span><br><span class="line">Automatic use of a ConfigurableWebBindingInitializer bean (covered later in this document).</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">如果您希望保留Spring Boot MVC功能，并且希望添加其他MVC配置（拦截器、格式化程序、视图控制器和其他功能），则可以添加自己</span><br><span class="line">的@configuration类，类型为webmvcconfiguer，但不添加@EnableWebMvc。如果希望提供</span><br><span class="line">RequestMappingHandlerMapping、RequestMappingHandlerAdapter或ExceptionHandlerExceptionResolver的自定义</span><br><span class="line">实例，则可以声明WebMVCregistrationAdapter实例来提供此类组件。</span><br><span class="line">*/</span><br><span class="line">If you want to keep Spring Boot MVC features and you want to add additional MVC configuration </span><br><span class="line">(interceptors, formatters, view controllers, and other features), you can add your own </span><br><span class="line">@Configuration class of type WebMvcConfigurer but without @EnableWebMvc. If you wish to provide </span><br><span class="line">custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter, or </span><br><span class="line">ExceptionHandlerExceptionResolver, you can declare a WebMvcRegistrationsAdapter instance to provide such components.</span><br><span class="line"></span><br><span class="line">// 如果您想完全控制Spring MVC，可以添加自己的@Configuration，并用@EnableWebMvc进行注释。</span><br><span class="line">If you want to take complete control of Spring MVC, you can add your own @Configuration annotated with @EnableWebMvc.</span><br></pre></td></tr></table></figure>
<p>我们来仔细对照，看一下它怎么实现的，它告诉我们SpringBoot已经帮我们自动配置好了SpringMVC，然后自动配置了哪些东西呢？</p>
<h2 id="ContentNegotiatingViewResolver-内容协商视图解析器"><a href="#ContentNegotiatingViewResolver-内容协商视图解析器" class="headerlink" title="ContentNegotiatingViewResolver 内容协商视图解析器"></a><strong>ContentNegotiatingViewResolver 内容协商视图解析器</strong></h2><p>自动配置了ViewResolver，就是我们之前学习的SpringMVC的视图解析器；</p>
<p>即根据方法的返回值取得视图对象（View），然后由视图对象决定如何渲染（转发，重定向）。</p>
<p>我们去看看这里的源码：我们找到 WebMvcAutoConfiguration ， 然后搜索ContentNegotiatingViewResolver。找到如下方法！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">@ConditionalOnBean(ViewResolver.class)</span><br><span class="line">@ConditionalOnMissingBean(name = &quot;viewResolver&quot;, value = ContentNegotiatingViewResolver.class)</span><br><span class="line">public ContentNegotiatingViewResolver viewResolver(BeanFactory beanFactory) &#123;</span><br><span class="line">    ContentNegotiatingViewResolver resolver = new ContentNegotiatingViewResolver();</span><br><span class="line">    resolver.setContentNegotiationManager(beanFactory.getBean(ContentNegotiationManager.class));</span><br><span class="line">    // ContentNegotiatingViewResolver使用所有其他视图解析器来定位视图，因此它应该具有较高的优先级</span><br><span class="line">    resolver.setOrder(Ordered.HIGHEST_PRECEDENCE);</span><br><span class="line">    return resolver;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以点进这类看看！找到对应的解析视图的代码；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@Nullable // 注解说明：@Nullable 即参数可为null</span><br><span class="line">public View resolveViewName(String viewName, Locale locale) throws Exception &#123;</span><br><span class="line">    RequestAttributes attrs = RequestContextHolder.getRequestAttributes();</span><br><span class="line">    Assert.state(attrs instanceof ServletRequestAttributes, &quot;No current ServletRequestAttributes&quot;);</span><br><span class="line">    List&lt;MediaType&gt; requestedMediaTypes = this.getMediaTypes(((ServletRequestAttributes)attrs).getRequest());</span><br><span class="line">    if (requestedMediaTypes != null) &#123;</span><br><span class="line">        // 获取候选的视图对象</span><br><span class="line">        List&lt;View&gt; candidateViews = this.getCandidateViews(viewName, locale, requestedMediaTypes);</span><br><span class="line">        // 选择一个最适合的视图对象，然后把这个对象返回</span><br><span class="line">        View bestView = this.getBestView(candidateViews, requestedMediaTypes, attrs);</span><br><span class="line">        if (bestView != null) &#123;</span><br><span class="line">            return bestView;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们继续点进去看，他是怎么获得候选的视图的呢？</p>
<p>getCandidateViews中看到他是把所有的视图解析器拿来，进行while循环，挨个解析！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Iterator var5 = this.viewResolvers.iterator();</span><br></pre></td></tr></table></figure>
<p>所以得出结论：<strong>ContentNegotiatingViewResolver 这个视图解析器就是用来组合所有的视图解析器的</strong> </p>
<p>我们再去研究下他的组合逻辑，看到有个属性viewResolvers，看看它是在哪里进行赋值的！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">protected void initServletContext(ServletContext servletContext) &#123;</span><br><span class="line">    // 这里它是从beanFactory工具中获取容器中的所有视图解析器</span><br><span class="line">    // ViewRescolver.class 把所有的视图解析器来组合的</span><br><span class="line">    Collection&lt;ViewResolver&gt; matchingBeans = BeanFactoryUtils.beansOfTypeIncludingAncestors(this.obtainApplicationContext(), ViewResolver.class).values();</span><br><span class="line">    ViewResolver viewResolver;</span><br><span class="line">    if (this.viewResolvers == null) &#123;</span><br><span class="line">        this.viewResolvers = new ArrayList(matchingBeans.size());</span><br><span class="line">    &#125;</span><br><span class="line">    // ...............</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>既然它是在容器中去找视图解析器，我们是否可以猜想，我们就可以去实现一个视图解析器了呢？</p>
<p>我们可以自己给容器中去添加一个视图解析器；这个类就会帮我们自动的将它组合进来；<strong>我们去实现一下</strong></p>
<p>1、我们在我们的主程序中去写一个视图解析器来试试；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected void initServletContext(ServletContext servletContext) &#123;</span><br><span class="line">    // 这里它是从beanFactory工具中获取容器中的所有视图解析器</span><br><span class="line">    // ViewRescolver.class 把所有的视图解析器来组合的</span><br><span class="line">    Collection&lt;ViewResolver&gt; matchingBeans = BeanFactoryUtils.beansOfTypeIncludingAncestors(this.obtainApplicationContext(), ViewResolver.class).values();</span><br><span class="line">    ViewResolver viewResolver;</span><br><span class="line">    if (this.viewResolvers == null) &#123;</span><br><span class="line">        this.viewResolvers = new ArrayList(matchingBeans.size());</span><br><span class="line">    &#125;</span><br><span class="line">    // ...............</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、怎么看我们自己写的视图解析器有没有起作用呢？</p>
<p>我们给 DispatcherServlet 中的 doDispatch方法 加个断点进行调试一下，因为所有的请求都会走到这个方法中</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/14/oy2.png"></p>
<p>3、我们启动我们的项目，然后随便访问一个页面，看一下Debug信息；</p>
<p>找到this</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/14/y2ce.png"></p>
<p>找到视图解析器，我们看到我们自己定义的就在这里了；</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/14/y5v7.png"></p>
<p>所以说，我们如果想要使用自己定制化的东西，我们只需要给容器中添加这个组件就好了！剩下的事情SpringBoot就会帮我们做了！</p>
<h2 id="转换器和格式化器"><a href="#转换器和格式化器" class="headerlink" title="转换器和格式化器"></a>转换器和格式化器</h2><p>找到格式化转换器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">@Override</span><br><span class="line">public FormattingConversionService mvcConversionService() &#123;</span><br><span class="line">    // 拿到配置文件中的格式化规则</span><br><span class="line">    WebConversionService conversionService = </span><br><span class="line">        new WebConversionService(this.mvcProperties.getDateFormat());</span><br><span class="line">    addFormatters(conversionService);</span><br><span class="line">    return conversionService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>点击去：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public String getDateFormat() &#123;</span><br><span class="line">    return this.dateFormat;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* Date format to use. For instance, `dd/MM/yyyy`. 默认的</span><br><span class="line"> */</span><br><span class="line">private String dateFormat;</span><br></pre></td></tr></table></figure>
<p>可以看到在我们的Properties文件中，我们可以进行自动配置它！</p>
<p>如果配置了自己的格式化方式，就会注册到Bean中生效，我们可以在配置文件中配置日期格式化的规则：</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/14/4vm5.png"></p>
<p>其余的就不一一举例了，大家可以下去多研究探讨即可！</p>
<h2 id="修改SpringBoot的默认配置"><a href="#修改SpringBoot的默认配置" class="headerlink" title="修改SpringBoot的默认配置"></a>修改SpringBoot的默认配置</h2><p>这么多的自动配置，原理都是一样的，通过这个WebMVC的自动配置原理分析，我们要学会一种学习方式，通过源码探究，得出结论；这个结论一定是属于自己的，而且一通百通。</p>
<p>SpringBoot的底层，大量用到了这些设计细节思想，所以，没事需要多阅读源码！得出结论；</p>
<p>SpringBoot在自动配置很多组件的时候，先看容器中有没有用户自己配置的（如果用户自己配置@bean），如果有就用用户配置的，如果没有就用自动配置的；</p>
<p>如果有些组件可以存在多个，比如我们的视图解析器，就将用户配置的和自己默认的组合起来！</p>
<p><strong>扩展使用SpringMVC</strong>  官方文档如下：</p>
<p>If you want to keep Spring Boot MVC features and you want to add additional MVC configuration (interceptors, formatters, view controllers, and other features), you can add your own @Configuration class of type WebMvcConfigurer but without @EnableWebMvc. If you wish to provide custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter, or ExceptionHandlerExceptionResolver, you can declare a WebMvcRegistrationsAdapter instance to provide such components.</p>
<p>我们要做的就是编写一个@Configuration注解类，并且类型要为WebMvcConfigurer，还不能标注@EnableWebMvc注解；我们去自己写一个；我们新建一个包叫config，写一个类MyMvcConfig；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">//应为类型要求为WebMvcConfigurer，所以我们实现其接口</span><br><span class="line">//可以使用自定义类扩展MVC的功能</span><br><span class="line">@Configuration</span><br><span class="line">public class MyMvcConfig implements WebMvcConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void addViewControllers(ViewControllerRegistry registry) &#123;</span><br><span class="line">        // 浏览器发送/test ， 就会跳转到test页面；</span><br><span class="line">        registry.addViewController(&quot;/test&quot;).setViewName(&quot;test&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们去浏览器访问一下：</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/14/ozk.png"></p>
<p><strong>确实也跳转过来了！所以说，我们要扩展SpringMVC，官方就推荐我们这么去使用，既保SpringBoot留所有的自动配置，也能用我们扩展的配置！</strong></p>
<p>我们可以去分析一下原理：</p>
<p>1、WebMvcAutoConfiguration 是 SpringMVC的自动配置类，里面有一个类WebMvcAutoConfigurationAdapter</p>
<p>2、这个类上有一个注解，在做其他自动配置时会导入：@Import(EnableWebMvcConfiguration.class)</p>
<p>3、我们点进EnableWebMvcConfiguration这个类看一下，它继承了一个父类：DelegatingWebMvcConfiguration</p>
<p>这个父类中有这样一段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport &#123;</span><br><span class="line">    private final WebMvcConfigurerComposite configurers = new WebMvcConfigurerComposite();</span><br><span class="line">    </span><br><span class="line">  // 从容器中获取所有的webmvcConfigurer</span><br><span class="line">    @Autowired(required = false)</span><br><span class="line">    public void setConfigurers(List&lt;WebMvcConfigurer&gt; configurers) &#123;</span><br><span class="line">        if (!CollectionUtils.isEmpty(configurers)) &#123;</span><br><span class="line">            this.configurers.addWebMvcConfigurers(configurers);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4、我们可以在这个类中去寻找一个我们刚才设置的viewController当做参考，发现它调用了一个</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected void addViewControllers(ViewControllerRegistry registry) &#123;</span><br><span class="line">    this.configurers.addViewControllers(registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5、我们点进去看一下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public void addViewControllers(ViewControllerRegistry registry) &#123;</span><br><span class="line">    Iterator var2 = this.delegates.iterator();</span><br><span class="line"></span><br><span class="line">    while(var2.hasNext()) &#123;</span><br><span class="line">        // 将所有的WebMvcConfigurer相关配置来一起调用！包括我们自己配置的和Spring给我们配置的</span><br><span class="line">        WebMvcConfigurer delegate = (WebMvcConfigurer)var2.next();</span><br><span class="line">        delegate.addViewControllers(registry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以得出结论：所有的WebMvcConfiguration都会被作用，不止Spring自己的配置类，我们自己的配置类当然也会被调用；</p>
<h2 id="全面接管SpringMVC"><a href="#全面接管SpringMVC" class="headerlink" title="全面接管SpringMVC"></a>全面接管SpringMVC</h2><p>官方文档：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">If you want to take complete control of Spring MVC</span><br><span class="line">you can add your own @Configuration annotated with @EnableWebMvc.</span><br></pre></td></tr></table></figure>
<p>全面接管即：SpringBoot对SpringMVC的自动配置不需要了，所有都是我们自己去配置！</p>
<p>只需在我们的配置类中要加一个@EnableWebMvc。</p>
<p>我们看下如果我们全面接管了SpringMVC了，我们之前SpringBoot给我们配置的静态资源映射一定会无效，我们可以去测试一下；</p>
<p>不加注解之前，访问首页：</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/14/p61.png"></p>
<p>给配置类加上注解：@EnableWebMvc</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/14/4w7q.png"></p>
<p>我们发现所有的SpringMVC自动配置都失效了！回归到了最初的样子；</p>
<p><strong>当然，我们开发中，不推荐使用全面接管SpringMVC</strong></p>
<p>思考问题？为什么加了一个注解，自动配置就失效了！我们看下源码：</p>
<p>1、这里发现它是导入了一个类，我们可以继续进去看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Import(&#123;DelegatingWebMvcConfiguration.class&#125;)</span><br><span class="line">public @interface EnableWebMvc &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、它继承了一个父类 WebMvcConfigurationSupport</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport &#123;</span><br><span class="line">  // ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、我们来回顾一下Webmvc自动配置类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration(proxyBeanMethods = false)</span><br><span class="line">@ConditionalOnWebApplication(type = Type.SERVLET)</span><br><span class="line">@ConditionalOnClass(&#123; Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class &#125;)</span><br><span class="line">// 这个注解的意思就是：容器中没有这个组件的时候，这个自动配置类才生效</span><br><span class="line">@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)</span><br><span class="line">@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)</span><br><span class="line">@AutoConfigureAfter(&#123; DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class,</span><br><span class="line">    ValidationAutoConfiguration.class &#125;)</span><br><span class="line">public class WebMvcAutoConfiguration &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结一句话：@EnableWebMvc将WebMvcConfigurationSupport组件导入进来了；</p>
<p>而导入的WebMvcConfigurationSupport只是SpringMVC最基本的功能！</p>
<p><strong>在SpringBoot中会有非常多的扩展配置，只要看见了这个，我们就应该多留心注意~</strong></p>
]]></content>
      <tags>
        <tag>SpringBoot</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot：集成Swagger</title>
    <url>/2023/01/15/SpringBoot%EF%BC%9A%E9%9B%86%E6%88%90Swagger/</url>
    <content><![CDATA[<h3 id="Swagger简介"><a href="#Swagger简介" class="headerlink" title="Swagger简介"></a>Swagger简介</h3><p><strong>前后端分离</strong></p>
<ul>
<li>前端 -&gt; 前端控制层、视图层</li>
<li>后端 -&gt; 后端控制层、服务层、数据访问层</li>
<li>前后端通过API进行交互</li>
<li>前后端相对独立且松耦合<span id="more"></span></li>
</ul>
<p><strong>产生的问题</strong></p>
<ul>
<li>前后端集成，前端或者后端无法做到“及时协商，尽早解决”，最终导致问题集中爆发</li>
</ul>
<p><strong>解决方案</strong></p>
<ul>
<li>首先定义schema [ 计划的提纲 ]，并实时跟踪最新的API，降低集成风险</li>
</ul>
<p><strong>Swagger</strong></p>
<ul>
<li>号称世界上最流行的API框架</li>
<li>Restful Api 文档在线自动生成器 =&gt; <strong>API 文档 与API 定义同步更新</strong></li>
<li>直接运行，在线测试API</li>
<li>支持多种语言 （如：Java，PHP等）</li>
<li>官网：<a href="https://swagger.io/">https://swagger.io/</a></li>
</ul>
<h3 id="SpringBoot集成Swagger"><a href="#SpringBoot集成Swagger" class="headerlink" title="SpringBoot集成Swagger"></a>SpringBoot集成Swagger</h3><p><strong>SpringBoot集成Swagger</strong> =&gt; <strong>springfox</strong>，两个jar包</p>
<ul>
<li><strong>Springfox-swagger2</strong></li>
<li>swagger-springmvc</li>
</ul>
<p><strong>使用Swagger</strong></p>
<p>要求：jdk 1.8 + 否则swagger2无法运行</p>
<p>步骤：</p>
<p>1、新建一个SpringBoot-web项目</p>
<p>2、添加Maven依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger2 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;2.9.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger-ui --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;2.9.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>3、编写HelloController，测试确保运行成功！</p>
<p>4、要使用Swagger，我们需要编写一个配置类-SwaggerConfig来配置 Swagger</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration //配置类</span><br><span class="line">@EnableSwagger2// 开启Swagger2的自动配置</span><br><span class="line">public class SwaggerConfig &#123;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5、访问测试 ：<a href="http://localhost:8080/swagger-ui.html">http://localhost:8080/swagger-ui.html</a> ，可以看到swagger的界面；</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/15/m6f9.png"></p>
<h3 id="配置Swagger"><a href="#配置Swagger" class="headerlink" title="配置Swagger"></a>配置Swagger</h3><p>1、Swagger实例Bean是Docket，所以通过配置Docket实例来配置Swaggger。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean //配置docket以配置Swagger具体参数</span><br><span class="line">public Docket docket() &#123;</span><br><span class="line">   return new Docket(DocumentationType.SWAGGER_2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、可以通过apiInfo()属性配置文档信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//配置文档信息</span><br><span class="line">private ApiInfo apiInfo() &#123;</span><br><span class="line">   Contact contact = new Contact(&quot;联系人名字&quot;, &quot;http://xxx.xxx.com/联系人访问链接&quot;, &quot;联系人邮箱&quot;);</span><br><span class="line">   return new ApiInfo(</span><br><span class="line">           &quot;Swagger学习&quot;, // 标题</span><br><span class="line">           &quot;学习演示如何配置Swagger&quot;, // 描述</span><br><span class="line">           &quot;v1.0&quot;, // 版本</span><br><span class="line">           &quot;http://terms.service.url/组织链接&quot;, // 组织链接</span><br><span class="line">           contact, // 联系人信息</span><br><span class="line">           &quot;Apach 2.0 许可&quot;, // 许可</span><br><span class="line">           &quot;许可链接&quot;, // 许可连接</span><br><span class="line">           new ArrayList&lt;&gt;()// 扩展</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、Docket 实例关联上 apiInfo()</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public Docket docket() &#123;</span><br><span class="line">   return new Docket(DocumentationType.SWAGGER_2).apiInfo(apiInfo());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4、重启项目，访问测试 <a href="http://localhost:8080/swagger-ui.html">http://localhost:8080/swagger-ui.html</a>  看下效果；</p>
<h3 id="配置扫描接口"><a href="#配置扫描接口" class="headerlink" title="配置扫描接口"></a>配置扫描接口</h3><p>1、构建Docket时通过select()方法配置怎么扫描接口。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public Docket docket() &#123;</span><br><span class="line">   return new Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">      .apiInfo(apiInfo())</span><br><span class="line">      .select()// 通过.select()方法，去配置扫描接口,RequestHandlerSelectors配置如何扫描接口</span><br><span class="line">      .apis(RequestHandlerSelectors.basePackage(&quot;com.kuang.swagger.controller&quot;))</span><br><span class="line">      .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、重启项目测试，由于我们配置根据包的路径扫描接口，所以我们只能看到一个类</p>
<p>3、除了通过包路径配置扫描接口外，还可以通过配置其他方式扫描接口，这里注释一下所有的配置方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">any() // 扫描所有，项目中的所有接口都会被扫描到</span><br><span class="line">none() // 不扫描接口</span><br><span class="line">// 通过方法上的注解扫描，如withMethodAnnotation(GetMapping.class)只扫描get请求</span><br><span class="line">withMethodAnnotation(final Class&lt;? extends Annotation&gt; annotation)</span><br><span class="line">// 通过类上的注解扫描，如.withClassAnnotation(Controller.class)只扫描有controller注解的类中的接口</span><br><span class="line">withClassAnnotation(final Class&lt;? extends Annotation&gt; annotation)</span><br><span class="line">basePackage(final String basePackage) // 根据包路径扫描接口</span><br></pre></td></tr></table></figure>
<p>4、除此之外，我们还可以配置接口扫描过滤：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public Docket docket() &#123;</span><br><span class="line">   return new Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">      .apiInfo(apiInfo())</span><br><span class="line">      .select()// 通过.select()方法，去配置扫描接口,RequestHandlerSelectors配置如何扫描接口</span><br><span class="line">      .apis(RequestHandlerSelectors.basePackage(&quot;com.kuang.swagger.controller&quot;))</span><br><span class="line">       // 配置如何通过path过滤,即这里只扫描请求以/kuang开头的接口</span><br><span class="line">      .paths(PathSelectors.ant(&quot;/kuang/**&quot;))</span><br><span class="line">      .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5、这里的可选值还有</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">any() // 任何请求都扫描</span><br><span class="line">none() // 任何请求都不扫描</span><br><span class="line">regex(final String pathRegex) // 通过正则表达式控制</span><br><span class="line">ant(final String antPattern) // 通过ant()控制</span><br></pre></td></tr></table></figure>
<p><img src="https://i.p04e.com/baid/i/2023/01/15/2y28.png"></p>
<h3 id><a href="#" class="headerlink" title=" "></a> </h3><h3 id="配置Swagger开关"><a href="#配置Swagger开关" class="headerlink" title="配置Swagger开关"></a>配置Swagger开关</h3><p>1、通过enable()方法配置是否启用swagger，如果是false，swagger将不能在浏览器中访问了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public Docket docket() &#123;</span><br><span class="line">   return new Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">      .apiInfo(apiInfo())</span><br><span class="line">      .enable(false) //配置是否启用Swagger，如果是false，在浏览器将无法访问</span><br><span class="line">      .select()// 通过.select()方法，去配置扫描接口,RequestHandlerSelectors配置如何扫描接口</span><br><span class="line">      .apis(RequestHandlerSelectors.basePackage(&quot;com.kuang.swagger.controller&quot;))</span><br><span class="line">       // 配置如何通过path过滤,即这里只扫描请求以/kuang开头的接口</span><br><span class="line">      .paths(PathSelectors.ant(&quot;/kuang/**&quot;))</span><br><span class="line">      .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、如何动态配置当项目处于test、dev环境时显示swagger，处于prod时不显示？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public Docket docket(Environment environment) &#123;</span><br><span class="line">   // 设置要显示swagger的环境</span><br><span class="line">   Profiles of = Profiles.of(&quot;dev&quot;, &quot;test&quot;);</span><br><span class="line">   // 判断当前是否处于该环境</span><br><span class="line">   // 通过 enable() 接收此参数判断是否要显示</span><br><span class="line">   boolean b = environment.acceptsProfiles(of);</span><br><span class="line">   </span><br><span class="line">   return new Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">      .apiInfo(apiInfo())</span><br><span class="line">      .enable(b) //配置是否启用Swagger，如果是false，在浏览器将无法访问</span><br><span class="line">      .select()// 通过.select()方法，去配置扫描接口,RequestHandlerSelectors配置如何扫描接口</span><br><span class="line">      .apis(RequestHandlerSelectors.basePackage(&quot;com.kuang.swagger.controller&quot;))</span><br><span class="line">       // 配置如何通过path过滤,即这里只扫描请求以/kuang开头的接口</span><br><span class="line">      .paths(PathSelectors.ant(&quot;/kuang/**&quot;))</span><br><span class="line">      .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、可以在项目中增加一个dev的配置文件查看效果！</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/15/280.png"></p>
<h3 id="配置API分组"><a href="#配置API分组" class="headerlink" title="配置API分组"></a>配置API分组</h3><p><img src="https://i.p04e.com/baid/i/2023/01/15/33ce.png"></p>
<p>1、如果没有配置分组，默认是default。通过groupName()方法即可配置分组：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public Docket docket(Environment environment) &#123;</span><br><span class="line">   return new Docket(DocumentationType.SWAGGER_2).apiInfo(apiInfo())</span><br><span class="line">      .groupName(&quot;hello&quot;) // 配置分组</span><br><span class="line">       // 省略配置....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、重启项目查看分组</p>
<p>3、如何配置多个分组？配置多个分组只需要配置多个docket即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public Docket docket1()&#123;</span><br><span class="line">   return new Docket(DocumentationType.SWAGGER_2).groupName(&quot;group1&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@Bean</span><br><span class="line">public Docket docket2()&#123;</span><br><span class="line">   return new Docket(DocumentationType.SWAGGER_2).groupName(&quot;group2&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@Bean</span><br><span class="line">public Docket docket3()&#123;</span><br><span class="line">   return new Docket(DocumentationType.SWAGGER_2).groupName(&quot;group3&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4、重启项目查看即可</p>
<h3 id="实体配置"><a href="#实体配置" class="headerlink" title="实体配置"></a>实体配置</h3><p>1、新建一个实体类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ApiModel(&quot;用户实体&quot;)</span><br><span class="line">public class User &#123;</span><br><span class="line">   @ApiModelProperty(&quot;用户名&quot;)</span><br><span class="line">   public String username;</span><br><span class="line">   @ApiModelProperty(&quot;密码&quot;)</span><br><span class="line">   public String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、只要这个实体在<strong>请求接口</strong>的返回值上（即使是泛型），都能映射到实体项中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequestMapping(&quot;/getUser&quot;)</span><br><span class="line">public User getUser()&#123;</span><br><span class="line">   return new User();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、重启查看测试</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/15/36qu.png"></p>
<p>注：并不是因为@ApiModel这个注解让实体显示在这里了，而是只要出现在接口方法的返回值上的实体都会显示在这里，而@ApiModel和@ApiModelProperty这两个注解只是为实体添加注释的。</p>
<p>@ApiModel为类添加注释</p>
<p>@ApiModelProperty为类属性添加注释</p>
<h3 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h3><p>Swagger的所有注解定义在io.swagger.annotations包下</p>
<p>下面列一些经常用到的，未列举出来的可以另行查阅说明：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Swagger注解</th>
<th>简单说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>@Api(tags = “xxx模块说明”)</td>
<td>作用在模块类上</td>
</tr>
<tr>
<td>@ApiOperation(“xxx接口说明”)</td>
<td>作用在接口方法上</td>
</tr>
<tr>
<td>@ApiModel(“xxxPOJO说明”)</td>
<td>作用在模型类上：如VO、BO</td>
</tr>
<tr>
<td>@ApiModelProperty(value = “xxx属性说明”,hidden = true)</td>
<td>作用在类方法和属性上，hidden设置为true可以隐藏该属性</td>
</tr>
<tr>
<td>@ApiParam(“xxx参数说明”)</td>
<td>作用在参数、方法和字段上，类似@ApiModelProperty</td>
</tr>
</tbody>
</table>
</div>
<p>我们也可以给请求的接口配置一些注释</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ApiOperation(&quot;狂神的接口&quot;)</span><br><span class="line">@PostMapping(&quot;/kuang&quot;)</span><br><span class="line">@ResponseBody</span><br><span class="line">public String kuang(@ApiParam(&quot;这个名字会被返回&quot;)String username)&#123;</span><br><span class="line">   return username;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的话，可以给一些比较难理解的属性或者接口，增加一些配置信息，让人更容易阅读！</p>
<p>相较于传统的Postman或Curl方式测试接口，使用swagger简直就是傻瓜式操作，不需要额外说明文档(写得好本身就是文档)而且更不容易出错，只需要录入数据然后点击Execute，如果再配合自动化框架，可以说基本就不需要人为操作了。</p>
<p>Swagger是个优秀的工具，现在国内已经有很多的中小型互联网公司都在使用它，相较于传统的要先出Word接口文档再测试的方式，显然这样也更符合现在的快速迭代开发行情。当然了，提醒下大家在正式环境要记得关闭Swagger，一来出于安全考虑二来也可以节省运行时内存。</p>
<h3 id="拓展：其他皮肤"><a href="#拓展：其他皮肤" class="headerlink" title="拓展：其他皮肤"></a>拓展：其他皮肤</h3><p>我们可以导入不同的包实现不同的皮肤定义：</p>
<p>1、默认的   <strong>访问 <a href="http://localhost:8080/swagger-ui.html">http://localhost:8080/swagger-ui.html</a></strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;2.9.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.p04e.com/baid/i/2023/01/15/39av.png"></p>
<p>2、bootstrap-ui  <strong>访问 <a href="http://localhost:8080/doc.html">http://localhost:8080/doc.html</a></strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 引入swagger-bootstrap-ui包 /doc.html--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;swagger-bootstrap-ui&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;1.9.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>3、Layui-ui   <strong>访问 <a href="http://localhost:8080/docs.html">http://localhost:8080/docs.html</a></strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 引入swagger-ui-layer包 /docs.html--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;com.github.caspar-chen&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;swagger-ui-layer&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;1.1.3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>4、mg-ui   <strong>访问 <a href="http://localhost:8080/document.html">http://localhost:8080/document.html</a></strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 引入swagger-ui-layer包 /document.html--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;com.zyplayer&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;swagger-mg-ui&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;1.0.6&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Swagger</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot：页面国际化</title>
    <url>/2023/01/15/SpringBoot%EF%BC%9A%E9%A1%B5%E9%9D%A2%E5%9B%BD%E9%99%85%E5%8C%96/</url>
    <content><![CDATA[<p>有的时候，我们的网站会去涉及中英文甚至多语言的切换，这时候我们就需要学习国际化了！</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>先在IDEA中统一设置properties的编码问题！</p>
<span id="more"></span>
<p><img src="https://i.p04e.com/baid/i/2023/01/15/6psjl.png"></p>
<p>编写国际化配置文件，抽取页面需要显示的国际化页面消息。我们可以去登录页面查看一下，哪些内容我们需要编写国际化的配置！</p>
<h2 id="配置文件编写"><a href="#配置文件编写" class="headerlink" title="配置文件编写"></a>配置文件编写</h2><p>1、我们在resources资源文件下新建一个i18n目录，存放国际化配置文件</p>
<p>2、建立一个login.properties文件，还有一个login_zh_CN.properties；发现IDEA自动识别了我们要做国际化操作；文件夹变了！</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/15/ylwh.png"></p>
<p>3、我们可以在这上面去新建一个文件；</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/15/6q2ve.png"></p>
<p>弹出如下页面：我们再添加一个英文的；</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/15/ykj7.png"></p>
<p>这样就快捷多了！</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/15/yc9r.png"></p>
<p><strong>4、接下来，我们就来编写配置，我们可以看到idea下面有另外一个视图；</strong></p>
<p><img src="https://i.p04e.com/baid/i/2023/01/15/paf.png"></p>
<p>这个视图我们点击 + 号就可以直接添加属性了；我们新建一个login.tip，可以看到边上有三个文件框可以输入</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/15/yicj.png"></p>
<p>我们添加一下首页的内容！</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/15/yaqx.png"></p>
<p>然后依次添加其他页面内容即可！</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/15/3lw.png"></p>
<p>然后去查看我们的配置文件；</p>
<p>login.properties ：默认</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">login.btn=登录</span><br><span class="line">login.password=密码</span><br><span class="line">login.remember=记住我</span><br><span class="line">login.tip=请登录</span><br><span class="line">login.username=用户名</span><br></pre></td></tr></table></figure>
<p>英文：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">login.btn=Sign in</span><br><span class="line">login.password=Password</span><br><span class="line">login.remember=Remember me</span><br><span class="line">login.tip=Please sign in</span><br><span class="line">login.username=Username</span><br></pre></td></tr></table></figure>
<p>中文：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">login.btn=登录</span><br><span class="line">login.password=密码</span><br><span class="line">login.remember=记住我</span><br><span class="line">login.tip=请登录</span><br><span class="line">login.username=用户名</span><br></pre></td></tr></table></figure>
<p>OK，配置文件步骤搞定！</p>
<h2 id="配置文件生效探究"><a href="#配置文件生效探究" class="headerlink" title="配置文件生效探究"></a>配置文件生效探究</h2><p>我们去看一下SpringBoot对国际化的自动配置！这里又涉及到一个类：MessageSourceAutoConfiguration</p>
<p>里面有一个方法，这里发现SpringBoot已经自动配置好了管理我们国际化资源文件的组件 ResourceBundleMessageSource；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 获取 properties 传递过来的值进行判断</span><br><span class="line">@Bean</span><br><span class="line">public MessageSource messageSource(MessageSourceProperties properties) &#123;</span><br><span class="line">    ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource();</span><br><span class="line">    if (StringUtils.hasText(properties.getBasename())) &#123;</span><br><span class="line">        // 设置国际化文件的基础名（去掉语言国家代码的）</span><br><span class="line">        messageSource.setBasenames(</span><br><span class="line">            StringUtils.commaDelimitedListToStringArray(</span><br><span class="line">                                       StringUtils.trimAllWhitespace(properties.getBasename())));</span><br><span class="line">    &#125;</span><br><span class="line">    if (properties.getEncoding() != null) &#123;</span><br><span class="line">        messageSource.setDefaultEncoding(properties.getEncoding().name());</span><br><span class="line">    &#125;</span><br><span class="line">    messageSource.setFallbackToSystemLocale(properties.isFallbackToSystemLocale());</span><br><span class="line">    Duration cacheDuration = properties.getCacheDuration();</span><br><span class="line">    if (cacheDuration != null) &#123;</span><br><span class="line">        messageSource.setCacheMillis(cacheDuration.toMillis());</span><br><span class="line">    &#125;</span><br><span class="line">    messageSource.setAlwaysUseMessageFormat(properties.isAlwaysUseMessageFormat());</span><br><span class="line">    messageSource.setUseCodeAsDefaultMessage(properties.isUseCodeAsDefaultMessage());</span><br><span class="line">    return messageSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们真实 的情况是放在了i18n目录下，所以我们要去配置这个messages的路径；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring.messages.basename=i18n.login</span><br></pre></td></tr></table></figure>
<h2 id="配置页面国际化值"><a href="#配置页面国际化值" class="headerlink" title="配置页面国际化值"></a>配置页面国际化值</h2><p>去页面获取国际化的值，查看Thymeleaf的文档，找到message取值操作为：#{…}。我们去页面测试下：</p>
<p>IDEA还有提示，非常智能的！</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/15/6pby7.png"></p>
<p>我们可以去启动项目，访问一下，发现已经自动识别为中文的了！</p>
<p><img src="https://i.p04e.com/baid/i/2023/01/15/yj1f.png">)</p>
<p><strong>但是我们想要更好！可以根据按钮自动切换中文英文！</strong></p>
<h2 id="配置国际化解析"><a href="#配置国际化解析" class="headerlink" title="配置国际化解析"></a>配置国际化解析</h2><p>在Spring中有一个国际化的Locale （区域信息对象）；里面有一个叫做LocaleResolver （获取区域信息对象）的解析器！</p>
<p>我们去我们webmvc自动配置文件，寻找一下！看到SpringBoot默认配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">@ConditionalOnMissingBean</span><br><span class="line">@ConditionalOnProperty(prefix = &quot;spring.mvc&quot;, name = &quot;locale&quot;)</span><br><span class="line">public LocaleResolver localeResolver() &#123;</span><br><span class="line">    // 容器中没有就自己配，有的话就用用户配置的</span><br><span class="line">    if (this.mvcProperties.getLocaleResolver() == WebMvcProperties.LocaleResolver.FIXED) &#123;</span><br><span class="line">        return new FixedLocaleResolver(this.mvcProperties.getLocale());</span><br><span class="line">    &#125;</span><br><span class="line">    // 接收头国际化分解</span><br><span class="line">    AcceptHeaderLocaleResolver localeResolver = new AcceptHeaderLocaleResolver();</span><br><span class="line">    localeResolver.setDefaultLocale(this.mvcProperties.getLocale());</span><br><span class="line">    return localeResolver;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AcceptHeaderLocaleResolver 这个类中有一个方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public Locale resolveLocale(HttpServletRequest request) &#123;</span><br><span class="line">    Locale defaultLocale = this.getDefaultLocale();</span><br><span class="line">    // 默认的就是根据请求头带来的区域信息获取Locale进行国际化</span><br><span class="line">    if (defaultLocale != null &amp;&amp; request.getHeader(&quot;Accept-Language&quot;) == null) &#123;</span><br><span class="line">        return defaultLocale;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Locale requestLocale = request.getLocale();</span><br><span class="line">        List&lt;Locale&gt; supportedLocales = this.getSupportedLocales();</span><br><span class="line">        if (!supportedLocales.isEmpty() &amp;&amp; !supportedLocales.contains(requestLocale)) &#123;</span><br><span class="line">            Locale supportedLocale = this.findSupportedLocale(request, supportedLocales);</span><br><span class="line">            if (supportedLocale != null) &#123;</span><br><span class="line">                return supportedLocale;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return defaultLocale != null ? defaultLocale : requestLocale;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return requestLocale;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那假如我们现在想点击链接让我们的国际化资源生效，就需要让我们自己的Locale生效！</p>
<p>我们去自己写一个自己的LocaleResolver，可以在链接上携带区域信息！</p>
<p>修改一下前端页面的跳转连接：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 这里传入参数不需要使用 ？使用 （key=value）--&gt;</span><br><span class="line">&lt;a class=&quot;btn btn-sm&quot; th:href=&quot;@&#123;/index.html(l=&#x27;zh_CN&#x27;)&#125;&quot;&gt;中文&lt;/a&gt;</span><br><span class="line">&lt;a class=&quot;btn btn-sm&quot; th:href=&quot;@&#123;/index.html(l=&#x27;en_US&#x27;)&#125;&quot;&gt;English&lt;/a&gt;</span><br></pre></td></tr></table></figure>
<p>我们去写一个处理的组件类！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">package com.kuang.component;</span><br><span class="line"></span><br><span class="line">import org.springframework.util.StringUtils;</span><br><span class="line">import org.springframework.web.servlet.LocaleResolver;</span><br><span class="line"></span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line">import java.util.Locale;</span><br><span class="line"></span><br><span class="line">//可以在链接上携带区域信息</span><br><span class="line">public class MyLocaleResolver implements LocaleResolver &#123;</span><br><span class="line"></span><br><span class="line">    //解析请求</span><br><span class="line">    @Override</span><br><span class="line">    public Locale resolveLocale(HttpServletRequest request) &#123;</span><br><span class="line"></span><br><span class="line">        String language = request.getParameter(&quot;l&quot;);</span><br><span class="line">        Locale locale = Locale.getDefault(); // 如果没有获取到就使用系统默认的</span><br><span class="line">        //如果请求链接不为空</span><br><span class="line">        if (!StringUtils.isEmpty(language))&#123;</span><br><span class="line">            //分割请求参数</span><br><span class="line">            String[] split = language.split(&quot;_&quot;);</span><br><span class="line">            //国家，地区</span><br><span class="line">            locale = new Locale(split[0],split[1]);</span><br><span class="line">        &#125;</span><br><span class="line">        return locale;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setLocale(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Locale locale) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了让我们的区域化信息能够生效，我们需要再配置一下这个组件！在我们自己的MvcConofig下添加bean；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public LocaleResolver localeResolver()&#123;</span><br><span class="line">    return new MyLocaleResolver();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Springboot系列：整合Mybatis-puls</title>
    <url>/2023/01/13/SpringBoot%E7%B3%BB%E5%88%97%EF%BC%9A%E6%95%B4%E5%90%88Mybatis-puls/</url>
    <content><![CDATA[<h1 id="一、SpringBoot-Mybatis-plus整合"><a href="#一、SpringBoot-Mybatis-plus整合" class="headerlink" title="一、SpringBoot+Mybatis-plus整合"></a>一、SpringBoot+Mybatis-plus整合</h1><p><a href="https://so.csdn.net/so/search?q=MyBatis-Plus&amp;spm=1001.2101.3001.7020">MyBatis-Plus</a> 是一个 Mybatis 增强版工具，在 MyBatis 上扩充了其他功能没有改变其基本功能，为了简化开发提交效率而存在。</p>
<span id="more"></span>
<p>官网文档地址：<a href="https://mp.baomidou.com/guide/">https://mp.baomidou.com/guide/</a></p>
<p>添加 MyBatis-Plus 依赖（mybatis-plus-boot-starter）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--mybatis-plus依赖--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.4.2&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>（4）为了测试开发，此处使用 mysql8，需要引入 mysql 相关依赖。　　</p>
<p>为了简化代码，引入 lombok 依赖（减少 getter、setter 等方法）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--mysql依赖--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--lombok依赖--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">            &lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>（5）在  <build> </build>里面添加如下进行yml、properties、xml自动扫描</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">        &lt;resources&gt;</span><br><span class="line">            &lt;resource&gt;</span><br><span class="line">                &lt;directory&gt;src/main/java&lt;/directory&gt;</span><br><span class="line">                &lt;includes&gt;</span><br><span class="line">                    &lt;include&gt;**/*.yml&lt;/include&gt;</span><br><span class="line">                    &lt;include&gt;**/*.properties&lt;/include&gt;</span><br><span class="line">                    &lt;include&gt;**/*.xml&lt;/include&gt;</span><br><span class="line">                &lt;/includes&gt;</span><br><span class="line">                &lt;filtering&gt;false&lt;/filtering&gt;</span><br><span class="line">            &lt;/resource&gt;</span><br><span class="line">            &lt;resource&gt;</span><br><span class="line">                &lt;directory&gt;src/main/resources&lt;/directory&gt;</span><br><span class="line">                &lt;includes&gt;</span><br><span class="line">                    &lt;include&gt;**/*.yml&lt;/include&gt;</span><br><span class="line">                    &lt;include&gt;**/*.properties&lt;/include&gt;</span><br><span class="line">                    &lt;include&gt;**/*.xml&lt;/include&gt;</span><br><span class="line">                &lt;/includes&gt;</span><br><span class="line">                &lt;filtering&gt;false&lt;/filtering&gt;</span><br><span class="line">            &lt;/resource&gt;</span><br><span class="line">        &lt;/resources&gt;</span><br><span class="line">    &lt;/build&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在 application.yml 文件中配置 mysql 数据源信息。</span><br><span class="line"></span><br><span class="line">mysql5如下配置</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    driver-class-name: com.mysql.jdbc.Driver</span><br><span class="line">    url: jdbc:mysql://localhost:3306/testMyBatisPlus?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8</span><br><span class="line">    username: root</span><br><span class="line">    password: root</span><br><span class="line">  thymeleaf:</span><br><span class="line">    cache: false   #设置为false，否则会有缓存，导致页面没法及时看到更新后的效果。</span><br><span class="line"></span><br><span class="line">修改端口号默认是8080</span><br><span class="line"></span><br><span class="line">server:</span><br><span class="line">  port: 8888</span><br><span class="line"></span><br><span class="line">mybatis-plus相关配置</span><br><span class="line"></span><br><span class="line">mybatis-plus:</span><br><span class="line">  mapper-locations: classpath:mapper/*.xml #扫描mapper下的所有xml文件</span><br><span class="line">  configuration:</span><br><span class="line">    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl</span><br><span class="line">  type-aliases-package: com.zwl.entity   #扫描实体类包/配置别名 </span><br></pre></td></tr></table></figure>
<p>（8）编写实体类、Service、ServiceImpl、UserMapper、UserMapper.xml等文件文件</p>
<p>方法一：手动编写（容易出错）</p>
<p>（1）编写表对应的 实体类User。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import lombok.Data;</span><br><span class="line"></span><br><span class="line">@Data</span><br><span class="line">public class Users &#123;</span><br><span class="line">    private Long id;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    private String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（2）编写操作实体类的 Mapper 类。　　</p>
<p> 直接继承 BaseMapper，这是 mybatis-plus 封装好的类。</p>
<pre><code>import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.zx.mybatis_plus.bean.Users;

public interface UsersMapper extends BaseMapper&lt;Users&gt; &#123;
&#125;
</code></pre><p>BaseMapper封装了CRUD相关的方法</p>
<p>（3）实体类、Mapper 类都写好了，就可以使用了。　　</p>
<p>​    Step1：先得在启动类里扫描 Mapper 类，即添加 @MapperScan 注解</p>
<pre><code>import org.mybatis.spring.annotation.MapperScan;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
@MapperScan(&quot;com.zwl.mapper&quot;)  //填写对应mapper存放位置，自动识别mapper下的所有**Mapper
@SpringBootApplication
public class MybatisplusDemoApplication &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(MybatisplusDemoApplication.class, args);
    &#125;

&#125;
</code></pre><p>　Step2：写一个测试类测试一下。</p>
<pre><code>import com.zwl.entity.User;
import com.zwl.mapper.UserMapper;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

import java.util.List;

@SpringBootTest
class Springboot05ApplicationTests &#123;
</code></pre><p>​<br>​        @Autowired<br>​        UserMapper userMapper;<br>​<br>        //查询所有用户<br>        @Test<br>        void contextLoads() {<br>            List<User> users = userMapper.selectList(null);<br>            for (User user : users) {<br>                System.out.println(user);<br>            }<br>        }</User></p>
<pre><code>    //根据ID查询当前用户
    @Test
    void test1() &#123;
        User user = userMapper.selectById(2);
        System.out.println(user);
    &#125;
&#125;
</code></pre><h1 id="二、Mybatis-Plus内置方法"><a href="#二、Mybatis-Plus内置方法" class="headerlink" title="二、Mybatis-Plus内置方法"></a>二、Mybatis-Plus内置方法</h1><h2 id="1-插入方法"><a href="#1-插入方法" class="headerlink" title="1 插入方法"></a>1 插入方法</h2><h3 id="1-1-save"><a href="#1-1-save" class="headerlink" title="1.1 save()"></a>1.1 save()</h3><p>插入单条数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用内置方法save(插入)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/save&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">save</span><span class="params">(<span class="meta">@RequestBody</span> UserEntity userEntity)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> userService.save(userEntity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-saveBatch"><a href="#1-2-saveBatch" class="headerlink" title="1.2 saveBatch()"></a>1.2 saveBatch()</h3><p>批量插入数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用内置方法saveBatch(插入)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/saveBatch&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">saveBatch</span><span class="params">(<span class="meta">@RequestBody</span> List&lt;UserEntity&gt; userList)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> userService.saveBatch(userList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-更新方法"><a href="#2-更新方法" class="headerlink" title="2 更新方法"></a>2 更新方法</h2><h3 id="2-1-updateById"><a href="#2-1-updateById" class="headerlink" title="2.1 updateById()"></a>2.1 updateById()</h3><p>更新单条数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用内置方法updateById(更新)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/updateById&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">updateById</span><span class="params">(<span class="meta">@RequestBody</span> UserEntity userEntity)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> userService.updateById(userEntity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-updateBatchById"><a href="#2-2-updateBatchById" class="headerlink" title="2.2 updateBatchById()"></a>2.2 updateBatchById()</h3><p>批量更新数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用内置方法updateBatchById(更新)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/updateBatchById&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">updateBatchById</span><span class="params">(<span class="meta">@RequestBody</span> List&lt;UserEntity&gt; userList)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> userService.updateBatchById(userList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-插入或更新方法"><a href="#3-插入或更新方法" class="headerlink" title="3 插入或更新方法"></a>3 插入或更新方法</h2><h3 id="3-1-saveOrUpdate"><a href="#3-1-saveOrUpdate" class="headerlink" title="3.1 saveOrUpdate()"></a>3.1 saveOrUpdate()</h3><p>插入或更新单条数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用内置方法saveOrUpdate(插入或更新)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/saveOrUpdate&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">saveOrUpdate</span><span class="params">(<span class="meta">@RequestBody</span> UserEntity userEntity)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> userService.saveOrUpdate(userEntity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-saveOrUpdateBatch"><a href="#3-2-saveOrUpdateBatch" class="headerlink" title="3.2 saveOrUpdateBatch()"></a>3.2 saveOrUpdateBatch()</h3><p>批量插入或更新数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用内置方法saveOrUpdateBatch(插入或更新)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/saveOrUpdateBatch&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">saveOrUpdateBatch</span><span class="params">(<span class="meta">@RequestBody</span> List&lt;UserEntity&gt; userList)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> userService.saveOrUpdateBatch(userList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-删除方法"><a href="#4-删除方法" class="headerlink" title="4 删除方法"></a>4 删除方法</h2><h3 id="4-1-removeById"><a href="#4-1-removeById" class="headerlink" title="4.1 removeById()"></a>4.1 removeById()</h3><p>删除单条数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用内置方法removeById(删除)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@DeleteMapping(&quot;/removeById/&#123;username&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeById</span><span class="params">(<span class="meta">@PathVariable(&quot;username&quot;)</span> String username)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> userService.removeById(username);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-2-removeByIds"><a href="#4-2-removeByIds" class="headerlink" title="4.2 removeByIds()"></a>4.2 removeByIds()</h3><p>批量删除数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用内置方法removeByIds(删除)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@DeleteMapping(&quot;removeByIds&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeByIds</span><span class="params">(<span class="meta">@RequestBody</span> List&lt;String&gt; usernameList)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> userService.removeByIds(usernameList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-查询数据"><a href="#5-查询数据" class="headerlink" title="5 查询数据"></a>5 查询数据</h2><h3 id="5-1-list"><a href="#5-1-list" class="headerlink" title="5.1 list()"></a>5.1 list()</h3><p>根据指定条件查询列表数据，返回数据类型为实体类类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用内置方法list(查询)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;list&quot;)</span></span><br><span class="line"><span class="keyword">public</span> List&lt;UserEntity&gt; <span class="title function_">list</span><span class="params">()</span> &#123;</span><br><span class="line">    QueryWrapper&lt;UserEntity&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>();</span><br><span class="line">    queryWrapper.lambda().eq(UserEntity::getUsername, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> userService.list(queryWrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-2-listMaps"><a href="#5-2-listMaps" class="headerlink" title="5.2 listMaps()"></a>5.2 listMaps()</h3><p>根据指定条件查询列表数据，返回数据类型为Map类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用内置方法listMaps(查询)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;listMaps&quot;)</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">listMaps</span><span class="params">()</span> &#123;</span><br><span class="line">    QueryWrapper&lt;UserEntity&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>();</span><br><span class="line">    queryWrapper.lambda().eq(UserEntity::getUsername, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> userService.listMaps(queryWrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-3-listObjs"><a href="#5-3-listObjs" class="headerlink" title="5.3 listObjs()"></a>5.3 listObjs()</h3><p>根据指定条件查询列表数据，返回数据类型为Object类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用内置方法listObjs(查询)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;listObjs&quot;)</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Object&gt; <span class="title function_">listObjs</span><span class="params">()</span> &#123;</span><br><span class="line">    QueryWrapper&lt;UserEntity&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>();</span><br><span class="line">    queryWrapper.lambda().eq(UserEntity::getUsername, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> userService.listObjs(queryWrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-4-listByIds"><a href="#5-4-listByIds" class="headerlink" title="5.4 listByIds()"></a>5.4 listByIds()</h3><p>根据主键列表查询列表数据，返回数据类型为实体类类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用内置方法listByIds(查询)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;listByIds&quot;)</span></span><br><span class="line"><span class="keyword">public</span> List&lt;UserEntity&gt; <span class="title function_">listByIds</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> userService.listByIds(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="string">&quot;123&quot;</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-5-listByMap"><a href="#5-5-listByMap" class="headerlink" title="5.5 listByMap()"></a>5.5 listByMap()</h3><p>根据指定条件查询列表数据，返回数据类型为实体类类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用内置方法listByMap(查询)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;listByMap&quot;)</span></span><br><span class="line"><span class="keyword">public</span> List&lt;UserEntity&gt; <span class="title function_">listByMap</span><span class="params">()</span> &#123;</span><br><span class="line">    Map&lt;String, Object&gt; columnMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    columnMap.put(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> userService.listByMap(columnMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-6-getById"><a href="#5-6-getById" class="headerlink" title="5.6 getById()"></a>5.6 getById()</h3><p>根据主键查询单条数据，返回数据类型为实体类类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用内置方法getById(查询)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;getById&quot;)</span></span><br><span class="line"><span class="keyword">public</span> UserEntity <span class="title function_">getById</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> userService.getById(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-7-getOne"><a href="#5-7-getOne" class="headerlink" title="5.7 getOne()"></a>5.7 getOne()</h3><p>根据指定条件查询单条数据，返回数据类型为实体类类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用内置方法getOne(查询)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;getOne&quot;)</span></span><br><span class="line"><span class="keyword">public</span> UserEntity <span class="title function_">getOne</span><span class="params">()</span> &#123;</span><br><span class="line">    QueryWrapper&lt;UserEntity&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>();</span><br><span class="line">    queryWrapper.lambda().eq(UserEntity::getUsername, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> userService.getOne(queryWrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-8-getMap"><a href="#5-8-getMap" class="headerlink" title="5.8 getMap()"></a>5.8 getMap()</h3><p>根据指定条件查询单条数据，返回数据类型为Map类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用内置方法getMap(查询)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;getMap&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title function_">getMap</span><span class="params">()</span> &#123;</span><br><span class="line">    QueryWrapper&lt;UserEntity&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>();</span><br><span class="line">    queryWrapper.lambda().eq(UserEntity::getUsername, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> userService.getMap(queryWrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-9-count"><a href="#5-9-count" class="headerlink" title="5.9 count()"></a>5.9 count()</h3><p>根据指定条件查询记录条数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用内置方法count(查询)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;count&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">count</span><span class="params">()</span> &#123;</span><br><span class="line">    QueryWrapper&lt;UserEntity&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>();</span><br><span class="line">    queryWrapper.lambda().eq(UserEntity::getUsername, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> userService.count(queryWrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-10-page"><a href="#5-10-page" class="headerlink" title="5.10 page()"></a>5.10 page()</h3><p>根据指定条件查询数据并分页，返回数据类型为实体类类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用内置方法page(查询)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;page&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Page&lt;UserEntity&gt; <span class="title function_">page</span><span class="params">()</span> &#123;</span><br><span class="line">    Page&lt;UserEntity&gt; page = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">    QueryWrapper&lt;UserEntity&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>();</span><br><span class="line">    queryWrapper.lambda().eq(UserEntity::getUsername, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> userService.page(page, queryWrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-11-page"><a href="#5-11-page" class="headerlink" title="5.11 page"></a>5.11 page</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用内置方法pageMaps(查询)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;pageMaps&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Page&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">pageMaps</span><span class="params">()</span> &#123;</span><br><span class="line">    Page&lt;Map&lt;String, Object&gt;&gt; page = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">    QueryWrapper&lt;UserEntity&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>();</span><br><span class="line">    queryWrapper.lambda().eq(UserEntity::getUsername, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> userService.pageMaps(page, queryWrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Maps"><a href="#Maps" class="headerlink" title="Maps()"></a>Maps()</h3><p>根据指定条件查询数据并分页，返回数据类型为Map类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用内置方法pageMaps(查询)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;pageMaps&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Page&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">pageMaps</span><span class="params">()</span> &#123;</span><br><span class="line">    Page&lt;Map&lt;String, Object&gt;&gt; page = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">    QueryWrapper&lt;UserEntity&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>();</span><br><span class="line">    queryWrapper.lambda().eq(UserEntity::getUsername, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> userService.pageMaps(page, queryWrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Mybatis-plus</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot系列：异步、定时、邮件任务</title>
    <url>/2023/02/01/SpringBoot%E7%B3%BB%E5%88%97%EF%BC%9A%E5%BC%82%E6%AD%A5%E3%80%81%E5%AE%9A%E6%97%B6%E3%80%81%E9%82%AE%E4%BB%B6%E4%BB%BB%E5%8A%A1/</url>
    <content><![CDATA[<h2 id="异步任务"><a href="#异步任务" class="headerlink" title="异步任务"></a>异步任务</h2><p>1、创建一个service包</p>
<p>2、创建一个类AsyncService</p>
<span id="more"></span>
<p>异步处理还是非常常用的，比如我们在网站上发送邮件，后台会去发送邮件，此时前台会造成响应不动，直到邮件发送完毕，响应才会成功，所以我们一般会采用多线程的方式去处理这些任务。</p>
<p>编写方法，假装正在处理数据，使用线程设置一些延时，模拟同步等待的情况；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class AsyncService &#123;</span><br><span class="line"></span><br><span class="line">   public void hello()&#123;</span><br><span class="line">       try &#123;</span><br><span class="line">           Thread.sleep(3000);</span><br><span class="line">      &#125; catch (InterruptedException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">       System.out.println(&quot;业务进行中....&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、编写controller包</p>
<p>4、编写AsyncController类</p>
<p>我们去写一个Controller测试一下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class AsyncController &#123;</span><br><span class="line"></span><br><span class="line">   @Autowired</span><br><span class="line">   AsyncService asyncService;</span><br><span class="line"></span><br><span class="line">   @GetMapping(&quot;/hello&quot;)</span><br><span class="line">   public String hello()&#123;</span><br><span class="line">       asyncService.hello();</span><br><span class="line">       return &quot;success&quot;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5、访问<a href="http://localhost:8080/hello进行测试，3秒后出现success，这是同步等待的情况。">http://localhost:8080/hello进行测试，3秒后出现success，这是同步等待的情况。</a></p>
<p>问题：我们如果想让用户直接得到消息，就在后台使用多线程的方式进行处理即可，但是每次都需要自己手动去编写多线程的实现的话，太麻烦了，我们只需要用一个简单的办法，在我们的方法上加一个简单的注解即可，如下：</p>
<p>6、给hello方法添加@Async注解；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//告诉Spring这是一个异步方法</span><br><span class="line">@Async</span><br><span class="line">public void hello()&#123;</span><br><span class="line">   try &#123;</span><br><span class="line">       Thread.sleep(3000);</span><br><span class="line">  &#125; catch (InterruptedException e) &#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">   System.out.println(&quot;业务进行中....&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SpringBoot就会自己开一个线程池，进行调用！但是要让这个注解生效，我们还需要在主程序上添加一个注解@EnableAsync ，开启异步注解功能；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@EnableAsync //开启异步注解功能</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class SpringbootTaskApplication &#123;</span><br><span class="line"></span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">       SpringApplication.run(SpringbootTaskApplication.class, args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>7、重启测试，网页瞬间响应，后台代码依旧执行！</p>
<h2 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h2><p>项目开发中经常需要执行一些定时任务，比如需要在每天凌晨的时候，分析一次前一天的日志信息，Spring为我们提供了异步执行任务调度的方式，提供了两个接口。</p>
<ul>
<li>TaskExecutor接口</li>
<li>TaskScheduler接口</li>
</ul>
<p>两个注解：</p>
<ul>
<li>@EnableScheduling</li>
<li>@Scheduled</li>
</ul>
<p><strong>测试步骤：</strong></p>
<p>1、创建一个ScheduledService</p>
<p>我们里面存在一个hello方法，他需要定时执行，怎么处理呢？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class ScheduledService &#123;</span><br><span class="line">   </span><br><span class="line">   //秒   分   时     日   月   周几</span><br><span class="line">   //0 * * * * MON-FRI</span><br><span class="line">   //注意cron表达式的用法；</span><br><span class="line">   @Scheduled(cron = &quot;0 * * * * 0-7&quot;)</span><br><span class="line">   public void hello()&#123;</span><br><span class="line">       System.out.println(&quot;hello.....&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、这里写完定时任务之后，我们需要在主程序上增加@EnableScheduling 开启定时任务功能</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@EnableAsync //开启异步注解功能</span><br><span class="line">@EnableScheduling //开启基于注解的定时任务</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class SpringbootTaskApplication &#123;</span><br><span class="line"></span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">       SpringApplication.run(SpringbootTaskApplication.class, args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、我们来详细了解下cron表达式；</p>
<p><a href="http://www.bejson.com/othertools/cron/">http://www.bejson.com/othertools/cron/</a></p>
<p>4、常用的表达式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）0/2 * * * * ?   表示每2秒 执行任务</span><br><span class="line">（1）0 0/2 * * * ?   表示每2分钟 执行任务</span><br><span class="line">（1）0 0 2 1 * ?   表示在每月的1日的凌晨2点调整任务</span><br><span class="line">（2）0 15 10 ? * MON-FRI   表示周一到周五每天上午10:15执行作业</span><br><span class="line">（3）0 15 10 ? 6L 2002-2006   表示2002-2006年的每个月的最后一个星期五上午10:15执行作</span><br><span class="line">（4）0 0 10,14,16 * * ?   每天上午10点，下午2点，4点</span><br><span class="line">（5）0 0/30 9-17 * * ?   朝九晚五工作时间内每半小时</span><br><span class="line">（6）0 0 12 ? * WED   表示每个星期三中午12点</span><br><span class="line">（7）0 0 12 * * ?   每天中午12点触发</span><br><span class="line">（8）0 15 10 ? * *   每天上午10:15触发</span><br><span class="line">（9）0 15 10 * * ?     每天上午10:15触发</span><br><span class="line">（10）0 15 10 * * ?   每天上午10:15触发</span><br><span class="line">（11）0 15 10 * * ? 2005   2005年的每天上午10:15触发</span><br><span class="line">（12）0 * 14 * * ?     在每天下午2点到下午2:59期间的每1分钟触发</span><br><span class="line">（13）0 0/5 14 * * ?   在每天下午2点到下午2:55期间的每5分钟触发</span><br><span class="line">（14）0 0/5 14,18 * * ?     在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发</span><br><span class="line">（15）0 0-5 14 * * ?   在每天下午2点到下午2:05期间的每1分钟触发</span><br><span class="line">（16）0 10,44 14 ? 3 WED   每年三月的星期三的下午2:10和2:44触发</span><br><span class="line">（17）0 15 10 ? * MON-FRI   周一至周五的上午10:15触发</span><br><span class="line">（18）0 15 10 15 * ?   每月15日上午10:15触发</span><br><span class="line">（19）0 15 10 L * ?   每月最后一日的上午10:15触发</span><br><span class="line">（20）0 15 10 ? * 6L   每月的最后一个星期五上午10:15触发</span><br><span class="line">（21）0 15 10 ? * 6L 2002-2005   2002年至2005年的每月的最后一个星期五上午10:15触发</span><br><span class="line">（22）0 15 10 ? * 6#3   每月的第三个星期五上午10:15触发</span><br></pre></td></tr></table></figure>
<h2 id="邮件任务"><a href="#邮件任务" class="headerlink" title="邮件任务"></a>邮件任务</h2><p>邮件发送，在我们的日常开发中，也非常的多，Springboot也帮我们做了支持</p>
<ul>
<li>邮件发送需要引入spring-boot-start-mail</li>
<li>SpringBoot 自动配置MailSenderAutoConfiguration</li>
<li>定义MailProperties内容，配置在application.yml中</li>
<li>自动装配JavaMailSender</li>
<li>测试邮件发送</li>
</ul>
<p><strong>测试：</strong></p>
<p>1、引入pom依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>看它引入的依赖，可以看到 jakarta.mail</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;com.sun.mail&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;jakarta.mail&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;1.6.4&lt;/version&gt;</span><br><span class="line">   &lt;scope&gt;compile&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>2、查看自动配置类：MailSenderAutoConfiguration</p>
<p><img src="https://i.p04e.com/baid/i/2023/02/01/3sbk5.png"></p>
<p>这个类中存在bean，JavaMailSenderImpl</p>
<p><img src="https://i.p04e.com/baid/i/2023/02/01/2ta6.png"></p>
<p>然后我们去看下配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ConfigurationProperties(</span><br><span class="line">   prefix = &quot;spring.mail&quot;</span><br><span class="line">)</span><br><span class="line">public class MailProperties &#123;</span><br><span class="line">   private static final Charset DEFAULT_CHARSET;</span><br><span class="line">   private String host;</span><br><span class="line">   private Integer port;</span><br><span class="line">   private String username;</span><br><span class="line">   private String password;</span><br><span class="line">   private String protocol = &quot;smtp&quot;;</span><br><span class="line">   private Charset defaultEncoding;</span><br><span class="line">   private Map&lt;String, String&gt; properties;</span><br><span class="line">   private String jndiName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、配置文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring.mail.username=24736743@qq.com</span><br><span class="line">spring.mail.password=你的qq授权码</span><br><span class="line">spring.mail.host=smtp.qq.com</span><br><span class="line"># qq需要配置ssl</span><br><span class="line">spring.mail.properties.mail.smtp.ssl.enable=true</span><br></pre></td></tr></table></figure>
<p>获取授权码：在QQ邮箱中的设置-&gt;账户-&gt;开启pop3和smtp服务</p>
<p><img src="https://i.p04e.com/baid/i/2023/02/01/jko3.png"></p>
<p>4、Spring单元测试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">JavaMailSenderImpl mailSender;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void contextLoads() &#123;</span><br><span class="line">   //邮件设置1：一个简单的邮件</span><br><span class="line">   SimpleMailMessage message = new SimpleMailMessage();</span><br><span class="line">   message.setSubject(&quot;通知-明天来狂神这听课&quot;);</span><br><span class="line">   message.setText(&quot;今晚7:30开会&quot;);</span><br><span class="line"></span><br><span class="line">   message.setTo(&quot;24736743@qq.com&quot;);</span><br><span class="line">   message.setFrom(&quot;24736743@qq.com&quot;);</span><br><span class="line">   mailSender.send(message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void contextLoads2() throws MessagingException &#123;</span><br><span class="line">   //邮件设置2：一个复杂的邮件</span><br><span class="line">   MimeMessage mimeMessage = mailSender.createMimeMessage();</span><br><span class="line">   MimeMessageHelper helper = new MimeMessageHelper(mimeMessage, true);</span><br><span class="line"></span><br><span class="line">   helper.setSubject(&quot;通知-明天来狂神这听课&quot;);</span><br><span class="line">   helper.setText(&quot;&lt;b style=&#x27;color:red&#x27;&gt;今天 7:30来开会&lt;/b&gt;&quot;,true);</span><br><span class="line"></span><br><span class="line">   //发送附件</span><br><span class="line">   helper.addAttachment(&quot;1.jpg&quot;,new File(&quot;&quot;));</span><br><span class="line">   helper.addAttachment(&quot;2.jpg&quot;,new File(&quot;&quot;));</span><br><span class="line"></span><br><span class="line">   helper.setTo(&quot;24736743@qq.com&quot;);</span><br><span class="line">   helper.setFrom(&quot;24736743@qq.com&quot;);</span><br><span class="line"></span><br><span class="line">   mailSender.send(mimeMessage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看邮箱，邮件接收成功！</p>
]]></content>
      <tags>
        <tag>SpringBoot</tag>
        <tag>邮箱</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot：Dubbo和Zookeeper集成</title>
    <url>/2023/02/01/SpringBoot%EF%BC%9ADubbo%E5%92%8CZookeeper%E9%9B%86%E6%88%90/</url>
    <content><![CDATA[<p>随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，急需<strong>一个治理系统</strong>确保架构有条不紊的演进。<span id="more"></span></p>
<p>在Dubbo的官网文档有这样一张图</p>
<p><img src="https://i.p04e.com/baid/i/2023/02/01/rpme0.png"></p>
<h2 id="单一应用架构"><a href="#单一应用架构" class="headerlink" title="单一应用架构"></a><strong>单一应用架构</strong></h2><p>当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(ORM)是关键。</p>
<p><img src="https://i.p04e.com/baid/i/2023/02/01/3ykez.png"></p>
<p>适用于小型网站，小型管理系统，将所有功能都部署到一个功能里，简单易用。</p>
<p><strong>缺点：</strong></p>
<p>1、性能扩展比较难</p>
<p>2、协同开发问题</p>
<p>3、不利于升级维护</p>
<h2 id="垂直应用架构"><a href="#垂直应用架构" class="headerlink" title="垂直应用架构"></a><strong>垂直应用架构</strong></h2><p>当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的Web框架(MVC)是关键。</p>
<p><img src="https://i.p04e.com/baid/i/2023/02/01/2wud.png"></p>
<p>通过切分业务来实现各个模块独立部署，降低了维护和部署的难度，团队各司其职更易管理，性能扩展也更方便，更有针对性。</p>
<p>缺点：公用模块无法重复利用，开发性的浪费</p>
<h2 id="分布式服务架构"><a href="#分布式服务架构" class="headerlink" title="分布式服务架构"></a><strong>分布式服务架构</strong></h2><p>当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的<strong>分布式服务框架(RPC)</strong>是关键。</p>
<p><img src="https://i.p04e.com/baid/i/2023/02/01/2wy1.png"></p>
<h2 id="流动计算架构"><a href="#流动计算架构" class="headerlink" title="流动计算架构"></a><strong>流动计算架构</strong></h2><p>当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于<strong>提高机器利用率的资源调度和治理中心</strong>(SOA)[ Service Oriented Architecture]是关键。</p>
<p><img src="https://i.p04e.com/baid/i/2023/02/01/3yxfg.png"></p>
<p>什么是RPC</p>
<p>RPC【Remote Procedure Call】是指远程过程调用，是一种进程间通信方式，他是一种技术的思想，而不是规范。它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。即程序员无论是调用本地的还是远程的函数，本质上编写的调用代码基本相同。</p>
<p>也就是说两台服务器A，B，一个应用部署在A服务器上，想要调用B服务器上应用提供的函数/方法，由于不在一个内存空间，不能直接调用，需要通过网络来表达调用的语义和传达调用的数据。为什么要用RPC呢？就是无法在一个进程内，甚至一个计算机内通过本地调用的方式完成的需求，比如不同的系统间的通讯，甚至不同的组织间的通讯，由于计算能力需要横向扩展，需要在多台机器组成的集群上部署应用。RPC就是要像调用本地的函数一样去调远程函数；</p>
<p>推荐阅读文章：<a href="https://www.jianshu.com/p/2accc2840a1b">https://www.jianshu.com/p/2accc2840a1b</a></p>
<p><strong>RPC基本原理</strong></p>
<p><img src="https://i.p04e.com/baid/i/2023/02/01/kfzp.png"></p>
<p><strong>步骤解析：</strong></p>
<p><img src="https://i.p04e.com/baid/i/2023/02/01/kgjb.png"></p>
<p>RPC两个核心模块：通讯，序列化。</p>
<p>测试环境搭建</p>
<h2 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a><strong>Dubbo</strong></h2><p>Apache Dubbo |ˈdʌbəʊ| 是一款高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。</p>
<p>dubbo官网 <a href="http://dubbo.apache.org/zh-cn/index.html">http://dubbo.apache.org/zh-cn/index.html</a></p>
<p>1.了解Dubbo的特性</p>
<p>2.查看官方文档</p>
<p><strong>dubbo基本概念</strong></p>
<p><img src="https://i.p04e.com/baid/i/2023/02/01/3z7jj.png"></p>
<p><strong>服务提供者</strong>（Provider）：暴露服务的服务提供方，服务提供者在启动时，向注册中心注册自己提供的服务。</p>
<p><strong>服务消费者</strong>（Consumer）：调用远程服务的服务消费方，服务消费者在启动时，向注册中心订阅自己所需的服务，服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</p>
<p><strong>注册中心</strong>（Registry）：注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者</p>
<p><strong>监控中心</strong>（Monitor）：服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心</p>
<p><strong>调用关系说明</strong></p>
<p>l 服务容器负责启动，加载，运行服务提供者。</p>
<p>l 服务提供者在启动时，向注册中心注册自己提供的服务。</p>
<p>l 服务消费者在启动时，向注册中心订阅自己所需的服务。</p>
<p>l 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</p>
<p>l 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</p>
<p>l 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</p>
<h2 id="Dubbo环境搭建"><a href="#Dubbo环境搭建" class="headerlink" title="Dubbo环境搭建"></a><strong>Dubbo环境搭建</strong></h2><p>点进dubbo官方文档，推荐我们使用Zookeeper 注册中心</p>
<p>什么是zookeeper呢？可以查看官方文档</p>
<h2 id="Window下安装zookeeper"><a href="#Window下安装zookeeper" class="headerlink" title="Window下安装zookeeper"></a><strong>Window下安装zookeeper</strong></h2><p>1、下载zookeeper ：地址， 我们下载3.4.14 ， 最新版！解压zookeeper</p>
<p>2、运行/bin/zkServer.cmd ，初次运行会报错，没有zoo.cfg配置文件；</p>
<p>可能遇到问题：闪退 !</p>
<p>解决方案：编辑zkServer.cmd文件末尾添加pause 。这样运行出错就不会退出，会提示错误信息，方便找到原因。</p>
<p><img src="https://i.p04e.com/baid/i/2023/02/01/2wzz.png"></p>
<p>3、修改zoo.cfg配置文件</p>
<p>将conf文件夹下面的zoo_sample.cfg复制一份改名为zoo.cfg即可。</p>
<p>注意几个重要位置：</p>
<p>dataDir=./   临时数据存储的目录（可写相对路径）</p>
<p>clientPort=2181   zookeeper的端口号</p>
<p>修改完成后再次启动zookeeper</p>
<p>4、使用zkCli.cmd测试</p>
<p>ls /：列出zookeeper根下保存的所有节点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[zk: 127.0.0.1:2181(CONNECTED) 4] ls /</span><br><span class="line">[zookeeper]</span><br></pre></td></tr></table></figure>
<p>create –e /baidu 123：创建一个kuangshen节点，值为123</p>
<p>get /baidu：获取/baidu节点的值</p>
<h2 id="window下安装dubbo-admin"><a href="#window下安装dubbo-admin" class="headerlink" title="window下安装dubbo-admin"></a><strong>window下安装dubbo-admin</strong></h2><p>dubbo本身并不是一个服务软件。它其实就是一个jar包，能够帮你的java程序连接到zookeeper，并利用zookeeper消费、提供服务。</p>
<p>但是为了让用户更好的管理监控众多的dubbo服务，官方提供了一个可视化的监控程序dubbo-admin，不过这个监控即使不装也不影响使用。</p>
<p>我们这里来安装一下：</p>
<p><strong>1、下载dubbo-admin</strong></p>
<p>地址 ：<a href="https://github.com/apache/dubbo-admin/tree/master">https://github.com/apache/dubbo-admin/tree/master</a></p>
<p><strong>2、解压进入目录</strong></p>
<p>修改 dubbo-admin\src\main\resources \application.properties 指定zookeeper地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server.port=7001</span><br><span class="line">spring.velocity.cache=false</span><br><span class="line">spring.velocity.charset=UTF-8</span><br><span class="line">spring.velocity.layout-url=/templates/default.vm</span><br><span class="line">spring.messages.fallback-to-system-locale=false</span><br><span class="line">spring.messages.basename=i18n/message</span><br><span class="line">spring.root.password=root</span><br><span class="line">spring.guest.password=guest</span><br><span class="line"></span><br><span class="line">dubbo.registry.address=zookeeper://127.0.0.1:2181</span><br></pre></td></tr></table></figure>
<p><strong>3、在项目目录下</strong>打包dubbo-admin</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn clean package -Dmaven.test.skip=true</span><br></pre></td></tr></table></figure>
<p>4、执行 dubbo-admin\target 下的dubbo-admin-0.0.1-SNAPSHOT.jar</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -jar dubbo-admin-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure>
<p>【注意：zookeeper的服务一定要打开！】</p>
<p>执行完毕，我们去访问一下 <a href="http://localhost:7001/">http://localhost:7001/</a> ， 这时候我们需要输入登录账户和密码，我们都是默认的root-root；</p>
<p>登录成功后，查看界面</p>
<p><img src="https://i.p04e.com/baid/i/2023/02/01/kjoh.png"></p>
<p>安装完成！</p>
<h2 id="SpringBoot-Dubbo-zookeeper"><a href="#SpringBoot-Dubbo-zookeeper" class="headerlink" title="SpringBoot + Dubbo + zookeeper"></a>SpringBoot + Dubbo + zookeeper</h2><h2 id="框架搭建"><a href="#框架搭建" class="headerlink" title="框架搭建"></a><strong>框架搭建</strong></h2><p><strong>1. 启动zookeeper ！</strong></p>
<p><strong>2. IDEA创建一个空项目；</strong></p>
<p><strong>3.创建一个模块，实现服务提供者：provider-server ， 选择web依赖即可</strong></p>
<p><strong>4.项目创建完毕，我们写一个服务，比如卖票的服务；</strong></p>
<p>编写接口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">public interface TicketService &#123;</span><br><span class="line">   public String getTicket();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编写实现类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">public class TicketServiceImpl implements TicketService &#123;</span><br><span class="line">   @Override</span><br><span class="line">   public String getTicket() &#123;</span><br><span class="line">       return &quot;《狂神说Java》&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>5.创建一个模块，实现服务消费者：consumer-server ， 选择web依赖即可</strong></p>
<p><strong>6.项目创建完毕，我们写一个服务，比如用户的服务；</strong></p>
<p>编写service</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">public class UserService &#123;</span><br><span class="line">   //我们需要去拿去注册中心的服务</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>需求：现在我们的用户想使用买票的服务，这要怎么弄呢 ？</strong></p>
<h2 id="服务提供者"><a href="#服务提供者" class="headerlink" title="服务提供者"></a><strong>服务提供者</strong></h2><p><strong>1、将服务提供者注册到注册中心，我们需要整合Dubbo和zookeeper，所以需要导包</strong></p>
<p><strong>我们从dubbo官网进入github，看下方的帮助文档，找到dubbo-springboot，找到依赖包</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- Dubbo Spring Boot Starter --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;2.7.3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;    </span><br></pre></td></tr></table></figure>
<p><strong>zookeeper的包我们去maven仓库下载，zkclient；</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/com.github.sgroschupf/zkclient --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;com.github.sgroschupf&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;zkclient&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;0.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p><strong>【新版的坑】zookeeper及其依赖包，解决日志冲突，还需要剔除日志依赖；</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 引入zookeeper --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;curator-framework&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;2.12.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;2.12.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;3.4.14&lt;/version&gt;</span><br><span class="line">   &lt;!--排除这个slf4j-log4j12--&gt;</span><br><span class="line">   &lt;exclusions&gt;</span><br><span class="line">       &lt;exclusion&gt;</span><br><span class="line">           &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;</span><br><span class="line">       &lt;/exclusion&gt;</span><br><span class="line">   &lt;/exclusions&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p><strong>2、在springboot配置文件中配置dubbo相关属性！</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#当前应用名字</span><br><span class="line">dubbo.application.name=provider-server</span><br><span class="line">#注册中心地址</span><br><span class="line">dubbo.registry.address=zookeeper://127.0.0.1:2181</span><br><span class="line">#扫描指定包下服务</span><br><span class="line">dubbo.scan.base-packages=com.bai.provider.service</span><br></pre></td></tr></table></figure>
<p><strong>3、在service的实现类中配置服务注解，发布服务！注意导包问题</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import org.apache.dubbo.config.annotation.Service;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">@Service //将服务发布出去</span><br><span class="line">@Component //放在容器中</span><br><span class="line">public class TicketServiceImpl implements TicketService &#123;</span><br><span class="line">   @Override</span><br><span class="line">   public String getTicket() &#123;</span><br><span class="line">       return &quot;Java&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>逻辑理解 ：应用启动起来，dubbo就会扫描指定的包下带有@component注解的服务，将它发布在指定的注册中心中！</strong></p>
<h2 id="服务消费者"><a href="#服务消费者" class="headerlink" title="服务消费者"></a><strong>服务消费者</strong></h2><p><strong>1、导入依赖，和之前的依赖一样；</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--dubbo--&gt;</span><br><span class="line">&lt;!-- Dubbo Spring Boot Starter --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;2.7.3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--zookeeper--&gt;</span><br><span class="line">&lt;!-- https://mvnrepository.com/artifact/com.github.sgroschupf/zkclient --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;com.github.sgroschupf&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;zkclient&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;0.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- 引入zookeeper --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;curator-framework&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;2.12.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;2.12.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;3.4.14&lt;/version&gt;</span><br><span class="line">   &lt;!--排除这个slf4j-log4j12--&gt;</span><br><span class="line">   &lt;exclusions&gt;</span><br><span class="line">       &lt;exclusion&gt;</span><br><span class="line">           &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;</span><br><span class="line">       &lt;/exclusion&gt;</span><br><span class="line">   &lt;/exclusions&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>2、<strong>配置参数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#当前应用名字</span><br><span class="line">dubbo.application.name=consumer-server</span><br><span class="line">#注册中心地址</span><br><span class="line">dubbo.registry.address=zookeeper://127.0.0.1:2181</span><br></pre></td></tr></table></figure>
<p><strong>3. 本来正常步骤是需要将服务提供者的接口打包，然后用pom文件导入，我们这里使用简单的方式，直接将服务的接口拿过来，路径必须保证正确，即和服务提供者相同；</strong></p>
<p><strong>4. 完善消费者的服务类</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">import com.bai.provider.service.TicketService;</span><br><span class="line">import org.apache.dubbo.config.annotation.Reference;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line">@Service //注入到容器中</span><br><span class="line">public class UserService &#123;</span><br><span class="line"></span><br><span class="line">   @Reference //远程引用指定的服务，他会按照全类名进行匹配，看谁给注册中心注册了这个全类名</span><br><span class="line">   TicketService ticketService;</span><br><span class="line"></span><br><span class="line">   public void bugTicket()&#123;</span><br><span class="line">       String ticket = ticketService.getTicket();</span><br><span class="line">       System.out.println(&quot;在注册中心买到&quot;+ticket);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>5. 测试类编写；</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class ConsumerServerApplicationTests &#123;</span><br><span class="line"></span><br><span class="line">   @Autowired</span><br><span class="line">   UserService userService;</span><br><span class="line"></span><br><span class="line">   @Test</span><br><span class="line">   public void contextLoads() &#123;</span><br><span class="line"></span><br><span class="line">       userService.bugTicket();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="启动测试"><a href="#启动测试" class="headerlink" title="启动测试"></a><strong>启动测试</strong></h2><p><strong>1. 开启zookeeper</strong></p>
<p><strong>2. 打开dubbo-admin实现监控【可以不用做】</strong></p>
<p><strong>3. 开启服务者</strong></p>
<p><strong>4. 消费者消费测试：</strong></p>
<p><strong>ok , 这就是SpingBoot + dubbo + zookeeper实现分布式开发的应用，其实就是一个服务拆分的思想；</strong></p>
]]></content>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Dubbo</tag>
        <tag>Zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot系列：集成SpringSecurity</title>
    <url>/2023/02/01/SpringBoot%E7%B3%BB%E5%88%97%EF%BC%9A%E9%9B%86%E6%88%90SpringSecurity/</url>
    <content><![CDATA[<p>在 Web 开发中，安全一直是非常重要的一个方面。安全虽然属于应用的非功能性需求，但是应该在应用开发的初期就考虑进来。如果在应用开发的后期才考虑安全的问题，就可能陷入一个两难的境地：一方面，应用存在严重的安全漏洞，无法满足用户的要求，并可能造成用户的隐私数据被攻击者窃取；另一方面，应用的基本架构已经确定，要修复安全漏洞，可能需要对系统的架构做出比较重大的调整，因而需要更多的开发时间，影响应用的发布进程。因此，从应用开发的第一天就应该把安全相关的因素考虑进来，并在整个应用的开发过程中。</p>
<span id="more"></span>
<p>市面上存在比较有名的：Shiro，Spring Security ！</p>
<p>这里需要阐述一下的是，每一个框架的出现都是为了解决某一问题而产生了，那么Spring Security框架的出现是为了解决什么问题呢？</p>
<p>首先我们看下它的官网介绍：Spring Security官网地址</p>
<p>Spring Security is a powerful and highly customizable authentication and access-control framework. It is the de-facto standard for securing Spring-based applications.</p>
<p>Spring Security is a framework that focuses on providing both authentication and authorization to Java applications. Like all Spring projects, the real power of Spring Security is found in how easily it can be extended to meet custom requirements</p>
<p>Spring Security是一个功能强大且高度可定制的身份验证和访问控制框架。它实际上是保护基于spring的应用程序的标准。</p>
<p>Spring Security是一个框架，侧重于为Java应用程序提供身份验证和授权。与所有Spring项目一样，Spring安全性的真正强大之处在于它可以轻松地扩展以满足定制需求</p>
<p>从官网的介绍中可以知道这是一个权限框架。想我们之前做项目是没有使用框架是怎么控制权限的？对于权限 一般会细分为功能权限，访问权限，和菜单权限。代码会写的非常的繁琐，冗余。</p>
<p>怎么解决之前写权限代码繁琐，冗余的问题，一些主流框架就应运而生而Spring Scecurity就是其中的一种。</p>
<p>Spring 是一个非常流行和成功的 Java 应用开发框架。Spring Security 基于 Spring 框架，提供了一套 Web 应用安全性的完整解决方案。一般来说，Web 应用的安全性包括用户认证（Authentication）和用户授权（Authorization）两个部分。用户认证指的是验证某个用户是否为系统中的合法主体，也就是说用户能否访问该系统。用户认证一般要求用户提供用户名和密码。系统通过校验用户名和密码来完成认证过程。用户授权指的是验证某个用户是否有权限执行某个操作。在一个系统中，不同用户所具有的权限是不同的。比如对一个文件来说，有的用户只能进行读取，而有的用户可以进行修改。一般来说，系统会为不同的用户分配不同的角色，而每个角色则对应一系列的权限。</p>
<p>对于上面提到的两种应用情景，Spring Security 框架都有很好的支持。在用户认证方面，Spring Security 框架支持主流的认证方式，包括 HTTP 基本认证、HTTP 表单验证、HTTP 摘要认证、OpenID 和 LDAP 等。在用户授权方面，Spring Security 提供了基于角色的访问控制和访问控制列表（Access Control List，ACL），可以对应用中的领域对象进行细粒度的控制。</p>
<h2 id="实战测试"><a href="#实战测试" class="headerlink" title="实战测试"></a>实战测试</h2><h3 id="实验环境搭建"><a href="#实验环境搭建" class="headerlink" title="实验环境搭建"></a>实验环境搭建</h3><p>1、新建一个初始的springboot项目web模块，thymeleaf模块</p>
<p>2、导入静态资源</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">welcome.html</span><br><span class="line">|views</span><br><span class="line">|level1</span><br><span class="line">1.html</span><br><span class="line">2.html</span><br><span class="line">3.html</span><br><span class="line">|level2</span><br><span class="line">1.html</span><br><span class="line">2.html</span><br><span class="line">3.html</span><br><span class="line">|level3</span><br><span class="line">1.html</span><br><span class="line">2.html</span><br><span class="line">3.html</span><br><span class="line">Login.html</span><br></pre></td></tr></table></figure>
<p>3、controller跳转！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line">import org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"></span><br><span class="line">@Controller</span><br><span class="line">public class RouterController &#123;</span><br><span class="line"></span><br><span class="line">   @RequestMapping(&#123;&quot;/&quot;,&quot;/index&quot;&#125;)</span><br><span class="line">   public String index()&#123;</span><br><span class="line">       return &quot;index&quot;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   @RequestMapping(&quot;/toLogin&quot;)</span><br><span class="line">   public String toLogin()&#123;</span><br><span class="line">       return &quot;views/login&quot;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   @RequestMapping(&quot;/level1/&#123;id&#125;&quot;)</span><br><span class="line">   public String level1(@PathVariable(&quot;id&quot;) int id)&#123;</span><br><span class="line">       return &quot;views/level1/&quot;+id;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   @RequestMapping(&quot;/level2/&#123;id&#125;&quot;)</span><br><span class="line">   public String level2(@PathVariable(&quot;id&quot;) int id)&#123;</span><br><span class="line">       return &quot;views/level2/&quot;+id;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   @RequestMapping(&quot;/level3/&#123;id&#125;&quot;)</span><br><span class="line">   public String level3(@PathVariable(&quot;id&quot;) int id)&#123;</span><br><span class="line">       return &quot;views/level3/&quot;+id;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4、测试实验环境是否OK！</p>
<h3 id="认识SpringSecurity"><a href="#认识SpringSecurity" class="headerlink" title="认识SpringSecurity"></a>认识SpringSecurity</h3><p>Spring Security 是针对Spring项目的安全框架，也是Spring Boot底层安全模块默认的技术选型，他可以实现强大的Web安全控制，对于安全控制，我们仅需要引入 spring-boot-starter-security 模块，进行少量的配置，即可实现强大的安全管理！</p>
<p>记住几个类：</p>
<ul>
<li>WebSecurityConfigurerAdapter：自定义Security策略</li>
<li>AuthenticationManagerBuilder：自定义认证策略</li>
<li>@EnableWebSecurity：开启WebSecurity模式</li>
</ul>
<p>Spring Security的两个主要目标是 “认证” 和 “授权”（访问控制）。</p>
<p><strong>“认证”（Authentication）</strong></p>
<p>身份验证是关于验证您的凭据，如用户名/用户ID和密码，以验证您的身份。</p>
<p>身份验证通常通过用户名和密码完成，有时与身份验证因素结合使用。</p>
<p> <strong>“授权” （Authorization）</strong></p>
<p>授权发生在系统成功验证您的身份后，最终会授予您访问资源（如信息，文件，数据库，资金，位置，几乎任何内容）的完全权限。</p>
<p>这个概念是通用的，而不是只在Spring Security 中存在。</p>
<h3 id="认证和授权"><a href="#认证和授权" class="headerlink" title="认证和授权"></a>认证和授权</h3><p>目前，我们的测试环境，是谁都可以访问的，我们使用 Spring Security 增加上认证和授权的功能</p>
<p>1、引入 Spring Security 模块</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>2、编写 Spring Security 配置类</p>
<p>参考官网：<a href="https://spring.io/projects/spring-security">https://spring.io/projects/spring-security</a> </p>
<p>查看我们自己项目中的版本，找到对应的帮助文档：</p>
<p><a href="https://docs.spring.io/spring-security/site/docs/5.3.0.RELEASE/reference/html5">https://docs.spring.io/spring-security/site/docs/5.3.0.RELEASE/reference/html5</a>   #servlet-applications 8.16.4</p>
<p><img src="https://i.p04e.com/baid/i/2023/02/01/ktj9.png"></p>
<p>3、编写基础配置类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.kuang.config;</span><br><span class="line"></span><br><span class="line">import org.springframework.security.config.annotation.web.builders.HttpSecurity;</span><br><span class="line">import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;</span><br><span class="line">import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;</span><br><span class="line"></span><br><span class="line">@EnableWebSecurity // 开启WebSecurity模式</span><br><span class="line">public class SecurityConfig extends WebSecurityConfigurerAdapter &#123;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   protected void configure(HttpSecurity http) throws Exception &#123;</span><br><span class="line">       </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4、定制请求的授权规则</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void configure(HttpSecurity http) throws Exception &#123;</span><br><span class="line">   // 定制请求的授权规则</span><br><span class="line">   // 首页所有人可以访问</span><br><span class="line">   http.authorizeRequests().antMatchers(&quot;/&quot;).permitAll()</span><br><span class="line">  .antMatchers(&quot;/level1/**&quot;).hasRole(&quot;vip1&quot;)</span><br><span class="line">  .antMatchers(&quot;/level2/**&quot;).hasRole(&quot;vip2&quot;)</span><br><span class="line">  .antMatchers(&quot;/level3/**&quot;).hasRole(&quot;vip3&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5、测试一下：发现除了首页都进不去了！因为我们目前没有登录的角色，因为请求需要登录的角色拥有对应的权限才可以！</p>
<p>6、在configure()方法中加入以下配置，开启自动配置的登录功能！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 开启自动配置的登录功能</span><br><span class="line">// /login 请求来到登录页</span><br><span class="line">// /login?error 重定向到这里表示登录失败</span><br><span class="line">http.formLogin();</span><br></pre></td></tr></table></figure>
<p>7、测试一下：发现，没有权限的时候，会跳转到登录的页面！</p>
<p><img src="https://i.p04e.com/baid/i/2023/02/01/41wgh.png"></p>
<p>8、查看刚才登录页的注释信息；</p>
<p>我们可以定义认证规则，重写configure(AuthenticationManagerBuilder auth)方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//定义认证规则</span><br><span class="line">@Override</span><br><span class="line">protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;</span><br><span class="line">   </span><br><span class="line">   //在内存中定义，也可以在jdbc中去拿....</span><br><span class="line">   auth.inMemoryAuthentication()</span><br><span class="line">          .withUser(&quot;kuangshen&quot;).password(&quot;123456&quot;).roles(&quot;vip2&quot;,&quot;vip3&quot;)</span><br><span class="line">          .and()</span><br><span class="line">          .withUser(&quot;root&quot;).password(&quot;123456&quot;).roles(&quot;vip1&quot;,&quot;vip2&quot;,&quot;vip3&quot;)</span><br><span class="line">          .and()</span><br><span class="line">          .withUser(&quot;guest&quot;).password(&quot;123456&quot;).roles(&quot;vip1&quot;,&quot;vip2&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>9、测试，我们可以使用这些账号登录进行测试！发现会报错！</p>
<p>There is no PasswordEncoder mapped for the id “null”</p>
<p>10、原因，我们要将前端传过来的密码进行某种方式加密，否则就无法登录，修改代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//定义认证规则</span><br><span class="line">@Override</span><br><span class="line">protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;</span><br><span class="line">   //在内存中定义，也可以在jdbc中去拿....</span><br><span class="line">   //Spring security 5.0中新增了多种加密方式，也改变了密码的格式。</span><br><span class="line">   //要想我们的项目还能够正常登陆，需要修改一下configure中的代码。我们要将前端传过来的密码进行某种方式加密</span><br><span class="line">   //spring security 官方推荐的是使用bcrypt加密方式。</span><br><span class="line">   </span><br><span class="line">   auth.inMemoryAuthentication().passwordEncoder(new BCryptPasswordEncoder())</span><br><span class="line">          .withUser(&quot;kuangshen&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip2&quot;,&quot;vip3&quot;)</span><br><span class="line">          .and()</span><br><span class="line">          .withUser(&quot;root&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip1&quot;,&quot;vip2&quot;,&quot;vip3&quot;)</span><br><span class="line">          .and()</span><br><span class="line">          .withUser(&quot;guest&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip1&quot;,&quot;vip2&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>11、测试，发现，登录成功，并且每个角色只能访问自己认证下的规则！搞定</p>
<h3 id="权限控制和注销"><a href="#权限控制和注销" class="headerlink" title="权限控制和注销"></a>权限控制和注销</h3><p>1、开启自动配置的注销的功能</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//定制请求的授权规则</span><br><span class="line">@Override</span><br><span class="line">protected void configure(HttpSecurity http) throws Exception &#123;</span><br><span class="line">   //....</span><br><span class="line">   //开启自动配置的注销的功能</span><br><span class="line">      // /logout 注销请求</span><br><span class="line">   http.logout();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、我们在前端，增加一个注销的按钮，index.html 导航栏中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a class=&quot;item&quot; th:href=&quot;@&#123;/logout&#125;&quot;&gt;</span><br><span class="line">   &lt;i class=&quot;address card icon&quot;&gt;&lt;/i&gt; 注销</span><br><span class="line">&lt;/a&gt;</span><br></pre></td></tr></table></figure>
<p>3、我们可以去测试一下，登录成功后点击注销，发现注销完毕会跳转到登录页面！</p>
<p>4、但是，我们想让他注销成功后，依旧可以跳转到首页，该怎么处理呢？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// .logoutSuccessUrl(&quot;/&quot;); 注销成功来到首页</span><br><span class="line">http.logout().logoutSuccessUrl(&quot;/&quot;);</span><br></pre></td></tr></table></figure>
<p>5、测试，注销完毕后，发现跳转到首页OK</p>
<p>6、我们现在又来一个需求：用户没有登录的时候，导航栏上只显示登录按钮，用户登录之后，导航栏可以显示登录的用户信息及注销按钮！还有就是，比如kuangshen这个用户，它只有 vip2，vip3功能，那么登录则只显示这两个功能，而vip1的功能菜单不显示！这个就是真实的网站情况了！该如何做呢？</p>
<p>我们需要结合thymeleaf中的一些功能</p>
<p>sec：authorize=”isAuthenticated()”:是否认证登录！来显示不同的页面</p>
<p>Maven依赖：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/org.thymeleaf.extras/thymeleaf-extras-springsecurity4 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;thymeleaf-extras-springsecurity5&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;3.0.4.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>7、修改我们的 前端页面</p>
<ol>
<li><p>导入命名空间</p>
</li>
<li><p>```<br>xmlns:sec=”<a href="http://www.thymeleaf.org/thymeleaf-extras-springsecurity5">http://www.thymeleaf.org/thymeleaf-extras-springsecurity5</a>“</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">3. 修改导航栏，增加认证判断</span><br><span class="line"></span><br><span class="line">4. ```</span><br><span class="line">   &lt;!--登录注销--&gt;</span><br><span class="line">   &lt;div class=&quot;right menu&quot;&gt;</span><br><span class="line">   </span><br><span class="line">      &lt;!--如果未登录--&gt;</span><br><span class="line">      &lt;div sec:authorize=&quot;!isAuthenticated()&quot;&gt;</span><br><span class="line">          &lt;a class=&quot;item&quot; th:href=&quot;@&#123;/login&#125;&quot;&gt;</span><br><span class="line">              &lt;i class=&quot;address card icon&quot;&gt;&lt;/i&gt; 登录</span><br><span class="line">          &lt;/a&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">   </span><br><span class="line">      &lt;!--如果已登录--&gt;</span><br><span class="line">      &lt;div sec:authorize=&quot;isAuthenticated()&quot;&gt;</span><br><span class="line">          &lt;a class=&quot;item&quot;&gt;</span><br><span class="line">              &lt;i class=&quot;address card icon&quot;&gt;&lt;/i&gt;</span><br><span class="line">             用户名：&lt;span sec:authentication=&quot;principal.username&quot;&gt;&lt;/span&gt;</span><br><span class="line">             角色：&lt;span sec:authentication=&quot;principal.authorities&quot;&gt;&lt;/span&gt;</span><br><span class="line">          &lt;/a&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">   </span><br><span class="line">      &lt;div sec:authorize=&quot;isAuthenticated()&quot;&gt;</span><br><span class="line">          &lt;a class=&quot;item&quot; th:href=&quot;@&#123;/logout&#125;&quot;&gt;</span><br><span class="line">              &lt;i class=&quot;address card icon&quot;&gt;&lt;/i&gt; 注销</span><br><span class="line">          &lt;/a&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">   &lt;/div&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>8、重启测试，我们可以登录试试看，登录成功后确实，显示了我们想要的页面；</p>
<p>9、如果注销404了，就是因为它默认防止csrf跨站请求伪造，因为会产生安全问题，我们可以将请求改为post表单提交，或者在spring security中关闭csrf功能；我们试试：在 配置中增加 <code>http.csrf().disable();</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http.csrf().disable();//关闭csrf功能:跨站请求伪造,默认只能通过post方式提交logout请求</span><br><span class="line">http.logout().logoutSuccessUrl(&quot;/&quot;);</span><br></pre></td></tr></table></figure>
<p>10、我们继续将下面的角色功能块认证完成！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- sec:authorize=&quot;hasRole(&#x27;vip1&#x27;)&quot; --&gt;</span><br><span class="line">&lt;div class=&quot;column&quot; sec:authorize=&quot;hasRole(&#x27;vip1&#x27;)&quot;&gt;</span><br><span class="line">   &lt;div class=&quot;ui raised segment&quot;&gt;</span><br><span class="line">       &lt;div class=&quot;ui&quot;&gt;</span><br><span class="line">           &lt;div class=&quot;content&quot;&gt;</span><br><span class="line">               &lt;h5 class=&quot;content&quot;&gt;Level 1&lt;/h5&gt;</span><br><span class="line">               &lt;hr&gt;</span><br><span class="line">               &lt;div&gt;&lt;a th:href=&quot;@&#123;/level1/1&#125;&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-1-1&lt;/a&gt;&lt;/div&gt;</span><br><span class="line">               &lt;div&gt;&lt;a th:href=&quot;@&#123;/level1/2&#125;&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-1-2&lt;/a&gt;&lt;/div&gt;</span><br><span class="line">               &lt;div&gt;&lt;a th:href=&quot;@&#123;/level1/3&#125;&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-1-3&lt;/a&gt;&lt;/div&gt;</span><br><span class="line">           &lt;/div&gt;</span><br><span class="line">       &lt;/div&gt;</span><br><span class="line">   &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;column&quot; sec:authorize=&quot;hasRole(&#x27;vip2&#x27;)&quot;&gt;</span><br><span class="line">   &lt;div class=&quot;ui raised segment&quot;&gt;</span><br><span class="line">       &lt;div class=&quot;ui&quot;&gt;</span><br><span class="line">           &lt;div class=&quot;content&quot;&gt;</span><br><span class="line">               &lt;h5 class=&quot;content&quot;&gt;Level 2&lt;/h5&gt;</span><br><span class="line">               &lt;hr&gt;</span><br><span class="line">               &lt;div&gt;&lt;a th:href=&quot;@&#123;/level2/1&#125;&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-2-1&lt;/a&gt;&lt;/div&gt;</span><br><span class="line">               &lt;div&gt;&lt;a th:href=&quot;@&#123;/level2/2&#125;&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-2-2&lt;/a&gt;&lt;/div&gt;</span><br><span class="line">               &lt;div&gt;&lt;a th:href=&quot;@&#123;/level2/3&#125;&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-2-3&lt;/a&gt;&lt;/div&gt;</span><br><span class="line">           &lt;/div&gt;</span><br><span class="line">       &lt;/div&gt;</span><br><span class="line">   &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;column&quot; sec:authorize=&quot;hasRole(&#x27;vip3&#x27;)&quot;&gt;</span><br><span class="line">   &lt;div class=&quot;ui raised segment&quot;&gt;</span><br><span class="line">       &lt;div class=&quot;ui&quot;&gt;</span><br><span class="line">           &lt;div class=&quot;content&quot;&gt;</span><br><span class="line">               &lt;h5 class=&quot;content&quot;&gt;Level 3&lt;/h5&gt;</span><br><span class="line">               &lt;hr&gt;</span><br><span class="line">               &lt;div&gt;&lt;a th:href=&quot;@&#123;/level3/1&#125;&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-3-1&lt;/a&gt;&lt;/div&gt;</span><br><span class="line">               &lt;div&gt;&lt;a th:href=&quot;@&#123;/level3/2&#125;&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-3-2&lt;/a&gt;&lt;/div&gt;</span><br><span class="line">               &lt;div&gt;&lt;a th:href=&quot;@&#123;/level3/3&#125;&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-3-3&lt;/a&gt;&lt;/div&gt;</span><br><span class="line">           &lt;/div&gt;</span><br><span class="line">       &lt;/div&gt;</span><br><span class="line">   &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>11、测试一下！</p>
<p>12、权限控制和注销搞定！</p>
<h3 id="记住我"><a href="#记住我" class="headerlink" title="记住我"></a>记住我</h3><p>现在的情况，我们只要登录之后，关闭浏览器，再登录，就会让我们重新登录，但是很多网站的情况，就是有一个记住密码的功能，这个该如何实现呢？很简单</p>
<p>1、开启记住我功能</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//定制请求的授权规则</span><br><span class="line">@Override</span><br><span class="line">protected void configure(HttpSecurity http) throws Exception &#123;</span><br><span class="line">//。。。。。。。。。。。</span><br><span class="line">   //记住我</span><br><span class="line">   http.rememberMe();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、我们再次启动项目测试一下，发现登录页多了一个记住我功能，我们登录之后关闭 浏览器，然后重新打开浏览器访问，发现用户依旧存在！</p>
<p>思考：如何实现的呢？其实非常简单</p>
<p>我们可以查看浏览器的cookie</p>
<p>3、我们点击注销的时候，可以发现，spring security 帮我们自动删除了这个 cookie</p>
<p><img src="https://i.p04e.com/baid/i/2023/02/01/41oo3.png"></p>
<p>4、结论：登录成功后，将cookie发送给浏览器保存，以后登录带上这个cookie，只要通过检查就可以免登录了。如果点击注销，则会删除这个cookie，具体的原理我们在JavaWeb阶段都讲过了，这里就不在多说了！</p>
<h3 id="定制登录页"><a href="#定制登录页" class="headerlink" title="定制登录页"></a>定制登录页</h3><p>现在这个登录页面都是spring security 默认的，怎么样可以使用我们自己写的Login界面呢？</p>
<p>1、在刚才的登录页配置后面指定 loginpage</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http.formLogin().loginPage(&quot;/toLogin&quot;);</span><br></pre></td></tr></table></figure>
<p>2、然后前端也需要指向我们自己定义的 login请求</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a class=&quot;item&quot; th:href=&quot;@&#123;/toLogin&#125;&quot;&gt;</span><br><span class="line">   &lt;i class=&quot;address card icon&quot;&gt;&lt;/i&gt; 登录</span><br><span class="line">&lt;/a&gt;</span><br></pre></td></tr></table></figure>
<p>3、我们登录，需要将这些信息发送到哪里，我们也需要配置，login.html 配置提交请求及方式，方式必须为post:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;form th:action=&quot;@&#123;/login&#125;&quot; method=&quot;post&quot;&gt;</span><br><span class="line">   &lt;div class=&quot;field&quot;&gt;</span><br><span class="line">       &lt;label&gt;Username&lt;/label&gt;</span><br><span class="line">       &lt;div class=&quot;ui left icon input&quot;&gt;</span><br><span class="line">           &lt;input type=&quot;text&quot; placeholder=&quot;Username&quot; name=&quot;username&quot;&gt;</span><br><span class="line">           &lt;i class=&quot;user icon&quot;&gt;&lt;/i&gt;</span><br><span class="line">       &lt;/div&gt;</span><br><span class="line">   &lt;/div&gt;</span><br><span class="line">   &lt;div class=&quot;field&quot;&gt;</span><br><span class="line">       &lt;label&gt;Password&lt;/label&gt;</span><br><span class="line">       &lt;div class=&quot;ui left icon input&quot;&gt;</span><br><span class="line">           &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;</span><br><span class="line">           &lt;i class=&quot;lock icon&quot;&gt;&lt;/i&gt;</span><br><span class="line">       &lt;/div&gt;</span><br><span class="line">   &lt;/div&gt;</span><br><span class="line">   &lt;input type=&quot;submit&quot; class=&quot;ui blue submit button&quot;/&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>
<p>4、这个请求提交上来，我们还需要验证处理，怎么做呢？我们可以查看formLogin()方法的源码！我们配置接收登录的用户名和密码的参数！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http.formLogin()</span><br><span class="line">  .usernameParameter(&quot;username&quot;)</span><br><span class="line">  .passwordParameter(&quot;password&quot;)</span><br><span class="line">  .loginPage(&quot;/toLogin&quot;)</span><br><span class="line">  .loginProcessingUrl(&quot;/login&quot;); // 登陆表单提交请求</span><br></pre></td></tr></table></figure>
<p>5、在登录页增加记住我的多选框</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;checkbox&quot; name=&quot;remember&quot;&gt; 记住我</span><br></pre></td></tr></table></figure>
<p>6、后端验证处理！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//定制记住我的参数！</span><br><span class="line">http.rememberMe().rememberMeParameter(&quot;remember&quot;);</span><br></pre></td></tr></table></figure>
<p>7、测试，OK</p>
<h2 id="完整配置代码"><a href="#完整配置代码" class="headerlink" title="完整配置代码"></a>完整配置代码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.kuang.config;</span><br><span class="line"></span><br><span class="line">import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;</span><br><span class="line">import org.springframework.security.config.annotation.web.builders.HttpSecurity;</span><br><span class="line">import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;</span><br><span class="line">import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;</span><br><span class="line">import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;</span><br><span class="line"></span><br><span class="line">@EnableWebSecurity</span><br><span class="line">public class SecurityConfig extends WebSecurityConfigurerAdapter &#123;</span><br><span class="line"></span><br><span class="line">   //定制请求的授权规则</span><br><span class="line">   @Override</span><br><span class="line">   protected void configure(HttpSecurity http) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">       http.authorizeRequests().antMatchers(&quot;/&quot;).permitAll()</span><br><span class="line">      .antMatchers(&quot;/level1/**&quot;).hasRole(&quot;vip1&quot;)</span><br><span class="line">      .antMatchers(&quot;/level2/**&quot;).hasRole(&quot;vip2&quot;)</span><br><span class="line">      .antMatchers(&quot;/level3/**&quot;).hasRole(&quot;vip3&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       //开启自动配置的登录功能：如果没有权限，就会跳转到登录页面！</span><br><span class="line">           // /login 请求来到登录页</span><br><span class="line">           // /login?error 重定向到这里表示登录失败</span><br><span class="line">       http.formLogin()</span><br><span class="line">          .usernameParameter(&quot;username&quot;)</span><br><span class="line">          .passwordParameter(&quot;password&quot;)</span><br><span class="line">          .loginPage(&quot;/toLogin&quot;)</span><br><span class="line">          .loginProcessingUrl(&quot;/login&quot;); // 登陆表单提交请求</span><br><span class="line"></span><br><span class="line">       //开启自动配置的注销的功能</span><br><span class="line">           // /logout 注销请求</span><br><span class="line">           // .logoutSuccessUrl(&quot;/&quot;); 注销成功来到首页</span><br><span class="line"></span><br><span class="line">       http.csrf().disable();//关闭csrf功能:跨站请求伪造,默认只能通过post方式提交logout请求</span><br><span class="line">       http.logout().logoutSuccessUrl(&quot;/&quot;);</span><br><span class="line"></span><br><span class="line">       //记住我</span><br><span class="line">       http.rememberMe().rememberMeParameter(&quot;remember&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   //定义认证规则</span><br><span class="line">   @Override</span><br><span class="line">   protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;</span><br><span class="line">       //在内存中定义，也可以在jdbc中去拿....</span><br><span class="line">       //Spring security 5.0中新增了多种加密方式，也改变了密码的格式。</span><br><span class="line">       //要想我们的项目还能够正常登陆，需要修改一下configure中的代码。我们要将前端传过来的密码进行某种方式加密</span><br><span class="line">       //spring security 官方推荐的是使用bcrypt加密方式。</span><br><span class="line"></span><br><span class="line">       auth.inMemoryAuthentication().passwordEncoder(new BCryptPasswordEncoder())</span><br><span class="line">              .withUser(&quot;kuangshen&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip2&quot;,&quot;vip3&quot;)</span><br><span class="line">              .and()</span><br><span class="line">              .withUser(&quot;root&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip1&quot;,&quot;vip2&quot;,&quot;vip3&quot;)</span><br><span class="line">              .and()</span><br><span class="line">              .withUser(&quot;guest&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip1&quot;,&quot;vip2&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>SpringBoot</tag>
        <tag>SpringSecurity</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot：系列整合Shiro</title>
    <url>/2023/02/01/SpringBoot%EF%BC%9A%E7%B3%BB%E5%88%97%E6%95%B4%E5%90%88Shiro/</url>
    <content><![CDATA[<p>SpringBoot系列仅供自己学习！</p>
<p>shiro是什么</p>
<span id="more"></span>
<p>Shiro是Apache下的一个开源项目。shiro属于轻量级框架，相对于SpringSecurity简单的多，也没有SpringSecurity那么复杂。以下是我自己学习之后的记录。<br>官方架构图如下：</p>
<p>shiro主要有三大功能模块：</p>
<ol>
<li><p>Subject：主体，一般指用户。</p>
</li>
<li><p>SecurityManager：安全管理器，管理所有Subject，可以配合内部安全组件。(类似于SpringMVC中的DispatcherServlet)</p>
</li>
<li><p>Realms：用于进行权限信息的验证，一般需要自己实现。</p>
</li>
</ol>
<p>  细分功能</p>
<ol>
<li><p>Authentication：身份认证/登录(账号密码验证)。</p>
</li>
<li><p>Authorization：授权，即角色或者权限验证。</p>
</li>
<li><p>Session Manager：会话管理，用户登录后的session相关管理。</p>
</li>
<li><p>Cryptography：加密，密码加密等。</p>
</li>
<li><p>Web Support：Web支持，集成Web环境。</p>
</li>
<li><p>Caching：缓存，用户信息、角色、权限等缓存到如redis等缓存中。</p>
</li>
<li><p>Concurrency：多线程并发验证，在一个线程中开启另一个线程，可以把权限自动传播过去。</p>
</li>
<li><p>Testing：测试支持；</p>
</li>
<li><p>Run As：允许一个用户假装为另一个用户（如果他们允许）的身份进行访问。</p>
</li>
<li><p>Remember Me：记住我，登录后，下次再来的话不用登录了。</p>
</li>
</ol>
<h2 id="目录："><a href="#目录：" class="headerlink" title="目录："></a>目录：</h2><p><img src="https://img2020.cnblogs.com/blog/1732557/202005/1732557-20200525224837113-1455173795.png" alt="img"></p>
<h3 id="1-该整合项目所需的依赖"><a href="#1-该整合项目所需的依赖" class="headerlink" title="1.该整合项目所需的依赖"></a>1.该整合项目所需的依赖</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    &lt;dependencies&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--</span><br><span class="line">        subject 用户</span><br><span class="line">        securityManager 管理所有用户</span><br><span class="line">        realm  连接数据</span><br><span class="line">        --&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--连接数据库的依赖--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;8.0.15&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;log4j&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;log4j&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.2.17&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;druid&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.1.13&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--引入mybatis,这是mybatis官方提供的适配springboot的，而不是springboot自己的--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.1.2&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--不想书写setter、getter方法，导入此依赖--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.16.22&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--shiro整合spring的包--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.4.2&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">            &lt;exclusions&gt;</span><br><span class="line">                &lt;exclusion&gt;</span><br><span class="line">                    &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;</span><br><span class="line">                    &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;</span><br><span class="line">                &lt;/exclusion&gt;</span><br><span class="line">            &lt;/exclusions&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--导入thymeleaf依赖--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.thymeleaf&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;thymeleaf-spring5&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.0.11.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;thymeleaf-extras-java8time&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.0.4.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--shiro-thymeleaf整合--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.github.theborakompanioni&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;thymeleaf-extras-shiro&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.0.0&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;repositories&gt;</span><br><span class="line">        &lt;repository&gt;</span><br><span class="line">            &lt;id&gt;aliyun-repos&lt;/id&gt;</span><br><span class="line">            &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;</span><br><span class="line">            &lt;snapshots&gt;</span><br><span class="line">                &lt;enabled&gt;false&lt;/enabled&gt;</span><br><span class="line">            &lt;/snapshots&gt;</span><br><span class="line">        &lt;/repository&gt;</span><br><span class="line">    &lt;/repositories&gt;</span><br><span class="line">    &lt;pluginRepositories&gt;</span><br><span class="line">        &lt;pluginRepository&gt;</span><br><span class="line">            &lt;id&gt;aliyun-plugin&lt;/id&gt;</span><br><span class="line">            &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;</span><br><span class="line">            &lt;snapshots&gt;</span><br><span class="line">                &lt;enabled&gt;false&lt;/enabled&gt;</span><br><span class="line">            &lt;/snapshots&gt;</span><br><span class="line">        &lt;/pluginRepository&gt;</span><br><span class="line">    &lt;/pluginRepositories&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br><span class="line">    </span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>
<h3 id="2-application-yml设置连接数据库的相关配置"><a href="#2-application-yml设置连接数据库的相关配置" class="headerlink" title="2. application.yml设置连接数据库的相关配置"></a>2. application.yml设置连接数据库的相关配置</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    username: root</span><br><span class="line">    password: 123456</span><br><span class="line">    #?serverTimezone=UTC解决时区的报错</span><br><span class="line">    url: jdbc:mysql://localhost:3306/mybatis?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    type: com.alibaba.druid.pool.DruidDataSource</span><br><span class="line"></span><br><span class="line">    #Spring Boot 默认是不注入这些属性值的，需要自己绑定</span><br><span class="line">    #druid 数据源专有配置</span><br><span class="line">    initialSize: 5</span><br><span class="line">    minIdle: 5</span><br><span class="line">    maxActive: 20</span><br><span class="line">    maxWait: 60000</span><br><span class="line">    timeBetweenEvictionRunsMillis: 60000</span><br><span class="line">    minEvictableIdleTimeMillis: 300000</span><br><span class="line">    validationQuery: SELECT 1 FROM DUAL</span><br><span class="line">    testWhileIdle: true</span><br><span class="line">    testOnBorrow: false</span><br><span class="line">    testOnReturn: false</span><br><span class="line">    poolPreparedStatements: true</span><br><span class="line"></span><br><span class="line">    #配置监控统计拦截的filters，stat:监控统计、log4j：日志记录、wall：防御sql注入</span><br><span class="line">    #如果允许时报错  java.lang.ClassNotFoundException: org.apache.log4j.Priority</span><br><span class="line">    #则导入 log4j 依赖即可，Maven 地址：https://mvnrepository.com/artifact/log4j/log4j</span><br><span class="line">    filters: stat,wall,log4j</span><br><span class="line">    maxPoolPreparedStatementPerConnectionSize: 20</span><br><span class="line">    useGlobalDataSourceStat: true</span><br><span class="line">    connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500</span><br></pre></td></tr></table></figure>
<h3 id="3-index-html"><a href="#3-index-html" class="headerlink" title="3.index.html"></a>3.index.html</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.w3.org/1999/xhtml?&quot;</span><br><span class="line">      xmlns:shiro=&quot;http://www.thymeleaf.org/thymeleaf-extras-shiro&quot; &gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;首页&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div th:if=&quot;$&#123;session.loginUser==null&#125;&quot;&gt;</span><br><span class="line">        &lt;a th:href=&quot;@&#123;/toLogin&#125;&quot;&gt;登录&lt;/a&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;p th:text=&quot;$&#123;msg&#125;&quot;&gt;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">    &lt;hr&gt;</span><br><span class="line">    &lt;div shiro:hasPermission=&quot;user:add&quot;&gt;</span><br><span class="line">        &lt;a th:href=&quot;@&#123;/user/add&#125;&quot;&gt;add&lt;/a&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div shiro:hasPermission=&quot;user:update&quot;&gt;</span><br><span class="line">        &lt;a th:href=&quot;@&#123;/user/update&#125;&quot;&gt;update&lt;/a&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;a th:href=&quot;@&#123;/logout&#125;&quot;&gt;注销&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h3 id="4-add-html和update-html"><a href="#4-add-html和update-html" class="headerlink" title="4.add.html和update.html"></a>4.add.html和update.html</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;add&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line">-------------------------------------------------</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;update&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h3 id="5-login-html"><a href="#5-login-html" class="headerlink" title="5.login.html"></a>5.login.html</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.w3.org/1999/xhtml?&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;登录&lt;/h1&gt;</span><br><span class="line">&lt;hr&gt;</span><br><span class="line">&lt;p th:text=&quot;$&#123;msg&#125;&quot; style=&quot;color:red;&quot;&gt;&lt;/p&gt;</span><br><span class="line">&lt;form th:action=&quot;@&#123;/login&#125;&quot;&gt;</span><br><span class="line">    用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt;</span><br><span class="line">    密码：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;</span><br><span class="line">    &lt;br&gt;</span><br><span class="line">    &lt;input type=&quot;submit&quot; name=&quot;提交&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h3 id="6-MyController-java"><a href="#6-MyController-java" class="headerlink" title="6.MyController.java"></a>6.MyController.java</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class MyController &#123;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&#123;&quot;/&quot;,&quot;/index&quot;&#125;)</span><br><span class="line">    public String toIndex(Model model)&#123;</span><br><span class="line">        model.addAttribute(&quot;msg&quot;,&quot;hello,shiro!&quot;);</span><br><span class="line">        return &quot;index&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/user/add&quot;)</span><br><span class="line">    public String add()&#123;</span><br><span class="line">        return &quot;user/add&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/user/update&quot;)</span><br><span class="line">    public String update()&#123;</span><br><span class="line">        return &quot;user/update&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/toLogin&quot;)</span><br><span class="line">    public String toLogin()&#123;</span><br><span class="line">        return &quot;login&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/login&quot;)</span><br><span class="line">    public String login(String username,String password,Model model)&#123;</span><br><span class="line">        //获取当前用户</span><br><span class="line">        Subject subject = SecurityUtils.getSubject();</span><br><span class="line">        //封装用户的登录数据</span><br><span class="line">        UsernamePasswordToken token = new UsernamePasswordToken(username, password);</span><br><span class="line"></span><br><span class="line">        try&#123;</span><br><span class="line">            subject.login(token); //执行登录的方法，如果没有异常就说明ok了</span><br><span class="line">            return &quot;index&quot;;</span><br><span class="line">        &#125;catch (UnknownAccountException e)&#123; //用户名不存在</span><br><span class="line">            model.addAttribute(&quot;msg&quot;,&quot;用户名不存在！&quot;);</span><br><span class="line">            return &quot;login&quot;;</span><br><span class="line">        &#125;catch (IncorrectCredentialsException e)&#123;</span><br><span class="line">            model.addAttribute(&quot;msg&quot;,&quot;密码错误！&quot;);</span><br><span class="line">            return &quot;login&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">//在一个shiro的demo中，设计共有两个页面，add页面和update页面，add页面只能具有user:add字段的用 //户可以访问，update页面只能具有user:update字段的用户去访问，如果某用户访问add页面，但是没     //有user:add字段的话，则会呈现用户：未经授权不得访问 这样的一个页面。</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/noauth&quot;)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public String unauthorized()&#123;</span><br><span class="line">        return &quot;未授权无法访问此页面&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/logout&quot;)</span><br><span class="line">    public String logout()&#123;</span><br><span class="line">        //获取当前用户</span><br><span class="line">        Subject subject = SecurityUtils.getSubject();</span><br><span class="line">        System.out.println(subject.getSession().getAttribute(&quot;loginUser&quot;));</span><br><span class="line">        subject.logout(); // session 会销毁，在SessionListener监听session销毁，清理权限缓存</span><br><span class="line">        System.out.println(subject.getSession().getAttribute(&quot;loginUser&quot;));</span><br><span class="line">        System.out.println(&quot;执行了退出&quot;);</span><br><span class="line">        return &quot;login&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-ShiroConfig-java"><a href="#7-ShiroConfig-java" class="headerlink" title="7.ShiroConfig.java"></a>7.ShiroConfig.java</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class ShiroConfig &#123;</span><br><span class="line"></span><br><span class="line">    //ShiroFilterFactoryBean （第三步:连接到前端）</span><br><span class="line">    @Bean</span><br><span class="line">    public ShiroFilterFactoryBean getShiroFilterBean(@Qualifier(&quot;securityManager&quot;) DefaultWebSecurityManager defaultWebSecurityManager)&#123;</span><br><span class="line">        ShiroFilterFactoryBean bean = new ShiroFilterFactoryBean();</span><br><span class="line">        //设置安全管理器</span><br><span class="line">        bean.setSecurityManager(defaultWebSecurityManager);</span><br><span class="line"></span><br><span class="line">        //添加shiro的内置过滤器</span><br><span class="line">        /*</span><br><span class="line">        anon: 无需认证即可访问</span><br><span class="line">        authc: 必须认证才能用</span><br><span class="line">        user: 必须拥有 “记住我” 功能才能用</span><br><span class="line">        perms: 拥有对某个资源的权限才能用</span><br><span class="line">        role: 拥有某个角色权限才能访问</span><br><span class="line">        */</span><br><span class="line"></span><br><span class="line">        Map&lt;String,String&gt; filterMap = new LinkedHashMap&lt;&gt;();</span><br><span class="line">        //拦截</span><br><span class="line">        filterMap.put(&quot;/user/add&quot;,&quot;authc&quot;);</span><br><span class="line">        filterMap.put(&quot;/user/update&quot;,&quot;authc&quot;);</span><br><span class="line">        //也可使用通配符*</span><br><span class="line">        //filterMap.put(&quot;/user/*&quot;,&quot;authc&quot;);</span><br><span class="line"></span><br><span class="line">        //授权，正常情况下没有授权会跳转到未授权页面</span><br><span class="line">        filterMap.put(&quot;/user/add&quot;,&quot;perms[user:add]&quot;);</span><br><span class="line">        filterMap.put(&quot;/user/update&quot;,&quot;perms[user:update]&quot;);</span><br><span class="line"></span><br><span class="line">        bean.setFilterChainDefinitionMap(filterMap);</span><br><span class="line"></span><br><span class="line">        //若访问时用户未认证，则跳转至登录页面</span><br><span class="line">        bean.setLoginUrl(&quot;/toLogin&quot;);</span><br><span class="line">        //若访问时用户未被授权，则跳转至未授权页面</span><br><span class="line">        bean.setUnauthorizedUrl(&quot;/noauth&quot;);</span><br><span class="line"></span><br><span class="line">        return bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //DefaultWebSecurityManager （第二步：管理realm对象）</span><br><span class="line">    @Bean(name=&quot;securityManager&quot;) //@Bean注解后便被spring托管,不加name属性，默认name值为方法名,这里就加一下吧</span><br><span class="line">    public DefaultWebSecurityManager getDefaultWebSecurityManager(@Qualifier(&quot;userRealm&quot;) UserRealm userRealm)&#123;</span><br><span class="line">        DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();</span><br><span class="line">        //关联UserRealm</span><br><span class="line">        securityManager.setRealm(userRealm);</span><br><span class="line">        return securityManager;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //创建realm对象，需要自定义类 (第一步:创建realm对象)</span><br><span class="line">    @Bean(name=&quot;userRealm&quot;)  //@Bean注解后便被spring托管,不加name属性，默认name值为方法名,这里就加一下吧</span><br><span class="line">    public UserRealm userRealm()&#123;</span><br><span class="line">        return new UserRealm();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //整合ShiroDialect:用来整合shiro thymeleaf</span><br><span class="line">    @Bean</span><br><span class="line">    public ShiroDialect getShiroDialect()&#123;</span><br><span class="line">        return new ShiroDialect();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-UserRealm-java"><a href="#8-UserRealm-java" class="headerlink" title="8.UserRealm.java"></a>8.UserRealm.java</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//自定义UserRealm extends AuthorizingRealm</span><br><span class="line">public class UserRealm extends AuthorizingRealm &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //授权</span><br><span class="line">    @Override</span><br><span class="line">    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) &#123;</span><br><span class="line">        System.out.println(&quot;执行了授权&quot;);</span><br><span class="line"></span><br><span class="line">        SimpleAuthorizationInfo info = new SimpleAuthorizationInfo();</span><br><span class="line">        //info.addStringPermission(&quot;user:add&quot;);</span><br><span class="line"></span><br><span class="line">        //拿到当前登录的对象</span><br><span class="line">        Subject subject = SecurityUtils.getSubject();</span><br><span class="line">        User currentUser = (User) subject.getPrincipal(); //拿到user对象</span><br><span class="line"></span><br><span class="line">        info.addStringPermission(currentUser.getPerms());</span><br><span class="line"></span><br><span class="line">        return info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //认证</span><br><span class="line">    @Override</span><br><span class="line">    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123;</span><br><span class="line">        System.out.println(&quot;执行了认证&quot;);</span><br><span class="line"></span><br><span class="line">        UsernamePasswordToken userToken = (UsernamePasswordToken) token;</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">        //用户名、密码  模拟从数据库中获取</span><br><span class="line">        String name = &quot;root&quot;;</span><br><span class="line">        String password = &quot;1111&quot;;</span><br><span class="line"></span><br><span class="line">        if (!userToken.getUsername().equals(name))&#123;</span><br><span class="line">            return null; //抛出异常 UnknownAccountException</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //密码认证，shiro做~</span><br><span class="line">        return new SimpleAuthenticationInfo(&quot;&quot;,password,&quot;&quot;);</span><br><span class="line">        */</span><br><span class="line"></span><br><span class="line">        //连接真实数据库</span><br><span class="line">        User user = userService.queryUserByName(userToken.getUsername());</span><br><span class="line">        if (user==null)&#123; //没有这个人</span><br><span class="line">            return null; //抛出异常 UnknownAccountException</span><br><span class="line">        &#125;</span><br><span class="line">        Subject currentSubject = SecurityUtils.getSubject();</span><br><span class="line">        Session session = currentSubject.getSession();</span><br><span class="line">        session.setAttribute(&quot;loginUser&quot;,user);</span><br><span class="line"></span><br><span class="line">        //可以加密： MD5加密   MD5盐值加密</span><br><span class="line">        //密码认证，shiro做~</span><br><span class="line">        return new SimpleAuthenticationInfo(user,user.getPwd(),&quot;&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-UserMapper-java"><a href="#9-UserMapper-java" class="headerlink" title="9.UserMapper.java"></a>9.UserMapper.java</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Repository</span><br><span class="line">@Mapper</span><br><span class="line">public interface UserMapper &#123;</span><br><span class="line"></span><br><span class="line">    public User queryUserByName(String name);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="10-UserMapper-xml"><a href="#10-UserMapper-xml" class="headerlink" title="10.UserMapper.xml"></a>10.UserMapper.xml</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace=&quot;com.ztx.mapper.UserMapper&quot;&gt;</span><br><span class="line">    &lt;select id=&quot;queryUserByName&quot; parameterType=&quot;String&quot; resultType=&quot;User&quot;&gt;</span><br><span class="line">        select * from mybatis.user where name=#&#123;name&#125;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>
<h3 id="11-User-java"><a href="#11-User-java" class="headerlink" title="11.User.java"></a>11.User.java</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Data</span><br><span class="line">@AllArgsConstructor</span><br><span class="line">@NoArgsConstructor</span><br><span class="line">public class User &#123;</span><br><span class="line"></span><br><span class="line">    private int id;</span><br><span class="line">    private String name;</span><br><span class="line">    private String pwd;</span><br><span class="line">    private String perms;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="12-UserService-java和UserServiceImpl-java"><a href="#12-UserService-java和UserServiceImpl-java" class="headerlink" title="12.UserService.java和UserServiceImpl.java"></a>12.UserService.java和UserServiceImpl.java</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface UserService &#123;</span><br><span class="line"></span><br><span class="line">    public User queryUserByName(String name);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-----------------------------------------------------</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class UserServiceImpl implements UserService&#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public User queryUserByName(String name) &#123;</span><br><span class="line">        return userMapper.queryUserByName(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="13-数据库中的user表"><a href="#13-数据库中的user表" class="headerlink" title="13.数据库中的user表"></a>13.数据库中的user表</h3><p><img src="https://img2020.cnblogs.com/blog/1732557/202005/1732557-20200525232923150-1456279780.png" alt="img"></p>
<p>个人对该项目执行流程进行了梳理，如有错误，请指正：</p>
<p>　　1.ShiroConf.java中设置好拦截器，规定哪些页面需要用户具备何种要求才可访问，同时还设置当用户不满足要求时应该跳转至什么页面。对应本项目的代码：</p>
<p>　　<img src="https://img2020.cnblogs.com/blog/1732557/202005/1732557-20200528102317787-186241790.png" alt="img"></p>
<p>　　2.用户在未认证下，会跳转到登陆页面login.html。输入用户名密码，提交执行controller中的login()方法，该方法内将用户信息封装成token对象，传入subject.login()方法内进行登录验证。对应项目代码：</p>
<p>　　<img src="https://img2020.cnblogs.com/blog/1732557/202005/1732557-20200528102447393-2136646425.png" alt="img"> </p>
<p>　　3.执行登录验证时会跳转到UserRealm类，首先执行认证(doGetAuthenticationInfo)：连接数据库判断是否有此人，若没有则返回结果null，若有，则将数据库中的用户信息存储在subject的session中。接着进行密码验证，若验证失败，则将登录不通过返回失败认证信息，反之，返回成功的认证信息，并执行用户授权(doGetAuthorizationInfo)操作，返回授权信息。对应项目代码：</p>
<p>　　认证：</p>
<p> 　　<img src="https://img2020.cnblogs.com/blog/1732557/202005/1732557-20200528102519608-999242032.png" alt="img"></p>
<p>　　授权：</p>
<p>　　 <img src="https://img2020.cnblogs.com/blog/1732557/202005/1732557-20200528102540179-466571560.png" alt="img"></p>
<p>　　4.本项目中登录成功后跳转到index.html时依旧会再次执行授权操作，因为前端页面需要一个判断展示功能，代码如下：</p>
<p>　　 <img src="https://img2020.cnblogs.com/blog/1732557/202005/1732557-20200528102558235-1957418305.png" alt="img"></p>
<p>　　故控制台信息会是这样：（出现两次授权）</p>
<p>　　 <img src="https://img2020.cnblogs.com/blog/1732557/202005/1732557-20200528102613001-1241215544.png" alt="img"></p>
<p>　　5.之后进入add.html或update.html时，因为会被拦截，所以都要进行授权验证，而此时认证将不会在执行。</p>
]]></content>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Shiro</tag>
      </tags>
  </entry>
</search>
